var p5 = (function() {
	var __create = Object.create;
	var __defProp$1 = Object.defineProperty;
	var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames = Object.getOwnPropertyNames;
	var __getProtoOf = Object.getPrototypeOf;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __esmMin = (fn$1, res) => () => (fn$1 && (res = fn$1(fn$1 = 0)), res);
	var __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
	var __export$1 = (all) => {
		let target = {};
		for (var name in all) __defProp$1(target, name, {
			get: all[name],
			enumerable: true
		});
		return target;
	};
	var __copyProps = (to$1, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i$1 = 0, n$2 = keys.length, key; i$1 < n$2; i$1++) {
			key = keys[i$1];
			if (!__hasOwnProp.call(to$1, key) && key !== except) __defProp$1(to$1, key, {
				get: ((k) => from[k]).bind(null, key),
				enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
			});
		}
		return to$1;
	};
	var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp$1(target, "default", {
		value: mod,
		enumerable: true
	}) : target, mod));
	var __toCommonJS = (mod) => __copyProps(__defProp$1({}, "__esModule", { value: true }), mod);
	const _PI = Math.PI;
	const VERSION = "2.0.5";
	const P2D = "p2d";
	const P2DHDR = "p2d-hdr";
	const WEBGL = "webgl";
	const WEBGL2 = "webgl2";
	const ARROW = "default";
	const SIMPLE = "simple";
	const FULL = "full";
	const CROSS = "crosshair";
	const HAND = "pointer";
	const MOVE = "move";
	const TEXT = "text";
	const WAIT = "wait";
	const HALF_PI = _PI / 2;
	const PI = _PI;
	const QUARTER_PI = _PI / 4;
	const TAU = _PI * 2;
	const TWO_PI = _PI * 2;
	const DEG_TO_RAD = _PI / 180;
	const RAD_TO_DEG = 180 / _PI;
	const CORNER = "corner";
	const CORNERS = "corners";
	const RADIUS = "radius";
	const RIGHT = "right";
	const LEFT = "left";
	const CENTER = "center";
	const TOP = "top";
	const BOTTOM = "bottom";
	const BASELINE = "alphabetic";
	const POINTS = 0;
	const LINES = 1;
	const LINE_STRIP = 3;
	const LINE_LOOP = 2;
	const TRIANGLES = 4;
	const TRIANGLE_FAN = 6;
	const TRIANGLE_STRIP = 5;
	const QUADS = "quads";
	const QUAD_STRIP = "quad_strip";
	const TESS = "tess";
	const EMPTY_PATH = 7;
	const PATH = 8;
	const CLOSE = "close";
	const OPEN = "open";
	const CHORD = "chord";
	const PIE = "pie";
	const PROJECT = "square";
	const SQUARE = "butt";
	const ROUND = "round";
	const BEVEL = "bevel";
	const MITER = "miter";
	const AUTO = "auto";
	const ALT = "Alt";
	const BACKSPACE = "Backspace";
	const CONTROL = "Control";
	const DELETE = "Delete";
	const DOWN_ARROW = "ArrowDown";
	const ENTER = "Enter";
	const ESCAPE = "Escape";
	const LEFT_ARROW = "ArrowLeft";
	const OPTION = "Alt";
	const RETURN = "Enter";
	const RIGHT_ARROW = "ArrowRight";
	const SHIFT = "Shift";
	const TAB = "Tab";
	const UP_ARROW = "ArrowUp";
	const BLEND = "source-over";
	const REMOVE = "destination-out";
	const ADD = "lighter";
	const DARKEST = "darken";
	const LIGHTEST = "lighten";
	const DIFFERENCE = "difference";
	const SUBTRACT = "subtract";
	const EXCLUSION = "exclusion";
	const MULTIPLY = "multiply";
	const SCREEN = "screen";
	const REPLACE = "copy";
	const OVERLAY = "overlay";
	const HARD_LIGHT = "hard-light";
	const SOFT_LIGHT = "soft-light";
	const DODGE = "color-dodge";
	const BURN = "color-burn";
	const THRESHOLD = "threshold";
	const GRAY = "gray";
	const OPAQUE = "opaque";
	const INVERT = "invert";
	const POSTERIZE = "posterize";
	const DILATE = "dilate";
	const ERODE = "erode";
	const BLUR = "blur";
	const NORMAL = "normal";
	const ITALIC = "italic";
	const BOLD = "bold";
	const BOLDITALIC = "bold italic";
	const CHAR = "CHAR";
	const WORD = "WORD";
	const _DEFAULT_TEXT_FILL = "#000000";
	const _DEFAULT_LEADMULT = 1.25;
	const _CTX_MIDDLE = "middle";
	const LINEAR = "linear";
	const QUADRATIC = "quadratic";
	const BEZIER = "bezier";
	const CURVE = "curve";
	const STROKE = "stroke";
	const FILL = "fill";
	const TEXTURE = "texture";
	const IMMEDIATE = "immediate";
	const IMAGE = "image";
	const NEAREST = "nearest";
	const REPEAT = "repeat";
	const CLAMP = "clamp";
	const MIRROR = "mirror";
	const FLAT = "flat";
	const SMOOTH = "smooth";
	const LANDSCAPE = "landscape";
	const PORTRAIT = "portrait";
	const _DEFAULT_STROKE = "#000000";
	const _DEFAULT_FILL = "#FFFFFF";
	const GRID = "grid";
	const AXES = "axes";
	const LABEL = "label";
	const FALLBACK = "fallback";
	const CONTAIN = "contain";
	const COVER = "cover";
	const UNSIGNED_BYTE = "unsigned-byte";
	const UNSIGNED_INT = "unsigned-int";
	const FLOAT = "float";
	const HALF_FLOAT = "half-float";
	const INCLUDE = Symbol("include");
	const EXCLUDE = Symbol("exclude");
	const JOIN = Symbol("join");
	var constants = /* @__PURE__ */ Object.freeze({
		__proto__: null,
		ADD,
		ALT,
		ARROW,
		AUTO,
		AXES,
		BACKSPACE,
		BASELINE,
		BEVEL,
		BEZIER,
		BLEND,
		BLUR,
		BOLD,
		BOLDITALIC,
		BOTTOM,
		BURN,
		CENTER,
		CHAR,
		CHORD,
		CLAMP,
		CLOSE,
		CONTAIN,
		CONTROL,
		CORNER,
		CORNERS,
		COVER,
		CROSS,
		CURVE,
		DARKEST,
		DEG_TO_RAD,
		DELETE,
		DIFFERENCE,
		DILATE,
		DODGE,
		DOWN_ARROW,
		EMPTY_PATH,
		ENTER,
		ERODE,
		ESCAPE,
		EXCLUDE,
		EXCLUSION,
		FALLBACK,
		FILL,
		FLAT,
		FLOAT,
		FULL,
		GRAY,
		GRID,
		HALF_FLOAT,
		HALF_PI,
		HAND,
		HARD_LIGHT,
		IMAGE,
		IMMEDIATE,
		INCLUDE,
		INVERT,
		ITALIC,
		JOIN,
		LABEL,
		LANDSCAPE,
		LEFT,
		LEFT_ARROW,
		LIGHTEST,
		LINEAR,
		LINES,
		LINE_LOOP,
		LINE_STRIP,
		MIRROR,
		MITER,
		MOVE,
		MULTIPLY,
		NEAREST,
		NORMAL,
		OPAQUE,
		OPEN,
		OPTION,
		OVERLAY,
		P2D,
		P2DHDR,
		PATH,
		PI,
		PIE,
		POINTS,
		PORTRAIT,
		POSTERIZE,
		PROJECT,
		QUADRATIC,
		QUADS,
		QUAD_STRIP,
		QUARTER_PI,
		RADIUS,
		RAD_TO_DEG,
		REMOVE,
		REPEAT,
		REPLACE,
		RETURN,
		RIGHT,
		RIGHT_ARROW,
		ROUND,
		SCREEN,
		SHIFT,
		SIMPLE,
		SMOOTH,
		SOFT_LIGHT,
		SQUARE,
		STROKE,
		SUBTRACT,
		TAB,
		TAU,
		TESS,
		TEXT,
		TEXTURE,
		THRESHOLD,
		TOP,
		TRIANGLES,
		TRIANGLE_FAN,
		TRIANGLE_STRIP,
		TWO_PI,
		UNSIGNED_BYTE,
		UNSIGNED_INT,
		UP_ARROW,
		VERSION,
		WAIT,
		WEBGL,
		WEBGL2,
		WORD,
		_CTX_MIDDLE,
		_DEFAULT_FILL,
		_DEFAULT_LEADMULT,
		_DEFAULT_STROKE,
		_DEFAULT_TEXT_FILL
	});
	function transform$1(p5$2, fn$1) {
		fn$1.applyMatrix = function(...args) {
			let isTypedArray = args[0] instanceof Object.getPrototypeOf(Uint8Array);
			if (Array.isArray(args[0]) || isTypedArray) this._renderer.applyMatrix(...args[0]);
			else this._renderer.applyMatrix(...args);
			return this;
		};
		fn$1.resetMatrix = function() {
			this._renderer.resetMatrix();
			return this;
		};
		fn$1.rotate = function(angle, axis) {
			this._renderer.rotate(this._toRadians(angle), axis);
			return this;
		};
		fn$1.rotateX = function(angle) {
			this._assert3d("rotateX");
			this._renderer.rotateX(this._toRadians(angle));
			return this;
		};
		fn$1.rotateY = function(angle) {
			this._assert3d("rotateY");
			this._renderer.rotateY(this._toRadians(angle));
			return this;
		};
		fn$1.rotateZ = function(angle) {
			this._assert3d("rotateZ");
			this._renderer.rotateZ(this._toRadians(angle));
			return this;
		};
		fn$1.scale = function(x$1, y, z$1) {
			if (x$1 instanceof p5$2.Vector) {
				const v$1 = x$1;
				x$1 = v$1.x;
				y = v$1.y;
				z$1 = v$1.z;
			} else if (Array.isArray(x$1)) {
				const rg = x$1;
				x$1 = rg[0];
				y = rg[1];
				z$1 = rg[2] || 1;
			}
			if (isNaN(y)) y = z$1 = x$1;
			else if (isNaN(z$1)) z$1 = 1;
			this._renderer.scale(x$1, y, z$1);
			return this;
		};
		fn$1.shearX = function(angle) {
			const rad = this._toRadians(angle);
			this._renderer.applyMatrix(1, 0, Math.tan(rad), 1, 0, 0);
			return this;
		};
		fn$1.shearY = function(angle) {
			const rad = this._toRadians(angle);
			this._renderer.applyMatrix(1, Math.tan(rad), 0, 1, 0, 0);
			return this;
		};
		fn$1.translate = function(x$1, y, z$1) {
			if (this._renderer.isP3D) this._renderer.translate(x$1, y, z$1);
			else this._renderer.translate(x$1, y);
			return this;
		};
		fn$1.push = function() {
			this._renderer.push();
		};
		fn$1.pop = function() {
			this._renderer.pop();
		};
	}
	if (typeof p5 !== "undefined") transform$1(p5, p5.prototype);
	function structure(p5$2, fn$1) {
		fn$1.noLoop = function() {
			this._loop = false;
		};
		fn$1.loop = function() {
			if (!this._loop) {
				this._loop = true;
				if (this._setupDone) this._draw();
			}
		};
		fn$1.isLooping = function() {
			return this._loop;
		};
		fn$1.redraw = async function(n$2) {
			if (this._inUserDraw || !this._setupDone) return;
			let numberOfRedraws = parseInt(n$2);
			if (isNaN(numberOfRedraws) || numberOfRedraws < 1) numberOfRedraws = 1;
			const context = this._isGlobal ? window : this;
			if (typeof context.draw === "function") {
				if (typeof context.setup === "undefined") context.scale(context._pixelDensity, context._pixelDensity);
				for (let idxRedraw = 0; idxRedraw < numberOfRedraws; idxRedraw++) {
					context.resetMatrix();
					if (this._accessibleOutputs.grid || this._accessibleOutputs.text) this._updateAccsOutput();
					if (this._renderer.isP3D) this._renderer._update();
					this.frameCount = context.frameCount + 1;
					await this._runLifecycleHook("predraw");
					this._inUserDraw = true;
					try {
						await context.draw();
					} finally {
						this._inUserDraw = false;
					}
					await this._runLifecycleHook("postdraw");
				}
			}
		};
	}
	if (typeof p5 !== "undefined") structure(p5, p5.prototype);
	const calculateRemainder2D = function(xComponent, yComponent) {
		if (xComponent !== 0) this.x = this.x % xComponent;
		if (yComponent !== 0) this.y = this.y % yComponent;
		return this;
	};
	const calculateRemainder3D = function(xComponent, yComponent, zComponent) {
		if (xComponent !== 0) this.x = this.x % xComponent;
		if (yComponent !== 0) this.y = this.y % yComponent;
		if (zComponent !== 0) this.z = this.z % zComponent;
		return this;
	};
	var Vector = class Vector {
		constructor(...args) {
			let values = args.map((arg) => arg || 0);
			if (typeof args[0] === "function") {
				this.isPInst = true;
				this._fromRadians = args[0];
				this._toRadians = args[1];
				values = args.slice(2).map((arg) => arg || 0);
			}
			let dimensions = values.length;
			if (dimensions === 0) {
				this.dimensions = 2;
				this._values = [
					0,
					0,
					0
				];
			} else {
				this.dimensions = dimensions;
				this._values = values;
			}
		}
		get values() {
			return this._values;
		}
		set values(newValues) {
			let dimensions = newValues.length;
			if (dimensions === 0) {
				this.dimensions = 2;
				this._values = [
					0,
					0,
					0
				];
			} else {
				this.dimensions = dimensions;
				this._values = newValues.slice();
			}
		}
		get x() {
			return this._values[0] || 0;
		}
		getValue(index) {
			if (index < this._values.length) return this._values[index];
			else p5._friendlyError("The index parameter is trying to set a value outside the bounds of the vector", "p5.Vector.setValue");
		}
		setValue(index, value) {
			if (index < this._values.length) this._values[index] = value;
			else p5._friendlyError("The index parameter is trying to set a value outside the bounds of the vector", "p5.Vector.setValue");
		}
		get y() {
			return this._values[1] || 0;
		}
		get z() {
			return this._values[2] || 0;
		}
		get w() {
			return this._values[3] || 0;
		}
		set x(xVal) {
			if (this._values.length > 1) this._values[0] = xVal;
		}
		set y(yVal) {
			if (this._values.length > 1) this._values[1] = yVal;
		}
		set z(zVal) {
			if (this._values.length > 2) this._values[2] = zVal;
		}
		set w(wVal) {
			if (this._values.length > 3) this._values[3] = wVal;
		}
		toString() {
			return `[${this.values.join(", ")}]`;
		}
		set(...args) {
			if (args[0] instanceof Vector) this.values = args[0].values.slice();
			else if (Array.isArray(args[0])) this.values = args[0].map((arg) => arg || 0);
			else this.values = args.map((arg) => arg || 0);
			this.dimensions = this.values.length;
			return this;
		}
		copy() {
			if (this.isPInst) return new Vector(this._fromRadians, this._toRadians, ...this.values);
			else return new Vector(...this.values);
		}
		add(...args) {
			if (args[0] instanceof Vector) args = args[0].values;
			else if (Array.isArray(args[0])) args = args[0];
			args.forEach((value, index) => {
				this.values[index] = (this.values[index] || 0) + (value || 0);
			});
			return this;
		}
		rem(x$1, y, z$1) {
			if (x$1 instanceof Vector) {
				if ([
					x$1.x,
					x$1.y,
					x$1.z
				].every(Number.isFinite)) {
					const xComponent = parseFloat(x$1.x);
					const yComponent = parseFloat(x$1.y);
					const zComponent = parseFloat(x$1.z);
					return calculateRemainder3D.call(this, xComponent, yComponent, zComponent);
				}
			} else if (Array.isArray(x$1)) {
				if (x$1.every((element$1) => Number.isFinite(element$1))) {
					if (x$1.length === 2) return calculateRemainder2D.call(this, x$1[0], x$1[1]);
					if (x$1.length === 3) return calculateRemainder3D.call(this, x$1[0], x$1[1], x$1[2]);
				}
			} else if (arguments.length === 1) {
				if (Number.isFinite(arguments[0]) && arguments[0] !== 0) {
					this.x = this.x % arguments[0];
					this.y = this.y % arguments[0];
					this.z = this.z % arguments[0];
					return this;
				}
			} else if (arguments.length === 2) {
				const vectorComponents = [...arguments];
				if (vectorComponents.every((element$1) => Number.isFinite(element$1))) {
					if (vectorComponents.length === 2) return calculateRemainder2D.call(this, vectorComponents[0], vectorComponents[1]);
				}
			} else if (arguments.length === 3) {
				const vectorComponents = [...arguments];
				if (vectorComponents.every((element$1) => Number.isFinite(element$1))) {
					if (vectorComponents.length === 3) return calculateRemainder3D.call(this, vectorComponents[0], vectorComponents[1], vectorComponents[2]);
				}
			}
		}
		sub(...args) {
			if (args[0] instanceof Vector) args[0].values.forEach((value, index) => {
				this.values[index] -= value || 0;
			});
			else if (Array.isArray(args[0])) args[0].forEach((value, index) => {
				this.values[index] -= value || 0;
			});
			else args.forEach((value, index) => {
				this.values[index] -= value || 0;
			});
			return this;
		}
		mult(...args) {
			if (args.length === 1 && args[0] instanceof Vector) {
				const v$1 = args[0];
				const maxLen = Math.min(this.values.length, v$1.values.length);
				for (let i$1 = 0; i$1 < maxLen; i$1++) if (Number.isFinite(v$1.values[i$1]) && typeof v$1.values[i$1] === "number") this._values[i$1] *= v$1.values[i$1];
				else {
					console.warn("p5.Vector.prototype.mult:", "v contains components that are either undefined or not finite numbers");
					return this;
				}
			} else if (args.length === 1 && Array.isArray(args[0])) {
				const arr$1 = args[0];
				const maxLen = Math.min(this.values.length, arr$1.length);
				for (let i$1 = 0; i$1 < maxLen; i$1++) if (Number.isFinite(arr$1[i$1]) && typeof arr$1[i$1] === "number") this._values[i$1] *= arr$1[i$1];
				else {
					console.warn("p5.Vector.prototype.mult:", "arr contains elements that are either undefined or not finite numbers");
					return this;
				}
			} else if (args.length === 1 && typeof args[0] === "number" && Number.isFinite(args[0])) for (let i$1 = 0; i$1 < this._values.length; i$1++) this._values[i$1] *= args[0];
			return this;
		}
		div(...args) {
			if (args.length === 0) return this;
			if (args.length === 1 && args[0] instanceof Vector) {
				const v$1 = args[0];
				if (v$1._values.every((val$1) => Number.isFinite(val$1) && typeof val$1 === "number")) {
					if (v$1._values.some((val$1) => val$1 === 0)) {
						console.warn("p5.Vector.prototype.div:", "divide by 0");
						return this;
					}
					this._values = this._values.map((val$1, i$1) => val$1 / v$1._values[i$1]);
				} else console.warn("p5.Vector.prototype.div:", "vector contains components that are either undefined or not finite numbers");
				return this;
			}
			if (args.length === 1 && Array.isArray(args[0])) {
				const arr$1 = args[0];
				if (arr$1.every((val$1) => Number.isFinite(val$1) && typeof val$1 === "number")) {
					if (arr$1.some((val$1) => val$1 === 0)) {
						console.warn("p5.Vector.prototype.div:", "divide by 0");
						return this;
					}
					this._values = this._values.map((val$1, i$1) => val$1 / arr$1[i$1]);
				} else console.warn("p5.Vector.prototype.div:", "array contains components that are either undefined or not finite numbers");
				return this;
			}
			if (args.every((val$1) => Number.isFinite(val$1) && typeof val$1 === "number")) {
				if (args.some((val$1) => val$1 === 0)) {
					console.warn("p5.Vector.prototype.div:", "divide by 0");
					return this;
				}
				this._values = this._values.map((val$1, i$1) => val$1 / args[0]);
			} else console.warn("p5.Vector.prototype.div:", "arguments contain components that are either undefined or not finite numbers");
			return this;
		}
		mag() {
			return Math.sqrt(this.magSq());
		}
		magSq() {
			return this._values.reduce((sum, component) => sum + component * component, 0);
		}
		dot(...args) {
			if (args[0] instanceof Vector) return this.dot(...args[0]._values);
			return this._values.reduce((sum, component, index) => {
				return sum + component * (args[index] || 0);
			}, 0);
		}
		cross(v$1) {
			const x$1 = this.y * v$1.z - this.z * v$1.y;
			const y = this.z * v$1.x - this.x * v$1.z;
			const z$1 = this.x * v$1.y - this.y * v$1.x;
			if (this.isPInst) return new Vector(this._fromRadians, this._toRadians, x$1, y, z$1);
			else return new Vector(x$1, y, z$1);
		}
		dist(v$1) {
			return v$1.copy().sub(this).mag();
		}
		normalize() {
			const len = this.mag();
			if (len !== 0) this.mult(1 / len);
			return this;
		}
		limit(max) {
			const mSq = this.magSq();
			if (mSq > max * max) this.div(Math.sqrt(mSq)).mult(max);
			return this;
		}
		setMag(n$2) {
			return this.normalize().mult(n$2);
		}
		heading() {
			const h = Math.atan2(this.y, this.x);
			if (this.isPInst) return this._fromRadians(h);
			return h;
		}
		setHeading(a) {
			if (this.isPInst) a = this._toRadians(a);
			let m = this.mag();
			this.x = m * Math.cos(a);
			this.y = m * Math.sin(a);
			return this;
		}
		rotate(a) {
			let newHeading = this.heading() + a;
			if (this.isPInst) newHeading = this._toRadians(newHeading);
			const mag = this.mag();
			this.x = Math.cos(newHeading) * mag;
			this.y = Math.sin(newHeading) * mag;
			return this;
		}
		angleBetween(v$1) {
			if (this.magSq() * v$1.magSq() === 0) return NaN;
			const u$1 = this.cross(v$1);
			let angle = Math.atan2(u$1.mag(), this.dot(v$1)) * Math.sign(u$1.z || 1);
			if (this.isPInst) angle = this._fromRadians(angle);
			return angle;
		}
		lerp(x$1, y, z$1, amt) {
			if (x$1 instanceof Vector) return this.lerp(x$1.x, x$1.y, x$1.z, y);
			this.x += (x$1 - this.x) * amt || 0;
			this.y += (y - this.y) * amt || 0;
			this.z += (z$1 - this.z) * amt || 0;
			return this;
		}
		slerp(v$1, amt) {
			if (amt === 0) return this;
			if (amt === 1) return this.set(v$1);
			const selfMag = this.mag();
			const vMag = v$1.mag();
			if (selfMag * vMag === 0) {
				this.mult(1 - amt).add(v$1.x * amt, v$1.y * amt, v$1.z * amt);
				return this;
			}
			const axis = this.cross(v$1);
			const axisMag = axis.mag();
			const theta = Math.atan2(axisMag, this.dot(v$1));
			if (axisMag > 0) {
				axis.x /= axisMag;
				axis.y /= axisMag;
				axis.z /= axisMag;
			} else if (theta < Math.PI * .5) {
				this.mult(1 - amt).add(v$1.x * amt, v$1.y * amt, v$1.z * amt);
				return this;
			} else if (this.z === 0 && v$1.z === 0) axis.set(0, 0, 1);
			else if (this.x !== 0) axis.set(this.y, -this.x, 0).normalize();
			else axis.set(1, 0, 0);
			const ey = axis.cross(this);
			const lerpedMagFactor = 1 - amt + amt * vMag / selfMag;
			const cosMultiplier = lerpedMagFactor * Math.cos(amt * theta);
			const sinMultiplier = lerpedMagFactor * Math.sin(amt * theta);
			this.x = this.x * cosMultiplier + ey.x * sinMultiplier;
			this.y = this.y * cosMultiplier + ey.y * sinMultiplier;
			this.z = this.z * cosMultiplier + ey.z * sinMultiplier;
			return this;
		}
		reflect(surfaceNormal) {
			const surfaceNormalCopy = Vector.normalize(surfaceNormal);
			return this.sub(surfaceNormalCopy.mult(2 * this.dot(surfaceNormalCopy)));
		}
		array() {
			return [
				this.x || 0,
				this.y || 0,
				this.z || 0
			];
		}
		equals(...args) {
			let values;
			if (args[0] instanceof Vector) values = args[0]._values;
			else if (Array.isArray(args[0])) values = args[0];
			else values = args;
			for (let i$1 = 0; i$1 < this._values.length; i$1++) if (this._values[i$1] !== (values[i$1] || 0)) return false;
			return true;
		}
		clampToZero() {
			for (let i$1 = 0; i$1 < this._values.length; i$1++) this._values[i$1] = this._clampToZero(this._values[i$1]);
			return this;
		}
		_clampToZero(val$1) {
			return Math.abs((val$1 || 0) - 0) <= Number.EPSILON ? 0 : val$1;
		}
		static fromAngle(angle, length) {
			if (typeof length === "undefined") length = 1;
			return new Vector(length * Math.cos(angle), length * Math.sin(angle), 0);
		}
		static fromAngles(theta, phi, length) {
			if (typeof length === "undefined") length = 1;
			const cosPhi = Math.cos(phi);
			const sinPhi = Math.sin(phi);
			const cosTheta = Math.cos(theta);
			const sinTheta = Math.sin(theta);
			return new Vector(length * sinTheta * sinPhi, -length * cosTheta, length * sinTheta * cosPhi);
		}
		static random2D() {
			return this.fromAngle(Math.random() * TWO_PI);
		}
		static random3D() {
			const angle = Math.random() * TWO_PI;
			const vz = Math.random() * 2 - 1;
			const vzBase = Math.sqrt(1 - vz * vz);
			return new Vector(vzBase * Math.cos(angle), vzBase * Math.sin(angle), vz);
		}
		static copy(v$1) {
			return v$1.copy(v$1);
		}
		static add(v1, v2, target) {
			if (!target) {
				target = v1.copy();
				if (arguments.length === 3) p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.add");
			} else target.set(v1);
			target.add(v2);
			return target;
		}
		static rem(v1, v2) {
			if (v1 instanceof Vector && v2 instanceof Vector) {
				let target = v1.copy();
				target.rem(v2);
				return target;
			}
		}
		static sub(v1, v2, target) {
			if (!target) {
				target = v1.copy();
				if (arguments.length === 3) p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.sub");
			} else target.set(v1);
			target.sub(v2);
			return target;
		}
		static mult(v$1, n$2, target) {
			if (!target) {
				target = v$1.copy();
				if (arguments.length === 3) p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.mult");
			} else target.set(v$1);
			target.mult(n$2);
			return target;
		}
		static rotate(v$1, a, target) {
			if (arguments.length === 2) target = v$1.copy();
			else {
				if (!(target instanceof Vector)) p5._friendlyError("The target parameter should be of type p5.Vector", "p5.Vector.rotate");
				target.set(v$1);
			}
			target.rotate(a);
			return target;
		}
		static div(v$1, n$2, target) {
			if (!target) {
				target = v$1.copy();
				if (arguments.length === 3) p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.div");
			} else target.set(v$1);
			target.div(n$2);
			return target;
		}
		static dot(v1, v2) {
			return v1.dot(v2);
		}
		static cross(v1, v2) {
			return v1.cross(v2);
		}
		static dist(v1, v2) {
			return v1.dist(v2);
		}
		static lerp(v1, v2, amt, target) {
			if (!target) {
				target = v1.copy();
				if (arguments.length === 4) p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.lerp");
			} else target.set(v1);
			target.lerp(v2, amt);
			return target;
		}
		static slerp(v1, v2, amt, target) {
			if (!target) {
				target = v1.copy();
				if (arguments.length === 4) p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.slerp");
			} else target.set(v1);
			target.slerp(v2, amt);
			return target;
		}
		static mag(vecT) {
			return vecT.mag();
		}
		static magSq(vecT) {
			return vecT.magSq();
		}
		static normalize(v$1, target) {
			if (arguments.length < 2) target = v$1.copy();
			else {
				if (!(target instanceof Vector)) p5._friendlyError("The target parameter should be of type p5.Vector", "p5.Vector.normalize");
				target.set(v$1);
			}
			return target.normalize();
		}
		static limit(v$1, max, target) {
			if (arguments.length < 3) target = v$1.copy();
			else {
				if (!(target instanceof Vector)) p5._friendlyError("The target parameter should be of type p5.Vector", "p5.Vector.limit");
				target.set(v$1);
			}
			return target.limit(max);
		}
		static setMag(v$1, len, target) {
			if (arguments.length < 3) target = v$1.copy();
			else {
				if (!(target instanceof Vector)) p5._friendlyError("The target parameter should be of type p5.Vector", "p5.Vector.setMag");
				target.set(v$1);
			}
			return target.setMag(len);
		}
		static heading(v$1) {
			return v$1.heading();
		}
		static angleBetween(v1, v2) {
			return v1.angleBetween(v2);
		}
		static reflect(incidentVector, surfaceNormal, target) {
			if (arguments.length < 3) target = incidentVector.copy();
			else {
				if (!(target instanceof Vector)) p5._friendlyError("The target parameter should be of type p5.Vector", "p5.Vector.reflect");
				target.set(incidentVector);
			}
			return target.reflect(surfaceNormal);
		}
		static array(v$1) {
			return v$1.array();
		}
		static equals(v1, v2) {
			let v$1;
			if (v1 instanceof Vector) v$1 = v1;
			else if (v1 instanceof Array) v$1 = new Vector().set(v1);
			else p5._friendlyError("The v1 parameter should be of type Array or p5.Vector", "p5.Vector.equals");
			return v$1.equals(v2);
		}
	};
	function vector(p5$2, fn$1) {
		p5$2.Vector = Vector;
	}
	if (typeof p5 !== "undefined") vector(p5, p5.prototype);
	function environment(p5$2, fn$1) {
		const standardCursors = [
			ARROW,
			CROSS,
			HAND,
			MOVE,
			TEXT,
			WAIT
		];
		fn$1._frameRate = 0;
		fn$1._lastFrameTime = window.performance.now();
		fn$1._targetFrameRate = 60;
		const _windowPrint = window.print;
		let windowPrintDisabled = false;
		fn$1.print = function(...args) {
			if (!args.length) {
				if (!windowPrintDisabled) {
					_windowPrint();
					if (window.confirm("You just tried to print the webpage. Do you want to prevent this from running again?")) windowPrintDisabled = true;
				}
			} else console.log(...args);
		};
		fn$1.frameCount = 0;
		fn$1.deltaTime = 0;
		fn$1.focused = document.hasFocus();
		fn$1.cursor = function(type$2, x$1, y) {
			let cursor = "auto";
			const canvas$1 = this._curElement.elt;
			if (standardCursors.includes(type$2)) cursor = type$2;
			else if (typeof type$2 === "string") {
				let coords = "";
				if (x$1 && y && typeof x$1 === "number" && typeof y === "number") coords = `${x$1} ${y}`;
				if (type$2.substring(0, 7) === "http://" || type$2.substring(0, 8) === "https://") cursor = `url(${type$2}) ${coords}, auto`;
				else if (/\.(cur|jpg|jpeg|gif|png|CUR|JPG|JPEG|GIF|PNG)$/.test(type$2)) cursor = `url(${type$2}) ${coords}, auto`;
				else cursor = type$2;
			}
			canvas$1.style.cursor = cursor;
		};
		fn$1.frameRate = function(fps) {
			if (typeof fps !== "number" || fps < 0) return this._frameRate;
			else {
				this._targetFrameRate = fps;
				if (fps === 0) this._frameRate = fps;
				return this;
			}
		};
		fn$1.getFrameRate = function() {
			return this.frameRate();
		};
		fn$1.setFrameRate = function(fps) {
			return this.frameRate(fps);
		};
		fn$1.getTargetFrameRate = function() {
			return this._targetFrameRate;
		};
		fn$1.noCursor = function() {
			this._curElement.elt.style.cursor = "none";
		};
		fn$1.webglVersion = P2D;
		fn$1.displayWidth = screen.width;
		fn$1.displayHeight = screen.height;
		fn$1.windowWidth = 0;
		fn$1.windowHeight = 0;
		fn$1._onresize = function(e$1) {
			this.windowWidth = getWindowWidth();
			this.windowHeight = getWindowHeight();
			const context = this._isGlobal ? window : this;
			let executeDefault;
			if (typeof context.windowResized === "function") {
				executeDefault = context.windowResized(e$1);
				if (executeDefault !== void 0 && !executeDefault) e$1.preventDefault();
			}
		};
		function getWindowWidth() {
			return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth || 0;
		}
		function getWindowHeight() {
			return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight || 0;
		}
		fn$1._updateWindowSize = function() {
			this.windowWidth = getWindowWidth();
			this.windowHeight = getWindowHeight();
		};
		Object.defineProperty(fn$1, "width", { get() {
			return this._renderer.width;
		} });
		Object.defineProperty(fn$1, "height", { get() {
			return this._renderer.height;
		} });
		fn$1.fullscreen = function(val$1) {
			if (typeof val$1 === "undefined") return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
			else if (val$1) launchFullscreen(document.documentElement);
			else exitFullscreen();
		};
		fn$1.pixelDensity = function(val$1) {
			let returnValue;
			if (typeof val$1 === "number") {
				if (val$1 !== this._renderer._pixelDensity) this._renderer._pixelDensity = val$1;
				returnValue = this;
				this.resizeCanvas(this.width, this.height, true);
			} else returnValue = this._renderer._pixelDensity;
			return returnValue;
		};
		fn$1.displayDensity = () => window.devicePixelRatio;
		function launchFullscreen(element$1) {
			if (!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled)) throw new Error("Fullscreen not enabled in this browser.");
			if (element$1.requestFullscreen) element$1.requestFullscreen();
			else if (element$1.mozRequestFullScreen) element$1.mozRequestFullScreen();
			else if (element$1.webkitRequestFullscreen) element$1.webkitRequestFullscreen();
			else if (element$1.msRequestFullscreen) element$1.msRequestFullscreen();
		}
		function exitFullscreen() {
			if (document.exitFullscreen) document.exitFullscreen();
			else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
			else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
			else if (document.msExitFullscreen) document.msExitFullscreen();
		}
		fn$1.getURL = () => location.href;
		fn$1.getURLPath = () => location.pathname.split("/").filter((v$1) => v$1 !== "");
		fn$1.getURLParams = function() {
			const re = /[?&]([^&=]+)(?:[&=])([^&=]+)/gim;
			let m;
			const v$1 = {};
			while ((m = re.exec(location.search)) != null) {
				if (m.index === re.lastIndex) re.lastIndex++;
				v$1[m[1]] = m[2];
			}
			return v$1;
		};
		fn$1.worldToScreen = function(worldPosition) {
			if (typeof worldPosition === "number") worldPosition = this.createVector(...arguments);
			return this._renderer.getWorldToScreenMatrix().multiplyAndNormalizePoint(worldPosition);
		};
		fn$1.screenToWorld = function(screenPosition) {
			if (typeof screenPosition === "number") screenPosition = this.createVector(...arguments);
			const matrix$1 = this._renderer.getWorldToScreenMatrix();
			if (screenPosition.dimensions == 2) {
				let z$1 = matrix$1.mat4[14] / matrix$1.mat4[15];
				screenPosition = this.createVector(screenPosition.x, screenPosition.y, z$1);
			}
			return matrix$1.invert(matrix$1).multiplyAndNormalizePoint(screenPosition);
		};
	}
	if (typeof p5 !== "undefined") environment(p5, p5.prototype);
	function multiplyMatrices(A$1, B$1) {
		let m = A$1.length;
		if (!Array.isArray(A$1[0])) A$1 = [A$1];
		if (!Array.isArray(B$1[0])) B$1 = B$1.map((x$1) => [x$1]);
		let p$1 = B$1[0].length;
		let B_cols = B$1[0].map((_, i$1) => B$1.map((x$1) => x$1[i$1]));
		let product = A$1.map((row) => B_cols.map((col) => {
			let ret = 0;
			if (!Array.isArray(row)) {
				for (let c of col) ret += row * c;
				return ret;
			}
			for (let i$1 = 0; i$1 < row.length; i$1++) ret += row[i$1] * (col[i$1] || 0);
			return ret;
		}));
		if (m === 1) product = product[0];
		if (p$1 === 1) return product.map((x$1) => x$1[0]);
		return product;
	}
	function isString(str) {
		return type$1(str) === "string";
	}
	function type$1(o) {
		return (Object.prototype.toString.call(o).match(/^\[object\s+(.*?)\]$/)[1] || "").toLowerCase();
	}
	function serializeNumber(n$2, { precision, unit }) {
		if (isNone(n$2)) return "none";
		return toPrecision(n$2, precision) + (unit ?? "");
	}
	function isNone(n$2) {
		return Number.isNaN(n$2) || n$2 instanceof Number && n$2?.none;
	}
	function toPrecision(n$2, precision) {
		if (n$2 === 0) return 0;
		let integer$1 = ~~n$2;
		let digits = 0;
		if (integer$1 && precision) digits = ~~Math.log10(Math.abs(integer$1)) + 1;
		const multiplier = 10 ** (precision - digits);
		return Math.floor(n$2 * multiplier + .5) / multiplier;
	}
	const angleFactor = {
		deg: 1,
		grad: .9,
		rad: 180 / Math.PI,
		turn: 360
	};
	function parseFunction(str) {
		if (!str) return;
		str = str.trim();
		const isFunctionRegex = /^([a-z]+)\((.+?)\)$/i;
		const isNumberRegex = /^-?[\d.]+$/;
		const unitValueRegex = /%|deg|g?rad|turn$/;
		const singleArgument = /\/?\s*(none|[-\w.]+(?:%|deg|g?rad|turn)?)/g;
		let parts = str.match(isFunctionRegex);
		if (parts) {
			let args = [];
			parts[2].replace(singleArgument, ($0, rawArg) => {
				let match = rawArg.match(unitValueRegex);
				let arg = rawArg;
				if (match) {
					let unit = match[0];
					let unitlessArg = arg.slice(0, -unit.length);
					if (unit === "%") {
						arg = /* @__PURE__ */ new Number(unitlessArg / 100);
						arg.type = "<percentage>";
					} else {
						arg = new Number(unitlessArg * angleFactor[unit]);
						arg.type = "<angle>";
						arg.unit = unit;
					}
				} else if (isNumberRegex.test(arg)) {
					arg = new Number(arg);
					arg.type = "<number>";
				} else if (arg === "none") {
					arg = /* @__PURE__ */ new Number(NaN);
					arg.none = true;
				}
				if ($0.startsWith("/")) {
					arg = arg instanceof Number ? arg : new Number(arg);
					arg.alpha = true;
				}
				if (typeof arg === "object" && arg instanceof Number) arg.raw = rawArg;
				args.push(arg);
			});
			return {
				name: parts[1].toLowerCase(),
				rawName: parts[1],
				rawArgs: parts[2],
				args
			};
		}
	}
	function last(arr$1) {
		return arr$1[arr$1.length - 1];
	}
	function interpolate(start, end, p$1) {
		if (isNaN(start)) return end;
		if (isNaN(end)) return start;
		return start + (end - start) * p$1;
	}
	function interpolateInv(start, end, value) {
		return (value - start) / (end - start);
	}
	function mapRange(from, to$1, value) {
		return interpolate(to$1[0], to$1[1], interpolateInv(from[0], from[1], value));
	}
	function parseCoordGrammar(coordGrammars) {
		return coordGrammars.map((coordGrammar$1) => {
			return coordGrammar$1.split("|").map((type$2) => {
				type$2 = type$2.trim();
				let range$1 = type$2.match(/^(<[a-z]+>)\[(-?[.\d]+),\s*(-?[.\d]+)\]?$/);
				if (range$1) {
					let ret = new String(range$1[1]);
					ret.range = [+range$1[2], +range$1[3]];
					return ret;
				}
				return type$2;
			});
		});
	}
	function clamp$1(min, val$1, max) {
		return Math.max(Math.min(max, val$1), min);
	}
	function copySign(to$1, from) {
		return Math.sign(to$1) === Math.sign(from) ? to$1 : -to$1;
	}
	function spow(base$1, exp) {
		return copySign(Math.abs(base$1) ** exp, base$1);
	}
	function zdiv(n$2, d$1) {
		return d$1 === 0 ? 0 : n$2 / d$1;
	}
	function bisectLeft(arr$1, value, lo = 0, hi = arr$1.length) {
		while (lo < hi) {
			const mid = lo + hi >> 1;
			if (arr$1[mid] < value) lo = mid + 1;
			else hi = mid;
		}
		return lo;
	}
	var Hooks = class {
		add(name, callback, first) {
			if (typeof arguments[0] != "string") {
				for (var name in arguments[0]) this.add(name, arguments[0][name], arguments[1]);
				return;
			}
			(Array.isArray(name) ? name : [name]).forEach(function(name$1) {
				this[name$1] = this[name$1] || [];
				if (callback) this[name$1][first ? "unshift" : "push"](callback);
			}, this);
		}
		run(name, env) {
			this[name] = this[name] || [];
			this[name].forEach(function(callback) {
				callback.call(env && env.context ? env.context : env, env);
			});
		}
	};
	var hooks_default = new Hooks();
	const WHITES = {
		D50: [
			.3457 / .3585,
			1,
			.2958 / .3585
		],
		D65: [
			.3127 / .329,
			1,
			.3583 / .329
		]
	};
	function getWhite(name) {
		if (Array.isArray(name)) return name;
		return WHITES[name];
	}
	function adapt$1(W1, W2, XYZ, options$1 = {}) {
		W1 = getWhite(W1);
		W2 = getWhite(W2);
		if (!W1 || !W2) throw new TypeError(`Missing white point to convert ${!W1 ? "from" : ""}${!W1 && !W2 ? "/" : ""}${!W2 ? "to" : ""}`);
		if (W1 === W2) return XYZ;
		let env = {
			W1,
			W2,
			XYZ,
			options: options$1
		};
		hooks_default.run("chromatic-adaptation-start", env);
		if (!env.M) {
			if (env.W1 === WHITES.D65 && env.W2 === WHITES.D50) env.M = [
				[
					1.0479297925449969,
					.022946870601609652,
					-.05019226628920524
				],
				[
					.02962780877005599,
					.9904344267538799,
					-.017073799063418826
				],
				[
					-.009243040646204504,
					.015055191490298152,
					.7518742814281371
				]
			];
			else if (env.W1 === WHITES.D50 && env.W2 === WHITES.D65) env.M = [
				[
					.955473421488075,
					-.02309845494876471,
					.06325924320057072
				],
				[
					-.0283697093338637,
					1.0099953980813041,
					.021041441191917323
				],
				[
					.012314014864481998,
					-.020507649298898964,
					1.330365926242124
				]
			];
		}
		hooks_default.run("chromatic-adaptation-end", env);
		if (env.M) return multiplyMatrices(env.M, env.XYZ);
		else throw new TypeError("Only Bradford CAT with white points D50 and D65 supported for now.");
	}
	var defaults_default = {
		gamut_mapping: "css",
		precision: 5,
		deltaE: "76",
		verbose: globalThis?.process?.env?.NODE_ENV?.toLowerCase() !== "test",
		warn: function warn(msg) {
			if (this.verbose) globalThis?.console?.warn?.(msg);
		}
	};
	const noneTypes = new Set([
		"<number>",
		"<percentage>",
		"<angle>"
	]);
	function coerceCoords(space, format, name, coords) {
		return Object.entries(space.coords).map(([id, coordMeta], i$1) => {
			let coordGrammar$1 = format.coordGrammar[i$1];
			let arg = coords[i$1];
			let providedType = arg?.type;
			let type$2;
			if (arg.none) type$2 = coordGrammar$1.find((c) => noneTypes.has(c));
			else type$2 = coordGrammar$1.find((c) => c == providedType);
			if (!type$2) {
				let coordName = coordMeta.name || id;
				throw new TypeError(`${providedType ?? arg.raw} not allowed for ${coordName} in ${name}()`);
			}
			let fromRange = type$2.range;
			if (providedType === "<percentage>") fromRange ||= [0, 1];
			let toRange = coordMeta.range || coordMeta.refRange;
			if (fromRange && toRange) coords[i$1] = mapRange(fromRange, toRange, coords[i$1]);
			return type$2;
		});
	}
	function parse$4(str, { meta } = {}) {
		let env = { "str": String(str)?.trim() };
		hooks_default.run("parse-start", env);
		if (env.color) return env.color;
		env.parsed = parseFunction(env.str);
		if (env.parsed) {
			let name = env.parsed.name;
			if (name === "color") {
				let id = env.parsed.args.shift();
				let alternateId = id.startsWith("--") ? id.substring(2) : `--${id}`;
				let ids = [id, alternateId];
				let alpha = env.parsed.rawArgs.indexOf("/") > 0 ? env.parsed.args.pop() : 1;
				for (let space of ColorSpace.all) {
					let colorSpec = space.getFormat("color");
					if (colorSpec) {
						if (ids.includes(colorSpec.id) || colorSpec.ids?.filter((specId) => ids.includes(specId)).length) {
							const coords = Object.keys(space.coords).map((_, i$1) => env.parsed.args[i$1] || 0);
							let types$2;
							if (colorSpec.coordGrammar) types$2 = coerceCoords(space, colorSpec, "color", coords);
							if (meta) Object.assign(meta, {
								formatId: "color",
								types: types$2
							});
							if (colorSpec.id.startsWith("--") && !id.startsWith("--")) defaults_default.warn(`${space.name} is a non-standard space and not currently supported in the CSS spec. Use prefixed color(${colorSpec.id}) instead of color(${id}).`);
							if (id.startsWith("--") && !colorSpec.id.startsWith("--")) defaults_default.warn(`${space.name} is a standard space and supported in the CSS spec. Use color(${colorSpec.id}) instead of prefixed color(${id}).`);
							return {
								spaceId: space.id,
								coords,
								alpha
							};
						}
					}
				}
				let didYouMean = "";
				let registryId = id in ColorSpace.registry ? id : alternateId;
				if (registryId in ColorSpace.registry) {
					let cssId = ColorSpace.registry[registryId].formats?.color?.id;
					if (cssId) didYouMean = `Did you mean color(${cssId})?`;
				}
				throw new TypeError(`Cannot parse color(${id}). ` + (didYouMean || "Missing a plugin?"));
			} else for (let space of ColorSpace.all) {
				let format = space.getFormat(name);
				if (format && format.type === "function") {
					let alpha = 1;
					if (format.lastAlpha || last(env.parsed.args).alpha) alpha = env.parsed.args.pop();
					let coords = env.parsed.args;
					let types$2;
					if (format.coordGrammar) types$2 = coerceCoords(space, format, name, coords);
					if (meta) Object.assign(meta, {
						formatId: format.name,
						types: types$2
					});
					return {
						spaceId: space.id,
						coords,
						alpha
					};
				}
			}
		} else for (let space of ColorSpace.all) for (let formatId in space.formats) {
			let format = space.formats[formatId];
			if (format.type !== "custom") continue;
			if (format.test && !format.test(env.str)) continue;
			let color$2 = format.parse(env.str);
			if (color$2) {
				color$2.alpha ??= 1;
				if (meta) meta.formatId = formatId;
				return color$2;
			}
		}
		throw new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);
	}
	function getColor(color$2) {
		if (Array.isArray(color$2)) return color$2.map(getColor);
		if (!color$2) throw new TypeError("Empty color reference");
		if (isString(color$2)) color$2 = parse$4(color$2);
		let space = color$2.space || color$2.spaceId;
		if (!(space instanceof ColorSpace)) color$2.space = ColorSpace.get(space);
		if (color$2.alpha === void 0) color$2.alpha = 1;
		return color$2;
	}
	const ε$3 = 75e-6;
	var ColorSpace = class ColorSpace {
		constructor(options$1) {
			this.id = options$1.id;
			this.name = options$1.name;
			this.base = options$1.base ? ColorSpace.get(options$1.base) : null;
			this.aliases = options$1.aliases;
			if (this.base) {
				this.fromBase = options$1.fromBase;
				this.toBase = options$1.toBase;
			}
			let coords = options$1.coords ?? this.base.coords;
			for (let name in coords) if (!("name" in coords[name])) coords[name].name = name;
			this.coords = coords;
			this.white = getWhite(options$1.white ?? this.base.white ?? "D65");
			this.formats = options$1.formats ?? {};
			for (let name in this.formats) {
				let format = this.formats[name];
				format.type ||= "function";
				format.name ||= name;
			}
			if (!this.formats.color?.id) this.formats.color = {
				...this.formats.color ?? {},
				id: options$1.cssId || this.id
			};
			if (options$1.gamutSpace) this.gamutSpace = options$1.gamutSpace === "self" ? this : ColorSpace.get(options$1.gamutSpace);
			else if (this.isPolar) this.gamutSpace = this.base;
			else this.gamutSpace = this;
			if (this.gamutSpace.isUnbounded) this.inGamut = (coords$1, options$2) => {
				return true;
			};
			this.referred = options$1.referred;
			Object.defineProperty(this, "path", {
				value: getPath$1(this).reverse(),
				writable: false,
				enumerable: true,
				configurable: true
			});
			hooks_default.run("colorspace-init-end", this);
		}
		inGamut(coords, { epsilon = ε$3 } = {}) {
			if (!this.equals(this.gamutSpace)) {
				coords = this.to(this.gamutSpace, coords);
				return this.gamutSpace.inGamut(coords, { epsilon });
			}
			let coordMeta = Object.values(this.coords);
			return coords.every((c, i$1) => {
				let meta = coordMeta[i$1];
				if (meta.type !== "angle" && meta.range) {
					if (Number.isNaN(c)) return true;
					let [min, max] = meta.range;
					return (min === void 0 || c >= min - epsilon) && (max === void 0 || c <= max + epsilon);
				}
				return true;
			});
		}
		get isUnbounded() {
			return Object.values(this.coords).every((coord) => !("range" in coord));
		}
		get cssId() {
			return this.formats?.color?.id || this.id;
		}
		get isPolar() {
			for (let id in this.coords) if (this.coords[id].type === "angle") return true;
			return false;
		}
		getFormat(format) {
			if (typeof format === "object") {
				format = processFormat(format, this);
				return format;
			}
			let ret;
			if (format === "default") ret = Object.values(this.formats)[0];
			else ret = this.formats[format];
			if (ret) {
				ret = processFormat(ret, this);
				return ret;
			}
			return null;
		}
		equals(space) {
			if (!space) return false;
			return this === space || this.id === space || this.id === space.id;
		}
		to(space, coords) {
			if (arguments.length === 1) {
				const color$2 = getColor(space);
				[space, coords] = [color$2.space, color$2.coords];
			}
			space = ColorSpace.get(space);
			if (this.equals(space)) return coords;
			coords = coords.map((c) => Number.isNaN(c) ? 0 : c);
			let myPath = this.path;
			let otherPath = space.path;
			let connectionSpace, connectionSpaceIndex;
			for (let i$1 = 0; i$1 < myPath.length; i$1++) if (myPath[i$1].equals(otherPath[i$1])) {
				connectionSpace = myPath[i$1];
				connectionSpaceIndex = i$1;
			} else break;
			if (!connectionSpace) throw new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);
			for (let i$1 = myPath.length - 1; i$1 > connectionSpaceIndex; i$1--) coords = myPath[i$1].toBase(coords);
			for (let i$1 = connectionSpaceIndex + 1; i$1 < otherPath.length; i$1++) coords = otherPath[i$1].fromBase(coords);
			return coords;
		}
		from(space, coords) {
			if (arguments.length === 1) {
				const color$2 = getColor(space);
				[space, coords] = [color$2.space, color$2.coords];
			}
			space = ColorSpace.get(space);
			return space.to(this, coords);
		}
		toString() {
			return `${this.name} (${this.id})`;
		}
		getMinCoords() {
			let ret = [];
			for (let id in this.coords) {
				let meta = this.coords[id];
				let range$1 = meta.range || meta.refRange;
				ret.push(range$1?.min ?? 0);
			}
			return ret;
		}
		static registry = {};
		static get all() {
			return [...new Set(Object.values(ColorSpace.registry))];
		}
		static register(id, space) {
			if (arguments.length === 1) {
				space = arguments[0];
				id = space.id;
			}
			space = this.get(space);
			if (this.registry[id] && this.registry[id] !== space) throw new Error(`Duplicate color space registration: '${id}'`);
			this.registry[id] = space;
			if (arguments.length === 1 && space.aliases) for (let alias of space.aliases) this.register(alias, space);
			return space;
		}
		static get(space, ...alternatives) {
			if (!space || space instanceof ColorSpace) return space;
			if (type$1(space) === "string") {
				let ret = ColorSpace.registry[space.toLowerCase()];
				if (!ret) throw new TypeError(`No color space found with id = "${space}"`);
				return ret;
			}
			if (alternatives.length) return ColorSpace.get(...alternatives);
			throw new TypeError(`${space} is not a valid color space`);
		}
		static resolveCoord(ref$1, workingSpace) {
			let coordType = type$1(ref$1);
			let space, coord;
			if (coordType === "string") if (ref$1.includes(".")) [space, coord] = ref$1.split(".");
			else [space, coord] = [, ref$1];
			else if (Array.isArray(ref$1)) [space, coord] = ref$1;
			else {
				space = ref$1.space;
				coord = ref$1.coordId;
			}
			space = ColorSpace.get(space);
			if (!space) space = workingSpace;
			if (!space) throw new TypeError(`Cannot resolve coordinate reference ${ref$1}: No color space specified and relative references are not allowed here`);
			coordType = type$1(coord);
			if (coordType === "number" || coordType === "string" && coord >= 0) {
				let meta = Object.entries(space.coords)[coord];
				if (meta) return {
					space,
					id: meta[0],
					index: coord,
					...meta[1]
				};
			}
			space = ColorSpace.get(space);
			let normalizedCoord = coord.toLowerCase();
			let i$1 = 0;
			for (let id in space.coords) {
				let meta = space.coords[id];
				if (id.toLowerCase() === normalizedCoord || meta.name?.toLowerCase() === normalizedCoord) return {
					space,
					id,
					index: i$1,
					...meta
				};
				i$1++;
			}
			throw new TypeError(`No "${coord}" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(", ")}`);
		}
		static DEFAULT_FORMAT = {
			type: "functions",
			name: "color"
		};
	};
	function getPath$1(space) {
		let ret = [space];
		for (let s = space; s = s.base;) ret.push(s);
		return ret;
	}
	function processFormat(format, { coords } = {}) {
		if (format.coords && !format.coordGrammar) {
			format.type ||= "function";
			format.name ||= "color";
			format.coordGrammar = parseCoordGrammar(format.coords);
			let coordFormats = Object.entries(coords).map(([id, coordMeta], i$1) => {
				let outputType = format.coordGrammar[i$1][0];
				let fromRange = coordMeta.range || coordMeta.refRange;
				let toRange = outputType.range, suffix = "";
				if (outputType == "<percentage>") {
					toRange = [0, 100];
					suffix = "%";
				} else if (outputType == "<angle>") suffix = "deg";
				return {
					fromRange,
					toRange,
					suffix
				};
			});
			format.serializeCoords = (coords$1, precision) => {
				return coords$1.map((c, i$1) => {
					let { fromRange, toRange, suffix } = coordFormats[i$1];
					if (fromRange && toRange) c = mapRange(fromRange, toRange, c);
					c = serializeNumber(c, {
						precision,
						unit: suffix
					});
					return c;
				});
			};
		}
		return format;
	}
	var xyz_d65_default = new ColorSpace({
		id: "xyz-d65",
		name: "XYZ D65",
		coords: {
			x: { name: "X" },
			y: { name: "Y" },
			z: { name: "Z" }
		},
		white: "D65",
		formats: { color: { ids: ["xyz-d65", "xyz"] } },
		aliases: ["xyz"]
	});
	var RGBColorSpace = class extends ColorSpace {
		constructor(options$1) {
			if (!options$1.coords) options$1.coords = {
				r: {
					range: [0, 1],
					name: "Red"
				},
				g: {
					range: [0, 1],
					name: "Green"
				},
				b: {
					range: [0, 1],
					name: "Blue"
				}
			};
			if (!options$1.base) options$1.base = xyz_d65_default;
			if (options$1.toXYZ_M && options$1.fromXYZ_M) {
				options$1.toBase ??= (rgb) => {
					let xyz = multiplyMatrices(options$1.toXYZ_M, rgb);
					if (this.white !== this.base.white) xyz = adapt$1(this.white, this.base.white, xyz);
					return xyz;
				};
				options$1.fromBase ??= (xyz) => {
					xyz = adapt$1(this.base.white, this.white, xyz);
					return multiplyMatrices(options$1.fromXYZ_M, xyz);
				};
			}
			options$1.referred ??= "display";
			super(options$1);
		}
	};
	function getAll(color$2, space) {
		color$2 = getColor(color$2);
		if (!space || color$2.space.equals(space)) return color$2.coords.slice();
		space = ColorSpace.get(space);
		return space.from(color$2);
	}
	function get$1(color$2, prop) {
		color$2 = getColor(color$2);
		let { space, index } = ColorSpace.resolveCoord(prop, color$2.space);
		return getAll(color$2, space)[index];
	}
	function setAll(color$2, space, coords) {
		color$2 = getColor(color$2);
		space = ColorSpace.get(space);
		color$2.coords = space.to(color$2.space, coords);
		return color$2;
	}
	setAll.returns = "color";
	function set(color$2, prop, value) {
		color$2 = getColor(color$2);
		if (arguments.length === 2 && type$1(arguments[1]) === "object") {
			let object$1 = arguments[1];
			for (let p$1 in object$1) set(color$2, p$1, object$1[p$1]);
		} else {
			if (typeof value === "function") value = value(get$1(color$2, prop));
			let { space, index } = ColorSpace.resolveCoord(prop, color$2.space);
			let coords = getAll(color$2, space);
			coords[index] = value;
			setAll(color$2, space, coords);
		}
		return color$2;
	}
	set.returns = "color";
	var xyz_d50_default = new ColorSpace({
		id: "xyz-d50",
		name: "XYZ D50",
		white: "D50",
		base: xyz_d65_default,
		fromBase: (coords) => adapt$1(xyz_d65_default.white, "D50", coords),
		toBase: (coords) => adapt$1("D50", xyz_d65_default.white, coords)
	});
	const ε$2 = 216 / 24389;
	const ε3 = 24 / 116;
	const κ$1 = 24389 / 27;
	let white$2 = WHITES.D50;
	var lab_default = new ColorSpace({
		id: "lab",
		name: "Lab",
		coords: {
			l: {
				refRange: [0, 100],
				name: "Lightness"
			},
			a: { refRange: [-125, 125] },
			b: { refRange: [-125, 125] }
		},
		white: white$2,
		base: xyz_d50_default,
		fromBase(XYZ) {
			let f = XYZ.map((value, i$1) => value / white$2[i$1]).map((value) => value > ε$2 ? Math.cbrt(value) : (κ$1 * value + 16) / 116);
			return [
				116 * f[1] - 16,
				500 * (f[0] - f[1]),
				200 * (f[1] - f[2])
			];
		},
		toBase(Lab) {
			let f = [];
			f[1] = (Lab[0] + 16) / 116;
			f[0] = Lab[1] / 500 + f[1];
			f[2] = f[1] - Lab[2] / 200;
			return [
				f[0] > ε3 ? Math.pow(f[0], 3) : (116 * f[0] - 16) / κ$1,
				Lab[0] > 8 ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / κ$1,
				f[2] > ε3 ? Math.pow(f[2], 3) : (116 * f[2] - 16) / κ$1
			].map((value, i$1) => value * white$2[i$1]);
		},
		formats: { "lab": { coords: [
			"<number> | <percentage>",
			"<number> | <percentage>[-1,1]",
			"<number> | <percentage>[-1,1]"
		] } }
	});
	function constrain$1(angle) {
		return (angle % 360 + 360) % 360;
	}
	function adjust(arc, angles) {
		if (arc === "raw") return angles;
		let [a1, a2] = angles.map(constrain$1);
		let angleDiff = a2 - a1;
		if (arc === "increasing") {
			if (angleDiff < 0) a2 += 360;
		} else if (arc === "decreasing") {
			if (angleDiff > 0) a1 += 360;
		} else if (arc === "longer") {
			if (-180 < angleDiff && angleDiff < 180) if (angleDiff > 0) a1 += 360;
			else a2 += 360;
		} else if (arc === "shorter") {
			if (angleDiff > 180) a1 += 360;
			else if (angleDiff < -180) a2 += 360;
		}
		return [a1, a2];
	}
	var lch_default = new ColorSpace({
		id: "lch",
		name: "LCH",
		coords: {
			l: {
				refRange: [0, 100],
				name: "Lightness"
			},
			c: {
				refRange: [0, 150],
				name: "Chroma"
			},
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			}
		},
		base: lab_default,
		fromBase(Lab) {
			let [L$1, a, b$1] = Lab;
			let hue;
			const ε$4 = .02;
			if (Math.abs(a) < ε$4 && Math.abs(b$1) < ε$4) hue = NaN;
			else hue = Math.atan2(b$1, a) * 180 / Math.PI;
			return [
				L$1,
				Math.sqrt(a ** 2 + b$1 ** 2),
				constrain$1(hue)
			];
		},
		toBase(LCH$1) {
			let [Lightness, Chroma, Hue] = LCH$1;
			if (Chroma < 0) Chroma = 0;
			if (isNaN(Hue)) Hue = 0;
			return [
				Lightness,
				Chroma * Math.cos(Hue * Math.PI / 180),
				Chroma * Math.sin(Hue * Math.PI / 180)
			];
		},
		formats: { "lch": { coords: [
			"<number> | <percentage>",
			"<number> | <percentage>",
			"<number> | <angle>"
		] } }
	});
	const Gfactor = 25 ** 7;
	const π = Math.PI;
	const r2d = 180 / π;
	const d2r$1 = π / 180;
	function pow7(x$1) {
		const x2 = x$1 * x$1;
		return x2 * x2 * x2 * x$1;
	}
	function deltaE2000_default(color$2, sample, { kL = 1, kC = 1, kH = 1 } = {}) {
		[color$2, sample] = getColor([color$2, sample]);
		let [L1, a1, b1] = lab_default.from(color$2);
		let C1 = lch_default.from(lab_default, [
			L1,
			a1,
			b1
		])[1];
		let [L2, a2, b2] = lab_default.from(sample);
		let C2 = lch_default.from(lab_default, [
			L2,
			a2,
			b2
		])[1];
		if (C1 < 0) C1 = 0;
		if (C2 < 0) C2 = 0;
		let C7 = pow7((C1 + C2) / 2);
		let G$1 = .5 * (1 - Math.sqrt(C7 / (C7 + Gfactor)));
		let adash1 = (1 + G$1) * a1;
		let adash2 = (1 + G$1) * a2;
		let Cdash1 = Math.sqrt(adash1 ** 2 + b1 ** 2);
		let Cdash2 = Math.sqrt(adash2 ** 2 + b2 ** 2);
		let h1 = adash1 === 0 && b1 === 0 ? 0 : Math.atan2(b1, adash1);
		let h2 = adash2 === 0 && b2 === 0 ? 0 : Math.atan2(b2, adash2);
		if (h1 < 0) h1 += 2 * π;
		if (h2 < 0) h2 += 2 * π;
		h1 *= r2d;
		h2 *= r2d;
		let ΔL = L2 - L1;
		let ΔC = Cdash2 - Cdash1;
		let hdiff = h2 - h1;
		let hsum = h1 + h2;
		let habs = Math.abs(hdiff);
		let Δh;
		if (Cdash1 * Cdash2 === 0) Δh = 0;
		else if (habs <= 180) Δh = hdiff;
		else if (hdiff > 180) Δh = hdiff - 360;
		else if (hdiff < -180) Δh = hdiff + 360;
		else defaults_default.warn("the unthinkable has happened");
		let ΔH = 2 * Math.sqrt(Cdash2 * Cdash1) * Math.sin(Δh * d2r$1 / 2);
		let Ldash = (L1 + L2) / 2;
		let Cdash = (Cdash1 + Cdash2) / 2;
		let Cdash7 = pow7(Cdash);
		let hdash;
		if (Cdash1 * Cdash2 === 0) hdash = hsum;
		else if (habs <= 180) hdash = hsum / 2;
		else if (hsum < 360) hdash = (hsum + 360) / 2;
		else hdash = (hsum - 360) / 2;
		let lsq = (Ldash - 50) ** 2;
		let SL = 1 + .015 * lsq / Math.sqrt(20 + lsq);
		let SC = 1 + .045 * Cdash;
		let T$1 = 1;
		T$1 -= .17 * Math.cos((hdash - 30) * d2r$1);
		T$1 += .24 * Math.cos(2 * hdash * d2r$1);
		T$1 += .32 * Math.cos((3 * hdash + 6) * d2r$1);
		T$1 -= .2 * Math.cos((4 * hdash - 63) * d2r$1);
		let SH = 1 + .015 * Cdash * T$1;
		let Δθ = 30 * Math.exp(-1 * ((hdash - 275) / 25) ** 2);
		let RC = 2 * Math.sqrt(Cdash7 / (Cdash7 + Gfactor));
		let RT = -1 * Math.sin(2 * Δθ * d2r$1) * RC;
		let dE = (ΔL / (kL * SL)) ** 2;
		dE += (ΔC / (kC * SC)) ** 2;
		dE += (ΔH / (kH * SH)) ** 2;
		dE += RT * (ΔC / (kC * SC)) * (ΔH / (kH * SH));
		return Math.sqrt(dE);
	}
	const XYZtoLMS_M$1 = [
		[
			.819022437996703,
			.3619062600528904,
			-.1288737815209879
		],
		[
			.0329836539323885,
			.9292868615863434,
			.0361446663506424
		],
		[
			.0481771893596242,
			.2642395317527308,
			.6335478284694309
		]
	];
	const LMStoXYZ_M$1 = [
		[
			1.2268798758459243,
			-.5578149944602171,
			.2813910456659647
		],
		[
			-.0405757452148008,
			1.112286803280317,
			-.0717110580655164
		],
		[
			-.0763729366746601,
			-.4214933324022432,
			1.5869240198367816
		]
	];
	const LMStoLab_M = [
		[
			.210454268309314,
			.7936177747023054,
			-.0040720430116193
		],
		[
			1.9779985324311684,
			-2.42859224204858,
			.450593709617411
		],
		[
			.0259040424655478,
			.7827717124575296,
			-.8086757549230774
		]
	];
	const LabtoLMS_M = [
		[
			1,
			.3963377773761749,
			.2158037573099136
		],
		[
			1,
			-.1055613458156586,
			-.0638541728258133
		],
		[
			1,
			-.0894841775298119,
			-1.2914855480194092
		]
	];
	var oklab_default = new ColorSpace({
		id: "oklab",
		name: "Oklab",
		coords: {
			l: {
				refRange: [0, 1],
				name: "Lightness"
			},
			a: { refRange: [-.4, .4] },
			b: { refRange: [-.4, .4] }
		},
		white: "D65",
		base: xyz_d65_default,
		fromBase(XYZ) {
			return multiplyMatrices(LMStoLab_M, multiplyMatrices(XYZtoLMS_M$1, XYZ).map((val$1) => Math.cbrt(val$1)));
		},
		toBase(OKLab) {
			return multiplyMatrices(LMStoXYZ_M$1, multiplyMatrices(LabtoLMS_M, OKLab).map((val$1) => val$1 ** 3));
		},
		formats: { "oklab": { coords: [
			"<percentage> | <number>",
			"<number> | <percentage>[-1,1]",
			"<number> | <percentage>[-1,1]"
		] } }
	});
	function deltaEOK_default(color$2, sample) {
		[color$2, sample] = getColor([color$2, sample]);
		let [L1, a1, b1] = oklab_default.from(color$2);
		let [L2, a2, b2] = oklab_default.from(sample);
		let ΔL = L1 - L2;
		let Δa = a1 - a2;
		let Δb = b1 - b2;
		return Math.sqrt(ΔL ** 2 + Δa ** 2 + Δb ** 2);
	}
	const ε$1 = 75e-6;
	function inGamut(color$2, space, { epsilon = ε$1 } = {}) {
		color$2 = getColor(color$2);
		if (!space) space = color$2.space;
		space = ColorSpace.get(space);
		let coords = color$2.coords;
		if (space !== color$2.space) coords = space.from(color$2);
		return space.inGamut(coords, { epsilon });
	}
	function clone$1(color$2) {
		return {
			space: color$2.space,
			coords: color$2.coords.slice(),
			alpha: color$2.alpha
		};
	}
	function distance(color1, color2, space = "lab") {
		space = ColorSpace.get(space);
		let coords1 = space.from(color1);
		let coords2 = space.from(color2);
		return Math.sqrt(coords1.reduce((acc, c1$2, i$1) => {
			let c2$2 = coords2[i$1];
			if (isNaN(c1$2) || isNaN(c2$2)) return acc;
			return acc + (c2$2 - c1$2) ** 2;
		}, 0));
	}
	function deltaE76(color$2, sample) {
		return distance(color$2, sample, "lab");
	}
	const d2r = Math.PI / 180;
	function deltaECMC_default(color$2, sample, { l = 2, c = 1 } = {}) {
		[color$2, sample] = getColor([color$2, sample]);
		let [L1, a1, b1] = lab_default.from(color$2);
		let [, C1, H1] = lch_default.from(lab_default, [
			L1,
			a1,
			b1
		]);
		let [L2, a2, b2] = lab_default.from(sample);
		let C2 = lch_default.from(lab_default, [
			L2,
			a2,
			b2
		])[1];
		if (C1 < 0) C1 = 0;
		if (C2 < 0) C2 = 0;
		let ΔL = L1 - L2;
		let ΔC = C1 - C2;
		let Δa = a1 - a2;
		let Δb = b1 - b2;
		let H2 = Δa ** 2 + Δb ** 2 - ΔC ** 2;
		let SL = .511;
		if (L1 >= 16) SL = .040975 * L1 / (1 + .01765 * L1);
		let SC = .0638 * C1 / (1 + .0131 * C1) + .638;
		let T$1;
		if (Number.isNaN(H1)) H1 = 0;
		if (H1 >= 164 && H1 <= 345) T$1 = .56 + Math.abs(.2 * Math.cos((H1 + 168) * d2r));
		else T$1 = .36 + Math.abs(.4 * Math.cos((H1 + 35) * d2r));
		let C4 = Math.pow(C1, 4);
		let F$1 = Math.sqrt(C4 / (C4 + 1900));
		let SH = SC * (F$1 * T$1 + 1 - F$1);
		let dE = (ΔL / (l * SL)) ** 2;
		dE += (ΔC / (c * SC)) ** 2;
		dE += H2 / SH ** 2;
		return Math.sqrt(dE);
	}
	const Yw = 203;
	var xyz_abs_d65_default = new ColorSpace({
		id: "xyz-abs-d65",
		cssId: "--xyz-abs-d65",
		name: "Absolute XYZ D65",
		coords: {
			x: {
				refRange: [0, 9504.7],
				name: "Xa"
			},
			y: {
				refRange: [0, 1e4],
				name: "Ya"
			},
			z: {
				refRange: [0, 10888.3],
				name: "Za"
			}
		},
		base: xyz_d65_default,
		fromBase(XYZ) {
			return XYZ.map((v$1) => Math.max(v$1 * Yw, 0));
		},
		toBase(AbsXYZ) {
			return AbsXYZ.map((v$1) => Math.max(v$1 / Yw, 0));
		}
	});
	const b = 1.15;
	const g = .66;
	const n$1 = 2610 / 2 ** 14;
	const ninv = 2 ** 14 / 2610;
	const c1$1 = 3424 / 2 ** 12;
	const c2$1 = 2413 / 2 ** 7;
	const c3$1 = 2392 / 2 ** 7;
	const p = 1.7 * 2523 / 2 ** 5;
	const pinv = 2 ** 5 / (1.7 * 2523);
	const d = -.56;
	const d0 = 16295499532821565e-27;
	const XYZtoCone_M = [
		[
			.41478972,
			.579999,
			.014648
		],
		[
			-.20151,
			1.120649,
			.0531008
		],
		[
			-.0166008,
			.2648,
			.6684799
		]
	];
	const ConetoXYZ_M = [
		[
			1.9242264357876067,
			-1.0047923125953657,
			.037651404030618
		],
		[
			.35031676209499907,
			.7264811939316552,
			-.06538442294808501
		],
		[
			-.09098281098284752,
			-.3127282905230739,
			1.5227665613052603
		]
	];
	const ConetoIab_M = [
		[
			.5,
			.5,
			0
		],
		[
			3.524,
			-4.066708,
			.542708
		],
		[
			.199076,
			1.096799,
			-1.295875
		]
	];
	const IabtoCone_M = [
		[
			1,
			.1386050432715393,
			.05804731615611886
		],
		[
			.9999999999999999,
			-.1386050432715393,
			-.05804731615611886
		],
		[
			.9999999999999998,
			-.09601924202631895,
			-.8118918960560388
		]
	];
	var jzczhz_default = new ColorSpace({
		id: "jzczhz",
		name: "JzCzHz",
		coords: {
			jz: {
				refRange: [0, 1],
				name: "Jz"
			},
			cz: {
				refRange: [0, 1],
				name: "Chroma"
			},
			hz: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			}
		},
		base: new ColorSpace({
			id: "jzazbz",
			name: "Jzazbz",
			coords: {
				jz: {
					refRange: [0, 1],
					name: "Jz"
				},
				az: { refRange: [-.5, .5] },
				bz: { refRange: [-.5, .5] }
			},
			base: xyz_abs_d65_default,
			fromBase(XYZ) {
				let [Xa, Ya, Za] = XYZ;
				let [Iz, az, bz] = multiplyMatrices(ConetoIab_M, multiplyMatrices(XYZtoCone_M, [
					b * Xa - (b - 1) * Za,
					g * Ya - (g - 1) * Xa,
					Za
				]).map(function(val$1) {
					return ((c1$1 + c2$1 * (val$1 / 1e4) ** n$1) / (1 + c3$1 * (val$1 / 1e4) ** n$1)) ** p;
				}));
				return [
					(1 + d) * Iz / (1 + d * Iz) - d0,
					az,
					bz
				];
			},
			toBase(Jzazbz) {
				let [Jz, az, bz] = Jzazbz;
				let [Xm, Ym, Za] = multiplyMatrices(ConetoXYZ_M, multiplyMatrices(IabtoCone_M, [
					(Jz + d0) / (1 + d - d * (Jz + d0)),
					az,
					bz
				]).map(function(val$1) {
					return 1e4 * ((c1$1 - val$1 ** pinv) / (c3$1 * val$1 ** pinv - c2$1)) ** ninv;
				}));
				let Xa = (Xm + (b - 1) * Za) / b;
				return [
					Xa,
					(Ym + (g - 1) * Xa) / g,
					Za
				];
			},
			formats: { "color": { coords: [
				"<number> | <percentage>",
				"<number> | <percentage>[-1,1]",
				"<number> | <percentage>[-1,1]"
			] } }
		}),
		fromBase(jzazbz) {
			let [Jz, az, bz] = jzazbz;
			let hue;
			const ε$4 = 2e-4;
			if (Math.abs(az) < ε$4 && Math.abs(bz) < ε$4) hue = NaN;
			else hue = Math.atan2(bz, az) * 180 / Math.PI;
			return [
				Jz,
				Math.sqrt(az ** 2 + bz ** 2),
				constrain$1(hue)
			];
		},
		toBase(jzczhz) {
			return [
				jzczhz[0],
				jzczhz[1] * Math.cos(jzczhz[2] * Math.PI / 180),
				jzczhz[1] * Math.sin(jzczhz[2] * Math.PI / 180)
			];
		}
	});
	function deltaEJz_default(color$2, sample) {
		[color$2, sample] = getColor([color$2, sample]);
		let [Jz1, Cz1, Hz1] = jzczhz_default.from(color$2);
		let [Jz2, Cz2, Hz2] = jzczhz_default.from(sample);
		let ΔJ = Jz1 - Jz2;
		let ΔC = Cz1 - Cz2;
		if (Number.isNaN(Hz1) && Number.isNaN(Hz2)) {
			Hz1 = 0;
			Hz2 = 0;
		} else if (Number.isNaN(Hz1)) Hz1 = Hz2;
		else if (Number.isNaN(Hz2)) Hz2 = Hz1;
		let Δh = Hz1 - Hz2;
		let ΔH = 2 * Math.sqrt(Cz1 * Cz2) * Math.sin(Δh / 2 * (Math.PI / 180));
		return Math.sqrt(ΔJ ** 2 + ΔC ** 2 + ΔH ** 2);
	}
	const c1 = 3424 / 4096;
	const c2 = 2413 / 128;
	const c3 = 2392 / 128;
	const m1$1 = 2610 / 16384;
	const m2 = 2523 / 32;
	const im1 = 16384 / 2610;
	const im2 = 32 / 2523;
	const XYZtoLMS_M = [
		[
			.3592832590121217,
			.6976051147779502,
			-.035891593232029
		],
		[
			-.1920808463704993,
			1.100476797037432,
			.0753748658519118
		],
		[
			.0070797844607479,
			.0748396662186362,
			.8433265453898765
		]
	];
	const LMStoIPT_M = [
		[
			2048 / 4096,
			2048 / 4096,
			0
		],
		[
			6610 / 4096,
			-13613 / 4096,
			7003 / 4096
		],
		[
			17933 / 4096,
			-17390 / 4096,
			-543 / 4096
		]
	];
	const IPTtoLMS_M = [
		[
			.9999999999999998,
			.0086090370379328,
			.111029625003026
		],
		[
			.9999999999999998,
			-.0086090370379328,
			-.1110296250030259
		],
		[
			.9999999999999998,
			.5600313357106791,
			-.3206271749873188
		]
	];
	const LMStoXYZ_M = [
		[
			2.0701522183894223,
			-1.3263473389671563,
			.2066510476294053
		],
		[
			.3647385209748072,
			.6805660249472273,
			-.0453045459220347
		],
		[
			-.0497472075358123,
			-.0492609666966131,
			1.1880659249923042
		]
	];
	var ictcp_default = new ColorSpace({
		id: "ictcp",
		name: "ICTCP",
		coords: {
			i: {
				refRange: [0, 1],
				name: "I"
			},
			ct: {
				refRange: [-.5, .5],
				name: "CT"
			},
			cp: {
				refRange: [-.5, .5],
				name: "CP"
			}
		},
		base: xyz_abs_d65_default,
		fromBase(XYZ) {
			return LMStoICtCp(multiplyMatrices(XYZtoLMS_M, XYZ));
		},
		toBase(ICtCp) {
			return multiplyMatrices(LMStoXYZ_M, ICtCptoLMS(ICtCp));
		}
	});
	function LMStoICtCp(LMS) {
		return multiplyMatrices(LMStoIPT_M, LMS.map(function(val$1) {
			return ((c1 + c2 * (val$1 / 1e4) ** m1$1) / (1 + c3 * (val$1 / 1e4) ** m1$1)) ** m2;
		}));
	}
	function ICtCptoLMS(ICtCp) {
		return multiplyMatrices(IPTtoLMS_M, ICtCp).map(function(val$1) {
			return 1e4 * (Math.max(val$1 ** im2 - c1, 0) / (c2 - c3 * val$1 ** im2)) ** im1;
		});
	}
	function deltaEITP_default(color$2, sample) {
		[color$2, sample] = getColor([color$2, sample]);
		let [I1, T1, P1] = ictcp_default.from(color$2);
		let [I2, T2, P2] = ictcp_default.from(sample);
		return 720 * Math.sqrt((I1 - I2) ** 2 + .25 * (T1 - T2) ** 2 + (P1 - P2) ** 2);
	}
	const white$1 = WHITES.D65;
	const adaptedCoef = .42;
	const adaptedCoefInv = 1 / adaptedCoef;
	const tau = 2 * Math.PI;
	const cat16 = [
		[
			.401288,
			.650173,
			-.051461
		],
		[
			-.250268,
			1.204414,
			.045854
		],
		[
			-.002079,
			.048952,
			.953127
		]
	];
	const cat16Inv = [
		[
			1.8620678550872327,
			-1.0112546305316843,
			.14918677544445175
		],
		[
			.38752654323613717,
			.6214474419314753,
			-.008973985167612518
		],
		[
			-.015841498849333856,
			-.03412293802851557,
			1.0499644368778496
		]
	];
	const m1 = [
		[
			460,
			451,
			288
		],
		[
			460,
			-891,
			-261
		],
		[
			460,
			-220,
			-6300
		]
	];
	const surroundMap = {
		dark: [
			.8,
			.525,
			.8
		],
		dim: [
			.9,
			.59,
			.9
		],
		average: [
			1,
			.69,
			1
		]
	};
	const hueQuadMap = {
		h: [
			20.14,
			90,
			164.25,
			237.53,
			380.14
		],
		e: [
			.8,
			.7,
			1,
			1.2,
			.8
		],
		H: [
			0,
			100,
			200,
			300,
			400
		]
	};
	const rad2deg = 180 / Math.PI;
	const deg2rad$1 = Math.PI / 180;
	function adapt(coords, fl) {
		return coords.map((c) => {
			const x$1 = spow(fl * Math.abs(c) * .01, adaptedCoef);
			return 400 * copySign(x$1, c) / (x$1 + 27.13);
		});
	}
	function unadapt(adapted, fl) {
		const constant = 100 / fl * 27.13 ** adaptedCoefInv;
		return adapted.map((c) => {
			const cabs = Math.abs(c);
			return copySign(constant * spow(cabs / (400 - cabs), adaptedCoefInv), c);
		});
	}
	function hueQuadrature(h) {
		let hp = constrain$1(h);
		if (hp <= hueQuadMap.h[0]) hp += 360;
		const i$1 = bisectLeft(hueQuadMap.h, hp) - 1;
		const [hi, hii] = hueQuadMap.h.slice(i$1, i$1 + 2);
		const [ei, eii] = hueQuadMap.e.slice(i$1, i$1 + 2);
		const Hi = hueQuadMap.H[i$1];
		const t$1 = (hp - hi) / ei;
		return Hi + 100 * t$1 / (t$1 + (hii - hp) / eii);
	}
	function invHueQuadrature(H$1) {
		let Hp = (H$1 % 400 + 400) % 400;
		const i$1 = Math.floor(.01 * Hp);
		Hp = Hp % 100;
		const [hi, hii] = hueQuadMap.h.slice(i$1, i$1 + 2);
		const [ei, eii] = hueQuadMap.e.slice(i$1, i$1 + 2);
		return constrain$1((Hp * (eii * hi - ei * hii) - 100 * hi * eii) / (Hp * (eii - ei) - 100 * eii));
	}
	function environment$1(refWhite, adaptingLuminance, backgroundLuminance, surround, discounting) {
		const env = {};
		env.discounting = discounting;
		env.refWhite = refWhite;
		env.surround = surround;
		const xyzW = refWhite.map((c) => {
			return c * 100;
		});
		env.la = adaptingLuminance;
		env.yb = backgroundLuminance;
		const yw = xyzW[1];
		const rgbW = multiplyMatrices(cat16, xyzW);
		surround = surroundMap[env.surround];
		const f = surround[0];
		env.c = surround[1];
		env.nc = surround[2];
		const k4 = (1 / (5 * env.la + 1)) ** 4;
		env.fl = k4 * env.la + .1 * (1 - k4) * (1 - k4) * Math.cbrt(5 * env.la);
		env.flRoot = env.fl ** .25;
		env.n = env.yb / yw;
		env.z = 1.48 + Math.sqrt(env.n);
		env.nbb = .725 * env.n ** -.2;
		env.ncb = env.nbb;
		const d$1 = discounting ? 1 : Math.max(Math.min(f * (1 - 1 / 3.6 * Math.exp((-env.la - 42) / 92)), 1), 0);
		env.dRgb = rgbW.map((c) => {
			return interpolate(1, yw / c, d$1);
		});
		env.dRgbInv = env.dRgb.map((c) => {
			return 1 / c;
		});
		const rgbAW = adapt(rgbW.map((c, i$1) => {
			return c * env.dRgb[i$1];
		}), env.fl);
		env.aW = env.nbb * (2 * rgbAW[0] + rgbAW[1] + .05 * rgbAW[2]);
		return env;
	}
	const viewingConditions$1 = environment$1(white$1, 64 / Math.PI * .2, 20, "average", false);
	function fromCam16(cam16, env) {
		if (!(cam16.J !== void 0 ^ cam16.Q !== void 0)) throw new Error("Conversion requires one and only one: 'J' or 'Q'");
		if (!(cam16.C !== void 0 ^ cam16.M !== void 0 ^ cam16.s !== void 0)) throw new Error("Conversion requires one and only one: 'C', 'M' or 's'");
		if (!(cam16.h !== void 0 ^ cam16.H !== void 0)) throw new Error("Conversion requires one and only one: 'h' or 'H'");
		if (cam16.J === 0 || cam16.Q === 0) return [
			0,
			0,
			0
		];
		let hRad = 0;
		if (cam16.h !== void 0) hRad = constrain$1(cam16.h) * deg2rad$1;
		else hRad = invHueQuadrature(cam16.H) * deg2rad$1;
		const cosh = Math.cos(hRad);
		const sinh = Math.sin(hRad);
		let Jroot = 0;
		if (cam16.J !== void 0) Jroot = spow(cam16.J, 1 / 2) * .1;
		else if (cam16.Q !== void 0) Jroot = .25 * env.c * cam16.Q / ((env.aW + 4) * env.flRoot);
		let alpha = 0;
		if (cam16.C !== void 0) alpha = cam16.C / Jroot;
		else if (cam16.M !== void 0) alpha = cam16.M / env.flRoot / Jroot;
		else if (cam16.s !== void 0) alpha = 4e-4 * cam16.s ** 2 * (env.aW + 4) / env.c;
		const t$1 = spow(alpha * Math.pow(1.64 - Math.pow(.29, env.n), -.73), 10 / 9);
		const et = .25 * (Math.cos(hRad + 2) + 3.8);
		const A$1 = env.aW * spow(Jroot, 2 / env.c / env.z);
		const p1 = 5e4 / 13 * env.nc * env.ncb * et;
		const p2 = A$1 / env.nbb;
		const r = 23 * (p2 + .305) * zdiv(t$1, 23 * p1 + t$1 * (11 * cosh + 108 * sinh));
		return multiplyMatrices(cat16Inv, unadapt(multiplyMatrices(m1, [
			p2,
			r * cosh,
			r * sinh
		]).map((c) => {
			return c * 1 / 1403;
		}), env.fl).map((c, i$1) => {
			return c * env.dRgbInv[i$1];
		})).map((c) => {
			return c / 100;
		});
	}
	function toCam16(xyzd65, env) {
		const rgbA = adapt(multiplyMatrices(cat16, xyzd65.map((c) => {
			return c * 100;
		})).map((c, i$1) => {
			return c * env.dRgb[i$1];
		}), env.fl);
		const a = rgbA[0] + (-12 * rgbA[1] + rgbA[2]) / 11;
		const b$1 = (rgbA[0] + rgbA[1] - 2 * rgbA[2]) / 9;
		const hRad = (Math.atan2(b$1, a) % tau + tau) % tau;
		const et = .25 * (Math.cos(hRad + 2) + 3.8);
		const alpha = spow(5e4 / 13 * env.nc * env.ncb * zdiv(et * Math.sqrt(a ** 2 + b$1 ** 2), rgbA[0] + rgbA[1] + 1.05 * rgbA[2] + .305), .9) * Math.pow(1.64 - Math.pow(.29, env.n), .73);
		const Jroot = spow(env.nbb * (2 * rgbA[0] + rgbA[1] + .05 * rgbA[2]) / env.aW, .5 * env.c * env.z);
		const J$1 = 100 * spow(Jroot, 2);
		const Q$1 = 4 / env.c * Jroot * (env.aW + 4) * env.flRoot;
		const C$1 = alpha * Jroot;
		const M$1 = C$1 * env.flRoot;
		const h = constrain$1(hRad * rad2deg);
		const H$1 = hueQuadrature(h);
		return {
			J: J$1,
			C: C$1,
			h,
			s: 50 * spow(env.c * alpha / (env.aW + 4), 1 / 2),
			Q: Q$1,
			M: M$1,
			H: H$1
		};
	}
	new ColorSpace({
		id: "cam16-jmh",
		cssId: "--cam16-jmh",
		name: "CAM16-JMh",
		coords: {
			j: {
				refRange: [0, 100],
				name: "J"
			},
			m: {
				refRange: [0, 105],
				name: "Colorfulness"
			},
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			}
		},
		base: xyz_d65_default,
		fromBase(xyz) {
			const cam16 = toCam16(xyz, viewingConditions$1);
			return [
				cam16.J,
				cam16.M,
				cam16.h
			];
		},
		toBase(cam16) {
			return fromCam16({
				J: cam16[0],
				M: cam16[1],
				h: cam16[2]
			}, viewingConditions$1);
		}
	});
	const white = WHITES.D65;
	const ε = 216 / 24389;
	const κ = 24389 / 27;
	function toLstar(y) {
		return 116 * (y > ε ? Math.cbrt(y) : (κ * y + 16) / 116) - 16;
	}
	function fromLstar(lstar) {
		return lstar > 8 ? Math.pow((lstar + 16) / 116, 3) : lstar / κ;
	}
	function fromHct(coords, env) {
		let [h, c, t$1] = coords;
		let xyz = [];
		let j = 0;
		if (t$1 === 0) return [
			0,
			0,
			0
		];
		let y = fromLstar(t$1);
		if (t$1 > 0) j = .00379058511492914 * t$1 ** 2 + .608983189401032 * t$1 + .9155088574762233;
		else j = 9514440756550361e-21 * t$1 ** 2 + .08693057439788597 * t$1 - 21.928975842194614;
		const threshold = 2e-12;
		const max_attempts = 15;
		let attempt = 0;
		let last$1 = Infinity;
		while (attempt <= max_attempts) {
			xyz = fromCam16({
				J: j,
				C: c,
				h
			}, env);
			const delta = Math.abs(xyz[1] - y);
			if (delta < last$1) {
				if (delta <= threshold) return xyz;
				last$1 = delta;
			}
			j = j - (xyz[1] - y) * j / (2 * xyz[1]);
			attempt += 1;
		}
		return fromCam16({
			J: j,
			C: c,
			h
		}, env);
	}
	function toHct(xyz, env) {
		const t$1 = toLstar(xyz[1]);
		if (t$1 === 0) return [
			0,
			0,
			0
		];
		const cam16 = toCam16(xyz, viewingConditions);
		return [
			constrain$1(cam16.h),
			cam16.C,
			t$1
		];
	}
	const viewingConditions = environment$1(white, 200 / Math.PI * fromLstar(50), fromLstar(50) * 100, "average", false);
	var hct_default = new ColorSpace({
		id: "hct",
		name: "HCT",
		coords: {
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			},
			c: {
				refRange: [0, 145],
				name: "Colorfulness"
			},
			t: {
				refRange: [0, 100],
				name: "Tone"
			}
		},
		base: xyz_d65_default,
		fromBase(xyz) {
			return toHct(xyz, viewingConditions);
		},
		toBase(hct) {
			return fromHct(hct, viewingConditions);
		},
		formats: { color: {
			id: "--hct",
			coords: [
				"<number> | <angle>",
				"<percentage> | <number>",
				"<percentage> | <number>"
			]
		} }
	});
	180 / Math.PI;
	const deg2rad = Math.PI / 180;
	const ucsCoeff = [
		1,
		.007,
		.0228
	];
	function convertUcsAb(coords) {
		if (coords[1] < 0) coords = hct_default.fromBase(hct_default.toBase(coords));
		const M$1 = Math.log(Math.max(1 + ucsCoeff[2] * coords[1] * viewingConditions.flRoot, 1)) / ucsCoeff[2];
		const hrad = coords[0] * deg2rad;
		const a = M$1 * Math.cos(hrad);
		const b$1 = M$1 * Math.sin(hrad);
		return [
			coords[2],
			a,
			b$1
		];
	}
	function deltaEHCT_default(color$2, sample) {
		[color$2, sample] = getColor([color$2, sample]);
		let [t1, a1, b1] = convertUcsAb(hct_default.from(color$2));
		let [t2, a2, b2] = convertUcsAb(hct_default.from(sample));
		return Math.sqrt((t1 - t2) ** 2 + (a1 - a2) ** 2 + (b1 - b2) ** 2);
	}
	var deltaE_default = {
		deltaE76,
		deltaECMC: deltaECMC_default,
		deltaE2000: deltaE2000_default,
		deltaEJz: deltaEJz_default,
		deltaEITP: deltaEITP_default,
		deltaEOK: deltaEOK_default,
		deltaEHCT: deltaEHCT_default
	};
	function calcEpsilon(jnd) {
		const order = !jnd ? 0 : Math.floor(Math.log10(Math.abs(jnd)));
		return Math.max(parseFloat(`1e${order - 2}`), 1e-6);
	}
	const GMAPPRESET = {
		"hct": {
			method: "hct.c",
			jnd: 2,
			deltaEMethod: "hct",
			blackWhiteClamp: {}
		},
		"hct-tonal": {
			method: "hct.c",
			jnd: 0,
			deltaEMethod: "hct",
			blackWhiteClamp: {
				channel: "hct.t",
				min: 0,
				max: 100
			}
		}
	};
	function toGamut(color$2, { method = defaults_default.gamut_mapping, space = void 0, deltaEMethod = "", jnd = 2, blackWhiteClamp = {} } = {}) {
		color$2 = getColor(color$2);
		if (isString(arguments[1])) space = arguments[1];
		else if (!space) space = color$2.space;
		space = ColorSpace.get(space);
		if (inGamut(color$2, space, { epsilon: 0 })) return color$2;
		let spaceColor;
		if (method === "css") spaceColor = toGamutCSS(color$2, { space });
		else {
			if (method !== "clip" && !inGamut(color$2, space)) {
				if (Object.prototype.hasOwnProperty.call(GMAPPRESET, method)) ({method, jnd, deltaEMethod, blackWhiteClamp} = GMAPPRESET[method]);
				let de = deltaE2000_default;
				if (deltaEMethod !== "") {
					for (let m in deltaE_default) if ("deltae" + deltaEMethod.toLowerCase() === m.toLowerCase()) {
						de = deltaE_default[m];
						break;
					}
				}
				let clipped = toGamut(to(color$2, space), {
					method: "clip",
					space
				});
				if (de(color$2, clipped) > jnd) {
					if (Object.keys(blackWhiteClamp).length === 3) {
						let channelMeta = ColorSpace.resolveCoord(blackWhiteClamp.channel);
						let channel = get$1(to(color$2, channelMeta.space), channelMeta.id);
						if (isNone(channel)) channel = 0;
						if (channel >= blackWhiteClamp.max) return to({
							space: "xyz-d65",
							coords: WHITES["D65"]
						}, color$2.space);
						else if (channel <= blackWhiteClamp.min) return to({
							space: "xyz-d65",
							coords: [
								0,
								0,
								0
							]
						}, color$2.space);
					}
					let coordMeta = ColorSpace.resolveCoord(method);
					let mapSpace = coordMeta.space;
					let coordId = coordMeta.id;
					let mappedColor = to(color$2, mapSpace);
					mappedColor.coords.forEach((c, i$1) => {
						if (isNone(c)) mappedColor.coords[i$1] = 0;
					});
					let min = (coordMeta.range || coordMeta.refRange)[0];
					let ε$4 = calcEpsilon(jnd);
					let low = min;
					let high = get$1(mappedColor, coordId);
					while (high - low > ε$4) {
						let clipped$1 = clone$1(mappedColor);
						clipped$1 = toGamut(clipped$1, {
							space,
							method: "clip"
						});
						if (de(mappedColor, clipped$1) - jnd < ε$4) low = get$1(mappedColor, coordId);
						else high = get$1(mappedColor, coordId);
						set(mappedColor, coordId, (low + high) / 2);
					}
					spaceColor = to(mappedColor, space);
				} else spaceColor = clipped;
			} else spaceColor = to(color$2, space);
			if (method === "clip" || !inGamut(spaceColor, space, { epsilon: 0 })) {
				let bounds = Object.values(space.coords).map((c) => c.range || []);
				spaceColor.coords = spaceColor.coords.map((c, i$1) => {
					let [min, max] = bounds[i$1];
					if (min !== void 0) c = Math.max(min, c);
					if (max !== void 0) c = Math.min(c, max);
					return c;
				});
			}
		}
		if (space !== color$2.space) spaceColor = to(spaceColor, color$2.space);
		color$2.coords = spaceColor.coords;
		return color$2;
	}
	toGamut.returns = "color";
	const COLORS = {
		WHITE: {
			space: oklab_default,
			coords: [
				1,
				0,
				0
			]
		},
		BLACK: {
			space: oklab_default,
			coords: [
				0,
				0,
				0
			]
		}
	};
	function toGamutCSS(origin, { space } = {}) {
		const JND = .02;
		const ε$4 = 1e-4;
		origin = getColor(origin);
		if (!space) space = origin.space;
		space = ColorSpace.get(space);
		const oklchSpace = ColorSpace.get("oklch");
		if (space.isUnbounded) return to(origin, space);
		const origin_OKLCH = to(origin, oklchSpace);
		let L$1 = origin_OKLCH.coords[0];
		if (L$1 >= 1) {
			const white$3 = to(COLORS.WHITE, space);
			white$3.alpha = origin.alpha;
			return to(white$3, space);
		}
		if (L$1 <= 0) {
			const black = to(COLORS.BLACK, space);
			black.alpha = origin.alpha;
			return to(black, space);
		}
		if (inGamut(origin_OKLCH, space, { epsilon: 0 })) return to(origin_OKLCH, space);
		function clip(_color) {
			const destColor = to(_color, space);
			const spaceCoords = Object.values(space.coords);
			destColor.coords = destColor.coords.map((coord, index) => {
				if ("range" in spaceCoords[index]) {
					const [min$1, max$1] = spaceCoords[index].range;
					return clamp$1(min$1, coord, max$1);
				}
				return coord;
			});
			return destColor;
		}
		let min = 0;
		let max = origin_OKLCH.coords[1];
		let min_inGamut = true;
		let current = clone$1(origin_OKLCH);
		let clipped = clip(current);
		let E$1 = deltaEOK_default(clipped, current);
		if (E$1 < JND) return clipped;
		while (max - min > ε$4) {
			const chroma = (min + max) / 2;
			current.coords[1] = chroma;
			if (min_inGamut && inGamut(current, space, { epsilon: 0 })) min = chroma;
			else {
				clipped = clip(current);
				E$1 = deltaEOK_default(clipped, current);
				if (E$1 < JND) if (JND - E$1 < ε$4) break;
				else {
					min_inGamut = false;
					min = chroma;
				}
				else max = chroma;
			}
		}
		return clipped;
	}
	function to(color$2, space, { inGamut: inGamut$1 } = {}) {
		color$2 = getColor(color$2);
		space = ColorSpace.get(space);
		let coords = space.from(color$2);
		let ret = {
			space,
			coords,
			alpha: color$2.alpha
		};
		if (inGamut$1) ret = toGamut(ret, inGamut$1 === true ? void 0 : inGamut$1);
		return ret;
	}
	to.returns = "color";
	function serialize(color$2, { precision = defaults_default.precision, format = "default", inGamut: inGamut$1 = true,...customOptions } = {}) {
		let ret;
		color$2 = getColor(color$2);
		let formatId = format;
		format = color$2.space.getFormat(format) ?? color$2.space.getFormat("default") ?? ColorSpace.DEFAULT_FORMAT;
		let coords = color$2.coords.slice();
		inGamut$1 ||= format.toGamut;
		if (inGamut$1 && !inGamut(color$2)) coords = toGamut(clone$1(color$2), inGamut$1 === true ? void 0 : inGamut$1).coords;
		if (format.type === "custom") {
			customOptions.precision = precision;
			if (format.serialize) ret = format.serialize(coords, color$2.alpha, customOptions);
			else throw new TypeError(`format ${formatId} can only be used to parse colors, not for serialization`);
		} else {
			let name = format.name || "color";
			if (format.serializeCoords) coords = format.serializeCoords(coords, precision);
			else if (precision !== null) coords = coords.map((c) => {
				return serializeNumber(c, { precision });
			});
			let args = [...coords];
			if (name === "color") {
				let cssId = format.id || format.ids?.[0] || color$2.space.id;
				args.unshift(cssId);
			}
			let alpha = color$2.alpha;
			if (precision !== null) alpha = serializeNumber(alpha, { precision });
			let strAlpha = color$2.alpha >= 1 || format.noAlpha ? "" : `${format.commas ? "," : " /"} ${alpha}`;
			ret = `${name}(${args.join(format.commas ? ", " : " ")}${strAlpha})`;
		}
		return ret;
	}
	var p3_linear_default = new RGBColorSpace({
		id: "p3-linear",
		cssId: "--display-p3-linear",
		name: "Linear P3",
		white: "D65",
		toXYZ_M: [
			[
				.4865709486482162,
				.26566769316909306,
				.1982172852343625
			],
			[
				.2289745640697488,
				.6917385218365064,
				.079286914093745
			],
			[
				0,
				.04511338185890264,
				1.043944368900976
			]
		],
		fromXYZ_M: [
			[
				2.493496911941425,
				-.9313836179191239,
				-.40271078445071684
			],
			[
				-.8294889695615747,
				1.7626640603183463,
				.023624685841943577
			],
			[
				.03584583024378447,
				-.07617238926804182,
				.9568845240076872
			]
		]
	});
	var srgb_linear_default = new RGBColorSpace({
		id: "srgb-linear",
		name: "Linear sRGB",
		white: "D65",
		toXYZ_M: [
			[
				.41239079926595934,
				.357584339383878,
				.1804807884018343
			],
			[
				.21263900587151027,
				.715168678767756,
				.07219231536073371
			],
			[
				.01933081871559182,
				.11919477979462598,
				.9505321522496607
			]
		],
		fromXYZ_M: [
			[
				3.2409699419045226,
				-1.537383177570094,
				-.4986107602930034
			],
			[
				-.9692436362808796,
				1.8759675015077202,
				.04155505740717559
			],
			[
				.05563007969699366,
				-.20397695888897652,
				1.0569715142428786
			]
		]
	});
	var keywords_default = {
		"aliceblue": [
			240 / 255,
			248 / 255,
			1
		],
		"antiquewhite": [
			250 / 255,
			235 / 255,
			215 / 255
		],
		"aqua": [
			0,
			1,
			1
		],
		"aquamarine": [
			127 / 255,
			1,
			212 / 255
		],
		"azure": [
			240 / 255,
			1,
			1
		],
		"beige": [
			245 / 255,
			245 / 255,
			220 / 255
		],
		"bisque": [
			1,
			228 / 255,
			196 / 255
		],
		"black": [
			0,
			0,
			0
		],
		"blanchedalmond": [
			1,
			235 / 255,
			205 / 255
		],
		"blue": [
			0,
			0,
			1
		],
		"blueviolet": [
			138 / 255,
			43 / 255,
			226 / 255
		],
		"brown": [
			165 / 255,
			42 / 255,
			42 / 255
		],
		"burlywood": [
			222 / 255,
			184 / 255,
			135 / 255
		],
		"cadetblue": [
			95 / 255,
			158 / 255,
			160 / 255
		],
		"chartreuse": [
			127 / 255,
			1,
			0
		],
		"chocolate": [
			210 / 255,
			105 / 255,
			30 / 255
		],
		"coral": [
			1,
			127 / 255,
			80 / 255
		],
		"cornflowerblue": [
			100 / 255,
			149 / 255,
			237 / 255
		],
		"cornsilk": [
			1,
			248 / 255,
			220 / 255
		],
		"crimson": [
			220 / 255,
			20 / 255,
			60 / 255
		],
		"cyan": [
			0,
			1,
			1
		],
		"darkblue": [
			0,
			0,
			139 / 255
		],
		"darkcyan": [
			0,
			139 / 255,
			139 / 255
		],
		"darkgoldenrod": [
			184 / 255,
			134 / 255,
			11 / 255
		],
		"darkgray": [
			169 / 255,
			169 / 255,
			169 / 255
		],
		"darkgreen": [
			0,
			100 / 255,
			0
		],
		"darkgrey": [
			169 / 255,
			169 / 255,
			169 / 255
		],
		"darkkhaki": [
			189 / 255,
			183 / 255,
			107 / 255
		],
		"darkmagenta": [
			139 / 255,
			0,
			139 / 255
		],
		"darkolivegreen": [
			85 / 255,
			107 / 255,
			47 / 255
		],
		"darkorange": [
			1,
			140 / 255,
			0
		],
		"darkorchid": [
			153 / 255,
			50 / 255,
			204 / 255
		],
		"darkred": [
			139 / 255,
			0,
			0
		],
		"darksalmon": [
			233 / 255,
			150 / 255,
			122 / 255
		],
		"darkseagreen": [
			143 / 255,
			188 / 255,
			143 / 255
		],
		"darkslateblue": [
			72 / 255,
			61 / 255,
			139 / 255
		],
		"darkslategray": [
			47 / 255,
			79 / 255,
			79 / 255
		],
		"darkslategrey": [
			47 / 255,
			79 / 255,
			79 / 255
		],
		"darkturquoise": [
			0,
			206 / 255,
			209 / 255
		],
		"darkviolet": [
			148 / 255,
			0,
			211 / 255
		],
		"deeppink": [
			1,
			20 / 255,
			147 / 255
		],
		"deepskyblue": [
			0,
			191 / 255,
			1
		],
		"dimgray": [
			105 / 255,
			105 / 255,
			105 / 255
		],
		"dimgrey": [
			105 / 255,
			105 / 255,
			105 / 255
		],
		"dodgerblue": [
			30 / 255,
			144 / 255,
			1
		],
		"firebrick": [
			178 / 255,
			34 / 255,
			34 / 255
		],
		"floralwhite": [
			1,
			250 / 255,
			240 / 255
		],
		"forestgreen": [
			34 / 255,
			139 / 255,
			34 / 255
		],
		"fuchsia": [
			1,
			0,
			1
		],
		"gainsboro": [
			220 / 255,
			220 / 255,
			220 / 255
		],
		"ghostwhite": [
			248 / 255,
			248 / 255,
			1
		],
		"gold": [
			1,
			215 / 255,
			0
		],
		"goldenrod": [
			218 / 255,
			165 / 255,
			32 / 255
		],
		"gray": [
			128 / 255,
			128 / 255,
			128 / 255
		],
		"green": [
			0,
			128 / 255,
			0
		],
		"greenyellow": [
			173 / 255,
			1,
			47 / 255
		],
		"grey": [
			128 / 255,
			128 / 255,
			128 / 255
		],
		"honeydew": [
			240 / 255,
			1,
			240 / 255
		],
		"hotpink": [
			1,
			105 / 255,
			180 / 255
		],
		"indianred": [
			205 / 255,
			92 / 255,
			92 / 255
		],
		"indigo": [
			75 / 255,
			0,
			130 / 255
		],
		"ivory": [
			1,
			1,
			240 / 255
		],
		"khaki": [
			240 / 255,
			230 / 255,
			140 / 255
		],
		"lavender": [
			230 / 255,
			230 / 255,
			250 / 255
		],
		"lavenderblush": [
			1,
			240 / 255,
			245 / 255
		],
		"lawngreen": [
			124 / 255,
			252 / 255,
			0
		],
		"lemonchiffon": [
			1,
			250 / 255,
			205 / 255
		],
		"lightblue": [
			173 / 255,
			216 / 255,
			230 / 255
		],
		"lightcoral": [
			240 / 255,
			128 / 255,
			128 / 255
		],
		"lightcyan": [
			224 / 255,
			1,
			1
		],
		"lightgoldenrodyellow": [
			250 / 255,
			250 / 255,
			210 / 255
		],
		"lightgray": [
			211 / 255,
			211 / 255,
			211 / 255
		],
		"lightgreen": [
			144 / 255,
			238 / 255,
			144 / 255
		],
		"lightgrey": [
			211 / 255,
			211 / 255,
			211 / 255
		],
		"lightpink": [
			1,
			182 / 255,
			193 / 255
		],
		"lightsalmon": [
			1,
			160 / 255,
			122 / 255
		],
		"lightseagreen": [
			32 / 255,
			178 / 255,
			170 / 255
		],
		"lightskyblue": [
			135 / 255,
			206 / 255,
			250 / 255
		],
		"lightslategray": [
			119 / 255,
			136 / 255,
			153 / 255
		],
		"lightslategrey": [
			119 / 255,
			136 / 255,
			153 / 255
		],
		"lightsteelblue": [
			176 / 255,
			196 / 255,
			222 / 255
		],
		"lightyellow": [
			1,
			1,
			224 / 255
		],
		"lime": [
			0,
			1,
			0
		],
		"limegreen": [
			50 / 255,
			205 / 255,
			50 / 255
		],
		"linen": [
			250 / 255,
			240 / 255,
			230 / 255
		],
		"magenta": [
			1,
			0,
			1
		],
		"maroon": [
			128 / 255,
			0,
			0
		],
		"mediumaquamarine": [
			102 / 255,
			205 / 255,
			170 / 255
		],
		"mediumblue": [
			0,
			0,
			205 / 255
		],
		"mediumorchid": [
			186 / 255,
			85 / 255,
			211 / 255
		],
		"mediumpurple": [
			147 / 255,
			112 / 255,
			219 / 255
		],
		"mediumseagreen": [
			60 / 255,
			179 / 255,
			113 / 255
		],
		"mediumslateblue": [
			123 / 255,
			104 / 255,
			238 / 255
		],
		"mediumspringgreen": [
			0,
			250 / 255,
			154 / 255
		],
		"mediumturquoise": [
			72 / 255,
			209 / 255,
			204 / 255
		],
		"mediumvioletred": [
			199 / 255,
			21 / 255,
			133 / 255
		],
		"midnightblue": [
			25 / 255,
			25 / 255,
			112 / 255
		],
		"mintcream": [
			245 / 255,
			1,
			250 / 255
		],
		"mistyrose": [
			1,
			228 / 255,
			225 / 255
		],
		"moccasin": [
			1,
			228 / 255,
			181 / 255
		],
		"navajowhite": [
			1,
			222 / 255,
			173 / 255
		],
		"navy": [
			0,
			0,
			128 / 255
		],
		"oldlace": [
			253 / 255,
			245 / 255,
			230 / 255
		],
		"olive": [
			128 / 255,
			128 / 255,
			0
		],
		"olivedrab": [
			107 / 255,
			142 / 255,
			35 / 255
		],
		"orange": [
			1,
			165 / 255,
			0
		],
		"orangered": [
			1,
			69 / 255,
			0
		],
		"orchid": [
			218 / 255,
			112 / 255,
			214 / 255
		],
		"palegoldenrod": [
			238 / 255,
			232 / 255,
			170 / 255
		],
		"palegreen": [
			152 / 255,
			251 / 255,
			152 / 255
		],
		"paleturquoise": [
			175 / 255,
			238 / 255,
			238 / 255
		],
		"palevioletred": [
			219 / 255,
			112 / 255,
			147 / 255
		],
		"papayawhip": [
			1,
			239 / 255,
			213 / 255
		],
		"peachpuff": [
			1,
			218 / 255,
			185 / 255
		],
		"peru": [
			205 / 255,
			133 / 255,
			63 / 255
		],
		"pink": [
			1,
			192 / 255,
			203 / 255
		],
		"plum": [
			221 / 255,
			160 / 255,
			221 / 255
		],
		"powderblue": [
			176 / 255,
			224 / 255,
			230 / 255
		],
		"purple": [
			128 / 255,
			0,
			128 / 255
		],
		"rebeccapurple": [
			102 / 255,
			51 / 255,
			153 / 255
		],
		"red": [
			1,
			0,
			0
		],
		"rosybrown": [
			188 / 255,
			143 / 255,
			143 / 255
		],
		"royalblue": [
			65 / 255,
			105 / 255,
			225 / 255
		],
		"saddlebrown": [
			139 / 255,
			69 / 255,
			19 / 255
		],
		"salmon": [
			250 / 255,
			128 / 255,
			114 / 255
		],
		"sandybrown": [
			244 / 255,
			164 / 255,
			96 / 255
		],
		"seagreen": [
			46 / 255,
			139 / 255,
			87 / 255
		],
		"seashell": [
			1,
			245 / 255,
			238 / 255
		],
		"sienna": [
			160 / 255,
			82 / 255,
			45 / 255
		],
		"silver": [
			192 / 255,
			192 / 255,
			192 / 255
		],
		"skyblue": [
			135 / 255,
			206 / 255,
			235 / 255
		],
		"slateblue": [
			106 / 255,
			90 / 255,
			205 / 255
		],
		"slategray": [
			112 / 255,
			128 / 255,
			144 / 255
		],
		"slategrey": [
			112 / 255,
			128 / 255,
			144 / 255
		],
		"snow": [
			1,
			250 / 255,
			250 / 255
		],
		"springgreen": [
			0,
			1,
			127 / 255
		],
		"steelblue": [
			70 / 255,
			130 / 255,
			180 / 255
		],
		"tan": [
			210 / 255,
			180 / 255,
			140 / 255
		],
		"teal": [
			0,
			128 / 255,
			128 / 255
		],
		"thistle": [
			216 / 255,
			191 / 255,
			216 / 255
		],
		"tomato": [
			1,
			99 / 255,
			71 / 255
		],
		"turquoise": [
			64 / 255,
			224 / 255,
			208 / 255
		],
		"violet": [
			238 / 255,
			130 / 255,
			238 / 255
		],
		"wheat": [
			245 / 255,
			222 / 255,
			179 / 255
		],
		"white": [
			1,
			1,
			1
		],
		"whitesmoke": [
			245 / 255,
			245 / 255,
			245 / 255
		],
		"yellow": [
			1,
			1,
			0
		],
		"yellowgreen": [
			154 / 255,
			205 / 255,
			50 / 255
		]
	};
	let coordGrammar = Array(3).fill("<percentage> | <number>[0, 255]");
	let coordGrammarNumber = Array(3).fill("<number>[0, 255]");
	var srgb_default = new RGBColorSpace({
		id: "srgb",
		name: "sRGB",
		base: srgb_linear_default,
		fromBase: (rgb) => {
			return rgb.map((val$1) => {
				let sign = val$1 < 0 ? -1 : 1;
				let abs = val$1 * sign;
				if (abs > .0031308) return sign * (1.055 * abs ** (1 / 2.4) - .055);
				return 12.92 * val$1;
			});
		},
		toBase: (rgb) => {
			return rgb.map((val$1) => {
				let sign = val$1 < 0 ? -1 : 1;
				let abs = val$1 * sign;
				if (abs <= .04045) return val$1 / 12.92;
				return sign * ((abs + .055) / 1.055) ** 2.4;
			});
		},
		formats: {
			"rgb": { coords: coordGrammar },
			"rgb_number": {
				name: "rgb",
				commas: true,
				coords: coordGrammarNumber,
				noAlpha: true
			},
			"color": {},
			"rgba": {
				coords: coordGrammar,
				commas: true,
				lastAlpha: true
			},
			"rgba_number": {
				name: "rgba",
				commas: true,
				coords: coordGrammarNumber
			},
			"hex": {
				type: "custom",
				toGamut: true,
				test: (str) => /^#([a-f0-9]{3,4}){1,2}$/i.test(str),
				parse(str) {
					if (str.length <= 5) str = str.replace(/[a-f0-9]/gi, "$&$&");
					let rgba = [];
					str.replace(/[a-f0-9]{2}/gi, (component) => {
						rgba.push(parseInt(component, 16) / 255);
					});
					return {
						spaceId: "srgb",
						coords: rgba.slice(0, 3),
						alpha: rgba.slice(3)[0]
					};
				},
				serialize: (coords, alpha, { collapse = true } = {}) => {
					if (alpha < 1) coords.push(alpha);
					coords = coords.map((c) => Math.round(c * 255));
					let collapsible = collapse && coords.every((c) => c % 17 === 0);
					return "#" + coords.map((c) => {
						if (collapsible) return (c / 17).toString(16);
						return c.toString(16).padStart(2, "0");
					}).join("");
				}
			},
			"keyword": {
				type: "custom",
				test: (str) => /^[a-z]+$/i.test(str),
				parse(str) {
					str = str.toLowerCase();
					let ret = {
						spaceId: "srgb",
						coords: null,
						alpha: 1
					};
					if (str === "transparent") {
						ret.coords = keywords_default.black;
						ret.alpha = 0;
					} else ret.coords = keywords_default[str];
					if (ret.coords) return ret;
				}
			}
		}
	});
	var p3_default = new RGBColorSpace({
		id: "p3",
		cssId: "display-p3",
		name: "P3",
		base: p3_linear_default,
		fromBase: srgb_default.fromBase,
		toBase: srgb_default.toBase
	});
	function range(color1, color2, options$1 = {}) {
		if (isRange(color1)) {
			let [r, options$2] = [color1, color2];
			return range(...r.rangeArgs.colors, {
				...r.rangeArgs.options,
				...options$2
			});
		}
		let { space, outputSpace, progression, premultiplied } = options$1;
		color1 = getColor(color1);
		color2 = getColor(color2);
		color1 = clone$1(color1);
		color2 = clone$1(color2);
		let rangeArgs = {
			colors: [color1, color2],
			options: options$1
		};
		if (space) space = ColorSpace.get(space);
		else space = ColorSpace.registry[defaults_default.interpolationSpace] || color1.space;
		outputSpace = outputSpace ? ColorSpace.get(outputSpace) : space;
		color1 = to(color1, space);
		color2 = to(color2, space);
		color1 = toGamut(color1);
		color2 = toGamut(color2);
		if (space.coords.h && space.coords.h.type === "angle") {
			let arc = options$1.hue = options$1.hue || "shorter";
			let hue = [space, "h"];
			let [θ1, θ2] = [get$1(color1, hue), get$1(color2, hue)];
			if (isNaN(θ1) && !isNaN(θ2)) θ1 = θ2;
			else if (isNaN(θ2) && !isNaN(θ1)) θ2 = θ1;
			[θ1, θ2] = adjust(arc, [θ1, θ2]);
			set(color1, hue, θ1);
			set(color2, hue, θ2);
		}
		if (premultiplied) {
			color1.coords = color1.coords.map((c) => c * color1.alpha);
			color2.coords = color2.coords.map((c) => c * color2.alpha);
		}
		return Object.assign((p$1) => {
			p$1 = progression ? progression(p$1) : p$1;
			let coords = color1.coords.map((start, i$1) => {
				let end = color2.coords[i$1];
				return interpolate(start, end, p$1);
			});
			let alpha = interpolate(color1.alpha, color2.alpha, p$1);
			let ret = {
				space,
				coords,
				alpha
			};
			if (premultiplied) ret.coords = ret.coords.map((c) => c / alpha);
			if (outputSpace !== space) ret = to(ret, outputSpace);
			return ret;
		}, { rangeArgs });
	}
	function isRange(val$1) {
		return type$1(val$1) === "function" && !!val$1.rangeArgs;
	}
	defaults_default.interpolationSpace = "lab";
	var hsl_default = new ColorSpace({
		id: "hsl",
		name: "HSL",
		coords: {
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			},
			s: {
				range: [0, 100],
				name: "Saturation"
			},
			l: {
				range: [0, 100],
				name: "Lightness"
			}
		},
		base: srgb_default,
		fromBase: (rgb) => {
			let max = Math.max(...rgb);
			let min = Math.min(...rgb);
			let [r, g$1, b$1] = rgb;
			let [h, s, l] = [
				NaN,
				0,
				(min + max) / 2
			];
			let d$1 = max - min;
			if (d$1 !== 0) {
				s = l === 0 || l === 1 ? 0 : (max - l) / Math.min(l, 1 - l);
				switch (max) {
					case r:
						h = (g$1 - b$1) / d$1 + (g$1 < b$1 ? 6 : 0);
						break;
					case g$1:
						h = (b$1 - r) / d$1 + 2;
						break;
					case b$1: h = (r - g$1) / d$1 + 4;
				}
				h = h * 60;
			}
			if (s < 0) {
				h += 180;
				s = Math.abs(s);
			}
			if (h >= 360) h -= 360;
			return [
				h,
				s * 100,
				l * 100
			];
		},
		toBase: (hsl) => {
			let [h, s, l] = hsl;
			h = h % 360;
			if (h < 0) h += 360;
			s /= 100;
			l /= 100;
			function f(n$2) {
				let k = (n$2 + h / 30) % 12;
				let a = s * Math.min(l, 1 - l);
				return l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1));
			}
			return [
				f(0),
				f(8),
				f(4)
			];
		},
		formats: {
			"hsl": { coords: [
				"<number> | <angle>",
				"<percentage>",
				"<percentage>"
			] },
			"hsla": {
				coords: [
					"<number> | <angle>",
					"<percentage>",
					"<percentage>"
				],
				commas: true,
				lastAlpha: true
			}
		}
	});
	var hwb_default = new ColorSpace({
		id: "hwb",
		name: "HWB",
		coords: {
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			},
			w: {
				range: [0, 100],
				name: "Whiteness"
			},
			b: {
				range: [0, 100],
				name: "Blackness"
			}
		},
		base: new ColorSpace({
			id: "hsv",
			name: "HSV",
			coords: {
				h: {
					refRange: [0, 360],
					type: "angle",
					name: "Hue"
				},
				s: {
					range: [0, 100],
					name: "Saturation"
				},
				v: {
					range: [0, 100],
					name: "Value"
				}
			},
			base: hsl_default,
			fromBase(hsl) {
				let [h, s, l] = hsl;
				s /= 100;
				l /= 100;
				let v$1 = l + s * Math.min(l, 1 - l);
				return [
					h,
					v$1 === 0 ? 0 : 200 * (1 - l / v$1),
					100 * v$1
				];
			},
			toBase(hsv) {
				let [h, s, v$1] = hsv;
				s /= 100;
				v$1 /= 100;
				let l = v$1 * (1 - s / 2);
				return [
					h,
					l === 0 || l === 1 ? 0 : (v$1 - l) / Math.min(l, 1 - l) * 100,
					l * 100
				];
			},
			formats: { color: {
				id: "--hsv",
				coords: [
					"<number> | <angle>",
					"<percentage> | <number>",
					"<percentage> | <number>"
				]
			} }
		}),
		fromBase(hsv) {
			let [h, s, v$1] = hsv;
			return [
				h,
				v$1 * (100 - s) / 100,
				100 - v$1
			];
		},
		toBase(hwb) {
			let [h, w, b$1] = hwb;
			w /= 100;
			b$1 /= 100;
			let sum = w + b$1;
			if (sum >= 1) return [
				h,
				0,
				w / sum * 100
			];
			let v$1 = 1 - b$1;
			return [
				h,
				(v$1 === 0 ? 0 : 1 - w / v$1) * 100,
				v$1 * 100
			];
		},
		formats: { "hwb": { coords: [
			"<number> | <angle>",
			"<percentage> | <number>",
			"<percentage> | <number>"
		] } }
	});
	var oklch_default = new ColorSpace({
		id: "oklch",
		name: "Oklch",
		coords: {
			l: {
				refRange: [0, 1],
				name: "Lightness"
			},
			c: {
				refRange: [0, .4],
				name: "Chroma"
			},
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			}
		},
		white: "D65",
		base: oklab_default,
		fromBase(oklab) {
			let [L$1, a, b$1] = oklab;
			let h;
			const ε$4 = 2e-4;
			if (Math.abs(a) < ε$4 && Math.abs(b$1) < ε$4) h = NaN;
			else h = Math.atan2(b$1, a) * 180 / Math.PI;
			return [
				L$1,
				Math.sqrt(a ** 2 + b$1 ** 2),
				constrain$1(h)
			];
		},
		toBase(oklch) {
			let [L$1, C$1, h] = oklch;
			let a, b$1;
			if (isNaN(h)) {
				a = 0;
				b$1 = 0;
			} else {
				a = C$1 * Math.cos(h * Math.PI / 180);
				b$1 = C$1 * Math.sin(h * Math.PI / 180);
			}
			return [
				L$1,
				a,
				b$1
			];
		},
		formats: { "oklch": { coords: [
			"<percentage> | <number>",
			"<number> | <percentage>[0,1]",
			"<number> | <angle>"
		] } }
	});
	var HSBSpace = new ColorSpace({
		id: "hsb",
		name: "HSB",
		coords: {
			h: {
				refRange: [0, 360],
				type: "angle",
				name: "Hue"
			},
			s: {
				range: [0, 100],
				name: "Saturation"
			},
			b: {
				range: [0, 100],
				name: "Brightness"
			}
		},
		base: srgb_default,
		fromBase: (rgb) => {
			const val$1 = Math.max(...rgb);
			const chroma = val$1 - Math.min(...rgb);
			let [red, green, blue] = rgb;
			let hue, sat;
			if (chroma === 0) {
				hue = 0;
				sat = 0;
			} else {
				sat = chroma / val$1;
				if (red === val$1) hue = (green - blue) / chroma;
				else if (green === val$1) hue = 2 + (blue - red) / chroma;
				else if (blue === val$1) hue = 4 + (red - green) / chroma;
				if (hue < 0) hue += 6;
				else if (hue >= 6) hue -= 6;
			}
			return [
				hue / 6 * 360,
				sat * 100,
				val$1 * 100
			];
		},
		toBase,
		formats: {
			default: {
				type: "custom",
				serialize: (coords, alpha) => {
					const rgb = toBase(coords);
					let ret = `rgb(${Math.round(rgb[0] * 100 * 100) / 100}% ${Math.round(rgb[1] * 100 * 100) / 100}% ${Math.round(rgb[2] * 100 * 100) / 100}%`;
					if (alpha < 1) ret += ` / ${alpha}`;
					ret += ")";
					return ret;
				}
			},
			"hsb": { coords: [
				"<number> | <angle>",
				"<percentage>",
				"<percentage>"
			] },
			"hsba": {
				coords: [
					"<number> | <angle>",
					"<percentage>",
					"<percentage>"
				],
				commans: true,
				lastAlpha: true
			}
		}
	});
	function toBase(hsb) {
		const hue = hsb[0] / 360 * 6;
		const sat = hsb[1] / 100;
		const val$1 = hsb[2] / 100;
		let RGB$1 = [];
		if (sat === 0) RGB$1 = [
			val$1,
			val$1,
			val$1
		];
		else {
			const sector = Math.floor(hue);
			const tint1 = val$1 * (1 - sat);
			const tint2 = val$1 * (1 - sat * (hue - sector));
			const tint3 = val$1 * (1 - sat * (1 + sector - hue));
			let red, green, blue;
			if (sector === 1) {
				red = tint2;
				green = val$1;
				blue = tint1;
			} else if (sector === 2) {
				red = tint1;
				green = val$1;
				blue = tint3;
			} else if (sector === 3) {
				red = tint1;
				green = tint2;
				blue = val$1;
			} else if (sector === 4) {
				red = tint3;
				green = tint1;
				blue = val$1;
			} else if (sector === 5) {
				red = val$1;
				green = tint1;
				blue = tint2;
			} else {
				red = val$1;
				green = tint3;
				blue = tint1;
			}
			RGB$1 = [
				red,
				green,
				blue
			];
		}
		return RGB$1;
	}
	const map = (n$2, start1, stop1, start2, stop2, clamp$2) => {
		let result = (n$2 - start1) / (stop1 - start1) * (stop2 - start2) + start2;
		if (clamp$2) {
			result = Math.max(result, Math.min(start2, stop2));
			result = Math.min(result, Math.max(start2, stop2));
		}
		return result;
	};
	const serializationMap = {};
	var Color = class Color {
		_color;
		mode;
		static colorMap = {};
		static #colorjsMaxes = {};
		static #grayscaleMap = {};
		static addColorMode(mode, definition) {
			ColorSpace.register(definition);
			Color.colorMap[mode] = definition.id;
			Color.#colorjsMaxes[mode] = Object.values(definition.coords).reduce((acc, v$1) => {
				acc.push(v$1.refRange || v$1.range);
				return acc;
			}, []);
			Color.#colorjsMaxes[mode].push([0, 1]);
			Color.#grayscaleMap[mode] = definition.fromGray;
		}
		constructor(vals, colorMode, colorMaxes, { clamp: clamp$2 = false } = {}) {
			this.mode = colorMode || RGB;
			if (vals instanceof Color) {
				const mode = colorMode ? Color.colorMap[colorMode] : Color.colorMap[vals.mode];
				this._color = to(vals._color, mode);
				this.mode = mode;
			} else if (typeof vals === "object" && !Array.isArray(vals) && vals !== null) {
				this._color = to(vals, colorMode ? Color.colorMap[colorMode] : vals.spaceId);
				this.mode = colorMode || Object.entries(Color.colorMap).find(([key, val$1]) => {
					return val$1 === this._color.spaceId;
				});
			} else if (typeof vals[0] === "string") try {
				this._color = parse$4(vals[0]);
				const [mode] = Object.entries(Color.colorMap).find(([key, val$1]) => {
					return val$1 === this._color.spaceId;
				});
				this.mode = mode;
				this._color = to(this._color, this._color.spaceId);
			} catch (err$1) {
				throw new Error("Invalid color string");
			}
			else {
				let mappedVals;
				if (colorMaxes) if (vals.length === 4) mappedVals = Color.mapColorRange(vals, this.mode, colorMaxes, clamp$2);
				else if (vals.length === 3) {
					mappedVals = Color.mapColorRange([
						vals[0],
						vals[1],
						vals[2]
					], this.mode, colorMaxes, clamp$2);
					mappedVals.push(1);
				} else if (vals.length === 2) {
					if (Color.#grayscaleMap[this.mode]) mappedVals = Color.#grayscaleMap[this.mode](vals[0], colorMaxes, clamp$2);
					else mappedVals = Color.mapColorRange([
						vals[0],
						vals[0],
						vals[0]
					], this.mode, colorMaxes, clamp$2);
					const alphaMaxes = Array.isArray(colorMaxes[colorMaxes.length - 1]) ? colorMaxes[colorMaxes.length - 1] : [0, colorMaxes[colorMaxes.length - 1]];
					mappedVals.push(map(vals[1], alphaMaxes[0], alphaMaxes[1], 0, 1, clamp$2));
				} else if (vals.length === 1) {
					if (Color.#grayscaleMap[this.mode]) mappedVals = Color.#grayscaleMap[this.mode](vals[0], colorMaxes, clamp$2);
					else mappedVals = Color.mapColorRange([
						vals[0],
						vals[0],
						vals[0]
					], this.mode, colorMaxes, clamp$2);
					mappedVals.push(1);
				} else throw new Error("Invalid color");
				else mappedVals = vals;
				const space = Color.colorMap[this.mode] || console.error("Invalid color mode");
				this._color = to({
					space,
					coords: mappedVals.slice(0, 3),
					alpha: mappedVals[3]
				}, space);
			}
		}
		static mapColorRange(origin, mode, maxes, clamp$2) {
			const p5Maxes = maxes.map((max) => {
				if (!Array.isArray(max)) return [0, max];
				else return max;
			});
			const colorjsMaxes = Color.#colorjsMaxes[mode];
			return origin.map((channel, i$1) => {
				return map(channel, p5Maxes[i$1][0], p5Maxes[i$1][1], colorjsMaxes[i$1][0], colorjsMaxes[i$1][1], clamp$2);
			});
		}
		static unmapColorRange(origin, mode, maxes) {
			const p5Maxes = maxes.map((max) => {
				if (!Array.isArray(max)) return [0, max];
				else return max;
			});
			const colorjsMaxes = Color.#colorjsMaxes[mode];
			return origin.map((channel, i$1) => {
				return map(channel, colorjsMaxes[i$1][0], colorjsMaxes[i$1][1], p5Maxes[i$1][0], p5Maxes[i$1][1]);
			});
		}
		#toColorMode(mode) {
			return new Color(this._color, mode);
		}
		get _array() {
			return this._getRGBA();
		}
		array() {
			return this._array;
		}
		lerp(color$2, amt, mode) {
			let spaceIndex = -1;
			while ((spaceIndex + 1 < this._color.space.path.length || spaceIndex + 1 < color$2._color.space.path.length) && this._color.space.path[spaceIndex + 1] === color$2._color.space.path[spaceIndex + 1]) spaceIndex += 1;
			if (spaceIndex === -1) throw new Error("Cannot lerp colors. No common color space found");
			return new Color(range(this._color, color$2._color, { space: this._color.space.path[spaceIndex].id })(amt), mode || this.mode);
		}
		toString(format) {
			const key = `${this._color.space.id}-${this._color.coords.join(",")}-${this._color.alpha}-${format}`;
			let colorString = serializationMap[key];
			if (!colorString) {
				colorString = serialize(this._color, { format });
				serializationMap[key] = colorString;
			}
			return colorString;
		}
		setRed(new_red, max = [0, 1]) {
			if (!Array.isArray(max)) max = [0, max];
			const colorjsMax = Color.#colorjsMaxes[RGB][0];
			const newval = map(new_red, max[0], max[1], colorjsMax[0], colorjsMax[1]);
			if (this.mode === RGB || this.mode === RGBHDR) this._color.coords[0] = newval;
			else {
				const space = this._color.space.id;
				const representation = to(this._color, "srgb");
				representation.coords[0] = newval;
				this._color = to(representation, space);
			}
		}
		setGreen(new_green, max = [0, 1]) {
			if (!Array.isArray(max)) max = [0, max];
			const colorjsMax = Color.#colorjsMaxes[RGB][1];
			const newval = map(new_green, max[0], max[1], colorjsMax[0], colorjsMax[1]);
			if (this.mode === RGB || this.mode === RGBHDR) this._color.coords[1] = newval;
			else {
				const space = this._color.space.id;
				const representation = to(this._color, "srgb");
				representation.coords[1] = newval;
				this._color = to(representation, space);
			}
		}
		setBlue(new_blue, max = [0, 1]) {
			if (!Array.isArray(max)) max = [0, max];
			const colorjsMax = Color.#colorjsMaxes[RGB][2];
			const newval = map(new_blue, max[0], max[1], colorjsMax[0], colorjsMax[1]);
			if (this.mode === RGB || this.mode === RGBHDR) this._color.coords[2] = newval;
			else {
				const space = this._color.space.id;
				const representation = to(this._color, "srgb");
				representation.coords[2] = newval;
				this._color = to(representation, space);
			}
		}
		setAlpha(new_alpha, max = [0, 1]) {
			if (!Array.isArray(max)) max = [0, max];
			const colorjsMax = Color.#colorjsMaxes[this.mode][3];
			const newval = map(new_alpha, max[0], max[1], colorjsMax[0], colorjsMax[1]);
			this._color.alpha = newval;
		}
		_getRGBA(maxes = [
			1,
			1,
			1,
			1
		]) {
			const colorjsMaxes = Color.#colorjsMaxes[RGB];
			let coords = structuredClone(to(this._color, "srgb").coords);
			coords.push(this._color.alpha);
			const rangeMaxes = maxes.map((v$1) => {
				if (!Array.isArray(v$1)) return [0, v$1];
				else return v$1;
			});
			coords = coords.map((coord, i$1) => {
				return map(coord, colorjsMaxes[i$1][0], colorjsMaxes[i$1][1], rangeMaxes[i$1][0], rangeMaxes[i$1][1]);
			});
			return coords;
		}
		_getMode() {
			return this.mode;
		}
		_getRed(max = [0, 1]) {
			if (!Array.isArray(max)) max = [0, max];
			if (this.mode === RGB || this.mode === RGBHDR) {
				const colorjsMax = Color.#colorjsMaxes[this.mode][0];
				return map(this._color.coords[0], colorjsMax[0], colorjsMax[1], max[0], max[1]);
			} else {
				const colorjsMax = Color.#colorjsMaxes[RGB][0];
				return map(to(this._color, "srgb").coords[0], colorjsMax[0], colorjsMax[1], max[0], max[1]);
			}
		}
		_getGreen(max = [0, 1]) {
			if (!Array.isArray(max)) max = [0, max];
			if (this.mode === RGB || this.mode === RGBHDR) {
				const colorjsMax = Color.#colorjsMaxes[this.mode][1];
				return map(this._color.coords[1], colorjsMax[0], colorjsMax[1], max[0], max[1]);
			} else {
				const colorjsMax = Color.#colorjsMaxes[RGB][1];
				return map(to(this._color, "srgb").coords[1], colorjsMax[0], colorjsMax[1], max[0], max[1]);
			}
		}
		_getBlue(max = [0, 1]) {
			if (!Array.isArray(max)) max = [0, max];
			if (this.mode === RGB || this.mode === RGBHDR) {
				const colorjsMax = Color.#colorjsMaxes[this.mode][2];
				return map(this._color.coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
			} else {
				const colorjsMax = Color.#colorjsMaxes[RGB][2];
				return map(to(this._color, "srgb").coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
			}
		}
		_getAlpha(max = [0, 1]) {
			if (!Array.isArray(max)) max = [0, max];
			const colorjsMax = Color.#colorjsMaxes[this.mode][3];
			return map(this._color.alpha, colorjsMax[0], colorjsMax[1], max[0], max[1]);
		}
		_getHue(max = [0, 360]) {
			if (!Array.isArray(max)) max = [0, max];
			if (this.mode === HSB || this.mode === HSL) {
				const colorjsMax = Color.#colorjsMaxes[this.mode][0];
				return map(this._color.coords[0], colorjsMax[0], colorjsMax[1], max[0], max[1]);
			} else {
				const colorjsMax = Color.#colorjsMaxes[HSL][0];
				return map(to(this._color, "hsl").coords[0], colorjsMax[0], colorjsMax[1], max[0], max[1]);
			}
		}
		_getSaturation(max = [0, 100]) {
			if (!Array.isArray(max)) max = [0, max];
			if (this.mode === HSB || this.mode === HSL) {
				const colorjsMax = Color.#colorjsMaxes[this.mode][1];
				return map(this._color.coords[1], colorjsMax[0], colorjsMax[1], max[0], max[1]);
			} else {
				const colorjsMax = Color.#colorjsMaxes[HSL][1];
				return map(to(this._color, "hsl").coords[1], colorjsMax[0], colorjsMax[1], max[0], max[1]);
			}
		}
		_getBrightness(max = [0, 100]) {
			if (!Array.isArray(max)) max = [0, max];
			if (this.mode === HSB) {
				const colorjsMax = Color.#colorjsMaxes[this.mode][2];
				return map(this._color.coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
			} else {
				const colorjsMax = Color.#colorjsMaxes[HSB][2];
				return map(to(this._color, "hsb").coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
			}
		}
		_getLightness(max = [0, 100]) {
			if (!Array.isArray(max)) max = [0, max];
			if (this.mode === HSL) {
				const colorjsMax = Color.#colorjsMaxes[this.mode][2];
				return map(this._color.coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
			} else {
				const colorjsMax = Color.#colorjsMaxes[HSL][2];
				return map(to(this._color, "hsl").coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
			}
		}
	};
	function color$1(p5$2, fn$1, lifecycles) {
		p5$2.Color = Color;
		srgb_default.fromGray = p3_default.fromGray = function(val$1, maxes, clamp$2) {
			const p5Maxes = maxes.map((max) => {
				if (!Array.isArray(max)) return [0, max];
				else return max;
			});
			const v$1 = map(val$1, p5Maxes[2][0], p5Maxes[2][1], 0, 1, clamp$2);
			return [
				v$1,
				v$1,
				v$1
			];
		};
		HSBSpace.fromGray = hsl_default.fromGray = function(val$1, maxes, clamp$2) {
			const p5Maxes = maxes.map((max) => {
				if (!Array.isArray(max)) return [0, max];
				else return max;
			});
			return [
				0,
				0,
				map(val$1, p5Maxes[2][0], p5Maxes[2][1], 0, 100, clamp$2)
			];
		};
		hwb_default.fromGray = function(val$1, maxes, clamp$2) {
			const p5Maxes = maxes.map((max) => {
				if (!Array.isArray(max)) return [0, max];
				else return max;
			});
			const nVal = map(val$1, 0, Math.abs(p5Maxes[1][0] - p5Maxes[1][1]) / 2 + Math.abs(p5Maxes[2][0] - p5Maxes[2][1]) / 2, 0, 100);
			let white$3, black;
			if (nVal < 50) {
				black = nVal;
				white$3 = 100 - nVal;
			} else if (nVal >= 50) {
				white$3 = nVal;
				black = 100 - nVal;
			}
			return [
				0,
				white$3,
				black
			];
		};
		lab_default.fromGray = lch_default.fromGray = oklab_default.fromGray = oklch_default.fromGray = function(val$1, maxes, clamp$2) {
			const p5Maxes = maxes.map((max) => {
				if (!Array.isArray(max)) return [0, max];
				else return max;
			});
			return [
				map(val$1, p5Maxes[0][0], p5Maxes[0][1], 0, 100, clamp$2),
				0,
				0
			];
		};
		p5$2.Color.addColorMode(RGB, srgb_default);
		p5$2.Color.addColorMode(RGBHDR, p3_default);
		p5$2.Color.addColorMode(HSB, HSBSpace);
		p5$2.Color.addColorMode(HSL, hsl_default);
		p5$2.Color.addColorMode(HWB, hwb_default);
		p5$2.Color.addColorMode(LAB, lab_default);
		p5$2.Color.addColorMode(LCH, lch_default);
		p5$2.Color.addColorMode(OKLAB, oklab_default);
		p5$2.Color.addColorMode(OKLCH, oklch_default);
		lifecycles.presetup = function() {
			const pInst = this;
			const setMethods = [
				"Red",
				"Green",
				"Blue",
				"Alpha"
			];
			for (let i$1 in setMethods) {
				const method = setMethods[i$1];
				const setCopy = p5$2.Color.prototype["set" + method];
				p5$2.Color.prototype["set" + method] = function(newval, max) {
					max = max || pInst?._renderer?.states?.colorMaxes?.[RGB][i$1];
					return setCopy.call(this, newval, max);
				};
			}
			function decorateGet(channel, modes) {
				const getCopy = p5$2.Color.prototype["_get" + channel];
				p5$2.Color.prototype["_get" + channel] = function(max) {
					if (Object.keys(modes).includes(this.mode)) max = max || pInst?._renderer?.states?.colorMaxes?.[this.mode][modes[this.mode]];
					else {
						const defaultMode = Object.keys(modes)[0];
						max = max || pInst?._renderer?.states?.colorMaxes?.[defaultMode][modes[defaultMode]];
					}
					return getCopy.call(this, max);
				};
			}
			decorateGet("Red", {
				[RGB]: 0,
				[RGBHDR]: 0
			});
			decorateGet("Green", {
				[RGB]: 1,
				[RGBHDR]: 1
			});
			decorateGet("Blue", {
				[RGB]: 2,
				[RGBHDR]: 2
			});
			decorateGet("Alpha", {
				[RGB]: 3,
				[RGBHDR]: 3,
				[HSB]: 3,
				[HSL]: 3,
				[HWB]: 3,
				[LAB]: 3,
				[LCH]: 3,
				[OKLAB]: 3,
				[OKLCH]: 3
			});
			decorateGet("Hue", {
				[HSL]: 0,
				[HSB]: 0,
				[HWB]: 0,
				[LCH]: 2,
				[OKLCH]: 2
			});
			decorateGet("Saturation", {
				[HSL]: 1,
				[HSB]: 1
			});
			decorateGet("Brightness", { [HSB]: 2 });
			decorateGet("Lightness", { [HSL]: 2 });
		};
	}
	if (typeof p5 !== "undefined") color$1(p5, p5.prototype);
	const RGB = "rgb";
	const RGBHDR = "rgbhdr";
	const HSB = "hsb";
	const HSL = "hsl";
	const HWB = "hwb";
	const LAB = "lab";
	const LCH = "lch";
	const OKLAB = "oklab";
	const OKLCH = "oklch";
	const RGBA = "rgba";
	function creatingReading(p5$2, fn$1) {
		fn$1.RGB = RGB;
		fn$1.RGBHDR = RGBHDR;
		fn$1.HSB = HSB;
		fn$1.HSL = HSL;
		fn$1.HWB = HWB;
		fn$1.LAB = LAB;
		fn$1.LCH = LCH;
		fn$1.OKLAB = OKLAB;
		fn$1.OKLCH = OKLCH;
		fn$1.RGBA = RGBA;
		p5$2.Renderer.states.colorMode = RGB;
		p5$2.Renderer.states.colorMaxes = {
			[RGB]: [
				255,
				255,
				255,
				255
			],
			[RGBHDR]: [
				255,
				255,
				255,
				255
			],
			[HSB]: [
				360,
				100,
				100,
				1
			],
			[HSL]: [
				360,
				100,
				100,
				1
			],
			[HWB]: [
				360,
				100,
				100,
				1
			],
			[LAB]: [
				100,
				[-125, 125],
				[-125, 125],
				1
			],
			[LCH]: [
				100,
				150,
				360,
				1
			],
			[OKLAB]: [
				100,
				[-125, 125],
				[-125, 125],
				1
			],
			[OKLCH]: [
				100,
				150,
				360,
				1
			],
			clone: function() {
				const cloned = { ...this };
				for (const key in cloned) if (cloned[key] instanceof Array) cloned[key] = [...cloned[key]];
				return cloned;
			}
		};
		fn$1.color = function(...args) {
			if (args[0] instanceof Color) return args[0];
			return new Color(Array.isArray(args[0]) ? args[0] : args, this._renderer.states.colorMode, this._renderer.states.colorMaxes[this._renderer.states.colorMode], { clamp: true });
		};
		fn$1.red = function(c) {
			return this.color(c)._getRed();
		};
		fn$1.green = function(c) {
			return this.color(c)._getGreen();
		};
		fn$1.blue = function(c) {
			return this.color(c)._getBlue();
		};
		fn$1.alpha = function(c) {
			return this.color(c)._getAlpha();
		};
		fn$1.hue = function(c) {
			return this.color(c)._getHue();
		};
		fn$1.saturation = function(c) {
			return this.color(c)._getSaturation();
		};
		fn$1.brightness = function(c) {
			return this.color(c)._getBrightness();
		};
		fn$1.lightness = function(c) {
			return this.color(c)._getLightness();
		};
		fn$1.lerpColor = function(c1$2, c2$2, amt) {
			return c1$2.lerp(c2$2, amt, this._renderer.states.colorMode);
		};
		fn$1.paletteLerp = function(color_stops, amt) {
			const first_color_stop = color_stops[0];
			if (amt < first_color_stop[1]) return this.color(first_color_stop[0]);
			for (let i$1 = 1; i$1 < color_stops.length; i$1++) {
				const color_stop = color_stops[i$1];
				if (amt < color_stop[1]) {
					const prev_color_stop = color_stops[i$1 - 1];
					return this.lerpColor(this.color(prev_color_stop[0]), this.color(color_stop[0]), (amt - prev_color_stop[1]) / (color_stop[1] - prev_color_stop[1]));
				}
			}
			return this.color(color_stops[color_stops.length - 1][0]);
		};
	}
	if (typeof p5 !== "undefined") creatingReading(p5, p5.prototype);
	var XML = class XML {
		constructor(DOM) {
			if (!DOM) this.DOM = document.implementation.createDocument(null, "doc").createElement("root");
			else this.DOM = DOM;
		}
		getParent() {
			return new XML(this.DOM.parentElement);
		}
		getName() {
			return this.DOM.tagName;
		}
		setName(name) {
			const content = this.DOM.innerHTML;
			const attributes$1 = this.DOM.attributes;
			const newDOM = document.implementation.createDocument(null, "default").createElement(name);
			newDOM.innerHTML = content;
			for (let i$1 = 0; i$1 < attributes$1.length; i$1++) newDOM.setAttribute(attributes$1[i$1].nodeName, attributes$1[i$1].nodeValue);
			this.DOM = newDOM;
		}
		hasChildren() {
			return this.DOM.children.length > 0;
		}
		listChildren() {
			const arr$1 = [];
			for (let i$1 = 0; i$1 < this.DOM.childNodes.length; i$1++) arr$1.push(this.DOM.childNodes[i$1].nodeName);
			return arr$1;
		}
		getChildren(param) {
			if (param) return elementsToP5XML(this.DOM.getElementsByTagName(param));
			else return elementsToP5XML(this.DOM.children);
		}
		getChild(param) {
			if (typeof param === "string") {
				for (const child of this.DOM.children) if (child.tagName === param) return new XML(child);
			} else return new XML(this.DOM.children[param]);
		}
		addChild(node) {
			if (node instanceof XML) this.DOM.appendChild(node.DOM);
		}
		removeChild(param) {
			let ind = -1;
			if (typeof param === "string") {
				for (let i$1 = 0; i$1 < this.DOM.children.length; i$1++) if (this.DOM.children[i$1].tagName === param) {
					ind = i$1;
					break;
				}
			} else ind = param;
			if (ind !== -1) this.DOM.removeChild(this.DOM.children[ind]);
		}
		getAttributeCount() {
			return this.DOM.attributes.length;
		}
		listAttributes() {
			const arr$1 = [];
			for (const attribute of this.DOM.attributes) arr$1.push(attribute.nodeName);
			return arr$1;
		}
		hasAttribute(name) {
			const obj = {};
			for (const attribute of this.DOM.attributes) obj[attribute.nodeName] = attribute.nodeValue;
			return obj[name] ? true : false;
		}
		getNum(name, defaultValue) {
			const obj = {};
			for (const attribute of this.DOM.attributes) obj[attribute.nodeName] = attribute.nodeValue;
			return Number(obj[name]) || defaultValue || 0;
		}
		getString(name, defaultValue) {
			const obj = {};
			for (const attribute of this.DOM.attributes) obj[attribute.nodeName] = attribute.nodeValue;
			return obj[name] ? String(obj[name]) : defaultValue || null;
		}
		setAttribute(name, value) {
			this.DOM.setAttribute(name, value);
		}
		getContent(defaultValue) {
			let str;
			str = this.DOM.textContent;
			str = str.replace(/\s\s+/g, ",");
			return str || defaultValue || null;
		}
		setContent(content) {
			if (!this.DOM.children.length) this.DOM.textContent = content;
		}
		serialize() {
			return new XMLSerializer().serializeToString(this.DOM);
		}
	};
	function elementsToP5XML(elements) {
		const arr$1 = [];
		for (let i$1 = 0; i$1 < elements.length; i$1++) arr$1.push(new XML(elements[i$1]));
		return arr$1;
	}
	function xml(p5$2, fn$1) {
		p5$2.XML = XML;
	}
	if (typeof p5 !== "undefined") xml(p5, p5.prototype);
	var File$1 = class File$1 {
		constructor(file$1, pInst) {
			this.file = file$1;
			this._pInst = pInst;
			const typeList = file$1.type.split("/");
			this.type = typeList[0];
			this.subtype = typeList[1];
			this.name = file$1.name;
			this.size = file$1.size;
			this.data = void 0;
		}
		static _createLoader(theFile, callback) {
			const reader = new FileReader();
			reader.onload = function(e$1) {
				const p5file = new File$1(theFile);
				if (p5file.file.type === "application/json") p5file.data = JSON.parse(e$1.target.result);
				else if (p5file.file.type === "text/xml") p5file.data = new XML(new DOMParser().parseFromString(e$1.target.result, "text/xml").documentElement);
				else p5file.data = e$1.target.result;
				callback(p5file);
			};
			return reader;
		}
		static _load(f, callback) {
			if (/^text\//.test(f.type) || f.type === "application/json") File$1._createLoader(f, callback).readAsText(f);
			else if (!/^(video|audio)\//.test(f.type)) File$1._createLoader(f, callback).readAsDataURL(f);
			else {
				const file$1 = new File$1(f);
				file$1.data = URL.createObjectURL(f);
				callback(file$1);
			}
		}
	};
	function file(p5$2, fn$1) {
		p5$2.File = File$1;
	}
	if (typeof p5 !== "undefined") file(p5, p5.prototype);
	var Element = class Element {
		width;
		height;
		elt;
		constructor(elt, pInst) {
			this.elt = elt;
			this._pInst = this._pixelsState = pInst;
			this._events = {};
			this.width = this.elt.offsetWidth;
			this.height = this.elt.offsetHeight;
		}
		remove() {
			if (this.stop) {
				this.stop();
				const sources = this.elt.srcObject;
				if (sources !== null) sources.getTracks().forEach((track) => {
					track.stop();
				});
			}
			let sketch = this._pInst;
			if (sketch && !sketch._elements && sketch._pInst) sketch = sketch._pInst;
			if (sketch && sketch._elements) {
				const i$1 = sketch._elements.indexOf(this);
				if (i$1 !== -1) sketch._elements.splice(i$1, 1);
			}
			for (let ev in this._events) this.elt.removeEventListener(ev, this._events[ev]);
			if (this.elt && this.elt.parentNode) this.elt.parentNode.removeChild(this.elt);
		}
		parent(p$1) {
			if (typeof p$1 === "undefined") return this.elt.parentNode;
			if (typeof p$1 === "string") {
				if (p$1[0] === "#") p$1 = p$1.substring(1);
				p$1 = document.getElementById(p$1);
			} else if (p$1 instanceof Element) p$1 = p$1.elt;
			p$1.appendChild(this.elt);
			return this;
		}
		child(childNode) {
			if (typeof childNode === "undefined") return this.elt.childNodes;
			if (typeof childNode === "string") {
				if (childNode[0] === "#") childNode = childNode.substring(1);
				childNode = document.getElementById(childNode);
			} else if (childNode instanceof Element) childNode = childNode.elt;
			if (childNode instanceof HTMLElement) this.elt.appendChild(childNode);
			return this;
		}
		html(...args) {
			if (args.length === 0) return this.elt.innerHTML;
			else if (args[1]) {
				this.elt.insertAdjacentHTML("beforeend", args[0]);
				return this;
			} else {
				this.elt.innerHTML = args[0];
				return this;
			}
		}
		id(id) {
			if (typeof id === "undefined") return this.elt.id;
			this.elt.id = id;
			this.width = this.elt.offsetWidth;
			this.height = this.elt.offsetHeight;
			return this;
		}
		class(c) {
			if (typeof c === "undefined") return this.elt.className;
			this.elt.className = c;
			return this;
		}
		addClass(c) {
			if (this.elt.className) {
				if (!this.hasClass(c)) this.elt.className = this.elt.className + " " + c;
			} else this.elt.className = c;
			return this;
		}
		removeClass(c) {
			this.elt.classList.remove(c);
			return this;
		}
		hasClass(c) {
			return this.elt.classList.contains(c);
		}
		toggleClass(c) {
			if (this.elt.classList.contains(c)) this.elt.classList.remove(c);
			else this.elt.classList.add(c);
			return this;
		}
		center(align) {
			const style = this.elt.style.display;
			const hidden = this.elt.style.display === "none";
			const parentHidden = this.parent().style.display === "none";
			const pos = {
				x: this.elt.offsetLeft,
				y: this.elt.offsetTop
			};
			if (hidden) this.show();
			if (parentHidden) this.parent().show();
			this.elt.style.display = "block";
			this.position(0, 0);
			const wOffset = Math.abs(this.parent().offsetWidth - this.elt.offsetWidth);
			const hOffset = Math.abs(this.parent().offsetHeight - this.elt.offsetHeight);
			if (align === "both" || align === void 0) this.position(wOffset / 2 + this.parent().offsetLeft, hOffset / 2 + this.parent().offsetTop);
			else if (align === "horizontal") this.position(wOffset / 2 + this.parent().offsetLeft, pos.y);
			else if (align === "vertical") this.position(pos.x, hOffset / 2 + this.parent().offsetTop);
			this.style("display", style);
			if (hidden) this.hide();
			if (parentHidden) this.parent().hide();
			return this;
		}
		position(...args) {
			if (args.length === 0) return {
				x: this.elt.offsetLeft,
				y: this.elt.offsetTop
			};
			else {
				let positionType = "absolute";
				if (args[2] === "static" || args[2] === "fixed" || args[2] === "relative" || args[2] === "sticky" || args[2] === "initial" || args[2] === "inherit") positionType = args[2];
				this.elt.style.position = positionType;
				this.elt.style.left = args[0] + "px";
				this.elt.style.top = args[1] + "px";
				this.x = args[0];
				this.y = args[1];
				return this;
			}
		}
		show() {
			this.elt.style.display = "block";
			return this;
		}
		hide() {
			this.elt.style.display = "none";
			return this;
		}
		size(w, h) {
			if (arguments.length === 0) return {
				width: this.elt.offsetWidth,
				height: this.elt.offsetHeight
			};
			else {
				let aW = w;
				let aH = h;
				const AUTO$1 = AUTO;
				if (aW !== AUTO$1 || aH !== AUTO$1) {
					if (aW === AUTO$1) aW = h * this.width / this.height;
					else if (aH === AUTO$1) aH = w * this.height / this.width;
					if (this.elt instanceof HTMLCanvasElement) {
						const j = {};
						const k = this.elt.getContext("2d");
						let prop;
						for (prop in k) j[prop] = k[prop];
						this.elt.setAttribute("width", aW * this._pInst._pixelDensity);
						this.elt.setAttribute("height", aH * this._pInst._pixelDensity);
						this.elt.style.width = aW + "px";
						this.elt.style.height = aH + "px";
						this._pInst.scale(this._pInst._pixelDensity, this._pInst._pixelDensity);
						for (prop in j) this.elt.getContext("2d")[prop] = j[prop];
					} else {
						this.elt.style.width = aW + "px";
						this.elt.style.height = aH + "px";
						this.elt.width = aW;
						this.elt.height = aH;
					}
					this.width = aW;
					this.height = aH;
					if (this._pInst && this._pInst._curElement) {
						if (this._pInst._curElement.elt === this.elt) {
							this._pInst.width = aW;
							this._pInst.height = aH;
						}
					}
				}
				return this;
			}
		}
		style(prop, val$1) {
			const self$1 = this;
			if (val$1 instanceof Color) val$1 = val$1.toString();
			if (typeof val$1 === "undefined") if (prop.indexOf(":") === -1) return window.getComputedStyle(self$1.elt).getPropertyValue(prop);
			else {
				const attrs = prop.split(";");
				for (let i$1 = 0; i$1 < attrs.length; i$1++) {
					const parts = attrs[i$1].split(":");
					if (parts[0] && parts[1]) this.elt.style[parts[0].trim()] = parts[1].trim();
				}
			}
			else {
				this.elt.style[prop] = val$1;
				if (prop === "width" || prop === "height" || prop === "left" || prop === "top") {
					let numVal = window.getComputedStyle(self$1.elt).getPropertyValue(prop).replace(/[^\d.]/g, "");
					this[prop] = Math.round(parseFloat(numVal, 10));
				}
			}
			return this;
		}
		_translate(...args) {
			this.elt.style.position = "absolute";
			let transform$2 = "";
			if (this.elt.style.transform) {
				transform$2 = this.elt.style.transform.replace(/translate3d\(.*\)/g, "");
				transform$2 = transform$2.replace(/translate[X-Z]?\(.*\)/g, "");
			}
			if (args.length === 2) this.elt.style.transform = "translate(" + args[0] + "px, " + args[1] + "px)";
			else if (args.length > 2) {
				this.elt.style.transform = "translate3d(" + args[0] + "px," + args[1] + "px," + args[2] + "px)";
				if (args.length === 3) this.elt.parentElement.style.perspective = "1000px";
				else this.elt.parentElement.style.perspective = args[3] + "px";
			}
			this.elt.style.transform += transform$2;
			return this;
		}
		_rotate(...args) {
			let transform$2 = "";
			if (this.elt.style.transform) {
				transform$2 = this.elt.style.transform.replace(/rotate3d\(.*\)/g, "");
				transform$2 = transform$2.replace(/rotate[X-Z]?\(.*\)/g, "");
			}
			if (args.length === 1) this.elt.style.transform = "rotate(" + args[0] + "deg)";
			else if (args.length === 2) this.elt.style.transform = "rotate(" + args[0] + "deg, " + args[1] + "deg)";
			else if (args.length === 3) {
				this.elt.style.transform = "rotateX(" + args[0] + "deg)";
				this.elt.style.transform += "rotateY(" + args[1] + "deg)";
				this.elt.style.transform += "rotateZ(" + args[2] + "deg)";
			}
			this.elt.style.transform += transform$2;
			return this;
		}
		attribute(attr, value) {
			if (this.elt.firstChild != null && (this.elt.firstChild.type === "checkbox" || this.elt.firstChild.type === "radio")) if (typeof value === "undefined") return this.elt.firstChild.getAttribute(attr);
			else for (let i$1 = 0; i$1 < this.elt.childNodes.length; i$1++) this.elt.childNodes[i$1].setAttribute(attr, value);
			else if (typeof value === "undefined") return this.elt.getAttribute(attr);
			else {
				this.elt.setAttribute(attr, value);
				return this;
			}
		}
		removeAttribute(attr) {
			if (this.elt.firstChild != null && (this.elt.firstChild.type === "checkbox" || this.elt.firstChild.type === "radio")) for (let i$1 = 0; i$1 < this.elt.childNodes.length; i$1++) this.elt.childNodes[i$1].removeAttribute(attr);
			this.elt.removeAttribute(attr);
			return this;
		}
		value(...args) {
			if (args.length > 0) {
				this.elt.value = args[0];
				return this;
			} else if (this.elt.type === "range") return parseFloat(this.elt.value);
			else return this.elt.value;
		}
		mousePressed(fxn) {
			const eventPrependedFxn = function(event) {
				this._pInst.mouseIsPressed = true;
				this._pInst._activePointers.set(event.pointerId, event);
				this._pInst._setMouseButton(event);
				this._pInst._updatePointerCoords(event);
				return fxn.call(this, event);
			};
			Element._adjustListener("pointerdown", eventPrependedFxn, this);
			return this;
		}
		doubleClicked(fxn) {
			Element._adjustListener("dblclick", fxn, this);
			return this;
		}
		mouseWheel(fxn) {
			Element._adjustListener("wheel", fxn, this);
			return this;
		}
		mouseReleased(fxn) {
			Element._adjustListener("pointerup", fxn, this);
			return this;
		}
		mouseClicked(fxn) {
			Element._adjustListener("click", fxn, this);
			return this;
		}
		mouseMoved(fxn) {
			Element._adjustListener("pointermove", fxn, this);
			return this;
		}
		mouseOver(fxn) {
			Element._adjustListener("pointerover", fxn, this);
			return this;
		}
		mouseOut(fxn) {
			Element._adjustListener("pointerout", fxn, this);
			return this;
		}
		dragOver(fxn) {
			Element._adjustListener("dragover", fxn, this);
			return this;
		}
		dragLeave(fxn) {
			Element._adjustListener("dragleave", fxn, this);
			return this;
		}
		changed(fxn) {
			Element._adjustListener("change", fxn, this);
			return this;
		}
		input(fxn) {
			Element._adjustListener("input", fxn, this);
			return this;
		}
		drop(callback, fxn) {
			if (window.File && window.FileReader && window.FileList && window.Blob) {
				if (!this._dragDisabled) {
					this._dragDisabled = true;
					const preventDefault = function(evt) {
						evt.preventDefault();
					};
					this.elt.addEventListener("dragover", preventDefault);
					this.elt.addEventListener("dragleave", preventDefault);
				}
				Element._attachListener("drop", function(evt) {
					evt.preventDefault();
					if (typeof fxn === "function") fxn.call(this, evt);
					const files$1 = evt.dataTransfer.files;
					for (const f of files$1) File$1._load(f, callback);
				}, this);
			} else console.log("The File APIs are not fully supported in this browser.");
			return this;
		}
		draggable(elmMove) {
			let isTouch = "ontouchstart" in window;
			let x$1 = 0, y = 0, px = 0, py = 0, elmDrag, dragMouseDownEvt = isTouch ? "touchstart" : "mousedown", closeDragElementEvt = isTouch ? "touchend" : "mouseup", elementDragEvt = isTouch ? "touchmove" : "mousemove";
			if (elmMove === void 0) {
				elmMove = this.elt;
				elmDrag = elmMove;
			} else if (elmMove !== this.elt && elmMove.elt !== this.elt) {
				elmMove = elmMove.elt;
				elmDrag = this.elt;
			}
			elmDrag.addEventListener(dragMouseDownEvt, dragMouseDown, false);
			elmDrag.style.cursor = "move";
			function dragMouseDown(e$1) {
				e$1 = e$1 || window.event;
				if (isTouch) {
					const touches = e$1.changedTouches;
					px = parseInt(touches[0].clientX);
					py = parseInt(touches[0].clientY);
				} else {
					px = parseInt(e$1.clientX);
					py = parseInt(e$1.clientY);
				}
				document.addEventListener(closeDragElementEvt, closeDragElement, false);
				document.addEventListener(elementDragEvt, elementDrag, false);
				return false;
			}
			function elementDrag(e$1) {
				e$1 = e$1 || window.event;
				if (isTouch) {
					const touches = e$1.changedTouches;
					x$1 = px - parseInt(touches[0].clientX);
					y = py - parseInt(touches[0].clientY);
					px = parseInt(touches[0].clientX);
					py = parseInt(touches[0].clientY);
				} else {
					x$1 = px - parseInt(e$1.clientX);
					y = py - parseInt(e$1.clientY);
					px = parseInt(e$1.clientX);
					py = parseInt(e$1.clientY);
				}
				elmMove.style.left = elmMove.offsetLeft - x$1 + "px";
				elmMove.style.top = elmMove.offsetTop - y + "px";
			}
			function closeDragElement() {
				document.removeEventListener(closeDragElementEvt, closeDragElement, false);
				document.removeEventListener(elementDragEvt, elementDrag, false);
			}
			return this;
		}
		static _adjustListener(ev, fxn, ctx) {
			if (fxn === false) Element._detachListener(ev, ctx);
			else Element._attachListener(ev, fxn, ctx);
			return this;
		}
		static _attachListener(ev, fxn, ctx) {
			if (ctx._events[ev]) Element._detachListener(ev, ctx);
			const f = fxn.bind(ctx);
			ctx.elt.addEventListener(ev, f, false);
			ctx._events[ev] = f;
		}
		static _detachListener(ev, ctx) {
			const f = ctx._events[ev];
			ctx.elt.removeEventListener(ev, f, false);
			ctx._events[ev] = null;
		}
	};
	function element(p5$2, fn$1) {
		p5$2.Element = Element;
	}
	if (typeof p5 !== "undefined") element(p5, p5.prototype);
	const Filters = {
		_toPixels(canvas$1) {
			if (canvas$1 instanceof ImageData) return canvas$1.data;
			else if (canvas$1.getContext("2d")) return canvas$1.getContext("2d").getImageData(0, 0, canvas$1.width, canvas$1.height).data;
			else if (canvas$1.getContext("webgl")) {
				const gl = canvas$1.getContext("webgl");
				const len = gl.drawingBufferWidth * gl.drawingBufferHeight * 4;
				const data$2 = new Uint8Array(len);
				gl.readPixels(0, 0, canvas$1.width, canvas$1.height, gl.RGBA, gl.UNSIGNED_BYTE, data$2);
				return data$2;
			}
		},
		_getARGB(data$2, i$1) {
			const offset = i$1 * 4;
			return data$2[offset + 3] << 24 & 4278190080 | data$2[offset] << 16 & 16711680 | data$2[offset + 1] << 8 & 65280 | data$2[offset + 2] & 255;
		},
		_setPixels(pixels$1, data$2) {
			let offset = 0;
			for (let i$1 = 0, al = pixels$1.length; i$1 < al; i$1++) {
				offset = i$1 * 4;
				pixels$1[offset + 0] = (data$2[i$1] & 16711680) >>> 16;
				pixels$1[offset + 1] = (data$2[i$1] & 65280) >>> 8;
				pixels$1[offset + 2] = data$2[i$1] & 255;
				pixels$1[offset + 3] = (data$2[i$1] & 4278190080) >>> 24;
			}
		},
		_toImageData(canvas$1) {
			if (canvas$1 instanceof ImageData) return canvas$1;
			else return canvas$1.getContext("2d").getImageData(0, 0, canvas$1.width, canvas$1.height);
		},
		_createImageData(width, height) {
			Filters._tmpCanvas = document.createElement("canvas");
			Filters._tmpCtx = Filters._tmpCanvas.getContext("2d");
			return this._tmpCtx.createImageData(width, height);
		},
		apply(canvas$1, func, filterParam) {
			const pixelsState = canvas$1.getContext("2d");
			const imageData = pixelsState.getImageData(0, 0, canvas$1.width, canvas$1.height);
			const newImageData = func(imageData, filterParam);
			if (newImageData instanceof ImageData) pixelsState.putImageData(newImageData, 0, 0, 0, 0, canvas$1.width, canvas$1.height);
			else pixelsState.putImageData(imageData, 0, 0, 0, 0, canvas$1.width, canvas$1.height);
		},
		threshold(canvas$1, level = .5) {
			const pixels$1 = Filters._toPixels(canvas$1);
			const thresh = Math.floor(level * 255);
			for (let i$1 = 0; i$1 < pixels$1.length; i$1 += 4) {
				const r = pixels$1[i$1];
				const g$1 = pixels$1[i$1 + 1];
				const b$1 = pixels$1[i$1 + 2];
				const gray = .2126 * r + .7152 * g$1 + .0722 * b$1;
				let val$1;
				if (gray >= thresh) val$1 = 255;
				else val$1 = 0;
				pixels$1[i$1] = pixels$1[i$1 + 1] = pixels$1[i$1 + 2] = val$1;
			}
		},
		gray(canvas$1) {
			const pixels$1 = Filters._toPixels(canvas$1);
			for (let i$1 = 0; i$1 < pixels$1.length; i$1 += 4) {
				const r = pixels$1[i$1];
				const g$1 = pixels$1[i$1 + 1];
				const b$1 = pixels$1[i$1 + 2];
				const gray = .2126 * r + .7152 * g$1 + .0722 * b$1;
				pixels$1[i$1] = pixels$1[i$1 + 1] = pixels$1[i$1 + 2] = gray;
			}
		},
		opaque(canvas$1) {
			const pixels$1 = Filters._toPixels(canvas$1);
			for (let i$1 = 0; i$1 < pixels$1.length; i$1 += 4) pixels$1[i$1 + 3] = 255;
			return pixels$1;
		},
		invert(canvas$1) {
			const pixels$1 = Filters._toPixels(canvas$1);
			for (let i$1 = 0; i$1 < pixels$1.length; i$1 += 4) {
				pixels$1[i$1] = 255 - pixels$1[i$1];
				pixels$1[i$1 + 1] = 255 - pixels$1[i$1 + 1];
				pixels$1[i$1 + 2] = 255 - pixels$1[i$1 + 2];
			}
		},
		posterize(canvas$1, level = 4) {
			const pixels$1 = Filters._toPixels(canvas$1);
			if (level < 2 || level > 255) throw new Error("Level must be greater than 2 and less than 255 for posterize");
			const levels1 = level - 1;
			for (let i$1 = 0; i$1 < pixels$1.length; i$1 += 4) {
				const rlevel = pixels$1[i$1];
				const glevel = pixels$1[i$1 + 1];
				const blevel = pixels$1[i$1 + 2];
				pixels$1[i$1] = (rlevel * level >> 8) * 255 / levels1;
				pixels$1[i$1 + 1] = (glevel * level >> 8) * 255 / levels1;
				pixels$1[i$1 + 2] = (blevel * level >> 8) * 255 / levels1;
			}
		},
		dilate(canvas$1) {
			const pixels$1 = Filters._toPixels(canvas$1);
			let currIdx = 0;
			const maxIdx = pixels$1.length ? pixels$1.length / 4 : 0;
			const out = new Int32Array(maxIdx);
			let currRowIdx, maxRowIdx, colOrig, colOut, currLum;
			let idxRight, idxLeft, idxUp, idxDown;
			let colRight, colLeft, colUp, colDown;
			let lumRight, lumLeft, lumUp, lumDown;
			while (currIdx < maxIdx) {
				currRowIdx = currIdx;
				maxRowIdx = currIdx + canvas$1.width;
				while (currIdx < maxRowIdx) {
					colOrig = colOut = Filters._getARGB(pixels$1, currIdx);
					idxLeft = currIdx - 1;
					idxRight = currIdx + 1;
					idxUp = currIdx - canvas$1.width;
					idxDown = currIdx + canvas$1.width;
					if (idxLeft < currRowIdx) idxLeft = currIdx;
					if (idxRight >= maxRowIdx) idxRight = currIdx;
					if (idxUp < 0) idxUp = 0;
					if (idxDown >= maxIdx) idxDown = currIdx;
					colUp = Filters._getARGB(pixels$1, idxUp);
					colLeft = Filters._getARGB(pixels$1, idxLeft);
					colDown = Filters._getARGB(pixels$1, idxDown);
					colRight = Filters._getARGB(pixels$1, idxRight);
					currLum = 77 * (colOrig >> 16 & 255) + 151 * (colOrig >> 8 & 255) + 28 * (colOrig & 255);
					lumLeft = 77 * (colLeft >> 16 & 255) + 151 * (colLeft >> 8 & 255) + 28 * (colLeft & 255);
					lumRight = 77 * (colRight >> 16 & 255) + 151 * (colRight >> 8 & 255) + 28 * (colRight & 255);
					lumUp = 77 * (colUp >> 16 & 255) + 151 * (colUp >> 8 & 255) + 28 * (colUp & 255);
					lumDown = 77 * (colDown >> 16 & 255) + 151 * (colDown >> 8 & 255) + 28 * (colDown & 255);
					if (lumLeft > currLum) {
						colOut = colLeft;
						currLum = lumLeft;
					}
					if (lumRight > currLum) {
						colOut = colRight;
						currLum = lumRight;
					}
					if (lumUp > currLum) {
						colOut = colUp;
						currLum = lumUp;
					}
					if (lumDown > currLum) {
						colOut = colDown;
						currLum = lumDown;
					}
					out[currIdx++] = colOut;
				}
			}
			Filters._setPixels(pixels$1, out);
		},
		erode(canvas$1) {
			const pixels$1 = Filters._toPixels(canvas$1);
			let currIdx = 0;
			const maxIdx = pixels$1.length ? pixels$1.length / 4 : 0;
			const out = new Int32Array(maxIdx);
			let currRowIdx, maxRowIdx, colOrig, colOut, currLum;
			let idxRight, idxLeft, idxUp, idxDown;
			let colRight, colLeft, colUp, colDown;
			let lumRight, lumLeft, lumUp, lumDown;
			while (currIdx < maxIdx) {
				currRowIdx = currIdx;
				maxRowIdx = currIdx + canvas$1.width;
				while (currIdx < maxRowIdx) {
					colOrig = colOut = Filters._getARGB(pixels$1, currIdx);
					idxLeft = currIdx - 1;
					idxRight = currIdx + 1;
					idxUp = currIdx - canvas$1.width;
					idxDown = currIdx + canvas$1.width;
					if (idxLeft < currRowIdx) idxLeft = currIdx;
					if (idxRight >= maxRowIdx) idxRight = currIdx;
					if (idxUp < 0) idxUp = 0;
					if (idxDown >= maxIdx) idxDown = currIdx;
					colUp = Filters._getARGB(pixels$1, idxUp);
					colLeft = Filters._getARGB(pixels$1, idxLeft);
					colDown = Filters._getARGB(pixels$1, idxDown);
					colRight = Filters._getARGB(pixels$1, idxRight);
					currLum = 77 * (colOrig >> 16 & 255) + 151 * (colOrig >> 8 & 255) + 28 * (colOrig & 255);
					lumLeft = 77 * (colLeft >> 16 & 255) + 151 * (colLeft >> 8 & 255) + 28 * (colLeft & 255);
					lumRight = 77 * (colRight >> 16 & 255) + 151 * (colRight >> 8 & 255) + 28 * (colRight & 255);
					lumUp = 77 * (colUp >> 16 & 255) + 151 * (colUp >> 8 & 255) + 28 * (colUp & 255);
					lumDown = 77 * (colDown >> 16 & 255) + 151 * (colDown >> 8 & 255) + 28 * (colDown & 255);
					if (lumLeft < currLum) {
						colOut = colLeft;
						currLum = lumLeft;
					}
					if (lumRight < currLum) {
						colOut = colRight;
						currLum = lumRight;
					}
					if (lumUp < currLum) {
						colOut = colUp;
						currLum = lumUp;
					}
					if (lumDown < currLum) {
						colOut = colDown;
						currLum = lumDown;
					}
					out[currIdx++] = colOut;
				}
			}
			Filters._setPixels(pixels$1, out);
		},
		blur(canvas$1, radius) {
			blurARGB(canvas$1, radius);
		}
	};
	let blurRadius;
	let blurKernelSize;
	let blurKernel;
	let blurMult;
	function buildBlurKernel(r) {
		let radius = r * 3.5 | 0;
		radius = radius < 1 ? 1 : radius < 248 ? radius : 248;
		if (blurRadius !== radius) {
			blurRadius = radius;
			blurKernelSize = 1 + blurRadius << 1;
			blurKernel = new Int32Array(blurKernelSize);
			blurMult = new Array(blurKernelSize);
			for (let l = 0; l < blurKernelSize; l++) blurMult[l] = new Int32Array(256);
			let bk, bki;
			let bm, bmi;
			for (let i$1 = 1, radiusi = radius - 1; i$1 < radius; i$1++) {
				blurKernel[radius + i$1] = blurKernel[radiusi] = bki = radiusi * radiusi;
				bm = blurMult[radius + i$1];
				bmi = blurMult[radiusi--];
				for (let j = 0; j < 256; j++) bm[j] = bmi[j] = bki * j;
			}
			bk = blurKernel[radius] = radius * radius;
			bm = blurMult[radius];
			for (let k = 0; k < 256; k++) bm[k] = bk * k;
		}
	}
	function blurARGB(canvas$1, radius) {
		const pixels$1 = Filters._toPixels(canvas$1);
		const width = canvas$1.width;
		const height = canvas$1.height;
		const numPackedPixels = width * height;
		const argb = new Int32Array(numPackedPixels);
		for (let j = 0; j < numPackedPixels; j++) argb[j] = Filters._getARGB(pixels$1, j);
		let sum, cr, cg, cb, ca$1;
		let read, ri, ym, ymi, bk0;
		const a2 = new Int32Array(numPackedPixels);
		const r2 = new Int32Array(numPackedPixels);
		const g2 = new Int32Array(numPackedPixels);
		const b2 = new Int32Array(numPackedPixels);
		let yi = 0;
		buildBlurKernel(radius);
		let x$1, y, i$1;
		let bm;
		for (y = 0; y < height; y++) {
			for (x$1 = 0; x$1 < width; x$1++) {
				cb = cg = cr = ca$1 = sum = 0;
				read = x$1 - blurRadius;
				if (read < 0) {
					bk0 = -read;
					read = 0;
				} else {
					if (read >= width) break;
					bk0 = 0;
				}
				for (i$1 = bk0; i$1 < blurKernelSize; i$1++) {
					if (read >= width) break;
					const c = argb[read + yi];
					bm = blurMult[i$1];
					ca$1 += bm[(c & -16777216) >>> 24];
					cr += bm[(c & 16711680) >> 16];
					cg += bm[(c & 65280) >> 8];
					cb += bm[c & 255];
					sum += blurKernel[i$1];
					read++;
				}
				ri = yi + x$1;
				a2[ri] = ca$1 / sum;
				r2[ri] = cr / sum;
				g2[ri] = cg / sum;
				b2[ri] = cb / sum;
			}
			yi += width;
		}
		yi = 0;
		ym = -blurRadius;
		ymi = ym * width;
		for (y = 0; y < height; y++) {
			for (x$1 = 0; x$1 < width; x$1++) {
				cb = cg = cr = ca$1 = sum = 0;
				if (ym < 0) {
					bk0 = ri = -ym;
					read = x$1;
				} else {
					if (ym >= height) break;
					bk0 = 0;
					ri = ym;
					read = x$1 + ymi;
				}
				for (i$1 = bk0; i$1 < blurKernelSize; i$1++) {
					if (ri >= height) break;
					bm = blurMult[i$1];
					ca$1 += bm[a2[read]];
					cr += bm[r2[read]];
					cg += bm[g2[read]];
					cb += bm[b2[read]];
					sum += blurKernel[i$1];
					ri++;
					read += width;
				}
				argb[x$1 + yi] = ca$1 / sum << 24 | cr / sum << 16 | cg / sum << 8 | cb / sum;
			}
			yi += width;
			ymi += width;
			ym++;
		}
		Filters._setPixels(pixels$1, argb);
	}
	function polylineLength(vertices) {
		let length = 0;
		for (let i$1 = 1; i$1 < vertices.length; i$1++) length += vertices[i$1 - 1].position.dist(vertices[i$1].position);
		return length;
	}
	var Vertex = class {
		constructor(properties) {
			for (const [key, value] of Object.entries(properties)) this[key] = value;
		}
	};
	var ShapePrimitive = class ShapePrimitive {
		vertices;
		_shape = null;
		_primitivesIndex = null;
		_contoursIndex = null;
		isClosing = false;
		constructor(...vertices) {
			if (this.constructor === ShapePrimitive) throw new Error("ShapePrimitive is an abstract class: it cannot be instantiated.");
			if (vertices.length > 0) this.vertices = vertices;
			else throw new Error("At least one vertex must be passed to the constructor.");
		}
		get vertexCount() {
			return this.vertices.length;
		}
		get vertexCapacity() {
			throw new Error("Getter vertexCapacity must be implemented.");
		}
		get _firstInterpolatedVertex() {
			return this.startVertex();
		}
		get canOverrideAnchor() {
			return false;
		}
		accept(visitor) {
			throw new Error("Method accept() must be implemented.");
		}
		addToShape(shape$1) {
			let lastContour = shape$1.at(-1);
			if (lastContour.primitives.length === 0) lastContour.primitives.push(this);
			else {
				let lastPrimitive = shape$1.at(-1, -1);
				let hasSameType = lastPrimitive instanceof this.constructor;
				let spareCapacity = lastPrimitive.vertexCapacity - lastPrimitive.vertexCount;
				let pushableVertices;
				let remainingVertices;
				if (hasSameType && spareCapacity > 0) {
					pushableVertices = this.vertices.splice(0, spareCapacity);
					remainingVertices = this.vertices;
					lastPrimitive.vertices.push(...pushableVertices);
					if (remainingVertices.length > 0) lastContour.primitives.push(this);
				} else lastContour.primitives.push(this);
			}
			if (this.vertices.length > 0) {
				this._primitivesIndex = shape$1.at(-1).primitives.length - 1;
				this._contoursIndex = shape$1.contours.length - 1;
				this._shape = shape$1;
			}
			return shape$1.at(-1, -1);
		}
		get _nextPrimitive() {
			return this._belongsToShape ? this._shape.at(this._contoursIndex, this._primitivesIndex + 1) : null;
		}
		get _belongsToShape() {
			return this._shape !== null;
		}
		handlesClose() {
			return false;
		}
		close(vertex$1) {
			throw new Error("Unimplemented!");
		}
	};
	var Contour = class {
		#kind;
		primitives;
		constructor(kind = PATH) {
			this.#kind = kind;
			this.primitives = [];
		}
		get kind() {
			const isEmpty = this.primitives.length === 0;
			const isPath = this.#kind === PATH;
			return isEmpty && isPath ? EMPTY_PATH : this.#kind;
		}
		accept(visitor) {
			for (const primitive of this.primitives) primitive.accept(visitor);
		}
	};
	var Anchor = class extends ShapePrimitive {
		#vertexCapacity = 1;
		get vertexCapacity() {
			return this.#vertexCapacity;
		}
		accept(visitor) {
			visitor.visitAnchor(this);
		}
		getEndVertex() {
			return this.vertices[0];
		}
	};
	var Segment = class Segment extends ShapePrimitive {
		constructor(...vertices) {
			super(...vertices);
			if (this.constructor === Segment) throw new Error("Segment is an abstract class: it cannot be instantiated.");
		}
		get _previousPrimitive() {
			return this._belongsToShape ? this._shape.at(this._contoursIndex, this._primitivesIndex - 1) : null;
		}
		getStartVertex() {
			return this._previousPrimitive.getEndVertex();
		}
		getEndVertex() {
			return this.vertices.at(-1);
		}
	};
	var LineSegment = class extends Segment {
		#vertexCapacity = 1;
		get vertexCapacity() {
			return this.#vertexCapacity;
		}
		accept(visitor) {
			visitor.visitLineSegment(this);
		}
	};
	var BezierSegment = class extends Segment {
		#order;
		#vertexCapacity;
		constructor(order, ...vertices) {
			super(...vertices);
			let numericalOrder = Array.isArray(order) ? order[0] : order;
			this.#order = numericalOrder;
			this.#vertexCapacity = numericalOrder;
		}
		get order() {
			return this.#order;
		}
		get vertexCapacity() {
			return this.#vertexCapacity;
		}
		#_hullLength;
		hullLength() {
			if (this.#_hullLength === void 0) this.#_hullLength = polylineLength([this.getStartVertex(), ...this.vertices]);
			return this.#_hullLength;
		}
		accept(visitor) {
			visitor.visitBezierSegment(this);
		}
	};
	var SplineSegment = class extends Segment {
		#vertexCapacity = Infinity;
		_splineProperties = {
			ends: INCLUDE,
			tightness: 0
		};
		get vertexCapacity() {
			return this.#vertexCapacity;
		}
		accept(visitor) {
			visitor.visitSplineSegment(this);
		}
		get _comesAfterSegment() {
			return this._previousPrimitive instanceof Segment;
		}
		get canOverrideAnchor() {
			return this._splineProperties.ends === EXCLUDE;
		}
		get _firstInterpolatedVertex() {
			if (this._splineProperties.ends === EXCLUDE) return this._comesAfterSegment ? this.vertices[1] : this.vertices[0];
			else return this.getStartVertex();
		}
		get _chainedToSegment() {
			if (this._belongsToShape && this._comesAfterSegment) {
				let interpolatedStartPosition = this._firstInterpolatedVertex.position;
				return this.getStartVertex().position.equals(interpolatedStartPosition);
			} else return false;
		}
		addToShape(shape$1) {
			const added = super.addToShape(shape$1);
			this._splineProperties.ends = shape$1._splineProperties.ends;
			this._splineProperties.tightness = shape$1._splineProperties.tightness;
			if (this._splineProperties.ends !== EXCLUDE) return added;
			let verticesPushed = !this._belongsToShape;
			let lastPrimitive = shape$1.at(-1, -1);
			let message = (array1, array2) => `Spline does not start where previous path segment ends:
      second spline vertex at (${array1})
      expected to be at (${array2}).`;
			if (verticesPushed && lastPrimitive.vertices.length === 2 && lastPrimitive._comesAfterSegment && !lastPrimitive._chainedToSegment) {
				let interpolatedStart = lastPrimitive._firstInterpolatedVertex.position;
				let predecessorEnd = lastPrimitive.getStartVertex().position;
				console.warn(message(interpolatedStart.array(), predecessorEnd.array()));
			}
			return added;
		}
		getEndVertex() {
			if (this._splineProperties.ends === INCLUDE) return super.getEndVertex();
			else if (this._splineProperties.ends === EXCLUDE) return this.vertices.at(-2);
			else return this.getStartVertex();
		}
		getControlPoints() {
			let points = [];
			if (this._comesAfterSegment) points.push(this.getStartVertex());
			points.push(this.getStartVertex());
			for (const vertex$1 of this.vertices) points.push(vertex$1);
			const prevVertex = this.getStartVertex();
			if (this._splineProperties.ends === INCLUDE) {
				points.unshift(prevVertex);
				points.push(this.vertices.at(-1));
			} else if (this._splineProperties.ends === JOIN) {
				points.unshift(this.vertices.at(-1));
				points.push(prevVertex, this.vertices.at(0));
			}
			return points;
		}
		handlesClose() {
			if (!this._belongsToShape) return false;
			return this._shape.at(this._contoursIndex).primitives.length === 2 && this._primitivesIndex === 1;
		}
		close() {
			this._splineProperties.ends = JOIN;
		}
	};
	var Point = class extends ShapePrimitive {
		#vertexCapacity = 1;
		get vertexCapacity() {
			return this.#vertexCapacity;
		}
		accept(visitor) {
			visitor.visitPoint(this);
		}
	};
	var Line = class extends ShapePrimitive {
		#vertexCapacity = 2;
		get vertexCapacity() {
			return this.#vertexCapacity;
		}
		accept(visitor) {
			visitor.visitLine(this);
		}
	};
	var Triangle = class extends ShapePrimitive {
		#vertexCapacity = 3;
		get vertexCapacity() {
			return this.#vertexCapacity;
		}
		accept(visitor) {
			visitor.visitTriangle(this);
		}
	};
	var Quad = class extends ShapePrimitive {
		#vertexCapacity = 4;
		get vertexCapacity() {
			return this.#vertexCapacity;
		}
		accept(visitor) {
			visitor.visitQuad(this);
		}
	};
	var TriangleFan = class extends ShapePrimitive {
		#vertexCapacity = Infinity;
		get vertexCapacity() {
			return this.#vertexCapacity;
		}
		accept(visitor) {
			visitor.visitTriangleFan(this);
		}
	};
	var TriangleStrip = class extends ShapePrimitive {
		#vertexCapacity = Infinity;
		get vertexCapacity() {
			return this.#vertexCapacity;
		}
		accept(visitor) {
			visitor.visitTriangleStrip(this);
		}
	};
	var QuadStrip = class extends ShapePrimitive {
		#vertexCapacity = Infinity;
		get vertexCapacity() {
			return this.#vertexCapacity;
		}
		accept(visitor) {
			visitor.visitQuadStrip(this);
		}
	};
	var PrimitiveShapeCreators = class {
		creators;
		constructor() {
			let creators = /* @__PURE__ */ new Map();
			creators.set(`vertex-${EMPTY_PATH}`, (...vertices) => new Anchor(...vertices));
			creators.set(`vertex-${PATH}`, (...vertices) => new LineSegment(...vertices));
			creators.set(`vertex-${POINTS}`, (...vertices) => new Point(...vertices));
			creators.set(`vertex-${LINES}`, (...vertices) => new Line(...vertices));
			creators.set(`vertex-${TRIANGLES}`, (...vertices) => new Triangle(...vertices));
			creators.set(`vertex-${QUADS}`, (...vertices) => new Quad(...vertices));
			creators.set(`vertex-${TRIANGLE_FAN}`, (...vertices) => new TriangleFan(...vertices));
			creators.set(`vertex-${TRIANGLE_STRIP}`, (...vertices) => new TriangleStrip(...vertices));
			creators.set(`vertex-${QUAD_STRIP}`, (...vertices) => new QuadStrip(...vertices));
			creators.set(`bezierVertex-${EMPTY_PATH}`, (order, ...vertices) => new Anchor(...vertices));
			creators.set(`bezierVertex-${PATH}`, (order, ...vertices) => new BezierSegment(order, ...vertices));
			creators.set(`splineVertex-${EMPTY_PATH}`, (...vertices) => new Anchor(...vertices));
			creators.set(`splineVertex-${PATH}`, (...vertices) => new SplineSegment(...vertices));
			this.creators = creators;
		}
		get(vertexKind, shapeKind) {
			const key = `${vertexKind}-${shapeKind}`;
			return this.creators.get(key);
		}
		set(vertexKind, shapeKind, creator) {
			const key = `${vertexKind}-${shapeKind}`;
			this.creators.set(key, creator);
		}
		clear() {
			this.creators.clear();
		}
	};
	var Shape = class {
		#vertexProperties;
		#initialVertexProperties;
		#primitiveShapeCreators;
		#bezierOrder = 3;
		kind = null;
		contours = [];
		_splineProperties = {
			tightness: 0,
			ends: INCLUDE
		};
		userVertexProperties = null;
		constructor(vertexProperties, primitiveShapeCreators = new PrimitiveShapeCreators()) {
			this.#initialVertexProperties = vertexProperties;
			this.#vertexProperties = vertexProperties;
			this.#primitiveShapeCreators = primitiveShapeCreators;
			for (const key in this.#vertexProperties) if (key !== "position" && key !== "textureCoordinates") this[key] = function(value) {
				this.#vertexProperties[key] = value;
			};
		}
		serializeToArray(val$1) {
			if (val$1 === null || val$1 === void 0) return [];
			if (val$1 instanceof Number) return [val$1];
			else if (val$1 instanceof Array) return val$1;
			else if (val$1.array instanceof Function) return val$1.array();
			else throw new Error(`Can't convert ${val$1} to array!`);
		}
		vertexToArray(vertex$1) {
			const array$1 = [];
			for (const key in this.#vertexProperties) {
				if (this.userVertexProperties && key in this.userVertexProperties) continue;
				const val$1 = vertex$1[key];
				array$1.push(...this.serializeToArray(val$1));
			}
			for (const key in this.userVertexProperties) if (key in vertex$1) array$1.push(...this.serializeToArray(vertex$1[key]));
			else array$1.push(...new Array(this.userVertexProperties[key]).fill(0));
			return array$1;
		}
		hydrateValue(queue, original) {
			if (original === null) return null;
			else if (original instanceof Number) return queue.shift();
			else if (original instanceof Array) {
				const array$1 = [];
				for (let i$1 = 0; i$1 < original.length; i$1++) array$1.push(queue.shift());
				return array$1;
			} else if (original instanceof Vector) return new Vector(queue.shift(), queue.shift(), queue.shift());
			else if (original instanceof Color) return new Color([
				queue.shift(),
				queue.shift(),
				queue.shift(),
				queue.shift()
			]);
		}
		arrayToVertex(array$1) {
			const vertex$1 = {};
			const queue = [...array$1];
			for (const key in this.#vertexProperties) {
				if (this.userVertexProperties && key in this.userVertexProperties) continue;
				const original = this.#vertexProperties[key];
				vertex$1[key] = this.hydrateValue(queue, original);
			}
			for (const key in this.userVertexProperties) {
				const original = this.#vertexProperties[key];
				vertex$1[key] = this.hydrateValue(queue, original);
			}
			return vertex$1;
		}
		arrayScale(array$1, scale) {
			return array$1.map((v$1) => v$1 * scale);
		}
		arraySum(first, ...rest) {
			return first.map((v$1, i$1) => {
				let result = v$1;
				for (let j = 0; j < rest.length; j++) result += rest[j][i$1];
				return result;
			});
		}
		arrayMinus(a, b$1) {
			return a.map((v$1, i$1) => v$1 - b$1[i$1]);
		}
		evaluateCubicBezier([a, b$1, c, d$1], t$1) {
			return this.arraySum(this.arrayScale(a, Math.pow(1 - t$1, 3)), this.arrayScale(b$1, 3 * Math.pow(1 - t$1, 2) * t$1), this.arrayScale(c, 3 * (1 - t$1) * Math.pow(t$1, 2)), this.arrayScale(d$1, Math.pow(t$1, 3)));
		}
		evaluateQuadraticBezier([a, b$1, c], t$1) {
			return this.arraySum(this.arrayScale(a, Math.pow(1 - t$1, 2)), this.arrayScale(b$1, 2 * (1 - t$1) * t$1), this.arrayScale(c, t$1 * t$1));
		}
		catmullRomToBezier(vertices, tightness) {
			let s = 1 - tightness;
			let bezArrays = [];
			for (let i$1 = 0; i$1 + 3 < vertices.length; i$1++) {
				const [a, b$1, c, d$1] = vertices.slice(i$1, i$1 + 4);
				const bezB = this.arraySum(b$1, this.arrayScale(this.arrayMinus(c, a), s / 6));
				const bezC = this.arraySum(c, this.arrayScale(this.arrayMinus(b$1, d$1), s / 6));
				const bezD = c;
				bezArrays.push([
					bezB,
					bezC,
					bezD
				]);
			}
			return bezArrays;
		}
		at(contoursIndex, primitivesIndex, verticesIndex) {
			let contour;
			let primitive;
			contour = this.contours.at(contoursIndex);
			switch (arguments.length) {
				case 1: return contour;
				case 2: return contour.primitives.at(primitivesIndex);
				case 3:
					primitive = contour.primitives.at(primitivesIndex);
					return primitive.vertices.at(verticesIndex);
			}
		}
		reset() {
			this.#vertexProperties = { ...this.#initialVertexProperties };
			this.kind = null;
			this.contours = [];
			this.userVertexProperties = null;
		}
		vertexProperty(name, data$2) {
			this.userVertexProperties = this.userVertexProperties || {};
			const key = this.vertexPropertyKey(name);
			const dataArray$1 = Array.isArray(data$2) ? data$2 : [data$2];
			if (!this.userVertexProperties[key]) this.userVertexProperties[key] = dataArray$1.length;
			this.#vertexProperties[key] = dataArray$1;
		}
		vertexPropertyName(key) {
			return key.replace(/Src$/, "");
		}
		vertexPropertyKey(name) {
			return name + "Src";
		}
		bezierOrder(...order) {
			this.#bezierOrder = order;
		}
		splineProperty(key, value) {
			this._splineProperties[key] = value;
		}
		splineProperties(values) {
			if (values) for (const key in values) this.splineProperty(key, values[key]);
			else return this._splineProperties;
		}
		#createVertex(position, textureCoordinates) {
			this.#vertexProperties.position = position;
			if (textureCoordinates !== void 0) this.#vertexProperties.textureCoordinates = textureCoordinates;
			return new Vertex(this.#vertexProperties);
		}
		#createPrimitiveShape(vertexKind, shapeKind, ...vertices) {
			let primitiveShapeCreator = this.#primitiveShapeCreators.get(vertexKind, shapeKind);
			return vertexKind === "bezierVertex" ? primitiveShapeCreator(this.#bezierOrder, ...vertices) : primitiveShapeCreator(...vertices);
		}
		#generalVertex(kind, position, textureCoordinates) {
			let vertexKind = kind;
			let lastContourKind = this.at(-1).kind;
			let vertex$1 = this.#createVertex(position, textureCoordinates);
			return this.#createPrimitiveShape(vertexKind, lastContourKind, vertex$1).addToShape(this);
		}
		vertex(position, textureCoordinates, { isClosing = false } = {}) {
			const added = this.#generalVertex("vertex", position, textureCoordinates);
			added.isClosing = isClosing;
		}
		bezierVertex(position, textureCoordinates) {
			this.#generalVertex("bezierVertex", position, textureCoordinates);
		}
		splineVertex(position, textureCoordinates) {
			this.#generalVertex("splineVertex", position, textureCoordinates);
		}
		arcVertex(position, textureCoordinates) {
			this.#generalVertex("arcVertex", position, textureCoordinates);
		}
		beginContour(shapeKind = PATH) {
			if (this.at(-1)?.kind === EMPTY_PATH) this.contours.pop();
			this.contours.push(new Contour(shapeKind));
		}
		endContour(closeMode = OPEN, _index = this.contours.length - 1) {
			const contour = this.at(_index);
			if (closeMode === CLOSE) {
				const isPath = contour.kind === PATH;
				const anchorVertex = this.at(_index, 0, 0);
				const anchorHasPosition = Object.hasOwn(anchorVertex, "position");
				const lastSegment = this.at(_index, -1);
				if (isPath && anchorHasPosition) if (lastSegment.handlesClose()) lastSegment.close(anchorVertex);
				else {
					const rest = this.contours.splice(_index + 1, this.contours.length - _index - 1);
					const prevVertexProperties = this.#vertexProperties;
					this.#vertexProperties = { ...prevVertexProperties };
					for (const key in anchorVertex) {
						if (["position", "textureCoordinates"].includes(key)) continue;
						this.#vertexProperties[key] = anchorVertex[key];
					}
					this.vertex(anchorVertex.position, anchorVertex.textureCoordinates, { isClosing: true });
					this.#vertexProperties = prevVertexProperties;
					this.contours.push(...rest);
				}
			}
		}
		beginShape(shapeKind = PATH) {
			this.kind = shapeKind;
			this.beginContour(shapeKind);
		}
		endShape(closeMode = OPEN) {
			if (closeMode === CLOSE) this.endContour(closeMode, 0);
		}
		accept(visitor) {
			for (const contour of this.contours) contour.accept(visitor);
		}
	};
	var PrimitiveVisitor = class PrimitiveVisitor {
		constructor() {
			if (this.constructor === PrimitiveVisitor) throw new Error("PrimitiveVisitor is an abstract class: it cannot be instantiated.");
		}
		visitAnchor(anchor) {
			throw new Error("Method visitAnchor() has not been implemented.");
		}
		visitLineSegment(lineSegment) {
			throw new Error("Method visitLineSegment() has not been implemented.");
		}
		visitBezierSegment(bezierSegment) {
			throw new Error("Method visitBezierSegment() has not been implemented.");
		}
		visitSplineSegment(curveSegment) {
			throw new Error("Method visitSplineSegment() has not been implemented.");
		}
		visitArcSegment(arcSegment) {
			throw new Error("Method visitArcSegment() has not been implemented.");
		}
		visitPoint(point) {
			throw new Error("Method visitPoint() has not been implemented.");
		}
		visitLine(line) {
			throw new Error("Method visitLine() has not been implemented.");
		}
		visitTriangle(triangle) {
			throw new Error("Method visitTriangle() has not been implemented.");
		}
		visitQuad(quad) {
			throw new Error("Method visitQuad() has not been implemented.");
		}
		visitTriangleFan(triangleFan) {
			throw new Error("Method visitTriangleFan() has not been implemented.");
		}
		visitTriangleStrip(triangleStrip) {
			throw new Error("Method visitTriangleStrip() has not been implemented.");
		}
		visitQuadStrip(quadStrip) {
			throw new Error("Method visitQuadStrip() has not been implemented.");
		}
	};
	var PrimitiveToPath2DConverter = class extends PrimitiveVisitor {
		path = new Path2D();
		strokeWeight;
		constructor({ strokeWeight }) {
			super();
			this.strokeWeight = strokeWeight;
		}
		visitAnchor(anchor) {
			let vertex$1 = anchor.getEndVertex();
			this.path.moveTo(vertex$1.position.x, vertex$1.position.y);
		}
		visitLineSegment(lineSegment) {
			if (lineSegment.isClosing) this.path.closePath();
			else {
				let vertex$1 = lineSegment.getEndVertex();
				this.path.lineTo(vertex$1.position.x, vertex$1.position.y);
			}
		}
		visitBezierSegment(bezierSegment) {
			let [v1, v2, v3] = bezierSegment.vertices;
			switch (bezierSegment.order) {
				case 2:
					this.path.quadraticCurveTo(v1.position.x, v1.position.y, v2.position.x, v2.position.y);
					break;
				case 3:
					this.path.bezierCurveTo(v1.position.x, v1.position.y, v2.position.x, v2.position.y, v3.position.x, v3.position.y);
					break;
			}
		}
		visitSplineSegment(splineSegment) {
			const shape$1 = splineSegment._shape;
			if (splineSegment._splineProperties.ends === EXCLUDE && !splineSegment._comesAfterSegment) {
				let startVertex = splineSegment._firstInterpolatedVertex;
				this.path.moveTo(startVertex.position.x, startVertex.position.y);
			}
			const arrayVertices = splineSegment.getControlPoints().map((v$1) => shape$1.vertexToArray(v$1));
			let bezierArrays = shape$1.catmullRomToBezier(arrayVertices, splineSegment._splineProperties.tightness).map((arr$1) => arr$1.map((vertArr) => shape$1.arrayToVertex(vertArr)));
			for (const array$1 of bezierArrays) {
				const points = array$1.flatMap((vert) => [vert.position.x, vert.position.y]);
				this.path.bezierCurveTo(...points);
			}
		}
		visitPoint(point) {
			const { x: x$1, y } = point.vertices[0].position;
			this.path.moveTo(x$1, y);
			this.path.lineTo(x$1 + 1e-5, y);
		}
		visitLine(line) {
			const { x: x0, y: y0 } = line.vertices[0].position;
			const { x: x1, y: y1 } = line.vertices[1].position;
			this.path.moveTo(x0, y0);
			this.path.lineTo(x1, y1);
		}
		visitTriangle(triangle) {
			const [v0, v1, v2] = triangle.vertices;
			this.path.moveTo(v0.position.x, v0.position.y);
			this.path.lineTo(v1.position.x, v1.position.y);
			this.path.lineTo(v2.position.x, v2.position.y);
			this.path.closePath();
		}
		visitQuad(quad) {
			const [v0, v1, v2, v3] = quad.vertices;
			this.path.moveTo(v0.position.x, v0.position.y);
			this.path.lineTo(v1.position.x, v1.position.y);
			this.path.lineTo(v2.position.x, v2.position.y);
			this.path.lineTo(v3.position.x, v3.position.y);
			this.path.closePath();
		}
		visitTriangleFan(triangleFan) {
			const [v0, ...rest] = triangleFan.vertices;
			for (let i$1 = 0; i$1 < rest.length - 1; i$1++) {
				const v1 = rest[i$1];
				const v2 = rest[i$1 + 1];
				this.path.moveTo(v0.position.x, v0.position.y);
				this.path.lineTo(v1.position.x, v1.position.y);
				this.path.lineTo(v2.position.x, v2.position.y);
				this.path.closePath();
			}
		}
		visitTriangleStrip(triangleStrip) {
			for (let i$1 = 0; i$1 < triangleStrip.vertices.length - 2; i$1++) {
				const v0 = triangleStrip.vertices[i$1];
				const v1 = triangleStrip.vertices[i$1 + 1];
				const v2 = triangleStrip.vertices[i$1 + 2];
				this.path.moveTo(v0.position.x, v0.position.y);
				this.path.lineTo(v1.position.x, v1.position.y);
				this.path.lineTo(v2.position.x, v2.position.y);
				this.path.closePath();
			}
		}
		visitQuadStrip(quadStrip) {
			for (let i$1 = 0; i$1 < quadStrip.vertices.length - 3; i$1 += 2) {
				const v0 = quadStrip.vertices[i$1];
				const v1 = quadStrip.vertices[i$1 + 1];
				const v2 = quadStrip.vertices[i$1 + 2];
				const v3 = quadStrip.vertices[i$1 + 3];
				this.path.moveTo(v0.position.x, v0.position.y);
				this.path.lineTo(v1.position.x, v1.position.y);
				this.path.lineTo(v3.position.x, v3.position.y);
				this.path.lineTo(v2.position.x, v2.position.y);
				this.path.closePath();
			}
		}
	};
	var PrimitiveToVerticesConverter = class extends PrimitiveVisitor {
		contours = [];
		curveDetail;
		constructor({ curveDetail = 1 } = {}) {
			super();
			this.curveDetail = curveDetail;
		}
		lastContour() {
			return this.contours[this.contours.length - 1];
		}
		visitAnchor(anchor) {
			this.contours.push([]);
			const next = anchor._nextPrimitive;
			if (next?.canOverrideAnchor) this.lastContour().push(next._firstInterpolatedVertex);
			else this.lastContour().push(anchor.getEndVertex());
		}
		visitLineSegment(lineSegment) {
			this.lastContour().push(lineSegment.getEndVertex());
		}
		visitBezierSegment(bezierSegment) {
			const contour = this.lastContour();
			const numPoints = Math.max(1, Math.ceil(bezierSegment.hullLength() * this.curveDetail));
			const vertexArrays = [bezierSegment.getStartVertex(), ...bezierSegment.vertices].map((v$1) => bezierSegment._shape.vertexToArray(v$1));
			for (let i$1 = 0; i$1 < numPoints; i$1++) {
				const t$1 = (i$1 + 1) / numPoints;
				contour.push(bezierSegment._shape.arrayToVertex(bezierSegment.order === 3 ? bezierSegment._shape.evaluateCubicBezier(vertexArrays, t$1) : bezierSegment._shape.evaluateQuadraticBezier(vertexArrays, t$1)));
			}
		}
		visitSplineSegment(splineSegment) {
			const shape$1 = splineSegment._shape;
			const contour = this.lastContour();
			const arrayVertices = splineSegment.getControlPoints().map((v$1) => shape$1.vertexToArray(v$1));
			let bezierArrays = shape$1.catmullRomToBezier(arrayVertices, splineSegment._splineProperties.tightness);
			let startVertex = shape$1.vertexToArray(splineSegment._firstInterpolatedVertex);
			for (const array$1 of bezierArrays) {
				const bezierControls = [startVertex, ...array$1];
				const numPoints = Math.max(1, Math.ceil(polylineLength(bezierControls.map((v$1) => shape$1.arrayToVertex(v$1))) * this.curveDetail));
				for (let i$1 = 0; i$1 < numPoints; i$1++) {
					const t$1 = (i$1 + 1) / numPoints;
					contour.push(shape$1.arrayToVertex(shape$1.evaluateCubicBezier(bezierControls, t$1)));
				}
				startVertex = array$1[2];
			}
		}
		visitPoint(point) {
			this.contours.push(point.vertices.slice());
		}
		visitLine(line) {
			this.contours.push(line.vertices.slice());
		}
		visitTriangle(triangle) {
			this.contours.push(triangle.vertices.slice());
		}
		visitQuad(quad) {
			this.contours.push(quad.vertices.slice());
		}
		visitTriangleFan(triangleFan) {
			this.contours.push(triangleFan.vertices.slice());
		}
		visitTriangleStrip(triangleStrip) {
			this.contours.push(triangleStrip.vertices.slice());
		}
		visitQuadStrip(quadStrip) {
			this.contours.push(quadStrip.vertices.slice());
		}
	};
	var PointAtLengthGetter = class extends PrimitiveVisitor {
		constructor() {
			super();
		}
	};
	function customShapes(p5$2, fn$1) {
		p5$2.Shape = Shape;
		p5$2.Contour = Contour;
		p5$2.ShapePrimitive = ShapePrimitive;
		p5$2.Vertex = Vertex;
		p5$2.Anchor = Anchor;
		p5$2.Segment = Segment;
		p5$2.LineSegment = LineSegment;
		p5$2.BezierSegment = BezierSegment;
		p5$2.SplineSegment = SplineSegment;
		p5$2.Point = Point;
		p5$2.Line = Line;
		p5$2.Triangle = Triangle;
		p5$2.Quad = Quad;
		p5$2.TriangleFan = TriangleFan;
		p5$2.TriangleStrip = TriangleStrip;
		p5$2.QuadStrip = QuadStrip;
		p5$2.PrimitiveVisitor = PrimitiveVisitor;
		p5$2.PrimitiveToPath2DConverter = PrimitiveToPath2DConverter;
		p5$2.PrimitiveToVerticesConverter = PrimitiveToVerticesConverter;
		p5$2.PointAtLengthGetter = PointAtLengthGetter;
		fn$1.bezierOrder = function(order) {
			return this._renderer.bezierOrder(order);
		};
		fn$1.splineVertex = function(...args) {
			let x$1 = 0, y = 0, z$1 = 0, u$1 = 0, v$1 = 0;
			if (args.length === 2) [x$1, y] = args;
			else if (args.length === 4) [x$1, y, u$1, v$1] = args;
			else if (args.length === 3) [x$1, y, z$1] = args;
			else if (args.length === 5) [x$1, y, z$1, u$1, v$1] = args;
			this._renderer.splineVertex(x$1, y, z$1, u$1, v$1);
		};
		fn$1.splineProperty = function(property, value) {
			return this._renderer.splineProperty(property, value);
		};
		fn$1.splineProperties = function(values) {
			return this._renderer.splineProperties(values);
		};
		fn$1.vertex = function(x$1, y) {
			let z$1, u$1, v$1;
			z$1 = u$1 = v$1 = 0;
			if (arguments.length === 3) z$1 = arguments[2];
			else if (arguments.length === 4) {
				u$1 = arguments[2];
				v$1 = arguments[3];
			} else if (arguments.length === 5) {
				z$1 = arguments[2];
				u$1 = arguments[3];
				v$1 = arguments[4];
			}
			this._renderer.vertex(x$1, y, z$1, u$1, v$1);
		};
		fn$1.beginContour = function(kind) {
			this._renderer.beginContour(kind);
		};
		fn$1.endContour = function(mode = OPEN) {
			this._renderer.endContour(mode);
		};
	}
	if (typeof p5 !== "undefined") customShapes(p5, p5.prototype);
	var States = class {
		#modified = {};
		constructor(initialState) {
			for (const key in initialState) this[key] = initialState[key];
		}
		setValue(key, value) {
			if (!(key in this.#modified)) this.#modified[key] = this[key];
			this[key] = value;
		}
		getDiff() {
			const diff = this.#modified;
			this.#modified = {};
			return diff;
		}
		getModified() {
			return this.#modified;
		}
		applyDiff(prevModified) {
			for (const key in this.#modified) this[key] = this.#modified[key];
			this.#modified = prevModified;
		}
	};
	var import_FileSaver = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports, module) => {
		/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
		var saveAs = saveAs || function(view) {
			if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) return;
			var doc = view.document, get_URL = function() {
				return view.URL || view.webkitURL || view;
			}, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"), can_use_save_link = "download" in save_link, click = function(node) {
				var event = new MouseEvent("click");
				node.dispatchEvent(event);
			}, is_safari = /constructor/i.test(view.HTMLElement) || view.safari, is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent), throw_outside = function(ex) {
				(view.setImmediate || view.setTimeout)(function() {
					throw ex;
				}, 0);
			}, force_saveable_type = "application/octet-stream", arbitrary_revoke_timeout = 1e3 * 40, revoke = function(file$1) {
				var revoker = function() {
					if (typeof file$1 === "string") get_URL().revokeObjectURL(file$1);
					else file$1.remove();
				};
				setTimeout(revoker, arbitrary_revoke_timeout);
			}, dispatch = function(filesaver, event_types, event) {
				event_types = [].concat(event_types);
				var i$1 = event_types.length;
				while (i$1--) {
					var listener = filesaver["on" + event_types[i$1]];
					if (typeof listener === "function") try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}, auto_bom = function(blob) {
				if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) return new Blob([String.fromCharCode(65279), blob], { type: blob.type });
				return blob;
			}, FileSaver = function(blob, name, no_auto_bom) {
				if (!no_auto_bom) blob = auto_bom(blob);
				var filesaver = this, force = blob.type === force_saveable_type, object_url, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}, fs_error = function() {
					if ((is_chrome_ios || force && is_safari) && view.FileReader) {
						var reader = new FileReader();
						reader.onloadend = function() {
							var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, "data:attachment/file;");
							if (!view.open(url, "_blank")) view.location.href = url;
							url = void 0;
							filesaver.readyState = filesaver.DONE;
							dispatch_all();
						};
						reader.readAsDataURL(blob);
						filesaver.readyState = filesaver.INIT;
						return;
					}
					if (!object_url) object_url = get_URL().createObjectURL(blob);
					if (force) view.location.href = object_url;
					else if (!view.open(object_url, "_blank")) view.location.href = object_url;
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				};
				filesaver.readyState = filesaver.INIT;
				if (can_use_save_link) {
					object_url = get_URL().createObjectURL(blob);
					setTimeout(function() {
						save_link.href = object_url;
						save_link.download = name;
						click(save_link);
						dispatch_all();
						revoke(object_url);
						filesaver.readyState = filesaver.DONE;
					});
					return;
				}
				fs_error();
			}, FS_proto = FileSaver.prototype, saveAs$1 = function(blob, name, no_auto_bom) {
				return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
			};
			if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) return function(blob, name, no_auto_bom) {
				name = name || blob.name || "download";
				if (!no_auto_bom) blob = auto_bom(blob);
				return navigator.msSaveOrOpenBlob(blob, name);
			};
			FS_proto.abort = function() {};
			FS_proto.readyState = FS_proto.INIT = 0;
			FS_proto.WRITING = 1;
			FS_proto.DONE = 2;
			FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null;
			return saveAs$1;
		}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || exports.content);
		if (typeof module !== "undefined" && module.exports) module.exports.saveAs = saveAs;
		else if (typeof define !== "undefined" && define !== null && define.amd !== null) define("FileSaver.js", function() {
			return saveAs;
		});
	})))());
	function downloadFile(data$2, fName, extension) {
		const filename = _checkFileExtension(fName, extension)[0];
		let saveData = data$2;
		if (!(saveData instanceof Blob)) saveData = new Blob([data$2]);
		import_FileSaver.saveAs(saveData, filename);
	}
	function _checkFileExtension(filename, extension) {
		if (!extension || extension === true || extension === "true") extension = "";
		if (!filename) filename = "untitled";
		let ext = "";
		if (filename && filename.includes(".")) ext = filename.split(".").pop();
		if (extension) {
			if (ext !== extension) {
				ext = extension;
				filename = `${filename}.${ext}`;
			}
		}
		return [filename, ext];
	}
	var Image = class Image {
		constructor(width, height) {
			this.width = width;
			this.height = height;
			this.canvas = document.createElement("canvas");
			this.canvas.width = this.width;
			this.canvas.height = this.height;
			this.drawingContext = this.canvas.getContext("2d");
			this._pixelsState = this;
			this._pixelDensity = 1;
			this.gifProperties = null;
			this._modified = false;
			this.pixels = [];
		}
		pixelDensity(density) {
			if (typeof density !== "undefined") {
				if (density <= 0) density = 1;
				this._pixelDensity = density;
				this.width /= density;
				this.height /= density;
				return this;
			} else return this._pixelDensity;
		}
		_animateGif(pInst) {
			const props = this.gifProperties;
			const curTime = pInst._lastRealFrameTime || window.performance.now();
			if (props.lastChangeTime === 0) props.lastChangeTime = curTime;
			if (props.playing) {
				props.timeDisplayed = curTime - props.lastChangeTime;
				const curDelay = props.frames[props.displayIndex].delay;
				if (props.timeDisplayed >= curDelay) {
					const skips = Math.floor(props.timeDisplayed / curDelay);
					props.timeDisplayed = 0;
					props.lastChangeTime = curTime;
					props.displayIndex += skips;
					props.loopCount = Math.floor(props.displayIndex / props.numFrames);
					if (props.loopLimit !== null && props.loopCount >= props.loopLimit) props.playing = false;
					else {
						const ind = props.displayIndex % props.numFrames;
						this.drawingContext.putImageData(props.frames[ind].image, 0, 0);
						props.displayIndex = ind;
						this.setModified(true);
					}
				}
			}
		}
		loadPixels() {
			const pixelsState = this._pixelsState;
			const pd = this._pixelDensity;
			const w = this.width * pd;
			const h = this.height * pd;
			const imageData = this.drawingContext.getImageData(0, 0, w, h);
			pixelsState.imageData = imageData;
			this.pixels = pixelsState.pixels = imageData.data;
			this.setModified(true);
		}
		updatePixels(x$1, y, w, h) {
			const pixelsState = this._pixelsState;
			const pd = this._pixelDensity;
			if (x$1 === void 0 && y === void 0 && w === void 0 && h === void 0) {
				x$1 = 0;
				y = 0;
				w = this.width;
				h = this.height;
			}
			x$1 *= pd;
			y *= pd;
			w *= pd;
			h *= pd;
			if (this.gifProperties) this.gifProperties.frames[this.gifProperties.displayIndex].image = pixelsState.imageData;
			this.drawingContext.putImageData(pixelsState.imageData, x$1, y, 0, 0, w, h);
			this.setModified(true);
		}
		get(x$1, y, w, h) {
			const pixelsState = this._pixelsState;
			const pd = this._pixelDensity;
			const canvas$1 = this.canvas;
			if (typeof x$1 === "undefined" && typeof y === "undefined") {
				x$1 = y = 0;
				w = pixelsState.width;
				h = pixelsState.height;
			} else {
				x$1 *= pd;
				y *= pd;
				if (typeof w === "undefined" && typeof h === "undefined") {
					if (x$1 < 0 || y < 0 || x$1 >= canvas$1.width || y >= canvas$1.height) return [
						0,
						0,
						0,
						0
					];
					return this._getPixel(x$1, y);
				}
			}
			const region = new Image(w * pd, h * pd);
			region.pixelDensity(pd);
			region.canvas.getContext("2d").drawImage(canvas$1, x$1, y, w * pd, h * pd, 0, 0, w * pd, h * pd);
			return region;
		}
		_getPixel(x$1, y) {
			let imageData, index;
			imageData = this.drawingContext.getImageData(x$1, y, 1, 1).data;
			index = 0;
			return [
				imageData[index + 0],
				imageData[index + 1],
				imageData[index + 2],
				imageData[index + 3]
			];
		}
		set(x$1, y, imgOrCol) {
			x$1 = Math.floor(x$1);
			y = Math.floor(y);
			const pixelsState = this._pixelsState;
			if (imgOrCol instanceof Image) {
				this.drawingContext.save();
				this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
				this.drawingContext.scale(this._pixelDensity, this._pixelDensity);
				this.drawingContext.clearRect(x$1, y, imgOrCol.width, imgOrCol.height);
				this.drawingContext.drawImage(imgOrCol.canvas, x$1, y);
				this.drawingContext.restore();
			} else {
				let r = 0, g$1 = 0, b$1 = 0, a = 0;
				let idx = 4 * (y * this._pixelDensity * (this.width * this._pixelDensity) + x$1 * this._pixelDensity);
				if (!pixelsState.imageData) pixelsState.loadPixels();
				if (typeof imgOrCol === "number") {
					if (idx < pixelsState.pixels.length) {
						r = imgOrCol;
						g$1 = imgOrCol;
						b$1 = imgOrCol;
						a = 255;
					}
				} else if (Array.isArray(imgOrCol)) {
					if (imgOrCol.length < 4) throw new Error("pixel array must be of the form [R, G, B, A]");
					if (idx < pixelsState.pixels.length) {
						r = imgOrCol[0];
						g$1 = imgOrCol[1];
						b$1 = imgOrCol[2];
						a = imgOrCol[3];
					}
				} else if (imgOrCol instanceof p5.Color) {
					if (idx < pixelsState.pixels.length) [r, g$1, b$1, a] = imgOrCol._getRGBA([
						255,
						255,
						255,
						255
					]);
				}
				for (let i$1 = 0; i$1 < this._pixelDensity; i$1++) for (let j = 0; j < this._pixelDensity; j++) {
					idx = 4 * ((y * this._pixelDensity + j) * this.width * this._pixelDensity + (x$1 * this._pixelDensity + i$1));
					pixelsState.pixels[idx] = r;
					pixelsState.pixels[idx + 1] = g$1;
					pixelsState.pixels[idx + 2] = b$1;
					pixelsState.pixels[idx + 3] = a;
				}
			}
			this.setModified(true);
		}
		resize(width, height) {
			if (width === 0 && height === 0) {
				width = this.canvas.width;
				height = this.canvas.height;
			} else if (width === 0) width = this.canvas.width * height / this.canvas.height;
			else if (height === 0) height = this.canvas.height * width / this.canvas.width;
			width = Math.floor(width);
			height = Math.floor(height);
			const tempCanvas = document.createElement("canvas");
			tempCanvas.width = width;
			tempCanvas.height = height;
			if (this.gifProperties) {
				const props = this.gifProperties;
				const nearestNeighbor = (src, dst) => {
					let pos = 0;
					for (let y = 0; y < dst.height; y++) for (let x$1 = 0; x$1 < dst.width; x$1++) {
						const srcX = Math.floor(x$1 * src.width / dst.width);
						let srcPos = (Math.floor(y * src.height / dst.height) * src.width + srcX) * 4;
						dst.data[pos++] = src.data[srcPos++];
						dst.data[pos++] = src.data[srcPos++];
						dst.data[pos++] = src.data[srcPos++];
						dst.data[pos++] = src.data[srcPos++];
					}
				};
				for (let i$1 = 0; i$1 < props.numFrames; i$1++) {
					const resizedImageData = this.drawingContext.createImageData(width, height);
					nearestNeighbor(props.frames[i$1].image, resizedImageData);
					props.frames[i$1].image = resizedImageData;
				}
			}
			tempCanvas.getContext("2d").drawImage(this.canvas, 0, 0, this.canvas.width, this.canvas.height, 0, 0, tempCanvas.width, tempCanvas.height);
			this.canvas.width = this.width = width;
			this.canvas.height = this.height = height;
			this.drawingContext.drawImage(tempCanvas, 0, 0, width, height, 0, 0, width, height);
			if (this.pixels.length > 0) this.loadPixels();
			this.setModified(true);
		}
		copy(...args) {
			let srcImage, sx, sy, sw, sh, dx, dy, dw, dh;
			if (args.length === 9) {
				srcImage = args[0];
				sx = args[1];
				sy = args[2];
				sw = args[3];
				sh = args[4];
				dx = args[5];
				dy = args[6];
				dw = args[7];
				dh = args[8];
			} else if (args.length === 8) {
				srcImage = this;
				sx = args[0];
				sy = args[1];
				sw = args[2];
				sh = args[3];
				dx = args[4];
				dy = args[5];
				dw = args[6];
				dh = args[7];
			} else throw new Error("Signature not supported");
			this._copyHelper(this, srcImage, sx, sy, sw, sh, dx, dy, dw, dh);
		}
		_copyHelper(dstImage, srcImage, sx, sy, sw, sh, dx, dy, dw, dh) {
			const s = srcImage.canvas.width / srcImage.width;
			let sxMod = 0;
			let syMod = 0;
			if (srcImage._renderer && srcImage._renderer.isP3D) {
				sxMod = srcImage.width / 2;
				syMod = srcImage.height / 2;
			}
			if (dstImage._renderer && dstImage._renderer.isP3D) {
				dstImage.push();
				dstImage.resetMatrix();
				dstImage.noLights();
				dstImage.blendMode(dstImage.BLEND);
				dstImage.imageMode(dstImage.CORNER);
				dstImage._renderer.image(srcImage, sx + sxMod, sy + syMod, sw, sh, dx, dy, dw, dh);
				dstImage.pop();
			} else dstImage.drawingContext.drawImage(srcImage.canvas, s * (sx + sxMod), s * (sy + syMod), s * sw, s * sh, dx, dy, dw, dh);
		}
		mask(p5Image) {
			if (p5Image === void 0) p5Image = this;
			const currBlend = this.drawingContext.globalCompositeOperation;
			let imgScaleFactor = this._pixelDensity;
			let maskScaleFactor = 1;
			if (p5Image instanceof Renderer) maskScaleFactor = p5Image._pInst._renderer._pixelDensity;
			const copyArgs = [
				p5Image,
				0,
				0,
				maskScaleFactor * p5Image.width,
				maskScaleFactor * p5Image.height,
				0,
				0,
				imgScaleFactor * this.width,
				imgScaleFactor * this.height
			];
			this.drawingContext.globalCompositeOperation = "destination-in";
			if (this.gifProperties) {
				for (let i$1 = 0; i$1 < this.gifProperties.frames.length; i$1++) {
					this.drawingContext.putImageData(this.gifProperties.frames[i$1].image, 0, 0);
					this.copy(...copyArgs);
					this.gifProperties.frames[i$1].image = this.drawingContext.getImageData(0, 0, imgScaleFactor * this.width, imgScaleFactor * this.height);
				}
				this.drawingContext.putImageData(this.gifProperties.frames[this.gifProperties.displayIndex].image, 0, 0);
			} else this.copy(...copyArgs);
			this.drawingContext.globalCompositeOperation = currBlend;
			this.setModified(true);
		}
		filter(operation, value) {
			Filters.apply(this.canvas, Filters[operation], value);
			this.setModified(true);
		}
		blend(...args) {
			const currBlend = this.drawingContext.globalCompositeOperation;
			const blendMode = args[args.length - 1];
			const copyArgs = Array.prototype.slice.call(args, 0, args.length - 1);
			this.drawingContext.globalCompositeOperation = blendMode;
			this.copy(...copyArgs);
			this.drawingContext.globalCompositeOperation = currBlend;
			this.setModified(true);
		}
		setModified(val$1) {
			this._modified = val$1;
		}
		isModified() {
			return this._modified;
		}
		save(filename, extension) {
			if (this.gifProperties) encodeAndDownloadGif(this, filename);
			else {
				let htmlCanvas = this.canvas;
				extension = extension || _checkFileExtension(filename, extension)[1] || "png";
				let mimeType;
				switch (extension) {
					default:
						mimeType = "image/png";
						break;
					case "webp":
						mimeType = "image/webp";
						break;
					case "jpeg":
					case "jpg":
						mimeType = "image/jpeg";
						break;
				}
				htmlCanvas.toBlob((blob) => {
					downloadFile(blob, filename, extension);
				}, mimeType);
			}
		}
		async toBlob() {
			return new Promise((resolve) => {
				this.canvas.toBlob(resolve);
			});
		}
		reset() {
			if (this.gifProperties) {
				const props = this.gifProperties;
				props.playing = true;
				props.timeSinceStart = 0;
				props.timeDisplayed = 0;
				props.lastChangeTime = 0;
				props.loopCount = 0;
				props.displayIndex = 0;
				this.drawingContext.putImageData(props.frames[0].image, 0, 0);
			}
		}
		getCurrentFrame() {
			if (this.gifProperties) {
				const props = this.gifProperties;
				return props.displayIndex % props.numFrames;
			}
		}
		setFrame(index) {
			if (this.gifProperties) {
				const props = this.gifProperties;
				if (index < props.numFrames && index >= 0) {
					props.timeDisplayed = 0;
					props.lastChangeTime = 0;
					props.displayIndex = index;
					this.drawingContext.putImageData(props.frames[index].image, 0, 0);
				} else console.log("Cannot set GIF to a frame number that is higher than total number of frames or below zero.");
			}
		}
		numFrames() {
			if (this.gifProperties) return this.gifProperties.numFrames;
		}
		play() {
			if (this.gifProperties) this.gifProperties.playing = true;
		}
		pause() {
			if (this.gifProperties) this.gifProperties.playing = false;
		}
		delay(d$1, index) {
			if (this.gifProperties) {
				const props = this.gifProperties;
				if (index < props.numFrames && index >= 0) props.frames[index].delay = d$1;
				else for (const frame of props.frames) frame.delay = d$1;
			}
		}
	};
	function encodeAndDownloadGif(pImg, filename) {
		const props = pImg.gifProperties;
		let loopLimit = props.loopLimit;
		if (loopLimit === 1) loopLimit = null;
		else if (loopLimit === null) loopLimit = 0;
		const buffer = new Uint8Array(pImg.width * pImg.height * props.numFrames);
		const allFramesPixelColors = [];
		const paletteFreqsAndFrames = {};
		for (let i$1 = 0; i$1 < props.numFrames; i$1++) {
			const paletteSet = /* @__PURE__ */ new Set();
			const data$2 = props.frames[i$1].image.data;
			const dataLength = data$2.length;
			const pixelColors = new Uint32Array(pImg.width * pImg.height);
			for (let j = 0, k = 0; j < dataLength; j += 4, k++) {
				const r = data$2[j + 0];
				const g$1 = data$2[j + 1];
				const b$1 = data$2[j + 2];
				const color$2 = r << 16 | g$1 << 8 | b$1 << 0;
				paletteSet.add(color$2);
				pixelColors[k] = color$2;
			}
			const paletteStr = [...paletteSet].sort().toString();
			if (paletteFreqsAndFrames[paletteStr] === void 0) paletteFreqsAndFrames[paletteStr] = {
				freq: 1,
				frames: [i$1]
			};
			else {
				paletteFreqsAndFrames[paletteStr].freq += 1;
				paletteFreqsAndFrames[paletteStr].frames.push(i$1);
			}
			allFramesPixelColors.push(pixelColors);
		}
		let framesUsingGlobalPalette = [];
		const palettesSortedByFreq = Object.keys(paletteFreqsAndFrames).sort(function(a, b$1) {
			return paletteFreqsAndFrames[b$1].freq - paletteFreqsAndFrames[a].freq;
		});
		const globalPalette = palettesSortedByFreq[0].split(",").map((a) => parseInt(a));
		framesUsingGlobalPalette = framesUsingGlobalPalette.concat(paletteFreqsAndFrames[globalPalette].frames);
		const globalPaletteSet = new Set(globalPalette);
		for (let i$1 = 1; i$1 < palettesSortedByFreq.length; i$1++) {
			const difference = palettesSortedByFreq[i$1].split(",").map((a) => parseInt(a)).filter((x$1) => !globalPaletteSet.has(x$1));
			if (globalPalette.length + difference.length <= 256) {
				for (let j = 0; j < difference.length; j++) {
					globalPalette.push(difference[j]);
					globalPaletteSet.add(difference[j]);
				}
				framesUsingGlobalPalette = framesUsingGlobalPalette.concat(paletteFreqsAndFrames[palettesSortedByFreq[i$1]].frames);
			}
		}
		framesUsingGlobalPalette = new Set(framesUsingGlobalPalette);
		const globalIndicesLookup = {};
		for (let i$1 = 0; i$1 < globalPalette.length; i$1++) if (!globalIndicesLookup[globalPalette[i$1]]) globalIndicesLookup[globalPalette[i$1]] = i$1;
		let powof2 = 1;
		while (powof2 < globalPalette.length) powof2 <<= 1;
		globalPalette.length = powof2;
		const opts = {
			loop: loopLimit,
			palette: new Uint32Array(globalPalette)
		};
		const gifWriter = new omggif.GifWriter(buffer, pImg.width, pImg.height, opts);
		let previousFrame = {};
		for (let i$1 = 0; i$1 < props.numFrames; i$1++) {
			const localPaletteRequired = !framesUsingGlobalPalette.has(i$1);
			const palette = localPaletteRequired ? [] : globalPalette;
			const pixelPaletteIndex = new Uint8Array(pImg.width * pImg.height);
			const colorIndicesLookup = {};
			const cannotBeTransparent = /* @__PURE__ */ new Set();
			allFramesPixelColors[i$1].forEach((color$2, k) => {
				if (localPaletteRequired) {
					if (colorIndicesLookup[color$2] === void 0) {
						colorIndicesLookup[color$2] = palette.length;
						palette.push(color$2);
					}
					pixelPaletteIndex[k] = colorIndicesLookup[color$2];
				} else pixelPaletteIndex[k] = globalIndicesLookup[color$2];
				if (i$1 > 0) {
					if (allFramesPixelColors[i$1 - 1][k] !== color$2) cannotBeTransparent.add(color$2);
				}
			});
			const frameOpts = {};
			const canBeTransparent = palette.filter((a) => !cannotBeTransparent.has(a));
			if (canBeTransparent.length > 0) {
				const transparent = canBeTransparent[0];
				const transparentIndex = localPaletteRequired ? colorIndicesLookup[transparent] : globalIndicesLookup[transparent];
				if (i$1 > 0) {
					for (let k = 0; k < allFramesPixelColors[i$1].length; k++) if (allFramesPixelColors[i$1 - 1][k] === allFramesPixelColors[i$1][k]) pixelPaletteIndex[k] = transparentIndex;
					frameOpts.transparent = transparentIndex;
					previousFrame.frameOpts.disposal = 1;
				}
			}
			frameOpts.delay = props.frames[i$1].delay / 10;
			if (localPaletteRequired) {
				let powof2$1 = 1;
				while (powof2$1 < palette.length) powof2$1 <<= 1;
				palette.length = powof2$1;
				frameOpts.palette = new Uint32Array(palette);
			}
			if (i$1 > 0) gifWriter.addFrame(0, 0, pImg.width, pImg.height, previousFrame.pixelPaletteIndex, previousFrame.frameOpts);
			previousFrame = {
				pixelPaletteIndex,
				frameOpts
			};
		}
		previousFrame.frameOpts.disposal = 1;
		gifWriter.addFrame(0, 0, pImg.width, pImg.height, previousFrame.pixelPaletteIndex, previousFrame.frameOpts);
		downloadFile(new Blob([buffer.slice(0, gifWriter.end())], { type: "image/gif" }), filename, "gif");
	}
	function image$2(p5$2, fn$1) {
		p5$2.Image = Image;
	}
	if (typeof p5 !== "undefined") image$2(p5, p5.prototype);
	var ClonableObject = class ClonableObject {
		constructor(obj = {}) {
			for (const key in obj) this[key] = obj[key];
		}
		clone() {
			return new ClonableObject(this);
		}
	};
	var Renderer = class Renderer {
		static states = {
			strokeColor: null,
			strokeSet: false,
			fillColor: null,
			fillSet: false,
			tint: null,
			imageMode: CORNER,
			rectMode: CORNER,
			ellipseMode: CENTER,
			strokeWeight: 1,
			textFont: { family: "sans-serif" },
			textLeading: 15,
			leadingSet: false,
			textSize: 12,
			textAlign: LEFT,
			textBaseline: BASELINE,
			bezierOrder: 3,
			splineProperties: new ClonableObject({
				ends: INCLUDE,
				tightness: 0
			}),
			textWrap: WORD,
			fontStyle: NORMAL,
			fontStretch: NORMAL,
			fontWeight: NORMAL,
			lineHeight: NORMAL,
			fontVariant: NORMAL,
			direction: "inherit"
		};
		constructor(pInst, w, h, isMainCanvas) {
			this._pInst = pInst;
			this._isMainCanvas = isMainCanvas;
			this.pixels = [];
			this._pixelDensity = Math.ceil(window.devicePixelRatio) || 1;
			this.width = w;
			this.height = h;
			this._events = {};
			if (isMainCanvas) this._isMainCanvas = true;
			this.states = new States(Renderer.states);
			this.states.strokeColor = new Color([
				0,
				0,
				0
			]);
			this.states.fillColor = new Color([
				1,
				1,
				1
			]);
			this._pushPopStack = [];
			this._pushPopDepth = 0;
			this._clipping = false;
			this._clipInvert = false;
			this._currentShape = void 0;
		}
		get currentShape() {
			if (!this._currentShape) this._currentShape = new Shape(this.getCommonVertexProperties());
			return this._currentShape;
		}
		remove() {}
		pixelDensity(val$1) {
			let returnValue;
			if (typeof val$1 === "number") {
				if (val$1 !== this._pixelDensity) this._pixelDensity = val$1;
				returnValue = this;
				this.resize(this.width, this.height);
			} else returnValue = this._pixelDensity;
			return returnValue;
		}
		push() {
			this._pushPopDepth++;
			this._pushPopStack.push(this.states.getDiff());
		}
		pop() {
			this._pushPopDepth--;
			const diff = this._pushPopStack.pop() || {};
			const modified = this.states.getModified();
			this.states.applyDiff(diff);
			this.updateShapeVertexProperties(modified);
			this.updateShapeProperties(modified);
		}
		bezierOrder(order) {
			if (order === void 0) return this.states.bezierOrder;
			else {
				this.states.setValue("bezierOrder", order);
				this.updateShapeProperties();
			}
		}
		bezierVertex(x$1, y, z$1 = 0, u$1 = 0, v$1 = 0) {
			const position = new Vector(x$1, y, z$1);
			const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates ? new Vector(u$1, v$1) : void 0;
			this.currentShape.bezierVertex(position, textureCoordinates);
		}
		splineProperty(key, value) {
			if (value === void 0) return this.states.splineProperties[key];
			else {
				this.states.setValue("splineProperties", this.states.splineProperties.clone());
				this.states.splineProperties[key] = value;
			}
			this.updateShapeProperties();
		}
		splineProperties(values) {
			if (values) for (const key in values) this.splineProperty(key, values[key]);
			else return { ...this.states.splineProperties };
		}
		splineVertex(x$1, y, z$1 = 0, u$1 = 0, v$1 = 0) {
			const position = new Vector(x$1, y, z$1);
			const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates ? new Vector(u$1, v$1) : void 0;
			this.currentShape.splineVertex(position, textureCoordinates);
		}
		curveDetail(d$1) {
			if (d$1 === void 0) return this.states.curveDetail;
			else this.states.setValue("curveDetail", d$1);
		}
		beginShape(...args) {
			this.currentShape.reset();
			this.updateShapeVertexProperties();
			this.currentShape.beginShape(...args);
		}
		endShape(...args) {
			this.currentShape.endShape(...args);
			this.drawShape(this.currentShape);
		}
		beginContour(shapeKind) {
			this.currentShape.beginContour(shapeKind);
		}
		endContour(mode) {
			this.currentShape.endContour(mode);
		}
		drawShape(shape$1, count) {
			throw new Error("Unimplemented");
		}
		vertex(x$1, y, z$1 = 0, u$1 = 0, v$1 = 0) {
			const position = new Vector(x$1, y, z$1);
			const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates ? new Vector(u$1, v$1) : void 0;
			this.currentShape.vertex(position, textureCoordinates);
		}
		bezier(x1, y1, x2, y2, x3, y3, x4, y4) {
			const oldOrder = this._pInst.bezierOrder();
			this._pInst.bezierOrder(oldOrder);
			this._pInst.beginShape();
			this._pInst.bezierVertex(x1, y1);
			this._pInst.bezierVertex(x2, y2);
			this._pInst.bezierVertex(x3, y3);
			this._pInst.bezierVertex(x4, y4);
			this._pInst.endShape();
			return this;
		}
		spline(...args) {
			if (args.length === 8) {
				const [x1, y1, x2, y2, x3, y3, x4, y4] = args;
				this._pInst.beginShape();
				this._pInst.splineVertex(x1, y1);
				this._pInst.splineVertex(x2, y2);
				this._pInst.splineVertex(x3, y3);
				this._pInst.splineVertex(x4, y4);
				this._pInst.endShape();
			} else if (args.length === 12) {
				const [x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4] = args;
				this._pInst.beginShape();
				this._pInst.splineVertex(x1, y1, z1);
				this._pInst.splineVertex(x2, y2, z2);
				this._pInst.splineVertex(x3, y3, z3);
				this._pInst.splineVertex(x4, y4, z4);
				this._pInst.endShape();
			}
			return this;
		}
		beginClip(options$1 = {}) {
			if (this._clipping) throw new Error("It looks like you're trying to clip while already in the middle of clipping. Did you forget to endClip()?");
			this._clipping = true;
			this._clipInvert = options$1.invert;
		}
		endClip() {
			if (!this._clipping) throw new Error("It looks like you've called endClip() without beginClip(). Did you forget to call beginClip() first?");
			this._clipping = false;
		}
		resize(w, h) {
			this.width = w;
			this.height = h;
		}
		get(x$1, y, w, h) {
			const pd = this._pixelDensity;
			const canvas$1 = this.canvas;
			if (typeof x$1 === "undefined" && typeof y === "undefined") {
				x$1 = y = 0;
				w = this.width;
				h = this.height;
			} else {
				x$1 *= pd;
				y *= pd;
				if (typeof w === "undefined" && typeof h === "undefined") {
					if (x$1 < 0 || y < 0 || x$1 >= canvas$1.width || y >= canvas$1.height) return [
						0,
						0,
						0,
						0
					];
					return this._getPixel(x$1, y);
				}
			}
			const region = new Image(w * pd, h * pd);
			region.pixelDensity(pd);
			region.canvas.getContext("2d").drawImage(canvas$1, x$1, y, w * pd, h * pd, 0, 0, w * pd, h * pd);
			return region;
		}
		scale(x$1, y) {}
		fill(...args) {
			this.states.setValue("fillSet", true);
			this.states.setValue("fillColor", this._pInst.color(...args));
			this.updateShapeVertexProperties();
		}
		noFill() {
			this.states.setValue("fillColor", null);
		}
		strokeWeight(w) {
			if (w === void 0) return this.states.strokeWeight;
			else this.states.setValue("strokeWeight", w);
		}
		stroke(...args) {
			this.states.setValue("strokeSet", true);
			this.states.setValue("strokeColor", this._pInst.color(...args));
			this.updateShapeVertexProperties();
		}
		noStroke() {
			this.states.setValue("strokeColor", null);
		}
		getCommonVertexProperties() {
			return {};
		}
		getSupportedIndividualVertexProperties() {
			return { textureCoordinates: false };
		}
		updateShapeProperties(modified) {
			if (!modified || modified.bezierOrder || modified.splineProperties) {
				const shape$1 = this.currentShape;
				shape$1.bezierOrder(this.states.bezierOrder);
				shape$1.splineProperty("ends", this.states.splineProperties.ends);
				shape$1.splineProperty("tightness", this.states.splineProperties.tightness);
			}
		}
		updateShapeVertexProperties(modified) {
			const props = this.getCommonVertexProperties();
			if (!modified || Object.keys(modified).some((k) => k in props)) {
				const shape$1 = this.currentShape;
				for (const key in props) shape$1[key](props[key]);
			}
		}
		_applyDefaults() {
			return this;
		}
	};
	function renderer(p5$2, fn$1) {
		p5$2.Renderer = Renderer;
	}
	var MediaElement = class extends Element {
		constructor(elt, pInst) {
			super(elt, pInst);
			const self$1 = this;
			this.elt.crossOrigin = "anonymous";
			this._prevTime = 0;
			this._cueIDCounter = 0;
			this._cues = [];
			this.pixels = [];
			this._pixelsState = this;
			this._pixelDensity = 1;
			this._modified = false;
			this._frameOnCanvas = -1;
			Object.defineProperty(self$1, "src", {
				get() {
					const firstChildSrc = self$1.elt.children[0].src;
					const srcVal = self$1.elt.src === window.location.href ? "" : self$1.elt.src;
					return firstChildSrc === window.location.href ? srcVal : firstChildSrc;
				},
				set(newValue) {
					for (let i$1 = 0; i$1 < self$1.elt.children.length; i$1++) self$1.elt.removeChild(self$1.elt.children[i$1]);
					const source = document.createElement("source");
					source.src = newValue;
					elt.appendChild(source);
					self$1.elt.src = newValue;
					self$1.modified = true;
				}
			});
			self$1._onended = function() {};
			self$1.elt.onended = function() {
				self$1._onended(self$1);
			};
		}
		play() {
			if (this.elt.currentTime === this.elt.duration) this.elt.currentTime = 0;
			let promise;
			if (this.elt.readyState > 1) promise = this.elt.play();
			else {
				this.elt.load();
				promise = this.elt.play();
			}
			if (promise && promise.catch) promise.catch((e$1) => {
				if (e$1.name === "NotAllowedError") if (typeof IS_MINIFIED === "undefined") p5._friendlyAutoplayError(this.src);
				else console.error(e$1);
				else console.error("Media play method encountered an unexpected error", e$1);
			});
			return this;
		}
		stop() {
			this.elt.pause();
			this.elt.currentTime = 0;
			return this;
		}
		pause() {
			this.elt.pause();
			return this;
		}
		loop() {
			this.elt.setAttribute("loop", true);
			this.play();
			return this;
		}
		noLoop() {
			this.elt.removeAttribute("loop");
			return this;
		}
		_setupAutoplayFailDetection() {
			const timeout = setTimeout(() => {
				if (typeof IS_MINIFIED === "undefined") p5._friendlyAutoplayError(this.src);
				else console.error(e);
			}, 500);
			this.elt.addEventListener("play", () => clearTimeout(timeout), {
				passive: true,
				once: true
			});
		}
		autoplay(val$1) {
			const oldVal = this.elt.getAttribute("autoplay");
			this.elt.setAttribute("autoplay", val$1);
			if (val$1 && !oldVal) {
				const setupAutoplayFailDetection = () => this._setupAutoplayFailDetection();
				if (this.elt.readyState === 4) setupAutoplayFailDetection();
				else this.elt.addEventListener("canplay", setupAutoplayFailDetection, {
					passive: true,
					once: true
				});
			}
			return this;
		}
		volume(val$1) {
			if (typeof val$1 === "undefined") return this.elt.volume;
			else this.elt.volume = val$1;
		}
		speed(val$1) {
			if (typeof val$1 === "undefined") return this.presetPlaybackRate || this.elt.playbackRate;
			else if (this.loadedmetadata) this.elt.playbackRate = val$1;
			else this.presetPlaybackRate = val$1;
		}
		time(val$1) {
			if (typeof val$1 === "undefined") return this.elt.currentTime;
			else {
				this.elt.currentTime = val$1;
				return this;
			}
		}
		duration() {
			return this.elt.duration;
		}
		_ensureCanvas() {
			if (!this.canvas) {
				this.canvas = document.createElement("canvas");
				this.drawingContext = this.canvas.getContext("2d");
				this.setModified(true);
			}
			const needsRedraw = this._frameOnCanvas !== this._pInst.frameCount;
			if (this.loadedmetadata && needsRedraw) {
				if (this.canvas.width !== this.elt.width) {
					this.canvas.width = this.elt.width;
					this.canvas.height = this.elt.height;
					this.width = this.canvas.width;
					this.height = this.canvas.height;
				}
				this.drawingContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
				if (this.flipped === true) {
					this.drawingContext.save();
					this.drawingContext.scale(-1, 1);
					this.drawingContext.translate(-this.canvas.width, 0);
				}
				this.drawingContext.drawImage(this.elt, 0, 0, this.canvas.width, this.canvas.height);
				if (this.flipped === true) this.drawingContext.restore();
				this.setModified(true);
				this._frameOnCanvas = this._pInst.frameCount;
			}
		}
		loadPixels(...args) {
			this._ensureCanvas();
			return p5.Renderer2D.prototype.loadPixels.apply(this, args);
		}
		updatePixels(x$1, y, w, h) {
			if (this.loadedmetadata) {
				this._ensureCanvas();
				p5.Renderer2D.prototype.updatePixels.call(this, x$1, y, w, h);
			}
			this.setModified(true);
			return this;
		}
		get(...args) {
			this._ensureCanvas();
			return p5.Renderer2D.prototype.get.apply(this, args);
		}
		_getPixel(...args) {
			this.loadPixels();
			return p5.Renderer2D.prototype._getPixel.apply(this, args);
		}
		set(x$1, y, imgOrCol) {
			if (this.loadedmetadata) {
				this._ensureCanvas();
				p5.Renderer2D.prototype.set.call(this, x$1, y, imgOrCol);
				this.setModified(true);
			}
		}
		copy(...args) {
			this._ensureCanvas();
			p5.prototype.copy.apply(this, args);
		}
		mask(...args) {
			this.loadPixels();
			this.setModified(true);
			p5.Image.prototype.mask.apply(this, args);
		}
		isModified() {
			return this._modified;
		}
		setModified(value) {
			this._modified = value;
		}
		onended(callback) {
			this._onended = callback;
			return this;
		}
		connect(obj) {
			let audioContext, mainOutput;
			if (typeof fn.getAudioContext === "function") {
				audioContext = fn.getAudioContext();
				mainOutput = p5.soundOut.input;
			} else try {
				audioContext = obj.context;
				mainOutput = audioContext.destination;
			} catch (e$1) {
				throw "connect() is meant to be used with Web Audio API or p5.sound.js";
			}
			if (!this.audioSourceNode) {
				this.audioSourceNode = audioContext.createMediaElementSource(this.elt);
				this.audioSourceNode.connect(mainOutput);
			}
			if (obj) if (obj.input) this.audioSourceNode.connect(obj.input);
			else this.audioSourceNode.connect(obj);
			else this.audioSourceNode.connect(mainOutput);
		}
		disconnect() {
			if (this.audioSourceNode) this.audioSourceNode.disconnect();
			else throw "nothing to disconnect";
		}
		showControls() {
			this.elt.style["text-align"] = "inherit";
			this.elt.controls = true;
		}
		hideControls() {
			this.elt.controls = false;
		}
		addCue(time$2, callback, val$1) {
			const id = this._cueIDCounter++;
			const cue = new Cue(callback, time$2, id, val$1);
			this._cues.push(cue);
			if (!this.elt.ontimeupdate) this.elt.ontimeupdate = this._onTimeUpdate.bind(this);
			return id;
		}
		removeCue(id) {
			for (let i$1 = 0; i$1 < this._cues.length; i$1++) if (this._cues[i$1].id === id) {
				console.log(id);
				this._cues.splice(i$1, 1);
			}
			if (this._cues.length === 0) this.elt.ontimeupdate = null;
		}
		clearCues() {
			this._cues = [];
			this.elt.ontimeupdate = null;
		}
		_onTimeUpdate() {
			const playbackTime = this.time();
			for (let i$1 = 0; i$1 < this._cues.length; i$1++) {
				const callbackTime = this._cues[i$1].time;
				const val$1 = this._cues[i$1].val;
				if (this._prevTime < callbackTime && callbackTime <= playbackTime) this._cues[i$1].callback(val$1);
			}
			this._prevTime = playbackTime;
		}
	};
	var Cue = class {
		constructor(callback, time$2, id, val$1) {
			this.callback = callback;
			this.time = time$2;
			this.id = id;
			this.val = val$1;
		}
	};
	function media(p5$2, fn$1) {
		function addElement(elt, pInst, media$1) {
			(pInst._userNode ? pInst._userNode : document.body).appendChild(elt);
			const c = media$1 ? new MediaElement(elt, pInst) : new Element(elt, pInst);
			pInst._elements.push(c);
			return c;
		}
		function createMedia(pInst, type$2, src, callback) {
			const elt = document.createElement(type$2);
			src = src || "";
			if (typeof src === "string") src = [src];
			for (const mediaSource of src) {
				const sourceEl = document.createElement("source");
				sourceEl.setAttribute("src", mediaSource);
				elt.appendChild(sourceEl);
			}
			const mediaEl = addElement(elt, pInst, true);
			mediaEl.loadedmetadata = false;
			elt.addEventListener("loadedmetadata", () => {
				mediaEl.width = elt.videoWidth;
				mediaEl.height = elt.videoHeight;
				if (mediaEl.elt.width === 0) mediaEl.elt.width = elt.videoWidth;
				if (mediaEl.elt.height === 0) mediaEl.elt.height = elt.videoHeight;
				if (mediaEl.presetPlaybackRate) {
					mediaEl.elt.playbackRate = mediaEl.presetPlaybackRate;
					delete mediaEl.presetPlaybackRate;
				}
				mediaEl.loadedmetadata = true;
			});
			if (typeof callback === "function") {
				const callbackHandler = () => {
					callback(mediaEl);
					elt.removeEventListener("canplaythrough", callbackHandler);
				};
				elt.addEventListener("canplaythrough", callbackHandler);
			}
			return mediaEl;
		}
		fn$1.createVideo = function(src, callback) {
			return createMedia(this, "video", src, callback);
		};
		fn$1.createAudio = function(src, callback) {
			return createMedia(this, "audio", src, callback);
		};
		fn$1.VIDEO = "video";
		fn$1.AUDIO = "audio";
		if (navigator.mediaDevices === void 0) navigator.mediaDevices = {};
		if (navigator.mediaDevices.getUserMedia === void 0) navigator.mediaDevices.getUserMedia = function(constraints) {
			const getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
			if (!getUserMedia) return Promise.reject(/* @__PURE__ */ new Error("getUserMedia is not implemented in this browser"));
			return new Promise(function(resolve, reject) {
				getUserMedia.call(navigator, constraints, resolve, reject);
			});
		};
		fn$1.createCapture = function(...args) {
			if (!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)) throw new DOMException("getUserMedia not supported in this browser");
			let useVideo = true;
			let useAudio = true;
			let constraints;
			let callback;
			let flipped = false;
			for (const arg of args) if (arg === fn$1.VIDEO) useAudio = false;
			else if (arg === fn$1.AUDIO) useVideo = false;
			else if (typeof arg === "object") {
				if (arg.flipped !== void 0) {
					flipped = arg.flipped;
					delete arg.flipped;
				}
				constraints = Object.assign({}, constraints, arg);
			} else if (typeof arg === "function") callback = arg;
			const videoConstraints = {
				video: useVideo,
				audio: useAudio
			};
			constraints = Object.assign({}, videoConstraints, constraints);
			const domElement = document.createElement("video");
			domElement.setAttribute("playsinline", "");
			navigator.mediaDevices.getUserMedia(constraints).then(function(stream) {
				try {
					if ("srcObject" in domElement) domElement.srcObject = stream;
					else domElement.src = window.URL.createObjectURL(stream);
				} catch (err$1) {
					domElement.src = stream;
				}
			}).catch((e$1) => {
				if (e$1.name === "NotFoundError") p5$2._friendlyError("No webcam found on this device", "createCapture");
				if (e$1.name === "NotAllowedError") p5$2._friendlyError("Access to the camera was denied", "createCapture");
				console.error(e$1);
			});
			const videoEl = addElement(domElement, this, true);
			videoEl.loadedmetadata = false;
			domElement.addEventListener("loadedmetadata", function() {
				domElement.play();
				if (domElement.width) {
					videoEl.width = domElement.width;
					videoEl.height = domElement.height;
					if (flipped) videoEl.elt.style.transform = "scaleX(-1)";
				} else {
					videoEl.width = videoEl.elt.width = domElement.videoWidth;
					videoEl.height = videoEl.elt.height = domElement.videoHeight;
				}
				videoEl.loadedmetadata = true;
				if (callback) callback(domElement.srcObject);
			});
			videoEl.flipped = flipped;
			return videoEl;
		};
		p5$2.MediaElement = MediaElement;
	}
	if (typeof p5 !== "undefined") media(p5, p5.prototype);
	function modeAdjust(a, b$1, c, d$1, mode) {
		let bbox;
		if (mode === CORNER) bbox = {
			x: a,
			y: b$1,
			w: Math.abs(c),
			h: Math.abs(d$1)
		};
		else if (mode === CORNERS) bbox = {
			x: Math.min(a, c),
			y: Math.min(b$1, d$1),
			w: Math.abs(c - a),
			h: Math.abs(d$1 - b$1)
		};
		else if (mode === RADIUS) {
			c = Math.abs(c);
			d$1 = Math.abs(d$1);
			bbox = {
				x: a - c,
				y: b$1 - d$1,
				w: 2 * c,
				h: 2 * d$1
			};
		} else if (mode === CENTER) {
			c = Math.abs(c);
			d$1 = Math.abs(d$1);
			bbox = {
				x: a - c * .5,
				y: b$1 - d$1 * .5,
				w: c,
				h: d$1
			};
		}
		return bbox;
	}
	var canvas = { modeAdjust };
	function primitives(p5$2, fn$1) {
		fn$1._normalizeArcAngles = (start, stop, width, height, correctForScaling) => {
			const epsilon = 1e-5;
			let separation;
			start = start - TWO_PI * Math.floor(start / TWO_PI);
			stop = stop - TWO_PI * Math.floor(stop / TWO_PI);
			separation = Math.min(Math.abs(start - stop), TWO_PI - Math.abs(start - stop));
			if (correctForScaling) {
				if (start <= HALF_PI) start = Math.atan(width / height * Math.tan(start));
				else if (start > HALF_PI && start <= 3 * HALF_PI) start = Math.atan(width / height * Math.tan(start)) + PI;
				else start = Math.atan(width / height * Math.tan(start)) + TWO_PI;
				if (stop <= HALF_PI) stop = Math.atan(width / height * Math.tan(stop));
				else if (stop > HALF_PI && stop <= 3 * HALF_PI) stop = Math.atan(width / height * Math.tan(stop)) + PI;
				else stop = Math.atan(width / height * Math.tan(stop)) + TWO_PI;
			}
			if (start > stop) stop += TWO_PI;
			return {
				start,
				stop,
				correspondToSamePoint: separation < epsilon
			};
		};
		fn$1.arc = function(x$1, y, w, h, start, stop, mode, detail) {
			if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) return this;
			if (start === stop) return this;
			start = this._toRadians(start);
			stop = this._toRadians(stop);
			const vals = canvas.modeAdjust(x$1, y, w, h, this._renderer.states.ellipseMode);
			const angles = this._normalizeArcAngles(start, stop, vals.w, vals.h, true);
			if (angles.correspondToSamePoint) this._renderer.ellipse([
				vals.x,
				vals.y,
				vals.w,
				vals.h,
				detail
			]);
			else {
				this._renderer.arc(vals.x, vals.y, vals.w, vals.h, angles.start, angles.stop, mode, detail);
				if (this._accessibleOutputs.grid || this._accessibleOutputs.text) this._accsOutput("arc", [
					vals.x,
					vals.y,
					vals.w,
					vals.h,
					angles.start,
					angles.stop,
					mode
				]);
			}
			return this;
		};
		fn$1.ellipse = function(x$1, y, w, h, detailX) {
			return this._renderEllipse(...arguments);
		};
		fn$1.circle = function(...args) {
			const argss = args.slice(0, 2);
			argss.push(args[2], args[2]);
			return this._renderEllipse(...argss);
		};
		fn$1._renderEllipse = function(x$1, y, w, h, detailX) {
			if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) return this;
			if (typeof h === "undefined") h = w;
			const vals = canvas.modeAdjust(x$1, y, w, h, this._renderer.states.ellipseMode);
			this._renderer.ellipse([
				vals.x,
				vals.y,
				vals.w,
				vals.h,
				detailX
			]);
			if (this._accessibleOutputs.grid || this._accessibleOutputs.text) this._accsOutput("ellipse", [
				vals.x,
				vals.y,
				vals.w,
				vals.h
			]);
			return this;
		};
		fn$1.line = function(...args) {
			if (this._renderer.states.strokeColor) this._renderer.line(...args);
			if (this._accessibleOutputs.grid || this._accessibleOutputs.text) this._accsOutput("line", args);
			return this;
		};
		fn$1.point = function(...args) {
			if (this._renderer.states.strokeColor) if (args.length === 1 && args[0] instanceof p5$2.Vector) this._renderer.point.call(this._renderer, args[0].x, args[0].y, args[0].z);
			else {
				this._renderer.point(...args);
				if (this._accessibleOutputs.grid || this._accessibleOutputs.text) this._accsOutput("point", args);
			}
			return this;
		};
		fn$1.quad = function(...args) {
			if (this._renderer.states.strokeColor || this._renderer.states.fillColor) if (this._renderer.isP3D && args.length < 12) this._renderer.quad.call(this._renderer, args[0], args[1], 0, args[2], args[3], 0, args[4], args[5], 0, args[6], args[7], 0, args[8], args[9]);
			else {
				this._renderer.quad(...args);
				if (this._accessibleOutputs.grid || this._accessibleOutputs.text) this._accsOutput("quadrilateral", args);
			}
			return this;
		};
		fn$1.rect = function(...args) {
			return this._renderRect(...args);
		};
		fn$1.square = function(x$1, y, s, tl, tr, br, bl) {
			return this._renderRect.call(this, x$1, y, s, s, tl, tr, br, bl);
		};
		fn$1._renderRect = function() {
			if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {
				if (arguments.length === 3) arguments[3] = arguments[2];
				const vals = canvas.modeAdjust(arguments[0], arguments[1], arguments[2], arguments[3], this._renderer.states.rectMode);
				if (this._renderer.states.rectMode === CORNER) {
					vals.w = arguments[2];
					vals.h = arguments[3];
				}
				const args = [
					vals.x,
					vals.y,
					vals.w,
					vals.h
				];
				for (let i$1 = 4; i$1 < arguments.length; i$1++) args[i$1] = arguments[i$1];
				this._renderer.rect(args);
				if (this._accessibleOutputs.grid || this._accessibleOutputs.text) this._accsOutput("rectangle", [
					vals.x,
					vals.y,
					vals.w,
					vals.h
				]);
			}
			return this;
		};
		fn$1.triangle = function(...args) {
			if (this._renderer.states.strokeColor || this._renderer.states.fillColor) this._renderer.triangle(args);
			if (this._accessibleOutputs.grid || this._accessibleOutputs.text) this._accsOutput("triangle", args);
			return this;
		};
	}
	if (typeof p5 !== "undefined") primitives(p5, p5.prototype);
	function attributes(p5$2, fn$1) {
		fn$1.ellipseMode = function(m) {
			if (m === CORNER || m === CORNERS || m === RADIUS || m === CENTER) this._renderer.states.setValue("ellipseMode", m);
			return this;
		};
		fn$1.noSmooth = function() {
			if (!this._renderer.isP3D) {
				if ("imageSmoothingEnabled" in this.drawingContext) this.drawingContext.imageSmoothingEnabled = false;
			} else this.setAttributes("antialias", false);
			return this;
		};
		fn$1.rectMode = function(m) {
			if (m === CORNER || m === CORNERS || m === RADIUS || m === CENTER) this._renderer.states.setValue("rectMode", m);
			return this;
		};
		fn$1.smooth = function() {
			if (!this._renderer.isP3D) {
				if ("imageSmoothingEnabled" in this.drawingContext) this.drawingContext.imageSmoothingEnabled = true;
			} else this.setAttributes("antialias", true);
			return this;
		};
		fn$1.strokeCap = function(cap) {
			if (cap === ROUND || cap === SQUARE || cap === PROJECT) this._renderer.strokeCap(cap);
			return this;
		};
		fn$1.strokeJoin = function(join$1) {
			if (join$1 === ROUND || join$1 === BEVEL || join$1 === MITER) this._renderer.strokeJoin(join$1);
			return this;
		};
		fn$1.strokeWeight = function(w) {
			this._renderer.strokeWeight(w);
			return this;
		};
	}
	if (typeof p5 !== "undefined") attributes(p5, p5.prototype);
	function curves(p5$2, fn$1) {
		fn$1.bezier = function(...args) {
			if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) return this;
			this._renderer.bezier(...args);
			return this;
		};
		fn$1.bezierPoint = function(a, b$1, c, d$1, t$1) {
			const adjustedT = 1 - t$1;
			return Math.pow(adjustedT, 3) * a + 3 * Math.pow(adjustedT, 2) * t$1 * b$1 + 3 * adjustedT * Math.pow(t$1, 2) * c + Math.pow(t$1, 3) * d$1;
		};
		fn$1.bezierTangent = function(a, b$1, c, d$1, t$1) {
			const adjustedT = 1 - t$1;
			return 3 * d$1 * Math.pow(t$1, 2) - 3 * c * Math.pow(t$1, 2) + 6 * c * adjustedT * t$1 - 6 * b$1 * adjustedT * t$1 + 3 * b$1 * Math.pow(adjustedT, 2) - 3 * a * Math.pow(adjustedT, 2);
		};
		fn$1.spline = function(...args) {
			if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) return this;
			this._renderer.spline(...args);
			return this;
		};
		fn$1.splinePoint = function(a, b$1, c, d$1, t$1) {
			const s = this._renderer.states.splineProperties.tightness, t3 = t$1 * t$1 * t$1, t2 = t$1 * t$1, f1 = (s - 1) / 2 * t3 + (1 - s) * t2 + (s - 1) / 2 * t$1, f2 = (s + 3) / 2 * t3 + (-5 - s) / 2 * t2 + 1, f3 = (-3 - s) / 2 * t3 + (s + 2) * t2 + (1 - s) / 2 * t$1, f4 = (1 - s) / 2 * t3 + (s - 1) / 2 * t2;
			return a * f1 + b$1 * f2 + c * f3 + d$1 * f4;
		};
		fn$1.splineTangent = function(a, b$1, c, d$1, t$1) {
			const s = this._renderer.states.splineProperties.tightness, tt3 = t$1 * t$1 * 3, t2 = t$1 * 2, f1 = (s - 1) / 2 * tt3 + (1 - s) * t2 + (s - 1) / 2, f2 = (s + 3) / 2 * tt3 + (-5 - s) / 2 * t2, f3 = (-3 - s) / 2 * tt3 + (s + 2) * t2 + (1 - s) / 2, f4 = (1 - s) / 2 * tt3 + (s - 1) / 2 * t2;
			return a * f1 + b$1 * f2 + c * f3 + d$1 * f4;
		};
	}
	if (typeof p5 !== "undefined") curves(p5, p5.prototype);
	function vertex(p5$2, fn$1) {
		fn$1.beginShape = function(kind) {
			this._renderer.beginShape(...arguments);
		};
		fn$1.bezierVertex = function(...args) {
			this._renderer.bezierVertex(...args);
		};
		fn$1.endShape = function(mode, count = 1) {
			if (count < 1) {
				console.log("🌸 p5.js says: You can not have less than one instance");
				count = 1;
			}
			this._renderer.endShape(mode, count);
		};
		fn$1.normal = function(x$1, y, z$1) {
			this._assert3d("normal");
			this._renderer.normal(...arguments);
			return this;
		};
		fn$1.vertexProperty = function(attributeName, data$2) {
			this._renderer.vertexProperty(attributeName, data$2);
		};
	}
	if (typeof p5 !== "undefined") vertex(p5, p5.prototype);
	function setting(p5$2, fn$1) {
		fn$1.beginClip = function(options$1 = {}) {
			this._renderer.beginClip(options$1);
		};
		fn$1.endClip = function() {
			this._renderer.endClip();
		};
		fn$1.clip = function(callback, options$1) {
			this._renderer.beginClip(options$1);
			callback();
			this._renderer.endClip(options$1);
		};
		fn$1.background = function(...args) {
			this._renderer.background(...args);
			return this;
		};
		fn$1.clear = function(...args) {
			const _r = args[0] || 0;
			const _g = args[1] || 0;
			const _b = args[2] || 0;
			const _a = args[3] || 0;
			this._renderer.clear(_r, _g, _b, _a);
			return this;
		};
		fn$1.colorMode = function(mode, max1, max2, max3, maxA) {
			if ([
				RGB,
				RGBHDR,
				HSB,
				HSL,
				HWB,
				LAB,
				LCH,
				OKLAB,
				OKLCH
			].includes(mode)) {
				this._renderer.states.setValue("colorMode", mode);
				this._renderer.states.setValue("colorMaxes", this._renderer.states.colorMaxes.clone());
				const maxes = this._renderer.states.colorMaxes[mode];
				if (arguments.length === 2) {
					maxes[0] = max1;
					maxes[1] = max1;
					maxes[2] = max1;
					maxes[3] = max1;
				} else if (arguments.length === 4) {
					maxes[0] = max1;
					maxes[1] = max2;
					maxes[2] = max3;
				} else if (arguments.length === 5) {
					maxes[0] = max1;
					maxes[1] = max2;
					maxes[2] = max3;
					maxes[3] = maxA;
				}
			}
			return this._renderer.states.colorMode;
		};
		fn$1.fill = function(...args) {
			this._renderer.fill(...args);
			return this;
		};
		fn$1.noFill = function() {
			this._renderer.noFill();
			return this;
		};
		fn$1.noStroke = function() {
			this._renderer.states.setValue("strokeColor", null);
			return this;
		};
		fn$1.stroke = function(...args) {
			this._renderer.stroke(...args);
			return this;
		};
		fn$1.erase = function(opacityFill = 255, opacityStroke = 255) {
			this._renderer.erase(opacityFill, opacityStroke);
			return this;
		};
		fn$1.noErase = function() {
			this._renderer.noErase();
			return this;
		};
		fn$1.blendMode = function(mode) {
			if (mode === NORMAL) {
				console.warn("NORMAL has been deprecated for use in blendMode. defaulting to BLEND instead.");
				mode = BLEND;
			}
			this._renderer.blendMode(mode);
		};
	}
	if (typeof p5 !== "undefined") setting(p5, p5.prototype);
	var import_omggif = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports) => {
		function GifWriter(buf, width, height, gopts) {
			var p$1 = 0;
			var gopts = gopts === void 0 ? {} : gopts;
			var loop_count = gopts.loop === void 0 ? null : gopts.loop;
			var global_palette = gopts.palette === void 0 ? null : gopts.palette;
			if (width <= 0 || height <= 0 || width > 65535 || height > 65535) throw new Error("Width/Height invalid.");
			function check_palette_and_num_colors(palette) {
				var num_colors = palette.length;
				if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
				return num_colors;
			}
			buf[p$1++] = 71;
			buf[p$1++] = 73;
			buf[p$1++] = 70;
			buf[p$1++] = 56;
			buf[p$1++] = 57;
			buf[p$1++] = 97;
			var gp_num_colors_pow2 = 0;
			var background = 0;
			if (global_palette !== null) {
				var gp_num_colors = check_palette_and_num_colors(global_palette);
				while (gp_num_colors >>= 1) ++gp_num_colors_pow2;
				gp_num_colors = 1 << gp_num_colors_pow2;
				--gp_num_colors_pow2;
				if (gopts.background !== void 0) {
					background = gopts.background;
					if (background >= gp_num_colors) throw new Error("Background index out of range.");
					if (background === 0) throw new Error("Background index explicitly passed as 0.");
				}
			}
			buf[p$1++] = width & 255;
			buf[p$1++] = width >> 8 & 255;
			buf[p$1++] = height & 255;
			buf[p$1++] = height >> 8 & 255;
			buf[p$1++] = (global_palette !== null ? 128 : 0) | gp_num_colors_pow2;
			buf[p$1++] = background;
			buf[p$1++] = 0;
			if (global_palette !== null) for (var i$1 = 0, il = global_palette.length; i$1 < il; ++i$1) {
				var rgb = global_palette[i$1];
				buf[p$1++] = rgb >> 16 & 255;
				buf[p$1++] = rgb >> 8 & 255;
				buf[p$1++] = rgb & 255;
			}
			if (loop_count !== null) {
				if (loop_count < 0 || loop_count > 65535) throw new Error("Loop count invalid.");
				buf[p$1++] = 33;
				buf[p$1++] = 255;
				buf[p$1++] = 11;
				buf[p$1++] = 78;
				buf[p$1++] = 69;
				buf[p$1++] = 84;
				buf[p$1++] = 83;
				buf[p$1++] = 67;
				buf[p$1++] = 65;
				buf[p$1++] = 80;
				buf[p$1++] = 69;
				buf[p$1++] = 50;
				buf[p$1++] = 46;
				buf[p$1++] = 48;
				buf[p$1++] = 3;
				buf[p$1++] = 1;
				buf[p$1++] = loop_count & 255;
				buf[p$1++] = loop_count >> 8 & 255;
				buf[p$1++] = 0;
			}
			var ended = false;
			this.addFrame = function(x$1, y, w, h, indexed_pixels, opts) {
				if (ended === true) {
					--p$1;
					ended = false;
				}
				opts = opts === void 0 ? {} : opts;
				if (x$1 < 0 || y < 0 || x$1 > 65535 || y > 65535) throw new Error("x/y invalid.");
				if (w <= 0 || h <= 0 || w > 65535 || h > 65535) throw new Error("Width/Height invalid.");
				if (indexed_pixels.length < w * h) throw new Error("Not enough pixels for the frame size.");
				var using_local_palette = true;
				var palette = opts.palette;
				if (palette === void 0 || palette === null) {
					using_local_palette = false;
					palette = global_palette;
				}
				if (palette === void 0 || palette === null) throw new Error("Must supply either a local or global palette.");
				var num_colors = check_palette_and_num_colors(palette);
				var min_code_size = 0;
				while (num_colors >>= 1) ++min_code_size;
				num_colors = 1 << min_code_size;
				var delay = opts.delay === void 0 ? 0 : opts.delay;
				var disposal = opts.disposal === void 0 ? 0 : opts.disposal;
				if (disposal < 0 || disposal > 3) throw new Error("Disposal out of range.");
				var use_transparency = false;
				var transparent_index = 0;
				if (opts.transparent !== void 0 && opts.transparent !== null) {
					use_transparency = true;
					transparent_index = opts.transparent;
					if (transparent_index < 0 || transparent_index >= num_colors) throw new Error("Transparent color index.");
				}
				if (disposal !== 0 || use_transparency || delay !== 0) {
					buf[p$1++] = 33;
					buf[p$1++] = 249;
					buf[p$1++] = 4;
					buf[p$1++] = disposal << 2 | (use_transparency === true ? 1 : 0);
					buf[p$1++] = delay & 255;
					buf[p$1++] = delay >> 8 & 255;
					buf[p$1++] = transparent_index;
					buf[p$1++] = 0;
				}
				buf[p$1++] = 44;
				buf[p$1++] = x$1 & 255;
				buf[p$1++] = x$1 >> 8 & 255;
				buf[p$1++] = y & 255;
				buf[p$1++] = y >> 8 & 255;
				buf[p$1++] = w & 255;
				buf[p$1++] = w >> 8 & 255;
				buf[p$1++] = h & 255;
				buf[p$1++] = h >> 8 & 255;
				buf[p$1++] = using_local_palette === true ? 128 | min_code_size - 1 : 0;
				if (using_local_palette === true) for (var i$2 = 0, il$1 = palette.length; i$2 < il$1; ++i$2) {
					var rgb$1 = palette[i$2];
					buf[p$1++] = rgb$1 >> 16 & 255;
					buf[p$1++] = rgb$1 >> 8 & 255;
					buf[p$1++] = rgb$1 & 255;
				}
				p$1 = GifWriterOutputLZWCodeStream(buf, p$1, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);
				return p$1;
			};
			this.end = function() {
				if (ended === false) {
					buf[p$1++] = 59;
					ended = true;
				}
				return p$1;
			};
			this.getOutputBuffer = function() {
				return buf;
			};
			this.setOutputBuffer = function(v$1) {
				buf = v$1;
			};
			this.getOutputBufferPosition = function() {
				return p$1;
			};
			this.setOutputBufferPosition = function(v$1) {
				p$1 = v$1;
			};
		}
		function GifWriterOutputLZWCodeStream(buf, p$1, min_code_size, index_stream) {
			buf[p$1++] = min_code_size;
			var cur_subblock = p$1++;
			var clear_code = 1 << min_code_size;
			var code_mask = clear_code - 1;
			var eoi_code = clear_code + 1;
			var next_code = eoi_code + 1;
			var cur_code_size = min_code_size + 1;
			var cur_shift = 0;
			var cur = 0;
			function emit_bytes_to_buffer(bit_block_size) {
				while (cur_shift >= bit_block_size) {
					buf[p$1++] = cur & 255;
					cur >>= 8;
					cur_shift -= 8;
					if (p$1 === cur_subblock + 256) {
						buf[cur_subblock] = 255;
						cur_subblock = p$1++;
					}
				}
			}
			function emit_code(c) {
				cur |= c << cur_shift;
				cur_shift += cur_code_size;
				emit_bytes_to_buffer(8);
			}
			var ib_code = index_stream[0] & code_mask;
			var code_table = {};
			emit_code(clear_code);
			for (var i$1 = 1, il = index_stream.length; i$1 < il; ++i$1) {
				var k = index_stream[i$1] & code_mask;
				var cur_key = ib_code << 8 | k;
				var cur_code = code_table[cur_key];
				if (cur_code === void 0) {
					cur |= ib_code << cur_shift;
					cur_shift += cur_code_size;
					while (cur_shift >= 8) {
						buf[p$1++] = cur & 255;
						cur >>= 8;
						cur_shift -= 8;
						if (p$1 === cur_subblock + 256) {
							buf[cur_subblock] = 255;
							cur_subblock = p$1++;
						}
					}
					if (next_code === 4096) {
						emit_code(clear_code);
						next_code = eoi_code + 1;
						cur_code_size = min_code_size + 1;
						code_table = {};
					} else {
						if (next_code >= 1 << cur_code_size) ++cur_code_size;
						code_table[cur_key] = next_code++;
					}
					ib_code = k;
				} else ib_code = cur_code;
			}
			emit_code(ib_code);
			emit_code(eoi_code);
			emit_bytes_to_buffer(1);
			if (cur_subblock + 1 === p$1) buf[cur_subblock] = 0;
			else {
				buf[cur_subblock] = p$1 - cur_subblock - 1;
				buf[p$1++] = 0;
			}
			return p$1;
		}
		function GifReader(buf) {
			var p$1 = 0;
			if (buf[p$1++] !== 71 || buf[p$1++] !== 73 || buf[p$1++] !== 70 || buf[p$1++] !== 56 || (buf[p$1++] + 1 & 253) !== 56 || buf[p$1++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
			var width = buf[p$1++] | buf[p$1++] << 8;
			var height = buf[p$1++] | buf[p$1++] << 8;
			var pf0 = buf[p$1++];
			var global_palette_flag = pf0 >> 7;
			var num_global_colors = 1 << (pf0 & 7) + 1;
			buf[p$1++];
			buf[p$1++];
			var global_palette_offset = null;
			var global_palette_size = null;
			if (global_palette_flag) {
				global_palette_offset = p$1;
				global_palette_size = num_global_colors;
				p$1 += num_global_colors * 3;
			}
			var no_eof = true;
			var frames = [];
			var delay = 0;
			var transparent_index = null;
			var disposal = 0;
			var loop_count = null;
			this.width = width;
			this.height = height;
			while (no_eof && p$1 < buf.length) switch (buf[p$1++]) {
				case 33:
					switch (buf[p$1++]) {
						case 255:
							if (buf[p$1] !== 11 || buf[p$1 + 1] == 78 && buf[p$1 + 2] == 69 && buf[p$1 + 3] == 84 && buf[p$1 + 4] == 83 && buf[p$1 + 5] == 67 && buf[p$1 + 6] == 65 && buf[p$1 + 7] == 80 && buf[p$1 + 8] == 69 && buf[p$1 + 9] == 50 && buf[p$1 + 10] == 46 && buf[p$1 + 11] == 48 && buf[p$1 + 12] == 3 && buf[p$1 + 13] == 1 && buf[p$1 + 16] == 0) {
								p$1 += 14;
								loop_count = buf[p$1++] | buf[p$1++] << 8;
								p$1++;
							} else {
								p$1 += 12;
								while (true) {
									var block_size = buf[p$1++];
									if (!(block_size >= 0)) throw Error("Invalid block size");
									if (block_size === 0) break;
									p$1 += block_size;
								}
							}
							break;
						case 249:
							if (buf[p$1++] !== 4 || buf[p$1 + 4] !== 0) throw new Error("Invalid graphics extension block.");
							var pf1 = buf[p$1++];
							delay = buf[p$1++] | buf[p$1++] << 8;
							transparent_index = buf[p$1++];
							if ((pf1 & 1) === 0) transparent_index = null;
							disposal = pf1 >> 2 & 7;
							p$1++;
							break;
						case 254:
							while (true) {
								var block_size = buf[p$1++];
								if (!(block_size >= 0)) throw Error("Invalid block size");
								if (block_size === 0) break;
								p$1 += block_size;
							}
							break;
						default: throw new Error("Unknown graphic control label: 0x" + buf[p$1 - 1].toString(16));
					}
					break;
				case 44:
					var x$1 = buf[p$1++] | buf[p$1++] << 8;
					var y = buf[p$1++] | buf[p$1++] << 8;
					var w = buf[p$1++] | buf[p$1++] << 8;
					var h = buf[p$1++] | buf[p$1++] << 8;
					var pf2 = buf[p$1++];
					var local_palette_flag = pf2 >> 7;
					var interlace_flag = pf2 >> 6 & 1;
					var num_local_colors = 1 << (pf2 & 7) + 1;
					var palette_offset = global_palette_offset;
					var palette_size = global_palette_size;
					var has_local_palette = false;
					if (local_palette_flag) {
						var has_local_palette = true;
						palette_offset = p$1;
						palette_size = num_local_colors;
						p$1 += num_local_colors * 3;
					}
					var data_offset = p$1;
					p$1++;
					while (true) {
						var block_size = buf[p$1++];
						if (!(block_size >= 0)) throw Error("Invalid block size");
						if (block_size === 0) break;
						p$1 += block_size;
					}
					frames.push({
						x: x$1,
						y,
						width: w,
						height: h,
						has_local_palette,
						palette_offset,
						palette_size,
						data_offset,
						data_length: p$1 - data_offset,
						transparent_index,
						interlaced: !!interlace_flag,
						delay,
						disposal
					});
					break;
				case 59:
					no_eof = false;
					break;
				default: throw new Error("Unknown gif block: 0x" + buf[p$1 - 1].toString(16));
			}
			this.numFrames = function() {
				return frames.length;
			};
			this.loopCount = function() {
				return loop_count;
			};
			this.frameInfo = function(frame_num) {
				if (frame_num < 0 || frame_num >= frames.length) throw new Error("Frame index out of range.");
				return frames[frame_num];
			};
			this.decodeAndBlitFrameBGRA = function(frame_num, pixels$1) {
				var frame = this.frameInfo(frame_num);
				var num_pixels = frame.width * frame.height;
				var index_stream = new Uint8Array(num_pixels);
				GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
				var palette_offset$1 = frame.palette_offset;
				var trans = frame.transparent_index;
				if (trans === null) trans = 256;
				var framewidth = frame.width;
				var framestride = width - framewidth;
				var xleft = framewidth;
				var opbeg = (frame.y * width + frame.x) * 4;
				var opend = ((frame.y + frame.height) * width + frame.x) * 4;
				var op = opbeg;
				var scanstride = framestride * 4;
				if (frame.interlaced === true) scanstride += width * 4 * 7;
				var interlaceskip = 8;
				for (var i$1 = 0, il = index_stream.length; i$1 < il; ++i$1) {
					var index = index_stream[i$1];
					if (xleft === 0) {
						op += scanstride;
						xleft = framewidth;
						if (op >= opend) {
							scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
							op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
							interlaceskip >>= 1;
						}
					}
					if (index === trans) op += 4;
					else {
						var r = buf[palette_offset$1 + index * 3];
						var g$1 = buf[palette_offset$1 + index * 3 + 1];
						var b$1 = buf[palette_offset$1 + index * 3 + 2];
						pixels$1[op++] = b$1;
						pixels$1[op++] = g$1;
						pixels$1[op++] = r;
						pixels$1[op++] = 255;
					}
					--xleft;
				}
			};
			this.decodeAndBlitFrameRGBA = function(frame_num, pixels$1) {
				var frame = this.frameInfo(frame_num);
				var num_pixels = frame.width * frame.height;
				var index_stream = new Uint8Array(num_pixels);
				GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
				var palette_offset$1 = frame.palette_offset;
				var trans = frame.transparent_index;
				if (trans === null) trans = 256;
				var framewidth = frame.width;
				var framestride = width - framewidth;
				var xleft = framewidth;
				var opbeg = (frame.y * width + frame.x) * 4;
				var opend = ((frame.y + frame.height) * width + frame.x) * 4;
				var op = opbeg;
				var scanstride = framestride * 4;
				if (frame.interlaced === true) scanstride += width * 4 * 7;
				var interlaceskip = 8;
				for (var i$1 = 0, il = index_stream.length; i$1 < il; ++i$1) {
					var index = index_stream[i$1];
					if (xleft === 0) {
						op += scanstride;
						xleft = framewidth;
						if (op >= opend) {
							scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
							op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
							interlaceskip >>= 1;
						}
					}
					if (index === trans) op += 4;
					else {
						var r = buf[palette_offset$1 + index * 3];
						var g$1 = buf[palette_offset$1 + index * 3 + 1];
						var b$1 = buf[palette_offset$1 + index * 3 + 2];
						pixels$1[op++] = r;
						pixels$1[op++] = g$1;
						pixels$1[op++] = b$1;
						pixels$1[op++] = 255;
					}
					--xleft;
				}
			};
		}
		function GifReaderLZWOutputIndexStream(code_stream, p$1, output, output_length) {
			var min_code_size = code_stream[p$1++];
			var clear_code = 1 << min_code_size;
			var eoi_code = clear_code + 1;
			var next_code = eoi_code + 1;
			var cur_code_size = min_code_size + 1;
			var code_mask = (1 << cur_code_size) - 1;
			var cur_shift = 0;
			var cur = 0;
			var op = 0;
			var subblock_size = code_stream[p$1++];
			var code_table = new Int32Array(4096);
			var prev_code = null;
			while (true) {
				while (cur_shift < 16) {
					if (subblock_size === 0) break;
					cur |= code_stream[p$1++] << cur_shift;
					cur_shift += 8;
					if (subblock_size === 1) subblock_size = code_stream[p$1++];
					else --subblock_size;
				}
				if (cur_shift < cur_code_size) break;
				var code = cur & code_mask;
				cur >>= cur_code_size;
				cur_shift -= cur_code_size;
				if (code === clear_code) {
					next_code = eoi_code + 1;
					cur_code_size = min_code_size + 1;
					code_mask = (1 << cur_code_size) - 1;
					prev_code = null;
					continue;
				} else if (code === eoi_code) break;
				var chase_code = code < next_code ? code : prev_code;
				var chase_length = 0;
				var chase = chase_code;
				while (chase > clear_code) {
					chase = code_table[chase] >> 8;
					++chase_length;
				}
				var k = chase;
				if (op + chase_length + (chase_code !== code ? 1 : 0) > output_length) {
					console.log("Warning, gif stream longer than expected.");
					return;
				}
				output[op++] = k;
				op += chase_length;
				var b$1 = op;
				if (chase_code !== code) output[op++] = k;
				chase = chase_code;
				while (chase_length--) {
					chase = code_table[chase];
					output[--b$1] = chase & 255;
					chase >>= 8;
				}
				if (prev_code !== null && next_code < 4096) {
					code_table[next_code++] = prev_code << 8 | k;
					if (next_code >= code_mask + 1 && cur_code_size < 12) {
						++cur_code_size;
						code_mask = code_mask << 1 | 1;
					}
				}
				prev_code = code;
			}
			if (op !== output_length) console.log("Warning, gif stream shorter than expected.");
			return output;
		}
		try {
			exports.GifWriter = GifWriter;
			exports.GifReader = GifReader;
		} catch (e$1) {}
	})))());
	function parse$3(csv, options$1, reviver = (v$1) => v$1) {
		const ctx = Object.create(null);
		ctx.options = options$1 || {};
		ctx.reviver = reviver;
		ctx.value = "";
		ctx.entry = [];
		ctx.output = [];
		ctx.col = 1;
		ctx.row = 1;
		ctx.options.delimiter = ctx.options.delimiter === void 0 ? "\"" : options$1.delimiter;
		if (ctx.options.delimiter.length > 1 || ctx.options.delimiter.length === 0) throw Error(`CSVError: delimiter must be one character [${ctx.options.separator}]`);
		ctx.options.separator = ctx.options.separator === void 0 ? "," : options$1.separator;
		if (ctx.options.separator.length > 1 || ctx.options.separator.length === 0) throw Error(`CSVError: separator must be one character [${ctx.options.separator}]`);
		const lexer = new RegExp(`${escapeRegExp(ctx.options.delimiter)}|${escapeRegExp(ctx.options.separator)}|\r\n|\n|\r|[^${escapeRegExp(ctx.options.delimiter)}${escapeRegExp(ctx.options.separator)}\r\n]+`, "y");
		const isNewline = /^(\r\n|\n|\r)$/;
		let matches = [];
		let match = "";
		let state = 0;
		while ((matches = lexer.exec(csv)) !== null) {
			match = matches[0];
			switch (state) {
				case 0:
					switch (true) {
						case match === ctx.options.delimiter:
							state = 3;
							break;
						case match === ctx.options.separator:
							state = 0;
							valueEnd(ctx);
							break;
						case isNewline.test(match):
							state = 0;
							valueEnd(ctx);
							entryEnd(ctx);
							break;
						default:
							ctx.value += match;
							state = 2;
							break;
					}
					break;
				case 2:
					switch (true) {
						case match === ctx.options.separator:
							state = 0;
							valueEnd(ctx);
							break;
						case isNewline.test(match):
							state = 0;
							valueEnd(ctx);
							entryEnd(ctx);
							break;
						default:
							state = 4;
							throw Error(`CSVError: Illegal state [row:${ctx.row}, col:${ctx.col}]`);
					}
					break;
				case 3:
					switch (true) {
						case match === ctx.options.delimiter:
							state = 4;
							break;
						default:
							state = 3;
							ctx.value += match;
							break;
					}
					break;
				case 4:
					switch (true) {
						case match === ctx.options.delimiter:
							state = 3;
							ctx.value += match;
							break;
						case match === ctx.options.separator:
							state = 0;
							valueEnd(ctx);
							break;
						case isNewline.test(match):
							state = 0;
							valueEnd(ctx);
							entryEnd(ctx);
							break;
						default: throw Error(`CSVError: Illegal state [row:${ctx.row}, col:${ctx.col}]`);
					}
					break;
			}
		}
		if (ctx.entry.length !== 0) {
			valueEnd(ctx);
			entryEnd(ctx);
		}
		return ctx.output;
	}
	function stringify(array$1, options$1 = {}, replacer = (v$1) => v$1) {
		const ctx = Object.create(null);
		ctx.options = options$1;
		ctx.options.eof = ctx.options.eof !== void 0 ? ctx.options.eof : true;
		ctx.row = 1;
		ctx.col = 1;
		ctx.output = "";
		ctx.options.delimiter = ctx.options.delimiter === void 0 ? "\"" : options$1.delimiter;
		if (ctx.options.delimiter.length > 1 || ctx.options.delimiter.length === 0) throw Error(`CSVError: delimiter must be one character [${ctx.options.separator}]`);
		ctx.options.separator = ctx.options.separator === void 0 ? "," : options$1.separator;
		if (ctx.options.separator.length > 1 || ctx.options.separator.length === 0) throw Error(`CSVError: separator must be one character [${ctx.options.separator}]`);
		const needsDelimiters = /* @__PURE__ */ new RegExp(`${escapeRegExp(ctx.options.delimiter)}|${escapeRegExp(ctx.options.separator)}|\r\n|\n|\r`);
		array$1.forEach((row, rIdx) => {
			let entry = "";
			ctx.col = 1;
			row.forEach((col, cIdx) => {
				if (typeof col === "string") {
					col = col.replace(new RegExp(ctx.options.delimiter, "g"), `${ctx.options.delimiter}${ctx.options.delimiter}`);
					col = needsDelimiters.test(col) ? `${ctx.options.delimiter}${col}${ctx.options.delimiter}` : col;
				}
				entry += replacer(col, ctx.row, ctx.col);
				if (cIdx !== row.length - 1) entry += ctx.options.separator;
				ctx.col++;
			});
			switch (true) {
				case ctx.options.eof:
				case !ctx.options.eof && rIdx !== array$1.length - 1:
					ctx.output += `${entry}\n`;
					break;
				default:
					ctx.output += `${entry}`;
					break;
			}
			ctx.row++;
		});
		return ctx.output;
	}
	function valueEnd(ctx) {
		const value = ctx.options.typed ? inferType(ctx.value) : ctx.value;
		ctx.entry.push(ctx.reviver(value, ctx.row, ctx.col));
		ctx.value = "";
		ctx.col++;
	}
	function entryEnd(ctx) {
		ctx.output.push(ctx.entry);
		ctx.entry = [];
		ctx.row++;
		ctx.col = 1;
	}
	function inferType(value) {
		const isNumber = /.\./;
		switch (true) {
			case value === "true":
			case value === "false": return value === "true";
			case isNumber.test(value): return parseFloat(value);
			case isFinite(value): return parseInt(value);
			default: return value;
		}
	}
	function escapeRegExp(str) {
		return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
	}
	var import_gifenc = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports) => {
		var __defProp = Object.defineProperty;
		var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
		var __export = (target, all) => {
			for (var name in all) __defProp(target, name, {
				get: all[name],
				enumerable: true
			});
		};
		__markAsModule(exports);
		__export(exports, {
			GIFEncoder: () => GIFEncoder$1,
			applyPalette: () => applyPalette,
			default: () => src_default,
			nearestColor: () => nearestColor,
			nearestColorIndex: () => nearestColorIndex$1,
			nearestColorIndexWithDistance: () => nearestColorIndexWithDistance,
			prequantize: () => prequantize,
			quantize: () => quantize$1,
			snapColorsToPalette: () => snapColorsToPalette
		});
		var constants_default = {
			signature: "GIF",
			version: "89a",
			trailer: 59,
			extensionIntroducer: 33,
			applicationExtensionLabel: 255,
			graphicControlExtensionLabel: 249,
			imageSeparator: 44,
			signatureSize: 3,
			versionSize: 3,
			globalColorTableFlagMask: 128,
			colorResolutionMask: 112,
			sortFlagMask: 8,
			globalColorTableSizeMask: 7,
			applicationIdentifierSize: 8,
			applicationAuthCodeSize: 3,
			disposalMethodMask: 28,
			userInputFlagMask: 2,
			transparentColorFlagMask: 1,
			localColorTableFlagMask: 128,
			interlaceFlagMask: 64,
			idSortFlagMask: 32,
			localColorTableSizeMask: 7
		};
		function createStream(initialCapacity = 256) {
			let cursor = 0;
			let contents = new Uint8Array(initialCapacity);
			return {
				get buffer() {
					return contents.buffer;
				},
				reset() {
					cursor = 0;
				},
				bytesView() {
					return contents.subarray(0, cursor);
				},
				bytes() {
					return contents.slice(0, cursor);
				},
				writeByte(byte) {
					expand(cursor + 1);
					contents[cursor] = byte;
					cursor++;
				},
				writeBytes(data$2, offset = 0, byteLength = data$2.length) {
					expand(cursor + byteLength);
					for (let i$1 = 0; i$1 < byteLength; i$1++) contents[cursor++] = data$2[i$1 + offset];
				},
				writeBytesView(data$2, offset = 0, byteLength = data$2.byteLength) {
					expand(cursor + byteLength);
					contents.set(data$2.subarray(offset, offset + byteLength), cursor);
					cursor += byteLength;
				}
			};
			function expand(newCapacity) {
				var prevCapacity = contents.length;
				if (prevCapacity >= newCapacity) return;
				newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < 1024 * 1024 ? 2 : 1.125) >>> 0);
				if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
				const oldContents = contents;
				contents = new Uint8Array(newCapacity);
				if (cursor > 0) contents.set(oldContents.subarray(0, cursor), 0);
			}
		}
		var BITS = 12;
		var DEFAULT_HSIZE = 5003;
		var MASKS = [
			0,
			1,
			3,
			7,
			15,
			31,
			63,
			127,
			255,
			511,
			1023,
			2047,
			4095,
			8191,
			16383,
			32767,
			65535
		];
		function lzwEncode(width, height, pixels$1, colorDepth, outStream = createStream(512), accum = new Uint8Array(256), htab = new Int32Array(DEFAULT_HSIZE), codetab = new Int32Array(DEFAULT_HSIZE)) {
			const hsize = htab.length;
			const initCodeSize = Math.max(2, colorDepth);
			accum.fill(0);
			codetab.fill(0);
			htab.fill(-1);
			let cur_accum = 0;
			let cur_bits = 0;
			const init_bits = initCodeSize + 1;
			const g_init_bits = init_bits;
			let clear_flg = false;
			let n_bits = g_init_bits;
			let maxcode = (1 << n_bits) - 1;
			const ClearCode = 1 << init_bits - 1;
			const EOFCode = ClearCode + 1;
			let free_ent = ClearCode + 2;
			let a_count = 0;
			let ent = pixels$1[0];
			let hshift = 0;
			for (let fcode = hsize; fcode < 65536; fcode *= 2) ++hshift;
			hshift = 8 - hshift;
			outStream.writeByte(initCodeSize);
			output(ClearCode);
			const length = pixels$1.length;
			for (let idx = 1; idx < length; idx++) next_block: {
				const c = pixels$1[idx];
				const fcode = (c << BITS) + ent;
				let i$1 = c << hshift ^ ent;
				if (htab[i$1] === fcode) {
					ent = codetab[i$1];
					break next_block;
				}
				const disp = i$1 === 0 ? 1 : hsize - i$1;
				while (htab[i$1] >= 0) {
					i$1 -= disp;
					if (i$1 < 0) i$1 += hsize;
					if (htab[i$1] === fcode) {
						ent = codetab[i$1];
						break next_block;
					}
				}
				output(ent);
				ent = c;
				if (free_ent < 1 << BITS) {
					codetab[i$1] = free_ent++;
					htab[i$1] = fcode;
				} else {
					htab.fill(-1);
					free_ent = ClearCode + 2;
					clear_flg = true;
					output(ClearCode);
				}
			}
			output(ent);
			output(EOFCode);
			outStream.writeByte(0);
			return outStream.bytesView();
			function output(code) {
				cur_accum &= MASKS[cur_bits];
				if (cur_bits > 0) cur_accum |= code << cur_bits;
				else cur_accum = code;
				cur_bits += n_bits;
				while (cur_bits >= 8) {
					accum[a_count++] = cur_accum & 255;
					if (a_count >= 254) {
						outStream.writeByte(a_count);
						outStream.writeBytesView(accum, 0, a_count);
						a_count = 0;
					}
					cur_accum >>= 8;
					cur_bits -= 8;
				}
				if (free_ent > maxcode || clear_flg) if (clear_flg) {
					n_bits = g_init_bits;
					maxcode = (1 << n_bits) - 1;
					clear_flg = false;
				} else {
					++n_bits;
					maxcode = n_bits === BITS ? 1 << n_bits : (1 << n_bits) - 1;
				}
				if (code == EOFCode) {
					while (cur_bits > 0) {
						accum[a_count++] = cur_accum & 255;
						if (a_count >= 254) {
							outStream.writeByte(a_count);
							outStream.writeBytesView(accum, 0, a_count);
							a_count = 0;
						}
						cur_accum >>= 8;
						cur_bits -= 8;
					}
					if (a_count > 0) {
						outStream.writeByte(a_count);
						outStream.writeBytesView(accum, 0, a_count);
						a_count = 0;
					}
				}
			}
		}
		var lzwEncode_default = lzwEncode;
		function rgb888_to_rgb565(r, g$1, b$1) {
			return r << 8 & 63488 | g$1 << 2 & 992 | b$1 >> 3;
		}
		function rgba8888_to_rgba4444(r, g$1, b$1, a) {
			return r >> 4 | g$1 & 240 | (b$1 & 240) << 4 | (a & 240) << 8;
		}
		function rgb888_to_rgb444(r, g$1, b$1) {
			return r >> 4 << 8 | g$1 & 240 | b$1 >> 4;
		}
		function clamp(value, min, max) {
			return value < min ? min : value > max ? max : value;
		}
		function sqr(value) {
			return value * value;
		}
		function find_nn(bins, idx, hasAlpha) {
			var nn = 0;
			var err$1 = 1e100;
			const bin1 = bins[idx];
			const n1 = bin1.cnt;
			const wa$1 = bin1.ac;
			const wr = bin1.rc;
			const wg = bin1.gc;
			const wb = bin1.bc;
			for (var i$1 = bin1.fw; i$1 != 0; i$1 = bins[i$1].fw) {
				const bin = bins[i$1];
				const n2 = bin.cnt;
				const nerr2 = n1 * n2 / (n1 + n2);
				if (nerr2 >= err$1) continue;
				var nerr = 0;
				if (hasAlpha) {
					nerr += nerr2 * sqr(bin.ac - wa$1);
					if (nerr >= err$1) continue;
				}
				nerr += nerr2 * sqr(bin.rc - wr);
				if (nerr >= err$1) continue;
				nerr += nerr2 * sqr(bin.gc - wg);
				if (nerr >= err$1) continue;
				nerr += nerr2 * sqr(bin.bc - wb);
				if (nerr >= err$1) continue;
				err$1 = nerr;
				nn = i$1;
			}
			bin1.err = err$1;
			bin1.nn = nn;
		}
		function create_bin() {
			return {
				ac: 0,
				rc: 0,
				gc: 0,
				bc: 0,
				cnt: 0,
				nn: 0,
				fw: 0,
				bk: 0,
				tm: 0,
				mtm: 0,
				err: 0
			};
		}
		function create_bin_list(data$2, format) {
			const bincount = format === "rgb444" ? 4096 : 65536;
			const bins = new Array(bincount);
			const size = data$2.length;
			if (format === "rgba4444") for (let i$1 = 0; i$1 < size; ++i$1) {
				const color$2 = data$2[i$1];
				const a = color$2 >> 24 & 255;
				const b$1 = color$2 >> 16 & 255;
				const g$1 = color$2 >> 8 & 255;
				const r = color$2 & 255;
				const index = rgba8888_to_rgba4444(r, g$1, b$1, a);
				let bin = index in bins ? bins[index] : bins[index] = create_bin();
				bin.rc += r;
				bin.gc += g$1;
				bin.bc += b$1;
				bin.ac += a;
				bin.cnt++;
			}
			else if (format === "rgb444") for (let i$1 = 0; i$1 < size; ++i$1) {
				const color$2 = data$2[i$1];
				const b$1 = color$2 >> 16 & 255;
				const g$1 = color$2 >> 8 & 255;
				const r = color$2 & 255;
				const index = rgb888_to_rgb444(r, g$1, b$1);
				let bin = index in bins ? bins[index] : bins[index] = create_bin();
				bin.rc += r;
				bin.gc += g$1;
				bin.bc += b$1;
				bin.cnt++;
			}
			else for (let i$1 = 0; i$1 < size; ++i$1) {
				const color$2 = data$2[i$1];
				const b$1 = color$2 >> 16 & 255;
				const g$1 = color$2 >> 8 & 255;
				const r = color$2 & 255;
				const index = rgb888_to_rgb565(r, g$1, b$1);
				let bin = index in bins ? bins[index] : bins[index] = create_bin();
				bin.rc += r;
				bin.gc += g$1;
				bin.bc += b$1;
				bin.cnt++;
			}
			return bins;
		}
		function quantize$1(rgba, maxColors, opts = {}) {
			const { format = "rgb565", clearAlpha = true, clearAlphaColor = 0, clearAlphaThreshold = 0, oneBitAlpha = false } = opts;
			if (!rgba || !rgba.buffer) throw new Error("quantize() expected RGBA Uint8Array data");
			if (!(rgba instanceof Uint8Array) && !(rgba instanceof Uint8ClampedArray)) throw new Error("quantize() expected RGBA Uint8Array data");
			const data$2 = new Uint32Array(rgba.buffer);
			let useSqrt = opts.useSqrt !== false;
			const hasAlpha = format === "rgba4444";
			const bins = create_bin_list(data$2, format);
			const bincount = bins.length;
			const bincountMinusOne = bincount - 1;
			const heap = new Uint32Array(bincount + 1);
			var maxbins = 0;
			for (var i$1 = 0; i$1 < bincount; ++i$1) {
				const bin = bins[i$1];
				if (bin != null) {
					var d$1 = 1 / bin.cnt;
					if (hasAlpha) bin.ac *= d$1;
					bin.rc *= d$1;
					bin.gc *= d$1;
					bin.bc *= d$1;
					bins[maxbins++] = bin;
				}
			}
			if (sqr(maxColors) / maxbins < .022) useSqrt = false;
			var i$1 = 0;
			for (; i$1 < maxbins - 1; ++i$1) {
				bins[i$1].fw = i$1 + 1;
				bins[i$1 + 1].bk = i$1;
				if (useSqrt) bins[i$1].cnt = Math.sqrt(bins[i$1].cnt);
			}
			if (useSqrt) bins[i$1].cnt = Math.sqrt(bins[i$1].cnt);
			var h, l, l2;
			for (i$1 = 0; i$1 < maxbins; ++i$1) {
				find_nn(bins, i$1, false);
				var err$1 = bins[i$1].err;
				for (l = ++heap[0]; l > 1; l = l2) {
					l2 = l >> 1;
					if (bins[h = heap[l2]].err <= err$1) break;
					heap[l] = h;
				}
				heap[l] = i$1;
			}
			var extbins = maxbins - maxColors;
			for (i$1 = 0; i$1 < extbins;) {
				var tb;
				for (;;) {
					var b1 = heap[1];
					tb = bins[b1];
					if (tb.tm >= tb.mtm && bins[tb.nn].mtm <= tb.tm) break;
					if (tb.mtm == bincountMinusOne) b1 = heap[1] = heap[heap[0]--];
					else {
						find_nn(bins, b1, false);
						tb.tm = i$1;
					}
					var err$1 = bins[b1].err;
					for (l = 1; (l2 = l + l) <= heap[0]; l = l2) {
						if (l2 < heap[0] && bins[heap[l2]].err > bins[heap[l2 + 1]].err) l2++;
						if (err$1 <= bins[h = heap[l2]].err) break;
						heap[l] = h;
					}
					heap[l] = b1;
				}
				var nb = bins[tb.nn];
				var n1 = tb.cnt;
				var n2 = nb.cnt;
				var d$1 = 1 / (n1 + n2);
				if (hasAlpha) tb.ac = d$1 * (n1 * tb.ac + n2 * nb.ac);
				tb.rc = d$1 * (n1 * tb.rc + n2 * nb.rc);
				tb.gc = d$1 * (n1 * tb.gc + n2 * nb.gc);
				tb.bc = d$1 * (n1 * tb.bc + n2 * nb.bc);
				tb.cnt += nb.cnt;
				tb.mtm = ++i$1;
				bins[nb.bk].fw = nb.fw;
				bins[nb.fw].bk = nb.bk;
				nb.mtm = bincountMinusOne;
			}
			let palette = [];
			var k = 0;
			for (i$1 = 0;; ++k) {
				let r = clamp(Math.round(bins[i$1].rc), 0, 255);
				let g$1 = clamp(Math.round(bins[i$1].gc), 0, 255);
				let b$1 = clamp(Math.round(bins[i$1].bc), 0, 255);
				let a = 255;
				if (hasAlpha) {
					a = clamp(Math.round(bins[i$1].ac), 0, 255);
					if (oneBitAlpha) a = a <= (typeof oneBitAlpha === "number" ? oneBitAlpha : 127) ? 0 : 255;
					if (clearAlpha && a <= clearAlphaThreshold) {
						r = g$1 = b$1 = clearAlphaColor;
						a = 0;
					}
				}
				const color$2 = hasAlpha ? [
					r,
					g$1,
					b$1,
					a
				] : [
					r,
					g$1,
					b$1
				];
				if (!existsInPalette(palette, color$2)) palette.push(color$2);
				if ((i$1 = bins[i$1].fw) == 0) break;
			}
			return palette;
		}
		function existsInPalette(palette, color$2) {
			for (let i$1 = 0; i$1 < palette.length; i$1++) {
				const p$1 = palette[i$1];
				let matchesRGB = p$1[0] === color$2[0] && p$1[1] === color$2[1] && p$1[2] === color$2[2];
				let matchesAlpha = p$1.length >= 4 && color$2.length >= 4 ? p$1[3] === color$2[3] : true;
				if (matchesRGB && matchesAlpha) return true;
			}
			return false;
		}
		function euclideanDistanceSquared(a, b$1) {
			var sum = 0;
			var n$2;
			for (n$2 = 0; n$2 < a.length; n$2++) {
				const dx = a[n$2] - b$1[n$2];
				sum += dx * dx;
			}
			return sum;
		}
		function roundStep(byte, step) {
			return step > 1 ? Math.round(byte / step) * step : byte;
		}
		function prequantize(rgba, { roundRGB = 5, roundAlpha = 10, oneBitAlpha = null } = {}) {
			const data$2 = new Uint32Array(rgba.buffer);
			for (let i$1 = 0; i$1 < data$2.length; i$1++) {
				const color$2 = data$2[i$1];
				let a = color$2 >> 24 & 255;
				let b$1 = color$2 >> 16 & 255;
				let g$1 = color$2 >> 8 & 255;
				let r = color$2 & 255;
				a = roundStep(a, roundAlpha);
				if (oneBitAlpha) a = a <= (typeof oneBitAlpha === "number" ? oneBitAlpha : 127) ? 0 : 255;
				r = roundStep(r, roundRGB);
				g$1 = roundStep(g$1, roundRGB);
				b$1 = roundStep(b$1, roundRGB);
				data$2[i$1] = a << 24 | b$1 << 16 | g$1 << 8 | r << 0;
			}
		}
		function applyPalette(rgba, palette, format = "rgb565") {
			if (!rgba || !rgba.buffer) throw new Error("quantize() expected RGBA Uint8Array data");
			if (!(rgba instanceof Uint8Array) && !(rgba instanceof Uint8ClampedArray)) throw new Error("quantize() expected RGBA Uint8Array data");
			if (palette.length > 256) throw new Error("applyPalette() only works with 256 colors or less");
			const data$2 = new Uint32Array(rgba.buffer);
			const length = data$2.length;
			const bincount = format === "rgb444" ? 4096 : 65536;
			const index = new Uint8Array(length);
			const cache = new Array(bincount);
			if (format === "rgba4444") for (let i$1 = 0; i$1 < length; i$1++) {
				const color$2 = data$2[i$1];
				const a = color$2 >> 24 & 255;
				const b$1 = color$2 >> 16 & 255;
				const g$1 = color$2 >> 8 & 255;
				const r = color$2 & 255;
				const key = rgba8888_to_rgba4444(r, g$1, b$1, a);
				index[i$1] = key in cache ? cache[key] : cache[key] = nearestColorIndexRGBA(r, g$1, b$1, a, palette);
			}
			else {
				const rgb888_to_key = format === "rgb444" ? rgb888_to_rgb444 : rgb888_to_rgb565;
				for (let i$1 = 0; i$1 < length; i$1++) {
					const color$2 = data$2[i$1];
					const b$1 = color$2 >> 16 & 255;
					const g$1 = color$2 >> 8 & 255;
					const r = color$2 & 255;
					const key = rgb888_to_key(r, g$1, b$1);
					index[i$1] = key in cache ? cache[key] : cache[key] = nearestColorIndexRGB(r, g$1, b$1, palette);
				}
			}
			return index;
		}
		function nearestColorIndexRGBA(r, g$1, b$1, a, palette) {
			let k = 0;
			let mindist = 1e100;
			for (let i$1 = 0; i$1 < palette.length; i$1++) {
				const px2 = palette[i$1];
				const a2 = px2[3];
				let curdist = sqr2(a2 - a);
				if (curdist > mindist) continue;
				const r2 = px2[0];
				curdist += sqr2(r2 - r);
				if (curdist > mindist) continue;
				const g2 = px2[1];
				curdist += sqr2(g2 - g$1);
				if (curdist > mindist) continue;
				const b2 = px2[2];
				curdist += sqr2(b2 - b$1);
				if (curdist > mindist) continue;
				mindist = curdist;
				k = i$1;
			}
			return k;
		}
		function nearestColorIndexRGB(r, g$1, b$1, palette) {
			let k = 0;
			let mindist = 1e100;
			for (let i$1 = 0; i$1 < palette.length; i$1++) {
				const px2 = palette[i$1];
				const r2 = px2[0];
				let curdist = sqr2(r2 - r);
				if (curdist > mindist) continue;
				const g2 = px2[1];
				curdist += sqr2(g2 - g$1);
				if (curdist > mindist) continue;
				const b2 = px2[2];
				curdist += sqr2(b2 - b$1);
				if (curdist > mindist) continue;
				mindist = curdist;
				k = i$1;
			}
			return k;
		}
		function snapColorsToPalette(palette, knownColors, threshold = 5) {
			if (!palette.length || !knownColors.length) return;
			const paletteRGB = palette.map((p$1) => p$1.slice(0, 3));
			const thresholdSq = threshold * threshold;
			const dim = palette[0].length;
			for (let i$1 = 0; i$1 < knownColors.length; i$1++) {
				let color$2 = knownColors[i$1];
				if (color$2.length < dim) color$2 = [
					color$2[0],
					color$2[1],
					color$2[2],
					255
				];
				else if (color$2.length > dim) color$2 = color$2.slice(0, 3);
				else color$2 = color$2.slice();
				const r = nearestColorIndexWithDistance(paletteRGB, color$2.slice(0, 3), euclideanDistanceSquared);
				const idx = r[0];
				const distanceSq = r[1];
				if (distanceSq > 0 && distanceSq <= thresholdSq) palette[idx] = color$2;
			}
		}
		function sqr2(a) {
			return a * a;
		}
		function nearestColorIndex$1(colors, pixel, distanceFn = euclideanDistanceSquared) {
			let minDist = Infinity;
			let minDistIndex = -1;
			for (let j = 0; j < colors.length; j++) {
				const paletteColor = colors[j];
				const dist = distanceFn(pixel, paletteColor);
				if (dist < minDist) {
					minDist = dist;
					minDistIndex = j;
				}
			}
			return minDistIndex;
		}
		function nearestColorIndexWithDistance(colors, pixel, distanceFn = euclideanDistanceSquared) {
			let minDist = Infinity;
			let minDistIndex = -1;
			for (let j = 0; j < colors.length; j++) {
				const paletteColor = colors[j];
				const dist = distanceFn(pixel, paletteColor);
				if (dist < minDist) {
					minDist = dist;
					minDistIndex = j;
				}
			}
			return [minDistIndex, minDist];
		}
		function nearestColor(colors, pixel, distanceFn = euclideanDistanceSquared) {
			return colors[nearestColorIndex$1(colors, pixel, distanceFn)];
		}
		function GIFEncoder$1(opt = {}) {
			const { initialCapacity = 4096, auto = true } = opt;
			const stream = createStream(initialCapacity);
			const HSIZE = 5003;
			const accum = new Uint8Array(256);
			const htab = new Int32Array(HSIZE);
			const codetab = new Int32Array(HSIZE);
			let hasInit = false;
			return {
				reset() {
					stream.reset();
					hasInit = false;
				},
				finish() {
					stream.writeByte(constants_default.trailer);
				},
				bytes() {
					return stream.bytes();
				},
				bytesView() {
					return stream.bytesView();
				},
				get buffer() {
					return stream.buffer;
				},
				get stream() {
					return stream;
				},
				writeHeader,
				writeFrame(index, width, height, opts = {}) {
					const { transparent = false, transparentIndex = 0, delay = 0, palette = null, repeat = 0, colorDepth = 8, dispose = -1 } = opts;
					let first = false;
					if (auto) {
						if (!hasInit) {
							first = true;
							writeHeader();
							hasInit = true;
						}
					} else first = Boolean(opts.first);
					width = Math.max(0, Math.floor(width));
					height = Math.max(0, Math.floor(height));
					if (first) {
						if (!palette) throw new Error("First frame must include a { palette } option");
						encodeLogicalScreenDescriptor(stream, width, height, palette, colorDepth);
						encodeColorTable(stream, palette);
						if (repeat >= 0) encodeNetscapeExt(stream, repeat);
					}
					encodeGraphicControlExt(stream, dispose, Math.round(delay / 10), transparent, transparentIndex);
					const useLocalColorTable = Boolean(palette) && !first;
					encodeImageDescriptor(stream, width, height, useLocalColorTable ? palette : null);
					if (useLocalColorTable) encodeColorTable(stream, palette);
					encodePixels(stream, index, width, height, colorDepth, accum, htab, codetab);
				}
			};
			function writeHeader() {
				writeUTFBytes(stream, "GIF89a");
			}
		}
		function encodeGraphicControlExt(stream, dispose, delay, transparent, transparentIndex) {
			stream.writeByte(33);
			stream.writeByte(249);
			stream.writeByte(4);
			if (transparentIndex < 0) {
				transparentIndex = 0;
				transparent = false;
			}
			var transp, disp;
			if (!transparent) {
				transp = 0;
				disp = 0;
			} else {
				transp = 1;
				disp = 2;
			}
			if (dispose >= 0) disp = dispose & 7;
			disp <<= 2;
			stream.writeByte(disp | 0 | transp);
			writeUInt16(stream, delay);
			stream.writeByte(transparentIndex || 0);
			stream.writeByte(0);
		}
		function encodeLogicalScreenDescriptor(stream, width, height, palette, colorDepth = 8) {
			const globalColorTableSize = colorTableSize(palette.length) - 1;
			const fields = colorDepth - 1 << 4 | 128 | globalColorTableSize;
			const backgroundColorIndex = 0;
			const pixelAspectRatio = 0;
			writeUInt16(stream, width);
			writeUInt16(stream, height);
			stream.writeBytes([
				fields,
				backgroundColorIndex,
				pixelAspectRatio
			]);
		}
		function encodeNetscapeExt(stream, repeat) {
			stream.writeByte(33);
			stream.writeByte(255);
			stream.writeByte(11);
			writeUTFBytes(stream, "NETSCAPE2.0");
			stream.writeByte(3);
			stream.writeByte(1);
			writeUInt16(stream, repeat);
			stream.writeByte(0);
		}
		function encodeColorTable(stream, palette) {
			const colorTableLength = 1 << colorTableSize(palette.length);
			for (let i$1 = 0; i$1 < colorTableLength; i$1++) {
				let color$2 = [
					0,
					0,
					0
				];
				if (i$1 < palette.length) color$2 = palette[i$1];
				stream.writeByte(color$2[0]);
				stream.writeByte(color$2[1]);
				stream.writeByte(color$2[2]);
			}
		}
		function encodeImageDescriptor(stream, width, height, localPalette) {
			stream.writeByte(44);
			writeUInt16(stream, 0);
			writeUInt16(stream, 0);
			writeUInt16(stream, width);
			writeUInt16(stream, height);
			if (localPalette) {
				const palSize = colorTableSize(localPalette.length) - 1;
				stream.writeByte(128 | palSize);
			} else stream.writeByte(0);
		}
		function encodePixels(stream, index, width, height, colorDepth = 8, accum, htab, codetab) {
			lzwEncode_default(width, height, index, colorDepth, stream, accum, htab, codetab);
		}
		function writeUInt16(stream, short) {
			stream.writeByte(short & 255);
			stream.writeByte(short >> 8 & 255);
		}
		function writeUTFBytes(stream, text$1) {
			for (var i$1 = 0; i$1 < text$1.length; i$1++) stream.writeByte(text$1.charCodeAt(i$1));
		}
		function colorTableSize(length) {
			return Math.max(Math.ceil(Math.log2(length)), 1);
		}
		var src_default = GIFEncoder$1;
	})))());
	function pixels(p5$2, fn$1) {
		fn$1.blend = function(...args) {
			if (this._renderer) this._renderer.blend(...args);
			else p5$2.Renderer2D.prototype.blend.apply(this, args);
		};
		fn$1.copy = function(...args) {
			let srcImage, sx, sy, sw, sh, dx, dy, dw, dh;
			if (args.length === 9) {
				srcImage = args[0];
				sx = args[1];
				sy = args[2];
				sw = args[3];
				sh = args[4];
				dx = args[5];
				dy = args[6];
				dw = args[7];
				dh = args[8];
			} else if (args.length === 8) {
				srcImage = this;
				sx = args[0];
				sy = args[1];
				sw = args[2];
				sh = args[3];
				dx = args[4];
				dy = args[5];
				dw = args[6];
				dh = args[7];
			} else throw new Error("Signature not supported");
			fn$1._copyHelper(this, srcImage, sx, sy, sw, sh, dx, dy, dw, dh);
		};
		fn$1._copyHelper = (dstImage, srcImage, sx, sy, sw, sh, dx, dy, dw, dh) => {
			const s = srcImage.canvas.width / srcImage.width;
			let sxMod = 0;
			let syMod = 0;
			if (srcImage._renderer && srcImage._renderer.isP3D) {
				sxMod = srcImage.width / 2;
				syMod = srcImage.height / 2;
			}
			if (dstImage._renderer && dstImage._renderer.isP3D) {
				dstImage.push();
				dstImage.resetMatrix();
				dstImage.noLights();
				dstImage.blendMode(dstImage.BLEND);
				dstImage.imageMode(dstImage.CORNER);
				dstImage._renderer.image(srcImage, sx + sxMod, sy + syMod, sw, sh, dx, dy, dw, dh);
				dstImage.pop();
			} else dstImage.drawingContext.drawImage(srcImage.canvas, s * (sx + sxMod), s * (sy + syMod), s * sw, s * sh, dx, dy, dw, dh);
		};
		fn$1.getFilterGraphicsLayer = function() {
			return this._renderer.getFilterGraphicsLayer();
		};
		fn$1.filter = function(...args) {
			let { shader: shader$1, operation, value, useWebGL } = parseFilterArgs(...args);
			if (this._renderer.isP3D && shader$1) {
				this._renderer.filter(shader$1);
				return;
			}
			if (!useWebGL && !this._renderer.isP3D) {
				if (this.canvas !== void 0) Filters.apply(this.canvas, Filters[operation], value);
				else Filters.apply(this.elt, Filters[operation], value);
				return;
			}
			if (!useWebGL && this._renderer.isP3D) console.warn("filter() with useWebGL=false is not supported in WEBGL");
			if (this._renderer.isP3D) this._renderer.filter(operation, value);
			else {
				if (shader$1) this._renderer.filterRenderer.setOperation(operation, value, shader$1);
				else this._renderer.filterRenderer.setOperation(operation, value);
				this._renderer.filterRenderer.applyFilter();
			}
		};
		function parseFilterArgs(...args) {
			let result = {
				shader: void 0,
				operation: void 0,
				value: void 0,
				useWebGL: true
			};
			if (args[0] instanceof p5$2.Shader) {
				result.shader = args[0];
				return result;
			} else result.operation = args[0];
			if (args.length > 1 && typeof args[1] === "number") result.value = args[1];
			if (args[args.length - 1] === false) result.useWebGL = false;
			return result;
		}
		fn$1.get = function(x$1, y, w, h) {
			return this._renderer.get(...arguments);
		};
		fn$1.loadPixels = function(...args) {
			this._renderer.loadPixels();
		};
		fn$1.set = function(x$1, y, imgOrCol) {
			this._renderer.set(x$1, y, imgOrCol);
		};
		fn$1.updatePixels = function(x$1, y, w, h) {
			if (this.pixels.length === 0) return;
			this._renderer.updatePixels(x$1, y, w, h);
		};
	}
	if (typeof p5 !== "undefined") pixels(p5, p5.prototype);
	Array;
	if (typeof Float32Array !== "undefined") Float32Array;
	var MatrixInterface = class MatrixInterface {
		#matrix = null;
		constructor(...args) {
			if (this.constructor === MatrixInterface) throw new Error("Class is of abstract type and can't be instantiated");
			[
				"add",
				"setElement",
				"reset",
				"set",
				"get",
				"copy",
				"clone",
				"diagonal",
				"row",
				"column",
				"transpose",
				"mult",
				"multiplyVec",
				"invert",
				"createSubMatrix3x3",
				"inverseTranspose4x4",
				"apply",
				"scale",
				"rotate4x4",
				"translate",
				"rotateX",
				"rotateY",
				"rotateZ",
				"perspective",
				"ortho",
				"multiplyVec4",
				"multiplyPoint",
				"multiplyAndNormalizePoint",
				"multiplyDirection",
				"multiplyVec3"
			].forEach((method) => {
				if (this[method] === void 0) throw new Error(`${method}() method must be implemented`);
			});
		}
	};
	const isPerfectSquare = (arr$1) => {
		if (Math.sqrt(Array.from(arr$1).length) % 1 !== 0) throw new Error("Array length must be a perfect square.");
		return true;
	};
	let GLMAT_ARRAY_TYPE = Array;
	let isMatrixArray = (x$1) => Array.isArray(x$1);
	if (typeof Float32Array !== "undefined") {
		GLMAT_ARRAY_TYPE = Float32Array;
		isMatrixArray = (x$1) => Array.isArray(x$1) || x$1 instanceof Float32Array;
	}
	var Matrix = class Matrix extends MatrixInterface {
		matrix;
		#sqDimention;
		constructor(...args) {
			super(...args);
			if (isMatrixArray(args[0]) && isPerfectSquare(args[0])) {
				this.#sqDimention = Math.sqrt(Array.from(args[0]).length);
				this.matrix = GLMAT_ARRAY_TYPE.from(args[0]);
			} else if (typeof args[0] === "number") {
				this.#sqDimention = Number(args[0]);
				this.matrix = this.#createIdentityMatrix(args[0]);
			}
			return this;
		}
		get mat3() {
			if (this.#sqDimention === 3) return this.matrix;
			else return;
		}
		get mat4() {
			if (this.#sqDimention === 4) return this.matrix;
			else return;
		}
		add(matrix$1) {
			if (this.matrix.length !== matrix$1.matrix.length) throw new Error("Matrices must be of the same dimension to add.");
			for (let i$1 = 0; i$1 < this.matrix.length; i$1++) this.matrix[i$1] += matrix$1.matrix[i$1];
			return this;
		}
		setElement(index, value) {
			if (index >= 0 && index < this.matrix.length) this.matrix[index] = value;
			return this;
		}
		reset() {
			this.matrix = this.#createIdentityMatrix(this.#sqDimention);
			return this;
		}
		set(inMatrix) {
			let refArray = GLMAT_ARRAY_TYPE.from([...arguments]);
			if (inMatrix instanceof Matrix) refArray = GLMAT_ARRAY_TYPE.from(inMatrix.matrix);
			else if (isMatrixArray(inMatrix)) refArray = GLMAT_ARRAY_TYPE.from(inMatrix);
			if (refArray.length !== this.matrix.length) {
				p5._friendlyError(`Expected same dimensions values but received different ${refArray.length}.`, "p5.Matrix.set");
				return this;
			}
			this.matrix = refArray;
			return this;
		}
		get() {
			return new Matrix(this.matrix);
		}
		copy() {
			return new Matrix(this.matrix);
		}
		clone() {
			return this.copy();
		}
		diagonal() {
			const diagonal = [];
			for (let i$1 = 0; i$1 < this.#sqDimention; i$1++) diagonal.push(this.matrix[i$1 * (this.#sqDimention + 1)]);
			return diagonal;
		}
		row(columnIndex) {
			const columnVector = [];
			for (let i$1 = 0; i$1 < this.#sqDimention; i$1++) columnVector.push(this.matrix[i$1 * this.#sqDimention + columnIndex]);
			return new Vector(...columnVector);
		}
		column(rowIndex) {
			const rowVector = [];
			for (let i$1 = 0; i$1 < this.#sqDimention; i$1++) rowVector.push(this.matrix[rowIndex * this.#sqDimention + i$1]);
			return new Vector(...rowVector);
		}
		transpose(a) {
			if (this.#sqDimention === 4) return this.#transpose4x4(a);
			else if (this.#sqDimention === 3) return this.#transpose3x3(a);
			else return this.#transposeNxN(a);
		}
		mult(multMatrix) {
			let _src;
			if (multMatrix === this || multMatrix === this.matrix) _src = this.copy().matrix;
			else if (multMatrix instanceof Matrix) _src = multMatrix.matrix;
			else if (isMatrixArray(multMatrix) && isPerfectSquare(multMatrix)) _src = multMatrix;
			else if (isPerfectSquare(arguments)) _src = Array.from(arguments);
			if (this.#sqDimention === 4 && _src.length === 16) return this.#mult4x4(_src);
			else if (this.#sqDimention === 3 && _src.length === 9) return this.#mult3x3(_src);
			else return this.#multNxN(_src);
		}
		multiplyVec(multVector, target) {
			if (target === void 0) target = multVector.copy();
			for (let i$1 = 0; i$1 < this.#sqDimention; i$1++) target.values[i$1] = this.row(i$1).dot(multVector);
			return target;
		}
		invert(a) {
			if (this.#sqDimention === 4) return this.#invert4x4(a);
			else if (this.#sqDimention === 3) return this.#invert3x3(a);
			else throw new Error("Invert is not implemented for N>4 at the moment, we are working on it");
		}
		createSubMatrix3x3() {
			if (this.#sqDimention === 4) {
				const result = new Matrix(3);
				result.mat3[0] = this.matrix[0];
				result.mat3[1] = this.matrix[1];
				result.mat3[2] = this.matrix[2];
				result.mat3[3] = this.matrix[4];
				result.mat3[4] = this.matrix[5];
				result.mat3[5] = this.matrix[6];
				result.mat3[6] = this.matrix[8];
				result.mat3[7] = this.matrix[9];
				result.mat3[8] = this.matrix[10];
				return result;
			} else throw new Error("Matrix dimension must be 4 to create a 3x3 submatrix.");
		}
		inverseTranspose4x4({ mat4 }) {
			if (this.#sqDimention !== 3) throw new Error("This function only works with 3×3 matrices.");
			else {
				this.matrix[0] = mat4[0];
				this.matrix[1] = mat4[1];
				this.matrix[2] = mat4[2];
				this.matrix[3] = mat4[4];
				this.matrix[4] = mat4[5];
				this.matrix[5] = mat4[6];
				this.matrix[6] = mat4[8];
				this.matrix[7] = mat4[9];
				this.matrix[8] = mat4[10];
			}
			const inverse = this.invert();
			if (inverse) inverse.transpose(this.matrix);
			else for (let i$1 = 0; i$1 < 9; i$1++) this.matrix[i$1] = 0;
			return this;
		}
		apply(multMatrix) {
			let _src;
			if (multMatrix === this || multMatrix === this.matrix) _src = this.copy().matrix;
			else if (multMatrix instanceof Matrix) _src = multMatrix.matrix;
			else if (isMatrixArray(multMatrix)) _src = multMatrix;
			else if (arguments.length === 16) _src = arguments;
			else return;
			const mat4 = this.matrix;
			const m0 = mat4[0];
			const m4 = mat4[4];
			const m8 = mat4[8];
			const m12 = mat4[12];
			mat4[0] = _src[0] * m0 + _src[1] * m4 + _src[2] * m8 + _src[3] * m12;
			mat4[4] = _src[4] * m0 + _src[5] * m4 + _src[6] * m8 + _src[7] * m12;
			mat4[8] = _src[8] * m0 + _src[9] * m4 + _src[10] * m8 + _src[11] * m12;
			mat4[12] = _src[12] * m0 + _src[13] * m4 + _src[14] * m8 + _src[15] * m12;
			const m1$2 = mat4[1];
			const m5 = mat4[5];
			const m9 = mat4[9];
			const m13 = mat4[13];
			mat4[1] = _src[0] * m1$2 + _src[1] * m5 + _src[2] * m9 + _src[3] * m13;
			mat4[5] = _src[4] * m1$2 + _src[5] * m5 + _src[6] * m9 + _src[7] * m13;
			mat4[9] = _src[8] * m1$2 + _src[9] * m5 + _src[10] * m9 + _src[11] * m13;
			mat4[13] = _src[12] * m1$2 + _src[13] * m5 + _src[14] * m9 + _src[15] * m13;
			const m2$1 = mat4[2];
			const m6 = mat4[6];
			const m10 = mat4[10];
			const m14 = mat4[14];
			mat4[2] = _src[0] * m2$1 + _src[1] * m6 + _src[2] * m10 + _src[3] * m14;
			mat4[6] = _src[4] * m2$1 + _src[5] * m6 + _src[6] * m10 + _src[7] * m14;
			mat4[10] = _src[8] * m2$1 + _src[9] * m6 + _src[10] * m10 + _src[11] * m14;
			mat4[14] = _src[12] * m2$1 + _src[13] * m6 + _src[14] * m10 + _src[15] * m14;
			const m3 = mat4[3];
			const m7 = mat4[7];
			const m11 = mat4[11];
			const m15 = mat4[15];
			mat4[3] = _src[0] * m3 + _src[1] * m7 + _src[2] * m11 + _src[3] * m15;
			mat4[7] = _src[4] * m3 + _src[5] * m7 + _src[6] * m11 + _src[7] * m15;
			mat4[11] = _src[8] * m3 + _src[9] * m7 + _src[10] * m11 + _src[11] * m15;
			mat4[15] = _src[12] * m3 + _src[13] * m7 + _src[14] * m11 + _src[15] * m15;
			return this;
		}
		scale(x$1, y, z$1) {
			if (x$1 instanceof Vector) {
				y = x$1.y;
				z$1 = x$1.z;
				x$1 = x$1.x;
			} else if (x$1 instanceof Array) {
				y = x$1[1];
				z$1 = x$1[2];
				x$1 = x$1[0];
			}
			this.matrix[0] *= x$1;
			this.matrix[1] *= x$1;
			this.matrix[2] *= x$1;
			this.matrix[3] *= x$1;
			this.matrix[4] *= y;
			this.matrix[5] *= y;
			this.matrix[6] *= y;
			this.matrix[7] *= y;
			this.matrix[8] *= z$1;
			this.matrix[9] *= z$1;
			this.matrix[10] *= z$1;
			this.matrix[11] *= z$1;
			return this;
		}
		rotate4x4(a, x$1, y, z$1) {
			if (x$1 instanceof Vector) {
				y = x$1.y;
				z$1 = x$1.z;
				x$1 = x$1.x;
			} else if (x$1 instanceof Array) {
				y = x$1[1];
				z$1 = x$1[2];
				x$1 = x$1[0];
			}
			const len = Math.sqrt(x$1 * x$1 + y * y + z$1 * z$1);
			x$1 *= 1 / len;
			y *= 1 / len;
			z$1 *= 1 / len;
			const a00 = this.matrix[0];
			const a01 = this.matrix[1];
			const a02 = this.matrix[2];
			const a03 = this.matrix[3];
			const a10 = this.matrix[4];
			const a11 = this.matrix[5];
			const a12 = this.matrix[6];
			const a13 = this.matrix[7];
			const a20 = this.matrix[8];
			const a21 = this.matrix[9];
			const a22 = this.matrix[10];
			const a23 = this.matrix[11];
			const sA = Math.sin(a);
			const cA = Math.cos(a);
			const tA = 1 - cA;
			const b00 = x$1 * x$1 * tA + cA;
			const b01 = y * x$1 * tA + z$1 * sA;
			const b02 = z$1 * x$1 * tA - y * sA;
			const b10 = x$1 * y * tA - z$1 * sA;
			const b11 = y * y * tA + cA;
			const b12 = z$1 * y * tA + x$1 * sA;
			const b20 = x$1 * z$1 * tA + y * sA;
			const b21 = y * z$1 * tA - x$1 * sA;
			const b22 = z$1 * z$1 * tA + cA;
			this.matrix[0] = a00 * b00 + a10 * b01 + a20 * b02;
			this.matrix[1] = a01 * b00 + a11 * b01 + a21 * b02;
			this.matrix[2] = a02 * b00 + a12 * b01 + a22 * b02;
			this.matrix[3] = a03 * b00 + a13 * b01 + a23 * b02;
			this.matrix[4] = a00 * b10 + a10 * b11 + a20 * b12;
			this.matrix[5] = a01 * b10 + a11 * b11 + a21 * b12;
			this.matrix[6] = a02 * b10 + a12 * b11 + a22 * b12;
			this.matrix[7] = a03 * b10 + a13 * b11 + a23 * b12;
			this.matrix[8] = a00 * b20 + a10 * b21 + a20 * b22;
			this.matrix[9] = a01 * b20 + a11 * b21 + a21 * b22;
			this.matrix[10] = a02 * b20 + a12 * b21 + a22 * b22;
			this.matrix[11] = a03 * b20 + a13 * b21 + a23 * b22;
			return this;
		}
		translate(v$1) {
			const x$1 = v$1[0], y = v$1[1], z$1 = v$1[2] || 0;
			this.matrix[12] += this.matrix[0] * x$1 + this.matrix[4] * y + this.matrix[8] * z$1;
			this.matrix[13] += this.matrix[1] * x$1 + this.matrix[5] * y + this.matrix[9] * z$1;
			this.matrix[14] += this.matrix[2] * x$1 + this.matrix[6] * y + this.matrix[10] * z$1;
			this.matrix[15] += this.matrix[3] * x$1 + this.matrix[7] * y + this.matrix[11] * z$1;
			return this;
		}
		rotateX(a) {
			this.rotate4x4(a, 1, 0, 0);
		}
		rotateY(a) {
			this.rotate4x4(a, 0, 1, 0);
		}
		rotateZ(a) {
			this.rotate4x4(a, 0, 0, 1);
		}
		perspective(fovy, aspect, near, far) {
			const f = 1 / Math.tan(fovy / 2), nf = 1 / (near - far);
			this.matrix[0] = f / aspect;
			this.matrix[1] = 0;
			this.matrix[2] = 0;
			this.matrix[3] = 0;
			this.matrix[4] = 0;
			this.matrix[5] = f;
			this.matrix[6] = 0;
			this.matrix[7] = 0;
			this.matrix[8] = 0;
			this.matrix[9] = 0;
			this.matrix[10] = (far + near) * nf;
			this.matrix[11] = -1;
			this.matrix[12] = 0;
			this.matrix[13] = 0;
			this.matrix[14] = 2 * far * near * nf;
			this.matrix[15] = 0;
			return this;
		}
		ortho(left, right, bottom, top, near, far) {
			const lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
			this.matrix[0] = -2 * lr;
			this.matrix[1] = 0;
			this.matrix[2] = 0;
			this.matrix[3] = 0;
			this.matrix[4] = 0;
			this.matrix[5] = -2 * bt;
			this.matrix[6] = 0;
			this.matrix[7] = 0;
			this.matrix[8] = 0;
			this.matrix[9] = 0;
			this.matrix[10] = 2 * nf;
			this.matrix[11] = 0;
			this.matrix[12] = (left + right) * lr;
			this.matrix[13] = (top + bottom) * bt;
			this.matrix[14] = (far + near) * nf;
			this.matrix[15] = 1;
			return this;
		}
		multiplyVec4(x$1, y, z$1, w) {
			const result = new Array(4);
			const m = this.matrix;
			result[0] = m[0] * x$1 + m[4] * y + m[8] * z$1 + m[12] * w;
			result[1] = m[1] * x$1 + m[5] * y + m[9] * z$1 + m[13] * w;
			result[2] = m[2] * x$1 + m[6] * y + m[10] * z$1 + m[14] * w;
			result[3] = m[3] * x$1 + m[7] * y + m[11] * z$1 + m[15] * w;
			return result;
		}
		multiplyPoint({ x: x$1, y, z: z$1 }) {
			const array$1 = this.multiplyVec4(x$1, y, z$1, 1);
			return new Vector(array$1[0], array$1[1], array$1[2]);
		}
		multiplyAndNormalizePoint({ x: x$1, y, z: z$1 }) {
			const array$1 = this.multiplyVec4(x$1, y, z$1, 1);
			array$1[0] /= array$1[3];
			array$1[1] /= array$1[3];
			array$1[2] /= array$1[3];
			return new Vector(array$1[0], array$1[1], array$1[2]);
		}
		multiplyDirection({ x: x$1, y, z: z$1 }) {
			const array$1 = this.multiplyVec4(x$1, y, z$1, 0);
			return new Vector(array$1[0], array$1[1], array$1[2]);
		}
		multiplyVec3(multVector, target) {
			if (target === void 0) target = multVector.copy();
			target.x = this.row(0).dot(multVector);
			target.y = this.row(1).dot(multVector);
			target.z = this.row(2).dot(multVector);
			return target;
		}
		#createIdentityMatrix(dimension) {
			if (dimension === 3) return new GLMAT_ARRAY_TYPE([
				1,
				0,
				0,
				0,
				1,
				0,
				0,
				0,
				1
			]);
			if (dimension === 4) return new GLMAT_ARRAY_TYPE([
				1,
				0,
				0,
				0,
				0,
				1,
				0,
				0,
				0,
				0,
				1,
				0,
				0,
				0,
				0,
				1
			]);
			const identityMatrix = new GLMAT_ARRAY_TYPE(dimension * dimension).fill(0);
			for (let i$1 = 0; i$1 < dimension; i$1++) identityMatrix[i$1 * dimension + i$1] = 1;
			return identityMatrix;
		}
		#mult4x4(_src) {
			let b0 = this.matrix[0], b1 = this.matrix[1], b2 = this.matrix[2], b3 = this.matrix[3];
			this.matrix[0] = b0 * _src[0] + b1 * _src[4] + b2 * _src[8] + b3 * _src[12];
			this.matrix[1] = b0 * _src[1] + b1 * _src[5] + b2 * _src[9] + b3 * _src[13];
			this.matrix[2] = b0 * _src[2] + b1 * _src[6] + b2 * _src[10] + b3 * _src[14];
			this.matrix[3] = b0 * _src[3] + b1 * _src[7] + b2 * _src[11] + b3 * _src[15];
			b0 = this.matrix[4];
			b1 = this.matrix[5];
			b2 = this.matrix[6];
			b3 = this.matrix[7];
			this.matrix[4] = b0 * _src[0] + b1 * _src[4] + b2 * _src[8] + b3 * _src[12];
			this.matrix[5] = b0 * _src[1] + b1 * _src[5] + b2 * _src[9] + b3 * _src[13];
			this.matrix[6] = b0 * _src[2] + b1 * _src[6] + b2 * _src[10] + b3 * _src[14];
			this.matrix[7] = b0 * _src[3] + b1 * _src[7] + b2 * _src[11] + b3 * _src[15];
			b0 = this.matrix[8];
			b1 = this.matrix[9];
			b2 = this.matrix[10];
			b3 = this.matrix[11];
			this.matrix[8] = b0 * _src[0] + b1 * _src[4] + b2 * _src[8] + b3 * _src[12];
			this.matrix[9] = b0 * _src[1] + b1 * _src[5] + b2 * _src[9] + b3 * _src[13];
			this.matrix[10] = b0 * _src[2] + b1 * _src[6] + b2 * _src[10] + b3 * _src[14];
			this.matrix[11] = b0 * _src[3] + b1 * _src[7] + b2 * _src[11] + b3 * _src[15];
			b0 = this.matrix[12];
			b1 = this.matrix[13];
			b2 = this.matrix[14];
			b3 = this.matrix[15];
			this.matrix[12] = b0 * _src[0] + b1 * _src[4] + b2 * _src[8] + b3 * _src[12];
			this.matrix[13] = b0 * _src[1] + b1 * _src[5] + b2 * _src[9] + b3 * _src[13];
			this.matrix[14] = b0 * _src[2] + b1 * _src[6] + b2 * _src[10] + b3 * _src[14];
			this.matrix[15] = b0 * _src[3] + b1 * _src[7] + b2 * _src[11] + b3 * _src[15];
			return this;
		}
		#multNxN(multMatrix) {
			if (multMatrix.length !== this.matrix.length) throw new Error("Matrices must be of the same dimension to multiply.");
			const result = new GLMAT_ARRAY_TYPE(this.matrix.length).fill(0);
			for (let i$1 = 0; i$1 < this.#sqDimention; i$1++) for (let j = 0; j < this.#sqDimention; j++) for (let k = 0; k < this.#sqDimention; k++) result[i$1 * this.#sqDimention + j] += this.matrix[i$1 * this.#sqDimention + k] * multMatrix[k * this.#sqDimention + j];
			this.matrix = result;
			return this;
		}
		#mult3x3(_src) {
			let b0 = this.mat3[0];
			let b1 = this.mat3[1];
			let b2 = this.mat3[2];
			this.mat3[0] = b0 * _src[0] + b1 * _src[3] + b2 * _src[6];
			this.mat3[1] = b0 * _src[1] + b1 * _src[4] + b2 * _src[7];
			this.mat3[2] = b0 * _src[2] + b1 * _src[5] + b2 * _src[8];
			b0 = this.mat3[3];
			b1 = this.mat3[4];
			b2 = this.mat3[5];
			this.mat3[3] = b0 * _src[0] + b1 * _src[3] + b2 * _src[6];
			this.mat3[4] = b0 * _src[1] + b1 * _src[4] + b2 * _src[7];
			this.mat3[5] = b0 * _src[2] + b1 * _src[5] + b2 * _src[8];
			b0 = this.mat3[6];
			b1 = this.mat3[7];
			b2 = this.mat3[8];
			this.mat3[6] = b0 * _src[0] + b1 * _src[3] + b2 * _src[6];
			this.mat3[7] = b0 * _src[1] + b1 * _src[4] + b2 * _src[7];
			this.mat3[8] = b0 * _src[2] + b1 * _src[5] + b2 * _src[8];
			return this;
		}
		#transposeNxN() {
			const n$2 = this.#sqDimention;
			for (let i$1 = 0; i$1 < n$2; i$1++) for (let j = 0; j < n$2; j++) this.matrix[i$1 * n$2 + j] = this.matrix[j * n$2 + i$1];
			return this;
		}
		#transpose4x4(a) {
			console.log("====> 4x4");
			let a01, a02, a03, a12, a13, a23;
			if (a instanceof Matrix) {
				a01 = a.matrix[1];
				a02 = a.matrix[2];
				a03 = a.matrix[3];
				a12 = a.matrix[6];
				a13 = a.matrix[7];
				a23 = a.matrix[11];
				this.matrix[0] = a.matrix[0];
				this.matrix[1] = a.matrix[4];
				this.matrix[2] = a.matrix[8];
				this.matrix[3] = a.matrix[12];
				this.matrix[4] = a01;
				this.matrix[5] = a.matrix[5];
				this.matrix[6] = a.matrix[9];
				this.matrix[7] = a.matrix[13];
				this.matrix[8] = a02;
				this.matrix[9] = a12;
				this.matrix[10] = a.matrix[10];
				this.matrix[11] = a.matrix[14];
				this.matrix[12] = a03;
				this.matrix[13] = a13;
				this.matrix[14] = a23;
				this.matrix[15] = a.matrix[15];
			} else if (isMatrixArray(a)) {
				a01 = a[1];
				a02 = a[2];
				a03 = a[3];
				a12 = a[6];
				a13 = a[7];
				a23 = a[11];
				this.matrix[0] = a[0];
				this.matrix[1] = a[4];
				this.matrix[2] = a[8];
				this.matrix[3] = a[12];
				this.matrix[4] = a01;
				this.matrix[5] = a[5];
				this.matrix[6] = a[9];
				this.matrix[7] = a[13];
				this.matrix[8] = a02;
				this.matrix[9] = a12;
				this.matrix[10] = a[10];
				this.matrix[11] = a[14];
				this.matrix[12] = a03;
				this.matrix[13] = a13;
				this.matrix[14] = a23;
				this.matrix[15] = a[15];
			}
			return this;
		}
		#transpose3x3(mat3) {
			if (mat3 === void 0) mat3 = this.mat3;
			const a01 = mat3[1];
			const a02 = mat3[2];
			const a12 = mat3[5];
			this.mat3[0] = mat3[0];
			this.mat3[1] = mat3[3];
			this.mat3[2] = mat3[6];
			this.mat3[3] = a01;
			this.mat3[4] = mat3[4];
			this.mat3[5] = mat3[7];
			this.mat3[6] = a02;
			this.mat3[7] = a12;
			this.mat3[8] = mat3[8];
			return this;
		}
		#invert4x4(a) {
			let a00, a01, a02, a03, a10, a11, a12, a13;
			let a20, a21, a22, a23, a30, a31, a32, a33;
			if (a instanceof Matrix) {
				a00 = a.matrix[0];
				a01 = a.matrix[1];
				a02 = a.matrix[2];
				a03 = a.matrix[3];
				a10 = a.matrix[4];
				a11 = a.matrix[5];
				a12 = a.matrix[6];
				a13 = a.matrix[7];
				a20 = a.matrix[8];
				a21 = a.matrix[9];
				a22 = a.matrix[10];
				a23 = a.matrix[11];
				a30 = a.matrix[12];
				a31 = a.matrix[13];
				a32 = a.matrix[14];
				a33 = a.matrix[15];
			} else if (isMatrixArray(a)) {
				a00 = a[0];
				a01 = a[1];
				a02 = a[2];
				a03 = a[3];
				a10 = a[4];
				a11 = a[5];
				a12 = a[6];
				a13 = a[7];
				a20 = a[8];
				a21 = a[9];
				a22 = a[10];
				a23 = a[11];
				a30 = a[12];
				a31 = a[13];
				a32 = a[14];
				a33 = a[15];
			}
			const b00 = a00 * a11 - a01 * a10;
			const b01 = a00 * a12 - a02 * a10;
			const b02 = a00 * a13 - a03 * a10;
			const b03 = a01 * a12 - a02 * a11;
			const b04 = a01 * a13 - a03 * a11;
			const b05 = a02 * a13 - a03 * a12;
			const b06 = a20 * a31 - a21 * a30;
			const b07 = a20 * a32 - a22 * a30;
			const b08 = a20 * a33 - a23 * a30;
			const b09 = a21 * a32 - a22 * a31;
			const b10 = a21 * a33 - a23 * a31;
			const b11 = a22 * a33 - a23 * a32;
			let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
			if (!det) return null;
			det = 1 / det;
			this.matrix[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
			this.matrix[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
			this.matrix[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
			this.matrix[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
			this.matrix[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
			this.matrix[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
			this.matrix[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
			this.matrix[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
			this.matrix[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
			this.matrix[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
			this.matrix[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
			this.matrix[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
			this.matrix[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
			this.matrix[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
			this.matrix[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
			this.matrix[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
			return this;
		}
		#invert3x3() {
			const a00 = this.mat3[0];
			const a01 = this.mat3[1];
			const a02 = this.mat3[2];
			const a10 = this.mat3[3];
			const a11 = this.mat3[4];
			const a12 = this.mat3[5];
			const a20 = this.mat3[6];
			const a21 = this.mat3[7];
			const a22 = this.mat3[8];
			const b01 = a22 * a11 - a12 * a21;
			const b11 = -a22 * a10 + a12 * a20;
			const b21 = a21 * a10 - a11 * a20;
			let det = a00 * b01 + a01 * b11 + a02 * b21;
			if (!det) return null;
			det = 1 / det;
			this.mat3[0] = b01 * det;
			this.mat3[1] = (-a22 * a01 + a02 * a21) * det;
			this.mat3[2] = (a12 * a01 - a02 * a11) * det;
			this.mat3[3] = b11 * det;
			this.mat3[4] = (a22 * a00 - a02 * a20) * det;
			this.mat3[5] = (-a12 * a00 + a02 * a10) * det;
			this.mat3[6] = b21 * det;
			this.mat3[7] = (-a21 * a00 + a01 * a20) * det;
			this.mat3[8] = (a11 * a00 - a01 * a10) * det;
			return this;
		}
		#determinant4x4() {
			if (this.#sqDimention !== 4) throw new Error("Determinant is only implemented for 4x4 matrices. We are working on it.");
			const d00 = this.matrix[0] * this.matrix[5] - this.matrix[1] * this.matrix[4], d01 = this.matrix[0] * this.matrix[6] - this.matrix[2] * this.matrix[4], d02 = this.matrix[0] * this.matrix[7] - this.matrix[3] * this.matrix[4], d03 = this.matrix[1] * this.matrix[6] - this.matrix[2] * this.matrix[5], d04 = this.matrix[1] * this.matrix[7] - this.matrix[3] * this.matrix[5], d05 = this.matrix[2] * this.matrix[7] - this.matrix[3] * this.matrix[6], d06 = this.matrix[8] * this.matrix[13] - this.matrix[9] * this.matrix[12], d07 = this.matrix[8] * this.matrix[14] - this.matrix[10] * this.matrix[12], d08 = this.matrix[8] * this.matrix[15] - this.matrix[11] * this.matrix[12], d09 = this.matrix[9] * this.matrix[14] - this.matrix[10] * this.matrix[13], d10 = this.matrix[9] * this.matrix[15] - this.matrix[11] * this.matrix[13];
			return d00 * (this.matrix[10] * this.matrix[15] - this.matrix[11] * this.matrix[14]) - d01 * d10 + d02 * d09 + d03 * d08 - d04 * d07 + d05 * d06;
		}
	};
	function matrix(p5$2, fn$1) {
		p5$2.Matrix = Matrix;
	}
	if (typeof p5 !== "undefined") matrix(p5, p5.prototype);
	var DataArray = class {
		constructor(initialLength = 128) {
			this.length = 0;
			this.data = new Float32Array(initialLength);
			this.initialLength = initialLength;
		}
		dataArray() {
			return this.subArray(0, this.length);
		}
		clear() {
			this.length = 0;
		}
		rescale() {
			if (this.length < this.data.length / 2) {
				const targetLength = 1 << Math.ceil(Math.log2(this.length));
				const newData = new Float32Array(targetLength);
				newData.set(this.data.subarray(0, this.length), 0);
				this.data = newData;
			}
		}
		reset() {
			this.clear();
			this.data = new Float32Array(this.initialLength);
		}
		push(...values) {
			this.ensureLength(this.length + values.length);
			this.data.set(values, this.length);
			this.length += values.length;
		}
		slice(from, to$1) {
			return this.data.slice(from, Math.min(to$1, this.length));
		}
		subArray(from, to$1) {
			return this.data.subarray(from, Math.min(to$1, this.length));
		}
		ensureLength(target) {
			while (this.data.length < target) {
				const newData = new Float32Array(this.data.length * 2);
				newData.set(this.data, 0);
				this.data = newData;
			}
		}
	};
	function dataArray(p5$2, fn$1) {
		p5$2.DataArray = DataArray;
	}
	if (typeof p5 !== "undefined") dataArray(p5, p5.prototype);
	var Geometry = class Geometry {
		constructor(detailX, detailY, callback, renderer$1) {
			this.renderer = renderer$1;
			this.vertices = [];
			this.boundingBoxCache = null;
			this.lineVertices = new DataArray();
			this.lineTangentsIn = new DataArray();
			this.lineTangentsOut = new DataArray();
			this.lineSides = new DataArray();
			this.vertexNormals = [];
			this.faces = [];
			this.uvs = [];
			this.edges = [];
			this.vertexColors = [];
			this.vertexStrokeColors = [];
			this.userVertexProperties = {};
			this.lineVertexColors = new DataArray();
			this.detailX = detailX !== void 0 ? detailX : 1;
			this.detailY = detailY !== void 0 ? detailY : 1;
			this.dirtyFlags = {};
			this._hasFillTransparency = void 0;
			this._hasStrokeTransparency = void 0;
			this.gid = `_p5_Geometry_${Geometry.nextId}`;
			Geometry.nextId++;
			if (callback instanceof Function) callback.call(this);
		}
		calculateBoundingBox() {
			if (this.boundingBoxCache) return this.boundingBoxCache;
			let minVertex = new Vector(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
			let maxVertex = new Vector(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
			for (let i$1 = 0; i$1 < this.vertices.length; i$1++) {
				let vertex$1 = this.vertices[i$1];
				minVertex.x = Math.min(minVertex.x, vertex$1.x);
				minVertex.y = Math.min(minVertex.y, vertex$1.y);
				minVertex.z = Math.min(minVertex.z, vertex$1.z);
				maxVertex.x = Math.max(maxVertex.x, vertex$1.x);
				maxVertex.y = Math.max(maxVertex.y, vertex$1.y);
				maxVertex.z = Math.max(maxVertex.z, vertex$1.z);
			}
			this.boundingBoxCache = {
				min: minVertex,
				max: maxVertex,
				size: new Vector(maxVertex.x - minVertex.x, maxVertex.y - minVertex.y, maxVertex.z - minVertex.z),
				offset: new Vector((minVertex.x + maxVertex.x) / 2, (minVertex.y + maxVertex.y) / 2, (minVertex.z + maxVertex.z) / 2)
			};
			return this.boundingBoxCache;
		}
		reset() {
			this._hasFillTransparency = void 0;
			this._hasStrokeTransparency = void 0;
			this.lineVertices.clear();
			this.lineTangentsIn.clear();
			this.lineTangentsOut.clear();
			this.lineSides.clear();
			this.vertices.length = 0;
			this.edges.length = 0;
			this.vertexColors.length = 0;
			this.vertexStrokeColors.length = 0;
			this.lineVertexColors.clear();
			this.vertexNormals.length = 0;
			this.uvs.length = 0;
			for (const propName in this.userVertexProperties) this.userVertexProperties[propName].delete();
			this.userVertexProperties = {};
			this.dirtyFlags = {};
		}
		hasFillTransparency() {
			if (this._hasFillTransparency === void 0) {
				this._hasFillTransparency = false;
				for (let i$1 = 0; i$1 < this.vertexColors.length; i$1 += 4) if (this.vertexColors[i$1 + 3] < 1) {
					this._hasFillTransparency = true;
					break;
				}
			}
			return this._hasFillTransparency;
		}
		hasStrokeTransparency() {
			if (this._hasStrokeTransparency === void 0) {
				this._hasStrokeTransparency = false;
				for (let i$1 = 0; i$1 < this.lineVertexColors.length; i$1 += 4) if (this.lineVertexColors[i$1 + 3] < 1) {
					this._hasStrokeTransparency = true;
					break;
				}
			}
			return this._hasStrokeTransparency;
		}
		clearColors() {
			this.vertexColors = [];
			return this;
		}
		saveObj(fileName = "model.obj") {
			let objStr = "";
			this.vertices.forEach((v$1) => {
				objStr += `v ${v$1.x} ${v$1.y} ${v$1.z}\n`;
			});
			if (this.uvs && this.uvs.length > 0) for (let i$1 = 0; i$1 < this.uvs.length; i$1 += 2) objStr += `vt ${this.uvs[i$1]} ${this.uvs[i$1 + 1]}\n`;
			if (this.vertexNormals && this.vertexNormals.length > 0) this.vertexNormals.forEach((n$2) => {
				objStr += `vn ${n$2.x} ${n$2.y} ${n$2.z}\n`;
			});
			this.faces.forEach((face) => {
				let faceStr = "f";
				face.forEach((index) => {
					faceStr += " ";
					faceStr += index + 1;
					if (this.vertexNormals.length > 0 || this.uvs.length > 0) {
						faceStr += "/";
						if (this.uvs.length > 0) faceStr += index + 1;
						faceStr += "/";
						if (this.vertexNormals.length > 0) faceStr += index + 1;
					}
				});
				objStr += faceStr + "\n";
			});
			downloadFile(new Blob([objStr], { type: "text/plain" }), fileName, "obj");
		}
		saveStl(fileName = "model.stl", { binary = false } = {}) {
			let modelOutput;
			let name = fileName.substring(0, fileName.lastIndexOf("."));
			let faceNormals = [];
			for (let f of this.faces) {
				const U$1 = Vector.sub(this.vertices[f[1]], this.vertices[f[0]]);
				const V$1 = Vector.sub(this.vertices[f[2]], this.vertices[f[0]]);
				const nx = U$1.y * V$1.z - U$1.z * V$1.y;
				const ny = U$1.z * V$1.x - U$1.x * V$1.z;
				const nz = U$1.x * V$1.y - U$1.y * V$1.x;
				faceNormals.push(new Vector(nx, ny, nz).normalize());
			}
			if (binary) {
				let offset = 80;
				const bufferLength = this.faces.length * 2 + this.faces.length * 3 * 4 * 4 + 80 + 4;
				const arrayBuffer = new ArrayBuffer(bufferLength);
				modelOutput = new DataView(arrayBuffer);
				modelOutput.setUint32(offset, this.faces.length, true);
				offset += 4;
				for (const [key, f] of Object.entries(this.faces)) {
					const norm = faceNormals[key];
					modelOutput.setFloat32(offset, norm.x, true);
					offset += 4;
					modelOutput.setFloat32(offset, norm.y, true);
					offset += 4;
					modelOutput.setFloat32(offset, norm.z, true);
					offset += 4;
					for (let vertexIndex of f) {
						const vert = this.vertices[vertexIndex];
						modelOutput.setFloat32(offset, vert.x, true);
						offset += 4;
						modelOutput.setFloat32(offset, vert.y, true);
						offset += 4;
						modelOutput.setFloat32(offset, vert.z, true);
						offset += 4;
					}
					modelOutput.setUint16(offset, 0, true);
					offset += 2;
				}
			} else {
				modelOutput = "solid " + name + "\n";
				for (const [key, f] of Object.entries(this.faces)) {
					const norm = faceNormals[key];
					modelOutput += " facet norm " + norm.x + " " + norm.y + " " + norm.z + "\n";
					modelOutput += "  outer loop\n";
					for (let vertexIndex of f) {
						const vert = this.vertices[vertexIndex];
						modelOutput += "   vertex " + vert.x + " " + vert.y + " " + vert.z + "\n";
					}
					modelOutput += "  endloop\n";
					modelOutput += " endfacet\n";
				}
				modelOutput += "endsolid " + name + "\n";
			}
			downloadFile(new Blob([modelOutput], { type: "text/plain" }), fileName, "stl");
		}
		flipU() {
			this.uvs = this.uvs.flat().map((val$1, index) => {
				if (index % 2 === 0) return 1 - val$1;
				else return val$1;
			});
		}
		flipV() {
			this.uvs = this.uvs.flat().map((val$1, index) => {
				if (index % 2 === 0) return val$1;
				else return 1 - val$1;
			});
		}
		computeFaces() {
			this.faces.length = 0;
			const sliceCount = this.detailX + 1;
			let a, b$1, c, d$1;
			for (let i$1 = 0; i$1 < this.detailY; i$1++) for (let j = 0; j < this.detailX; j++) {
				a = i$1 * sliceCount + j;
				b$1 = i$1 * sliceCount + j + 1;
				c = (i$1 + 1) * sliceCount + j + 1;
				d$1 = (i$1 + 1) * sliceCount + j;
				this.faces.push([
					a,
					b$1,
					d$1
				]);
				this.faces.push([
					d$1,
					b$1,
					c
				]);
			}
			return this;
		}
		_getFaceNormal(faceId) {
			const face = this.faces[faceId];
			const vA = this.vertices[face[0]];
			const vB = this.vertices[face[1]];
			const vC = this.vertices[face[2]];
			const ab = Vector.sub(vB, vA);
			const ac = Vector.sub(vC, vA);
			const n$2 = Vector.cross(ab, ac);
			const ln = Vector.mag(n$2);
			let sinAlpha = ln / (Vector.mag(ab) * Vector.mag(ac));
			if (sinAlpha === 0 || isNaN(sinAlpha)) {
				console.warn("p5.Geometry.prototype._getFaceNormal:", "face has colinear sides or a repeated vertex");
				return n$2;
			}
			if (sinAlpha > 1) sinAlpha = 1;
			return n$2.mult(Math.asin(sinAlpha) / ln);
		}
		computeNormals(shadingType = FLAT, { roundToPrecision = 3 } = {}) {
			const vertexNormals = this.vertexNormals;
			let vertices = this.vertices;
			const faces = this.faces;
			let iv;
			if (shadingType === SMOOTH) {
				const vertexIndices = {};
				const uniqueVertices = [];
				const power = Math.pow(10, roundToPrecision);
				const rounded = (val$1) => Math.round(val$1 * power) / power;
				const getKey = (vert) => `${rounded(vert.x)},${rounded(vert.y)},${rounded(vert.z)}`;
				for (let i$1 = 0; i$1 < vertices.length; i$1++) {
					const vertex$1 = vertices[i$1];
					const key = getKey(vertex$1);
					if (vertexIndices[key] === void 0) {
						vertexIndices[key] = uniqueVertices.length;
						uniqueVertices.push(vertex$1);
					}
				}
				faces.forEach((face) => {
					for (let fv = 0; fv < 3; ++fv) {
						const originalVertexIndex = face[fv];
						const originalVertex = vertices[originalVertexIndex];
						face[fv] = vertexIndices[getKey(originalVertex)];
					}
				});
				this.edges.forEach((edge) => {
					for (let ev = 0; ev < 2; ++ev) {
						const originalVertexIndex = edge[ev];
						const originalVertex = vertices[originalVertexIndex];
						edge[ev] = vertexIndices[getKey(originalVertex)];
					}
				});
				this.vertices = vertices = uniqueVertices;
			}
			vertexNormals.length = 0;
			for (iv = 0; iv < vertices.length; ++iv) vertexNormals.push(new Vector());
			faces.forEach((face, f) => {
				const faceNormal = this._getFaceNormal(f);
				for (let fv = 0; fv < 3; ++fv) vertexNormals[face[fv]].add(faceNormal);
			});
			for (iv = 0; iv < vertices.length; ++iv) vertexNormals[iv].normalize();
			return this;
		}
		averageNormals() {
			for (let i$1 = 0; i$1 <= this.detailY; i$1++) {
				const offset = this.detailX + 1;
				let temp = Vector.add(this.vertexNormals[i$1 * offset], this.vertexNormals[i$1 * offset + this.detailX]);
				temp = Vector.div(temp, 2);
				this.vertexNormals[i$1 * offset] = temp;
				this.vertexNormals[i$1 * offset + this.detailX] = temp;
			}
			return this;
		}
		averagePoleNormals() {
			let sum = new Vector(0, 0, 0);
			for (let i$1 = 0; i$1 < this.detailX; i$1++) sum.add(this.vertexNormals[i$1]);
			sum = Vector.div(sum, this.detailX);
			for (let i$1 = 0; i$1 < this.detailX; i$1++) this.vertexNormals[i$1] = sum;
			sum = new Vector(0, 0, 0);
			for (let i$1 = this.vertices.length - 1; i$1 > this.vertices.length - 1 - this.detailX; i$1--) sum.add(this.vertexNormals[i$1]);
			sum = Vector.div(sum, this.detailX);
			for (let i$1 = this.vertices.length - 1; i$1 > this.vertices.length - 1 - this.detailX; i$1--) this.vertexNormals[i$1] = sum;
			return this;
		}
		_makeTriangleEdges() {
			this.edges.length = 0;
			for (let j = 0; j < this.faces.length; j++) {
				this.edges.push([this.faces[j][0], this.faces[j][1]]);
				this.edges.push([this.faces[j][1], this.faces[j][2]]);
				this.edges.push([this.faces[j][2], this.faces[j][0]]);
			}
			return this;
		}
		makeEdgesFromFaces() {
			this._makeTriangleEdges();
		}
		_edgesToVertices() {
			this.lineVertices.clear();
			this.lineTangentsIn.clear();
			this.lineTangentsOut.clear();
			this.lineSides.clear();
			const potentialCaps = /* @__PURE__ */ new Map();
			const connected = /* @__PURE__ */ new Set();
			let lastValidDir;
			for (let i$1 = 0; i$1 < this.edges.length; i$1++) {
				const prevEdge = this.edges[i$1 - 1];
				const currEdge = this.edges[i$1];
				const begin = this.vertices[currEdge[0]];
				const end = this.vertices[currEdge[1]];
				const prevColor = this.vertexStrokeColors.length > 0 && prevEdge ? this.vertexStrokeColors.slice(prevEdge[1] * 4, (prevEdge[1] + 1) * 4) : [
					0,
					0,
					0,
					0
				];
				const fromColor = this.vertexStrokeColors.length > 0 ? this.vertexStrokeColors.slice(currEdge[0] * 4, (currEdge[0] + 1) * 4) : [
					0,
					0,
					0,
					0
				];
				const toColor = this.vertexStrokeColors.length > 0 ? this.vertexStrokeColors.slice(currEdge[1] * 4, (currEdge[1] + 1) * 4) : [
					0,
					0,
					0,
					0
				];
				const dir = end.copy().sub(begin).normalize();
				const dirOK = dir.magSq() > 0;
				if (dirOK) this._addSegment(begin, end, fromColor, toColor, dir);
				if (!this.renderer?._simpleLines) {
					if (i$1 > 0 && prevEdge[1] === currEdge[0]) {
						if (!connected.has(currEdge[0])) {
							connected.add(currEdge[0]);
							potentialCaps.delete(currEdge[0]);
							if (lastValidDir && dirOK && dir.dot(lastValidDir) < .99999999) this._addJoin(begin, lastValidDir, dir, fromColor);
						}
					} else {
						if (dirOK && !connected.has(currEdge[0])) {
							const existingCap = potentialCaps.get(currEdge[0]);
							if (existingCap) {
								this._addJoin(begin, existingCap.dir, dir, fromColor);
								potentialCaps.delete(currEdge[0]);
								connected.add(currEdge[0]);
							} else potentialCaps.set(currEdge[0], {
								point: begin,
								dir: dir.copy().mult(-1),
								color: fromColor
							});
						}
						if (lastValidDir && !connected.has(prevEdge[1])) {
							const existingCap = potentialCaps.get(prevEdge[1]);
							if (existingCap) {
								this._addJoin(this.vertices[prevEdge[1]], lastValidDir, existingCap.dir.copy().mult(-1), prevColor);
								potentialCaps.delete(prevEdge[1]);
								connected.add(prevEdge[1]);
							} else potentialCaps.set(prevEdge[1], {
								point: this.vertices[prevEdge[1]],
								dir: lastValidDir,
								color: prevColor
							});
							lastValidDir = void 0;
						}
					}
					if (i$1 === this.edges.length - 1 && !connected.has(currEdge[1])) {
						const existingCap = potentialCaps.get(currEdge[1]);
						if (existingCap) {
							this._addJoin(end, dir, existingCap.dir.copy().mult(-1), toColor);
							potentialCaps.delete(currEdge[1]);
							connected.add(currEdge[1]);
						} else potentialCaps.set(currEdge[1], {
							point: end,
							dir,
							color: toColor
						});
					}
					if (dirOK) lastValidDir = dir;
				}
			}
			for (const { point, dir, color: color$2 } of potentialCaps.values()) this._addCap(point, dir, color$2);
			return this;
		}
		_addSegment(begin, end, fromColor, toColor, dir) {
			const a = begin.array();
			const b$1 = end.array();
			const dirArr = dir.array();
			this.lineSides.push(1, 1, -1, 1, -1, -1);
			for (const tangents of [this.lineTangentsIn, this.lineTangentsOut]) for (let i$1 = 0; i$1 < 6; i$1++) tangents.push(...dirArr);
			this.lineVertices.push(...a, ...b$1, ...a, ...b$1, ...b$1, ...a);
			if (!this.renderer?._simpleLines) this.lineVertexColors.push(...fromColor, ...toColor, ...fromColor, ...toColor, ...toColor, ...fromColor);
			return this;
		}
		_addCap(point, tangent, color$2) {
			const ptArray = point.array();
			const tanInArray = tangent.array();
			const tanOutArray = [
				0,
				0,
				0
			];
			for (let i$1 = 0; i$1 < 6; i$1++) {
				this.lineVertices.push(...ptArray);
				this.lineTangentsIn.push(...tanInArray);
				this.lineTangentsOut.push(...tanOutArray);
				this.lineVertexColors.push(...color$2);
			}
			this.lineSides.push(-1, 2, -2, 1, 2, -1);
			return this;
		}
		_addJoin(point, fromTangent, toTangent, color$2) {
			const ptArray = point.array();
			const tanInArray = fromTangent.array();
			const tanOutArray = toTangent.array();
			for (let i$1 = 0; i$1 < 12; i$1++) {
				this.lineVertices.push(...ptArray);
				this.lineTangentsIn.push(...tanInArray);
				this.lineTangentsOut.push(...tanOutArray);
				this.lineVertexColors.push(...color$2);
			}
			this.lineSides.push(-1, -3, -2, -1, 0, -3);
			this.lineSides.push(3, 1, 2, 3, 0, 1);
			return this;
		}
		normalize() {
			if (this.vertices.length > 0) {
				const maxPosition = this.vertices[0].copy();
				const minPosition = this.vertices[0].copy();
				for (let i$1 = 0; i$1 < this.vertices.length; i$1++) {
					maxPosition.x = Math.max(maxPosition.x, this.vertices[i$1].x);
					minPosition.x = Math.min(minPosition.x, this.vertices[i$1].x);
					maxPosition.y = Math.max(maxPosition.y, this.vertices[i$1].y);
					minPosition.y = Math.min(minPosition.y, this.vertices[i$1].y);
					maxPosition.z = Math.max(maxPosition.z, this.vertices[i$1].z);
					minPosition.z = Math.min(minPosition.z, this.vertices[i$1].z);
				}
				const center = Vector.lerp(maxPosition, minPosition, .5);
				const dist = Vector.sub(maxPosition, minPosition);
				const scale = 200 / Math.max(Math.max(dist.x, dist.y), dist.z);
				for (let i$1 = 0; i$1 < this.vertices.length; i$1++) {
					this.vertices[i$1].sub(center);
					this.vertices[i$1].mult(scale);
				}
			}
			return this;
		}
		vertexProperty(propertyName, data$2, size) {
			let prop;
			if (!this.userVertexProperties[propertyName]) prop = this.userVertexProperties[propertyName] = this._userVertexPropertyHelper(propertyName, data$2, size);
			prop = this.userVertexProperties[propertyName];
			if (size) prop.pushDirect(data$2);
			else {
				prop.setCurrentData(data$2);
				prop.pushCurrentData();
			}
		}
		_userVertexPropertyHelper(propertyName, data$2, size) {
			const geometryInstance = this;
			const prop = this.userVertexProperties[propertyName] = {
				name: propertyName,
				dataSize: size ? size : data$2.length ? data$2.length : 1,
				geometry: geometryInstance,
				getName() {
					return this.name;
				},
				getCurrentData() {
					if (this.currentData === void 0) this.currentData = new Array(this.getDataSize()).fill(0);
					return this.currentData;
				},
				getDataSize() {
					return this.dataSize;
				},
				getSrcName() {
					return this.name.concat("Src");
				},
				getDstName() {
					return this.name.concat("Buffer");
				},
				getSrcArray() {
					const srcName = this.getSrcName();
					return this.geometry[srcName];
				},
				setCurrentData(data$3) {
					data$3.length && data$3.length;
					this.currentData = data$3;
				},
				pushCurrentData() {
					const data$3 = this.getCurrentData();
					this.pushDirect(data$3);
				},
				pushDirect(data$3) {
					if (data$3.length) this.getSrcArray().push(...data$3);
					else this.getSrcArray().push(data$3);
				},
				resetSrcArray() {
					this.geometry[this.getSrcName()] = [];
				},
				delete() {
					const srcName = this.getSrcName();
					delete this.geometry[srcName];
					delete this;
				}
			};
			this[prop.getSrcName()] = [];
			return this.userVertexProperties[propertyName];
		}
	};
	Geometry.nextId = 0;
	function geometry(p5$2, fn$1) {
		p5$2.Geometry = Geometry;
	}
	if (typeof p5 !== "undefined") geometry(p5, p5.prototype);
	var GeometryBuilder = class GeometryBuilder {
		constructor(renderer$1) {
			this.renderer = renderer$1;
			renderer$1._pInst.push();
			this.identityMatrix = new Matrix(4);
			renderer$1.states.setValue("uModelMatrix", new Matrix(4));
			this.geometry = new Geometry(void 0, void 0, void 0, this.renderer);
			this.geometry.gid = `_p5_GeometryBuilder_${GeometryBuilder.nextGeometryId}`;
			GeometryBuilder.nextGeometryId++;
			this.hasTransform = false;
		}
		transformVertices(vertices) {
			if (!this.hasTransform) return vertices;
			return vertices.map((v$1) => this.renderer.states.uModelMatrix.multiplyPoint(v$1));
		}
		transformNormals(normals) {
			if (!this.hasTransform) return normals;
			return normals.map((v$1) => this.renderer.scratchMat3.multiplyVec(v$1));
		}
		addGeometry(input) {
			this.hasTransform = !this.renderer.states.uModelMatrix.mat4.every((v$1, i$1) => v$1 === this.identityMatrix.mat4[i$1]);
			if (this.hasTransform) this.renderer.scratchMat3.inverseTranspose4x4(this.renderer.states.uModelMatrix);
			let startIdx = this.geometry.vertices.length;
			this.geometry.vertices.push(...this.transformVertices(input.vertices));
			this.geometry.vertexNormals.push(...this.transformNormals(input.vertexNormals));
			this.geometry.uvs.push(...input.uvs);
			const inputUserVertexProps = input.userVertexProperties;
			const builtUserVertexProps = this.geometry.userVertexProperties;
			const numPreviousVertices = this.geometry.vertices.length - input.vertices.length;
			for (const propName in builtUserVertexProps) {
				if (propName in inputUserVertexProps) continue;
				const prop = builtUserVertexProps[propName];
				const numMissingValues = prop.getDataSize() * input.vertices.length;
				const missingValues = Array(numMissingValues).fill(0);
				prop.pushDirect(missingValues);
			}
			for (const propName in inputUserVertexProps) {
				const prop = inputUserVertexProps[propName];
				const data$2 = prop.getSrcArray();
				const size = prop.getDataSize();
				if (numPreviousVertices > 0 && !(propName in builtUserVertexProps)) {
					const numMissingValues = size * numPreviousVertices;
					const missingValues = Array(numMissingValues).fill(0);
					this.geometry.vertexProperty(propName, missingValues, size);
				}
				this.geometry.vertexProperty(propName, data$2, size);
			}
			if (this.renderer.states.fillColor) this.geometry.faces.push(...input.faces.map((f) => f.map((idx) => idx + startIdx)));
			if (this.renderer.states.strokeColor) this.geometry.edges.push(...input.edges.map((edge) => edge.map((idx) => idx + startIdx)));
			const vertexColors = [...input.vertexColors];
			while (vertexColors.length < input.vertices.length * 4) vertexColors.push(...this.renderer.states.curFillColor);
			this.geometry.vertexColors.push(...vertexColors);
		}
		addImmediate(geometry$1, shapeMode, { validateFaces = false } = {}) {
			const faces = [];
			if (this.renderer.states.fillColor) {
				if (shapeMode === TRIANGLE_STRIP || shapeMode === QUAD_STRIP) for (let i$1 = 2; i$1 < geometry$1.vertices.length; i$1++) if (i$1 % 2 === 0) faces.push([
					i$1,
					i$1 - 1,
					i$1 - 2
				]);
				else faces.push([
					i$1,
					i$1 - 2,
					i$1 - 1
				]);
				else if (shapeMode === TRIANGLE_FAN) for (let i$1 = 2; i$1 < geometry$1.vertices.length; i$1++) faces.push([
					0,
					i$1 - 1,
					i$1
				]);
				else for (let i$1 = 0; i$1 < geometry$1.vertices.length; i$1 += 3) if (!validateFaces || geometry$1.vertices[i$1].copy().sub(geometry$1.vertices[i$1 + 1]).cross(geometry$1.vertices[i$1].copy().sub(geometry$1.vertices[i$1 + 2])).magSq() > 0) faces.push([
					i$1,
					i$1 + 1,
					i$1 + 2
				]);
			}
			this.addGeometry(Object.assign({}, geometry$1, { faces }));
		}
		addRetained(geometry$1) {
			this.addGeometry(geometry$1);
		}
		finish() {
			this.renderer._pInst.pop();
			return this.geometry;
		}
	};
	GeometryBuilder.nextGeometryId = 0;
	var Quat = class Quat {
		constructor(w, x$1, y, z$1) {
			this.w = w;
			this.vec = new Vector(x$1, y, z$1);
		}
		static fromAxisAngle(angle, x$1, y, z$1) {
			const w = Math.cos(angle / 2);
			const vec = new Vector(x$1, y, z$1).normalize().mult(Math.sin(angle / 2));
			return new Quat(w, vec.x, vec.y, vec.z);
		}
		conjugate() {
			return new Quat(this.w, -this.vec.x, -this.vec.y, -this.vec.z);
		}
		multiply(quat$1) {
			return new Quat(this.w * quat$1.w - this.vec.x * quat$1.vec.x - this.vec.y * quat$1.vec.y - this.vec.z - quat$1.vec.z, this.w * quat$1.vec.x + this.vec.x * quat$1.w + this.vec.y * quat$1.vec.z - this.vec.z * quat$1.vec.y, this.w * quat$1.vec.y - this.vec.x * quat$1.vec.z + this.vec.y * quat$1.w + this.vec.z * quat$1.vec.x, this.w * quat$1.vec.z + this.vec.x * quat$1.vec.y - this.vec.y * quat$1.vec.x + this.vec.z * quat$1.w);
		}
		rotateVector(p$1) {
			return Vector.mult(p$1, this.w * this.w - this.vec.dot(this.vec)).add(Vector.mult(this.vec, 2 * p$1.dot(this.vec))).add(Vector.mult(this.vec, 2 * this.w).cross(p$1)).clampToZero();
		}
		rotateBy(axesQuat) {
			return axesQuat.multiply(this).multiply(axesQuat.conjugate()).vec.clampToZero();
		}
	};
	function quat(p5$2, fn$1) {
		p5$2.Quat = Quat;
	}
	if (typeof p5 !== "undefined") quat(p5, p5.prototype);
	var RenderBuffer = class {
		constructor(size, src, dst, attr, renderer$1, map$1) {
			this.size = size;
			this.src = src;
			this.dst = dst;
			this.attr = attr;
			this._renderer = renderer$1;
			this.map = map$1;
		}
		_prepareBuffer(geometry$1, shader$1) {
			const attributes$1 = shader$1.attributes;
			const gl = this._renderer.GL;
			const glBuffers = this._renderer._getOrMakeCachedBuffers(geometry$1);
			const attr = attributes$1[this.attr];
			if (!attr) return;
			let buffer = glBuffers[this.dst];
			const src = geometry$1[this.src];
			if (src && src.length > 0) {
				const createBuffer = !buffer;
				if (createBuffer) glBuffers[this.dst] = buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
				if (createBuffer || geometry$1.dirtyFlags[this.src] !== false) {
					const map$1 = this.map;
					const values = map$1 ? map$1(src) : src;
					this._renderer._bindBuffer(buffer, gl.ARRAY_BUFFER, values);
					geometry$1.dirtyFlags[this.src] = false;
				}
				shader$1.enableAttrib(attr, this.size);
			} else {
				const loc = attr.location;
				if (loc === -1 || !this._renderer.registerEnabled.has(loc)) return;
				gl.disableVertexAttribArray(loc);
				this._renderer.registerEnabled.delete(loc);
			}
		}
	};
	function renderBuffer(p5$2, fn$1) {
		p5$2.RenderBuffer = RenderBuffer;
	}
	if (typeof p5 !== "undefined") renderBuffer(p5, p5.prototype);
	var import_libtess_min = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports, module) => {
		var n;
		function t(a, b$1) {
			return a.b === b$1.b && a.a === b$1.a;
		}
		function u(a, b$1) {
			return a.b < b$1.b || a.b === b$1.b && a.a <= b$1.a;
		}
		function v(a, b$1, c) {
			var d$1 = b$1.b - a.b, e$1 = c.b - b$1.b;
			return 0 < d$1 + e$1 ? d$1 < e$1 ? b$1.a - a.a + d$1 / (d$1 + e$1) * (a.a - c.a) : b$1.a - c.a + e$1 / (d$1 + e$1) * (c.a - a.a) : 0;
		}
		function x(a, b$1, c) {
			var d$1 = b$1.b - a.b, e$1 = c.b - b$1.b;
			return 0 < d$1 + e$1 ? (b$1.a - c.a) * d$1 + (b$1.a - a.a) * e$1 : 0;
		}
		function z(a, b$1) {
			return a.a < b$1.a || a.a === b$1.a && a.b <= b$1.b;
		}
		function aa(a, b$1, c) {
			var d$1 = b$1.a - a.a, e$1 = c.a - b$1.a;
			return 0 < d$1 + e$1 ? d$1 < e$1 ? b$1.b - a.b + d$1 / (d$1 + e$1) * (a.b - c.b) : b$1.b - c.b + e$1 / (d$1 + e$1) * (c.b - a.b) : 0;
		}
		function ba(a, b$1, c) {
			var d$1 = b$1.a - a.a, e$1 = c.a - b$1.a;
			return 0 < d$1 + e$1 ? (b$1.b - c.b) * d$1 + (b$1.b - a.b) * e$1 : 0;
		}
		function ca(a) {
			return u(a.b.a, a.a);
		}
		function da(a) {
			return u(a.a, a.b.a);
		}
		function A(a, b$1, c, d$1) {
			a = 0 > a ? 0 : a;
			c = 0 > c ? 0 : c;
			return a <= c ? 0 === c ? (b$1 + d$1) / 2 : b$1 + a / (a + c) * (d$1 - b$1) : d$1 + c / (a + c) * (b$1 - d$1);
		}
		function ea(a) {
			var b$1 = B(a.b);
			C(b$1, a.c);
			C(b$1.b, a.c);
			D(b$1, a.a);
			return b$1;
		}
		function E(a, b$1) {
			var c = !1, d$1 = !1;
			a !== b$1 && (b$1.a !== a.a && (d$1 = !0, F(b$1.a, a.a)), b$1.d !== a.d && (c = !0, G(b$1.d, a.d)), H(b$1, a), d$1 || (C(b$1, a.a), a.a.c = a), c || (D(b$1, a.d), a.d.a = a));
		}
		function I(a) {
			var b$1 = a.b, c = !1;
			a.d !== a.b.d && (c = !0, G(a.d, a.b.d));
			a.c === a ? F(a.a, null) : (a.b.d.a = J(a), a.a.c = a.c, H(a, J(a)), c || D(a, a.d));
			b$1.c === b$1 ? (F(b$1.a, null), G(b$1.d, null)) : (a.d.a = J(b$1), b$1.a.c = b$1.c, H(b$1, J(b$1)));
			fa(a);
		}
		function K(a) {
			var b$1 = B(a), c = b$1.b;
			H(b$1, a.e);
			b$1.a = a.b.a;
			C(c, b$1.a);
			b$1.d = c.d = a.d;
			b$1 = b$1.b;
			H(a.b, J(a.b));
			H(a.b, b$1);
			a.b.a = b$1.a;
			b$1.b.a.c = b$1.b;
			b$1.b.d = a.b.d;
			b$1.f = a.f;
			b$1.b.f = a.b.f;
			return b$1;
		}
		function L(a, b$1) {
			var c = !1, d$1 = B(a), e$1 = d$1.b;
			b$1.d !== a.d && (c = !0, G(b$1.d, a.d));
			H(d$1, a.e);
			H(e$1, b$1);
			d$1.a = a.b.a;
			e$1.a = b$1.a;
			d$1.d = e$1.d = a.d;
			a.d.a = e$1;
			c || D(d$1, a.d);
			return d$1;
		}
		function B(a) {
			var b$1 = new M(), c = new M(), d$1 = a.b.h;
			c.h = d$1;
			d$1.b.h = b$1;
			b$1.h = a;
			a.b.h = c;
			b$1.b = c;
			b$1.c = b$1;
			b$1.e = c;
			c.b = b$1;
			c.c = c;
			return c.e = b$1;
		}
		function H(a, b$1) {
			var c = a.c, d$1 = b$1.c;
			c.b.e = b$1;
			d$1.b.e = a;
			a.c = d$1;
			b$1.c = c;
		}
		function C(a, b$1) {
			var c = b$1.f, d$1 = new N(b$1, c);
			c.e = d$1;
			b$1.f = d$1;
			c = d$1.c = a;
			do
				c.a = d$1, c = c.c;
			while (c !== a);
		}
		function D(a, b$1) {
			var c = b$1.d, d$1 = new ga(b$1, c);
			c.b = d$1;
			b$1.d = d$1;
			d$1.a = a;
			d$1.c = b$1.c;
			c = a;
			do
				c.d = d$1, c = c.e;
			while (c !== a);
		}
		function fa(a) {
			var b$1 = a.h;
			a = a.b.h;
			b$1.b.h = a;
			a.b.h = b$1;
		}
		function F(a, b$1) {
			var c = a.c, d$1 = c;
			do
				d$1.a = b$1, d$1 = d$1.c;
			while (d$1 !== c);
			c = a.f;
			d$1 = a.e;
			d$1.f = c;
			c.e = d$1;
		}
		function G(a, b$1) {
			var c = a.a, d$1 = c;
			do
				d$1.d = b$1, d$1 = d$1.e;
			while (d$1 !== c);
			c = a.d;
			d$1 = a.b;
			d$1.d = c;
			c.b = d$1;
		}
		function ha(a) {
			var b$1 = 0;
			Math.abs(a[1]) > Math.abs(a[0]) && (b$1 = 1);
			Math.abs(a[2]) > Math.abs(a[b$1]) && (b$1 = 2);
			return b$1;
		}
		var O = 4 * 1e150;
		function P(a, b$1) {
			a.f += b$1.f;
			a.b.f += b$1.b.f;
		}
		function ia(a, b$1, c) {
			a = a.a;
			b$1 = b$1.a;
			c = c.a;
			if (b$1.b.a === a) return c.b.a === a ? u(b$1.a, c.a) ? 0 >= x(c.b.a, b$1.a, c.a) : 0 <= x(b$1.b.a, c.a, b$1.a) : 0 >= x(c.b.a, a, c.a);
			if (c.b.a === a) return 0 <= x(b$1.b.a, a, b$1.a);
			b$1 = v(b$1.b.a, a, b$1.a);
			a = v(c.b.a, a, c.a);
			return b$1 >= a;
		}
		function Q(a) {
			a.a.i = null;
			var b$1 = a.e;
			b$1.a.c = b$1.c;
			b$1.c.a = b$1.a;
			a.e = null;
		}
		function ja(a, b$1) {
			I(a.a);
			a.c = !1;
			a.a = b$1;
			b$1.i = a;
		}
		function ka(a) {
			var b$1 = a.a.a;
			do
				a = R(a);
			while (a.a.a === b$1);
			a.c && (b$1 = L(S(a).a.b, a.a.e), ja(a, b$1), a = R(a));
			return a;
		}
		function la(a, b$1, c) {
			var d$1 = new ma();
			d$1.a = c;
			d$1.e = na(a.f, b$1.e, d$1);
			return c.i = d$1;
		}
		function oa(a, b$1) {
			switch (a.s) {
				case 100130: return 0 !== (b$1 & 1);
				case 100131: return 0 !== b$1;
				case 100132: return 0 < b$1;
				case 100133: return 0 > b$1;
				case 100134: return 2 <= b$1 || -2 >= b$1;
			}
			return !1;
		}
		function pa(a) {
			var b$1 = a.a, c = b$1.d;
			c.c = a.d;
			c.a = b$1;
			Q(a);
		}
		function T(a, b$1, c) {
			a = b$1;
			for (b$1 = b$1.a; a !== c;) {
				a.c = !1;
				var d$1 = S(a), e$1 = d$1.a;
				if (e$1.a !== b$1.a) {
					if (!d$1.c) {
						pa(a);
						break;
					}
					e$1 = L(b$1.c.b, e$1.b);
					ja(d$1, e$1);
				}
				b$1.c !== e$1 && (E(J(e$1), e$1), E(b$1, e$1));
				pa(a);
				b$1 = d$1.a;
				a = d$1;
			}
			return b$1;
		}
		function U(a, b$1, c, d$1, e$1, f) {
			var g$1 = !0;
			do
				la(a, b$1, c.b), c = c.c;
			while (c !== d$1);
			for (null === e$1 && (e$1 = S(b$1).a.b.c);;) {
				d$1 = S(b$1);
				c = d$1.a.b;
				if (c.a !== e$1.a) break;
				c.c !== e$1 && (E(J(c), c), E(J(e$1), c));
				d$1.f = b$1.f - c.f;
				d$1.d = oa(a, d$1.f);
				b$1.b = !0;
				!g$1 && qa(a, b$1) && (P(c, e$1), Q(b$1), I(e$1));
				g$1 = !1;
				b$1 = d$1;
				e$1 = c;
			}
			b$1.b = !0;
			f && ra(a, b$1);
		}
		function sa(a, b$1, c, d$1, e$1) {
			var f = [
				b$1.g[0],
				b$1.g[1],
				b$1.g[2]
			];
			b$1.d = null;
			b$1.d = a.o ? a.o(f, c, d$1, a.c) || null : null;
			null === b$1.d && (e$1 ? a.n || (V(a, 100156), a.n = !0) : b$1.d = c[0]);
		}
		function ta(a, b$1, c) {
			var d$1 = [
				null,
				null,
				null,
				null
			];
			d$1[0] = b$1.a.d;
			d$1[1] = c.a.d;
			sa(a, b$1.a, d$1, [
				.5,
				.5,
				0,
				0
			], !1);
			E(b$1, c);
		}
		function ua(a, b$1, c, d$1, e$1) {
			var f = Math.abs(b$1.b - a.b) + Math.abs(b$1.a - a.a), g$1 = Math.abs(c.b - a.b) + Math.abs(c.a - a.a), h = e$1 + 1;
			d$1[e$1] = .5 * g$1 / (f + g$1);
			d$1[h] = .5 * f / (f + g$1);
			a.g[0] += d$1[e$1] * b$1.g[0] + d$1[h] * c.g[0];
			a.g[1] += d$1[e$1] * b$1.g[1] + d$1[h] * c.g[1];
			a.g[2] += d$1[e$1] * b$1.g[2] + d$1[h] * c.g[2];
		}
		function qa(a, b$1) {
			var c = S(b$1), d$1 = b$1.a, e$1 = c.a;
			if (u(d$1.a, e$1.a)) {
				if (0 < x(e$1.b.a, d$1.a, e$1.a)) return !1;
				if (!t(d$1.a, e$1.a)) K(e$1.b), E(d$1, J(e$1)), b$1.b = c.b = !0;
				else if (d$1.a !== e$1.a) {
					var c = a.e, f = d$1.a.h;
					if (0 <= f) {
						var c = c.b, g$1 = c.d, h = c.e, k = c.c, l = k[f];
						g$1[l] = g$1[c.a];
						k[g$1[l]] = l;
						l <= --c.a && (1 >= l ? W(c, l) : u(h[g$1[l >> 1]], h[g$1[l]]) ? W(c, l) : va(c, l));
						h[f] = null;
						k[f] = c.b;
						c.b = f;
					} else for (c.c[-(f + 1)] = null; 0 < c.a && null === c.c[c.d[c.a - 1]];) --c.a;
					ta(a, J(e$1), d$1);
				}
			} else {
				if (0 > x(d$1.b.a, e$1.a, d$1.a)) return !1;
				R(b$1).b = b$1.b = !0;
				K(d$1.b);
				E(J(e$1), d$1);
			}
			return !0;
		}
		function wa(a, b$1) {
			var c = S(b$1), d$1 = b$1.a, e$1 = c.a, f = d$1.a, g$1 = e$1.a, h = d$1.b.a, k = e$1.b.a, l = new N();
			x(h, a.a, f);
			x(k, a.a, g$1);
			if (f === g$1 || Math.min(f.a, h.a) > Math.max(g$1.a, k.a)) return !1;
			if (u(f, g$1)) {
				if (0 < x(k, f, g$1)) return !1;
			} else if (0 > x(h, g$1, f)) return !1;
			var r = h, p$1 = f, q = k, y = g$1, m, w;
			u(r, p$1) || (m = r, r = p$1, p$1 = m);
			u(q, y) || (m = q, q = y, y = m);
			u(r, q) || (m = r, r = q, q = m, m = p$1, p$1 = y, y = m);
			u(q, p$1) ? u(p$1, y) ? (m = v(r, q, p$1), w = v(q, p$1, y), 0 > m + w && (m = -m, w = -w), l.b = A(m, q.b, w, p$1.b)) : (m = x(r, q, p$1), w = -x(r, y, p$1), 0 > m + w && (m = -m, w = -w), l.b = A(m, q.b, w, y.b)) : l.b = (q.b + p$1.b) / 2;
			z(r, p$1) || (m = r, r = p$1, p$1 = m);
			z(q, y) || (m = q, q = y, y = m);
			z(r, q) || (m = r, r = q, q = m, m = p$1, p$1 = y, y = m);
			z(q, p$1) ? z(p$1, y) ? (m = aa(r, q, p$1), w = aa(q, p$1, y), 0 > m + w && (m = -m, w = -w), l.a = A(m, q.a, w, p$1.a)) : (m = ba(r, q, p$1), w = -ba(r, y, p$1), 0 > m + w && (m = -m, w = -w), l.a = A(m, q.a, w, y.a)) : l.a = (q.a + p$1.a) / 2;
			u(l, a.a) && (l.b = a.a.b, l.a = a.a.a);
			r = u(f, g$1) ? f : g$1;
			u(r, l) && (l.b = r.b, l.a = r.a);
			if (t(l, f) || t(l, g$1)) return qa(a, b$1), !1;
			if (!t(h, a.a) && 0 <= x(h, a.a, l) || !t(k, a.a) && 0 >= x(k, a.a, l)) {
				if (k === a.a) return K(d$1.b), E(e$1.b, d$1), b$1 = ka(b$1), d$1 = S(b$1).a, T(a, S(b$1), c), U(a, b$1, J(d$1), d$1, d$1, !0), !0;
				if (h === a.a) {
					K(e$1.b);
					E(d$1.e, J(e$1));
					f = c = b$1;
					g$1 = f.a.b.a;
					do
						f = R(f);
					while (f.a.b.a === g$1);
					b$1 = f;
					f = S(b$1).a.b.c;
					c.a = J(e$1);
					e$1 = T(a, c, null);
					U(a, b$1, e$1.c, d$1.b.c, f, !0);
					return !0;
				}
				0 <= x(h, a.a, l) && (R(b$1).b = b$1.b = !0, K(d$1.b), d$1.a.b = a.a.b, d$1.a.a = a.a.a);
				0 >= x(k, a.a, l) && (b$1.b = c.b = !0, K(e$1.b), e$1.a.b = a.a.b, e$1.a.a = a.a.a);
				return !1;
			}
			K(d$1.b);
			K(e$1.b);
			E(J(e$1), d$1);
			d$1.a.b = l.b;
			d$1.a.a = l.a;
			d$1.a.h = xa(a.e, d$1.a);
			d$1 = d$1.a;
			e$1 = [
				0,
				0,
				0,
				0
			];
			l = [
				f.d,
				h.d,
				g$1.d,
				k.d
			];
			d$1.g[0] = d$1.g[1] = d$1.g[2] = 0;
			ua(d$1, f, h, e$1, 0);
			ua(d$1, g$1, k, e$1, 2);
			sa(a, d$1, l, e$1, !0);
			R(b$1).b = b$1.b = c.b = !0;
			return !1;
		}
		function ra(a, b$1) {
			for (var c = S(b$1);;) {
				for (; c.b;) b$1 = c, c = S(c);
				if (!b$1.b && (c = b$1, b$1 = R(b$1), null === b$1 || !b$1.b)) break;
				b$1.b = !1;
				var d$1 = b$1.a, e$1 = c.a, f;
				if (f = d$1.b.a !== e$1.b.a) a: {
					f = b$1;
					var g$1 = S(f), h = f.a, k = g$1.a, l = void 0;
					if (u(h.b.a, k.b.a)) {
						if (0 > x(h.b.a, k.b.a, h.a)) {
							f = !1;
							break a;
						}
						R(f).b = f.b = !0;
						l = K(h);
						E(k.b, l);
						l.d.c = f.d;
					} else {
						if (0 < x(k.b.a, h.b.a, k.a)) {
							f = !1;
							break a;
						}
						f.b = g$1.b = !0;
						l = K(k);
						E(h.e, k.b);
						l.b.d.c = f.d;
					}
					f = !0;
				}
				f && (c.c ? (Q(c), I(e$1), c = S(b$1), e$1 = c.a) : b$1.c && (Q(b$1), I(d$1), b$1 = R(c), d$1 = b$1.a));
				if (d$1.a !== e$1.a) {
					if (d$1.b.a === e$1.b.a || b$1.c || c.c || d$1.b.a !== a.a && e$1.b.a !== a.a) qa(a, b$1);
					else if (wa(a, b$1)) break;
				}
				d$1.a === e$1.a && d$1.b.a === e$1.b.a && (P(e$1, d$1), Q(b$1), I(d$1), b$1 = R(c));
			}
		}
		function ya(a, b$1) {
			a.a = b$1;
			for (var c = b$1.c; null === c.i;) if (c = c.c, c === b$1.c) {
				var c = a, d$1 = b$1, e$1 = new ma();
				e$1.a = d$1.c.b;
				var f = c.f, g$1 = f.a;
				do
					g$1 = g$1.a;
				while (null !== g$1.b && !f.c(f.b, e$1, g$1.b));
				var f = g$1.b, h = S(f), e$1 = f.a, g$1 = h.a;
				if (0 === x(e$1.b.a, d$1, e$1.a)) e$1 = f.a, t(e$1.a, d$1) || t(e$1.b.a, d$1) || (K(e$1.b), f.c && (I(e$1.c), f.c = !1), E(d$1.c, e$1), ya(c, d$1));
				else {
					var k = u(g$1.b.a, e$1.b.a) ? f : h, h = void 0;
					f.d || k.c ? (k === f ? h = L(d$1.c.b, e$1.e) : h = L(g$1.b.c.b, d$1.c).b, k.c ? ja(k, h) : (e$1 = c, f = la(c, f, h), f.f = R(f).f + f.a.f, f.d = oa(e$1, f.f)), ya(c, d$1)) : U(c, f, d$1.c, d$1.c, null, !0);
				}
				return;
			}
			c = ka(c.i);
			e$1 = S(c);
			f = e$1.a;
			e$1 = T(a, e$1, null);
			if (e$1.c === f) {
				var f = e$1, e$1 = f.c, g$1 = S(c), h = c.a, k = g$1.a, l = !1;
				h.b.a !== k.b.a && wa(a, c);
				t(h.a, a.a) && (E(J(e$1), h), c = ka(c), e$1 = S(c).a, T(a, S(c), g$1), l = !0);
				t(k.a, a.a) && (E(f, J(k)), f = T(a, g$1, null), l = !0);
				l ? U(a, c, f.c, e$1, e$1, !0) : (u(k.a, h.a) ? d$1 = J(k) : d$1 = h, d$1 = L(f.c.b, d$1), U(a, c, d$1, d$1.c, d$1.c, !1), d$1.b.i.c = !0, ra(a, c));
			} else U(a, c, e$1.c, f, f, !0);
		}
		function za(a, b$1) {
			var c = new ma(), d$1 = ea(a.b);
			d$1.a.b = O;
			d$1.a.a = b$1;
			d$1.b.a.b = -O;
			d$1.b.a.a = b$1;
			a.a = d$1.b.a;
			c.a = d$1;
			c.f = 0;
			c.d = !1;
			c.c = !1;
			c.h = !0;
			c.b = !1;
			d$1 = a.f;
			d$1 = na(d$1, d$1.a, c);
			c.e = d$1;
		}
		function Aa(a) {
			this.a = new Ba();
			this.b = a;
			this.c = ia;
		}
		function na(a, b$1, c) {
			do
				b$1 = b$1.c;
			while (null !== b$1.b && !a.c(a.b, b$1.b, c));
			a = new Ba(c, b$1.a, b$1);
			b$1.a.c = a;
			return b$1.a = a;
		}
		function Ba(a, b$1, c) {
			this.b = a || null;
			this.a = b$1 || this;
			this.c = c || this;
		}
		function X() {
			this.d = Y;
			this.p = this.b = this.q = null;
			this.j = [
				0,
				0,
				0
			];
			this.s = 100130;
			this.n = !1;
			this.o = this.a = this.e = this.f = null;
			this.m = !1;
			this.c = this.r = this.i = this.k = this.l = this.h = null;
		}
		var Y = 0;
		n = X.prototype;
		n.x = function() {
			Z(this, Y);
		};
		n.B = function(a, b$1) {
			switch (a) {
				case 100142: return;
				case 100140:
					switch (b$1) {
						case 100130:
						case 100131:
						case 100132:
						case 100133:
						case 100134:
							this.s = b$1;
							return;
					}
					break;
				case 100141:
					this.m = !!b$1;
					return;
				default:
					V(this, 100900);
					return;
			}
			V(this, 100901);
		};
		n.y = function(a) {
			switch (a) {
				case 100142: return 0;
				case 100140: return this.s;
				case 100141: return this.m;
				default: V(this, 100900);
			}
			return !1;
		};
		n.A = function(a, b$1, c) {
			this.j[0] = a;
			this.j[1] = b$1;
			this.j[2] = c;
		};
		n.z = function(a, b$1) {
			var c = b$1 ? b$1 : null;
			switch (a) {
				case 100100:
				case 100106:
					this.h = c;
					break;
				case 100104:
				case 100110:
					this.l = c;
					break;
				case 100101:
				case 100107:
					this.k = c;
					break;
				case 100102:
				case 100108:
					this.i = c;
					break;
				case 100103:
				case 100109:
					this.p = c;
					break;
				case 100105:
				case 100111:
					this.o = c;
					break;
				case 100112:
					this.r = c;
					break;
				default: V(this, 100900);
			}
		};
		n.C = function(a, b$1) {
			var c = !1, d$1 = [
				0,
				0,
				0
			];
			Z(this, 2);
			for (var e$1 = 0; 3 > e$1; ++e$1) {
				var f = a[e$1];
				-1e150 > f && (f = -1e150, c = !0);
				1e150 < f && (f = 1e150, c = !0);
				d$1[e$1] = f;
			}
			c && V(this, 100155);
			c = this.q;
			null === c ? (c = ea(this.b), E(c, c.b)) : (K(c), c = c.e);
			c.a.d = b$1;
			c.a.g[0] = d$1[0];
			c.a.g[1] = d$1[1];
			c.a.g[2] = d$1[2];
			c.f = 1;
			c.b.f = -1;
			this.q = c;
		};
		n.u = function(a) {
			Z(this, Y);
			this.d = 1;
			this.b = new Ca();
			this.c = a;
		};
		n.t = function() {
			Z(this, 1);
			this.d = 2;
			this.q = null;
		};
		n.v = function() {
			Z(this, 2);
			this.d = 1;
		};
		n.w = function() {
			Z(this, 1);
			this.d = Y;
			var a = this.j[0], b$1 = this.j[1], c = this.j[2], d$1 = !1, e$1 = [
				a,
				b$1,
				c
			];
			if (0 === a && 0 === b$1 && 0 === c) {
				for (var b$1 = [
					-2 * 1e150,
					-2 * 1e150,
					-2 * 1e150
				], f = [
					2 * 1e150,
					2 * 1e150,
					2 * 1e150
				], c = [], g$1 = [], d$1 = this.b.c, a = d$1.e; a !== d$1; a = a.e) for (var h = 0; 3 > h; ++h) {
					var k = a.g[h];
					k < f[h] && (f[h] = k, g$1[h] = a);
					k > b$1[h] && (b$1[h] = k, c[h] = a);
				}
				a = 0;
				b$1[1] - f[1] > b$1[0] - f[0] && (a = 1);
				b$1[2] - f[2] > b$1[a] - f[a] && (a = 2);
				if (f[a] >= b$1[a]) e$1[0] = 0, e$1[1] = 0, e$1[2] = 1;
				else {
					b$1 = 0;
					f = g$1[a];
					c = c[a];
					g$1 = [
						0,
						0,
						0
					];
					f = [
						f.g[0] - c.g[0],
						f.g[1] - c.g[1],
						f.g[2] - c.g[2]
					];
					h = [
						0,
						0,
						0
					];
					for (a = d$1.e; a !== d$1; a = a.e) h[0] = a.g[0] - c.g[0], h[1] = a.g[1] - c.g[1], h[2] = a.g[2] - c.g[2], g$1[0] = f[1] * h[2] - f[2] * h[1], g$1[1] = f[2] * h[0] - f[0] * h[2], g$1[2] = f[0] * h[1] - f[1] * h[0], k = g$1[0] * g$1[0] + g$1[1] * g$1[1] + g$1[2] * g$1[2], k > b$1 && (b$1 = k, e$1[0] = g$1[0], e$1[1] = g$1[1], e$1[2] = g$1[2]);
					0 >= b$1 && (e$1[0] = e$1[1] = e$1[2] = 0, e$1[ha(f)] = 1);
				}
				d$1 = !0;
			}
			g$1 = ha(e$1);
			a = this.b.c;
			b$1 = (g$1 + 1) % 3;
			c = (g$1 + 2) % 3;
			g$1 = 0 < e$1[g$1] ? 1 : -1;
			for (e$1 = a.e; e$1 !== a; e$1 = e$1.e) e$1.b = e$1.g[b$1], e$1.a = g$1 * e$1.g[c];
			if (d$1) {
				e$1 = 0;
				d$1 = this.b.a;
				for (a = d$1.b; a !== d$1; a = a.b) if (b$1 = a.a, !(0 >= b$1.f)) do
					e$1 += (b$1.a.b - b$1.b.a.b) * (b$1.a.a + b$1.b.a.a), b$1 = b$1.e;
				while (b$1 !== a.a);
				if (0 > e$1) for (e$1 = this.b.c, d$1 = e$1.e; d$1 !== e$1; d$1 = d$1.e) d$1.a = -d$1.a;
			}
			this.n = !1;
			e$1 = this.b.b;
			for (a = e$1.h; a !== e$1; a = d$1) if (d$1 = a.h, b$1 = a.e, t(a.a, a.b.a) && a.e.e !== a && (ta(this, b$1, a), I(a), a = b$1, b$1 = a.e), b$1.e === a) {
				if (b$1 !== a) {
					if (b$1 === d$1 || b$1 === d$1.b) d$1 = d$1.h;
					I(b$1);
				}
				if (a === d$1 || a === d$1.b) d$1 = d$1.h;
				I(a);
			}
			this.e = e$1 = new Da();
			d$1 = this.b.c;
			for (a = d$1.e; a !== d$1; a = a.e) a.h = xa(e$1, a);
			Ea(e$1);
			this.f = new Aa(this);
			za(this, -O);
			for (za(this, O); null !== (e$1 = Fa(this.e));) {
				for (;;) {
					a: if (a = this.e, 0 === a.a) d$1 = Ga(a.b);
					else if (d$1 = a.c[a.d[a.a - 1]], 0 !== a.b.a && (a = Ga(a.b), u(a, d$1))) {
						d$1 = a;
						break a;
					}
					if (null === d$1 || !t(d$1, e$1)) break;
					d$1 = Fa(this.e);
					ta(this, e$1.c, d$1.c);
				}
				ya(this, e$1);
			}
			this.a = this.f.a.a.b.a.a;
			for (e$1 = 0; null !== (d$1 = this.f.a.a.b);) d$1.h || ++e$1, Q(d$1);
			this.f = null;
			e$1 = this.e;
			e$1.b = null;
			e$1.d = null;
			this.e = e$1.c = null;
			e$1 = this.b;
			for (a = e$1.a.b; a !== e$1.a; a = d$1) d$1 = a.b, a = a.a, a.e.e === a && (P(a.c, a), I(a));
			if (!this.n) {
				e$1 = this.b;
				if (this.m) for (a = e$1.b.h; a !== e$1.b; a = d$1) d$1 = a.h, a.b.d.c !== a.d.c ? a.f = a.d.c ? 1 : -1 : I(a);
				else for (a = e$1.a.b; a !== e$1.a; a = d$1) if (d$1 = a.b, a.c) {
					for (a = a.a; u(a.b.a, a.a); a = a.c.b);
					for (; u(a.a, a.b.a); a = a.e);
					b$1 = a.c.b;
					for (c = void 0; a.e !== b$1;) if (u(a.b.a, b$1.a)) {
						for (; b$1.e !== a && (ca(b$1.e) || 0 >= x(b$1.a, b$1.b.a, b$1.e.b.a));) c = L(b$1.e, b$1), b$1 = c.b;
						b$1 = b$1.c.b;
					} else {
						for (; b$1.e !== a && (da(a.c.b) || 0 <= x(a.b.a, a.a, a.c.b.a));) c = L(a, a.c.b), a = c.b;
						a = a.e;
					}
					for (; b$1.e.e !== a;) c = L(b$1.e, b$1), b$1 = c.b;
				}
				if (this.h || this.i || this.k || this.l) if (this.m) {
					for (e$1 = this.b, d$1 = e$1.a.b; d$1 !== e$1.a; d$1 = d$1.b) if (d$1.c) {
						this.h && this.h(2, this.c);
						a = d$1.a;
						do
							this.k && this.k(a.a.d, this.c), a = a.e;
						while (a !== d$1.a);
						this.i && this.i(this.c);
					}
				} else {
					e$1 = this.b;
					d$1 = !!this.l;
					a = !1;
					b$1 = -1;
					for (c = e$1.a.d; c !== e$1.a; c = c.d) if (c.c) {
						a || (this.h && this.h(4, this.c), a = !0);
						g$1 = c.a;
						do
							d$1 && (f = g$1.b.d.c ? 0 : 1, b$1 !== f && (b$1 = f, this.l && this.l(!!b$1, this.c))), this.k && this.k(g$1.a.d, this.c), g$1 = g$1.e;
						while (g$1 !== c.a);
					}
					a && this.i && this.i(this.c);
				}
				if (this.r) {
					e$1 = this.b;
					for (a = e$1.a.b; a !== e$1.a; a = d$1) if (d$1 = a.b, !a.c) {
						b$1 = a.a;
						c = b$1.e;
						g$1 = void 0;
						do
							g$1 = c, c = g$1.e, g$1.d = null, null === g$1.b.d && (g$1.c === g$1 ? F(g$1.a, null) : (g$1.a.c = g$1.c, H(g$1, J(g$1))), f = g$1.b, f.c === f ? F(f.a, null) : (f.a.c = f.c, H(f, J(f))), fa(g$1));
						while (g$1 !== b$1);
						b$1 = a.d;
						a = a.b;
						a.d = b$1;
						b$1.b = a;
					}
					this.r(this.b);
					this.c = this.b = null;
					return;
				}
			}
			this.b = this.c = null;
		};
		function Z(a, b$1) {
			if (a.d !== b$1) for (; a.d !== b$1;) if (a.d < b$1) switch (a.d) {
				case Y:
					V(a, 100151);
					a.u(null);
					break;
				case 1: V(a, 100152), a.t();
			}
			else switch (a.d) {
				case 2:
					V(a, 100154);
					a.v();
					break;
				case 1: V(a, 100153), a.w();
			}
		}
		function V(a, b$1) {
			a.p && a.p(b$1, a.c);
		}
		function ga(a, b$1) {
			this.b = a || this;
			this.d = b$1 || this;
			this.a = null;
			this.c = !1;
		}
		function M() {
			this.h = this;
			this.i = this.d = this.a = this.e = this.c = this.b = null;
			this.f = 0;
		}
		function J(a) {
			return a.b.e;
		}
		function Ca() {
			this.c = new N();
			this.a = new ga();
			this.b = new M();
			this.d = new M();
			this.b.b = this.d;
			this.d.b = this.b;
		}
		function N(a, b$1) {
			this.e = a || this;
			this.f = b$1 || this;
			this.d = this.c = null;
			this.g = [
				0,
				0,
				0
			];
			this.h = this.a = this.b = 0;
		}
		function Da() {
			this.c = [];
			this.d = null;
			this.a = 0;
			this.e = !1;
			this.b = new Ha();
		}
		function Ea(a) {
			a.d = [];
			for (var b$1 = 0; b$1 < a.a; b$1++) a.d[b$1] = b$1;
			a.d.sort(function(a$1) {
				return function(b$2, e$1) {
					return u(a$1[b$2], a$1[e$1]) ? 1 : -1;
				};
			}(a.c));
			a.e = !0;
			Ia(a.b);
		}
		function xa(a, b$1) {
			if (a.e) {
				var c = a.b, d$1 = ++c.a;
				2 * d$1 > c.f && (c.f *= 2, c.c = Ja(c.c, c.f + 1));
				var e$1;
				0 === c.b ? e$1 = d$1 : (e$1 = c.b, c.b = c.c[c.b]);
				c.e[e$1] = b$1;
				c.c[e$1] = d$1;
				c.d[d$1] = e$1;
				c.h && va(c, d$1);
				return e$1;
			}
			c = a.a++;
			a.c[c] = b$1;
			return -(c + 1);
		}
		function Fa(a) {
			if (0 === a.a) return Ka(a.b);
			var b$1 = a.c[a.d[a.a - 1]];
			if (0 !== a.b.a && u(Ga(a.b), b$1)) return Ka(a.b);
			do
				--a.a;
			while (0 < a.a && null === a.c[a.d[a.a - 1]]);
			return b$1;
		}
		function Ha() {
			this.d = Ja([0], 33);
			this.e = [null, null];
			this.c = [0, 0];
			this.a = 0;
			this.f = 32;
			this.b = 0;
			this.h = !1;
			this.d[1] = 1;
		}
		function Ja(a, b$1) {
			for (var c = Array(b$1), d$1 = 0; d$1 < a.length; d$1++) c[d$1] = a[d$1];
			for (; d$1 < b$1; d$1++) c[d$1] = 0;
			return c;
		}
		function Ia(a) {
			for (var b$1 = a.a; 1 <= b$1; --b$1) W(a, b$1);
			a.h = !0;
		}
		function Ga(a) {
			return a.e[a.d[1]];
		}
		function Ka(a) {
			var b$1 = a.d, c = a.e, d$1 = a.c, e$1 = b$1[1], f = c[e$1];
			0 < a.a && (b$1[1] = b$1[a.a], d$1[b$1[1]] = 1, c[e$1] = null, d$1[e$1] = a.b, a.b = e$1, 0 < --a.a && W(a, 1));
			return f;
		}
		function W(a, b$1) {
			for (var c = a.d, d$1 = a.e, e$1 = a.c, f = b$1, g$1 = c[f];;) {
				var h = f << 1;
				h < a.a && u(d$1[c[h + 1]], d$1[c[h]]) && (h += 1);
				var k = c[h];
				if (h > a.a || u(d$1[g$1], d$1[k])) {
					c[f] = g$1;
					e$1[g$1] = f;
					break;
				}
				c[f] = k;
				e$1[k] = f;
				f = h;
			}
		}
		function va(a, b$1) {
			for (var c = a.d, d$1 = a.e, e$1 = a.c, f = b$1, g$1 = c[f];;) {
				var h = f >> 1, k = c[h];
				if (0 === h || u(d$1[k], d$1[g$1])) {
					c[f] = g$1;
					e$1[g$1] = f;
					break;
				}
				c[f] = k;
				e$1[k] = f;
				f = h;
			}
		}
		function ma() {
			this.e = this.a = null;
			this.f = 0;
			this.c = this.b = this.h = this.d = !1;
		}
		function S(a) {
			return a.e.c.b;
		}
		function R(a) {
			return a.e.a.b;
		}
		exports.libtess = {
			GluTesselator: X,
			windingRule: {
				GLU_TESS_WINDING_ODD: 100130,
				GLU_TESS_WINDING_NONZERO: 100131,
				GLU_TESS_WINDING_POSITIVE: 100132,
				GLU_TESS_WINDING_NEGATIVE: 100133,
				GLU_TESS_WINDING_ABS_GEQ_TWO: 100134
			},
			primitiveType: {
				GL_LINE_LOOP: 2,
				GL_TRIANGLES: 4,
				GL_TRIANGLE_STRIP: 5,
				GL_TRIANGLE_FAN: 6
			},
			errorType: {
				GLU_TESS_MISSING_BEGIN_POLYGON: 100151,
				GLU_TESS_MISSING_END_POLYGON: 100153,
				GLU_TESS_MISSING_BEGIN_CONTOUR: 100152,
				GLU_TESS_MISSING_END_CONTOUR: 100154,
				GLU_TESS_COORD_TOO_LARGE: 100155,
				GLU_TESS_NEED_COMBINE_CALLBACK: 100156
			},
			gluEnum: {
				GLU_TESS_MESH: 100112,
				GLU_TESS_TOLERANCE: 100142,
				GLU_TESS_WINDING_RULE: 100140,
				GLU_TESS_BOUNDARY_ONLY: 100141,
				GLU_INVALID_ENUM: 100900,
				GLU_INVALID_VALUE: 100901,
				GLU_TESS_BEGIN: 100100,
				GLU_TESS_VERTEX: 100101,
				GLU_TESS_END: 100102,
				GLU_TESS_ERROR: 100103,
				GLU_TESS_EDGE_FLAG: 100104,
				GLU_TESS_COMBINE: 100105,
				GLU_TESS_BEGIN_DATA: 100106,
				GLU_TESS_VERTEX_DATA: 100107,
				GLU_TESS_END_DATA: 100108,
				GLU_TESS_ERROR_DATA: 100109,
				GLU_TESS_EDGE_FLAG_DATA: 100110,
				GLU_TESS_COMBINE_DATA: 100111
			}
		};
		X.prototype.gluDeleteTess = X.prototype.x;
		X.prototype.gluTessProperty = X.prototype.B;
		X.prototype.gluGetTessProperty = X.prototype.y;
		X.prototype.gluTessNormal = X.prototype.A;
		X.prototype.gluTessCallback = X.prototype.z;
		X.prototype.gluTessVertex = X.prototype.C;
		X.prototype.gluTessBeginPolygon = X.prototype.u;
		X.prototype.gluTessBeginContour = X.prototype.t;
		X.prototype.gluTessEndContour = X.prototype.v;
		X.prototype.gluTessEndPolygon = X.prototype.w;
		if (typeof module !== "undefined") module.exports = exports.libtess;
	})))());
	const INITIAL_BUFFER_STRIDES = {
		vertices: 1,
		vertexNormals: 1,
		vertexColors: 4,
		vertexStrokeColors: 4,
		uvs: 2
	};
	const INITIAL_VERTEX_SIZE = Object.values(INITIAL_BUFFER_STRIDES).reduce((acc, next) => acc + next);
	var ShapeBuilder = class {
		constructor(renderer$1) {
			this.renderer = renderer$1;
			this.shapeMode = PATH;
			this.geometry = new Geometry(void 0, void 0, void 0, this.renderer);
			this.geometry.gid = "__IMMEDIATE_MODE_GEOMETRY__";
			this.contourIndices = [];
			this._useUserVertexProperties = void 0;
			this._bezierVertex = [];
			this._quadraticVertex = [];
			this._curveVertex = [];
			this.isProcessingVertices = false;
			this._tessy = this._initTessy();
			this.tessyVertexSize = INITIAL_VERTEX_SIZE;
			this.bufferStrides = { ...INITIAL_BUFFER_STRIDES };
		}
		constructFromContours(shape$1, contours) {
			if (this._useUserVertexProperties) this._resetUserVertexProperties();
			this.geometry.reset();
			this.contourIndices = [];
			this.shapeMode = shape$1.contours[0].kind;
			const shouldProcessEdges = !!this.renderer.states.strokeColor;
			const userVertexPropertyHelpers = {};
			if (shape$1.userVertexProperties) {
				this._useUserVertexProperties = true;
				for (const key in shape$1.userVertexProperties) {
					const name = shape$1.vertexPropertyName(key);
					const prop = this.geometry._userVertexPropertyHelper(name, [], shape$1.userVertexProperties[key]);
					userVertexPropertyHelpers[key] = prop;
					this.tessyVertexSize += prop.getDataSize();
					this.bufferStrides[prop.getSrcName()] = prop.getDataSize();
					this.renderer.buffers.user.push(new RenderBuffer(prop.getDataSize(), prop.getSrcName(), prop.getDstName(), name, this.renderer));
				}
			} else this._useUserVertexProperties = false;
			for (const contour of contours) {
				this.contourIndices.push(this.geometry.vertices.length);
				for (const vertex$1 of contour) {
					if (this.shapeMode === QUADS) {
						if (this.geometry.vertices.length % 6 === 3) for (const key in this.bufferStrides) {
							const stride = this.bufferStrides[key];
							const buffer = this.geometry[key];
							buffer.push(...buffer.slice(buffer.length - 3 * stride, buffer.length - 2 * stride), ...buffer.slice(buffer.length - stride, buffer.length));
						}
					}
					this.geometry.vertices.push(vertex$1.position);
					this.geometry.vertexNormals.push(vertex$1.normal || new Vector(0, 0, 0));
					this.geometry.uvs.push(vertex$1.textureCoordinates.x, vertex$1.textureCoordinates.y);
					if (this.renderer.states.fillColor) this.geometry.vertexColors.push(...vertex$1.fill.array());
					else this.geometry.vertexColors.push(0, 0, 0, 0);
					if (this.renderer.states.strokeColor) this.geometry.vertexStrokeColors.push(...vertex$1.stroke.array());
					else this.geometry.vertexStrokeColors.push(0, 0, 0, 0);
					for (const key in userVertexPropertyHelpers) {
						const prop = userVertexPropertyHelpers[key];
						if (key in vertex$1) prop.setCurrentData(vertex$1[key]);
						prop.pushCurrentData();
					}
				}
			}
			if (shouldProcessEdges) this.geometry.edges = this._calculateEdges(this.shapeMode, this.geometry.vertices);
			if (shouldProcessEdges && !this.renderer.geometryBuilder) this.geometry._edgesToVertices();
			if (this.shapeMode === PATH) {
				this.isProcessingVertices = true;
				this._tesselateShape();
				this.isProcessingVertices = false;
			} else if (this.shapeMode === QUAD_STRIP) this.shapeMode = TRIANGLE_STRIP;
			else if (this.shapeMode === QUADS) this.shapeMode = TRIANGLES;
			if (this.renderer.states.textureMode === IMAGE && this.renderer.states._tex !== null && this.renderer.states._tex.width > 0 && this.renderer.states._tex.height > 0) this.geometry.uvs = this.geometry.uvs.map((val$1, i$1) => {
				if (i$1 % 2 === 0) return val$1 / this.renderer.states._tex.width;
				else return val$1 / this.renderer.states._tex.height;
			});
		}
		_resetUserVertexProperties() {
			const properties = this.geometry.userVertexProperties;
			for (const propName in properties) {
				const prop = properties[propName];
				delete this.bufferStrides[propName];
				prop.delete();
			}
			this._useUserVertexProperties = false;
			this.tessyVertexSize = INITIAL_VERTEX_SIZE;
			this.geometry.userVertexProperties = {};
		}
		_calculateEdges(shapeMode, verts) {
			const res = [];
			let i$1 = 0;
			const contourIndices = this.contourIndices.slice();
			let contourStart = -1;
			switch (shapeMode) {
				case TRIANGLE_STRIP:
					for (i$1 = 0; i$1 < verts.length - 2; i$1++) {
						res.push([i$1, i$1 + 1]);
						res.push([i$1, i$1 + 2]);
					}
					res.push([i$1, i$1 + 1]);
					break;
				case TRIANGLE_FAN:
					for (i$1 = 1; i$1 < verts.length - 1; i$1++) {
						res.push([0, i$1]);
						res.push([i$1, i$1 + 1]);
					}
					res.push([0, verts.length - 1]);
					break;
				case TRIANGLES:
					for (i$1 = 0; i$1 < verts.length - 2; i$1 = i$1 + 3) {
						res.push([i$1, i$1 + 1]);
						res.push([i$1 + 1, i$1 + 2]);
						res.push([i$1 + 2, i$1]);
					}
					break;
				case LINES:
					for (i$1 = 0; i$1 < verts.length - 1; i$1 = i$1 + 2) res.push([i$1, i$1 + 1]);
					break;
				case QUADS:
					for (i$1 = 0; i$1 < verts.length - 5; i$1 += 6) {
						res.push([i$1, i$1 + 1]);
						res.push([i$1 + 1, i$1 + 2]);
						res.push([i$1 + 2, i$1 + 5]);
						res.push([i$1 + 5, i$1]);
					}
					break;
				case QUAD_STRIP:
					for (i$1 = 0; i$1 < verts.length - 2; i$1 += 2) {
						res.push([i$1, i$1 + 1]);
						res.push([i$1 + 1, i$1 + 3]);
						res.push([i$1, i$1 + 2]);
					}
					res.push([i$1, i$1 + 1]);
					break;
				default:
					for (i$1 = 0; i$1 < verts.length; i$1++) if (i$1 === contourIndices[0]) contourStart = contourIndices.shift();
					else if (verts[contourStart] && verts[i$1].equals(verts[contourStart])) res.push([i$1 - 1, contourStart]);
					else res.push([i$1 - 1, i$1]);
					break;
			}
			return res;
		}
		_tesselateShape() {
			this.shapeMode = TRIANGLES;
			const contours = [];
			for (let i$1 = 0; i$1 < this.geometry.vertices.length; i$1++) {
				if (this.contourIndices.length > 0 && this.contourIndices[0] === i$1) {
					this.contourIndices.shift();
					contours.push([]);
				}
				contours[contours.length - 1].push(this.geometry.vertices[i$1].x, this.geometry.vertices[i$1].y, this.geometry.vertices[i$1].z, this.geometry.uvs[i$1 * 2], this.geometry.uvs[i$1 * 2 + 1], this.geometry.vertexColors[i$1 * 4], this.geometry.vertexColors[i$1 * 4 + 1], this.geometry.vertexColors[i$1 * 4 + 2], this.geometry.vertexColors[i$1 * 4 + 3], this.geometry.vertexNormals[i$1].x, this.geometry.vertexNormals[i$1].y, this.geometry.vertexNormals[i$1].z);
				for (const propName in this.geometry.userVertexProperties) {
					const prop = this.geometry.userVertexProperties[propName];
					const start = i$1 * prop.getDataSize();
					const end = start + prop.getDataSize();
					const vals = prop.getSrcArray().slice(start, end);
					contours[contours.length - 1].push(...vals);
				}
			}
			const polyTriangles = this._triangulate(contours);
			const originalVertices = this.geometry.vertices;
			this.geometry.vertices = [];
			this.geometry.vertexNormals = [];
			this.geometry.uvs = [];
			for (const propName in this.geometry.userVertexProperties) this.geometry.userVertexProperties[propName].resetSrcArray();
			const colors = [];
			for (let j = 0, polyTriLength = polyTriangles.length; j < polyTriLength; j = j + this.tessyVertexSize) {
				colors.push(...polyTriangles.slice(j + 5, j + 9));
				this.geometry.vertexNormals.push(new Vector(...polyTriangles.slice(j + 9, j + 12)));
				{
					let offset = 12;
					for (const propName in this.geometry.userVertexProperties) {
						const prop = this.geometry.userVertexProperties[propName];
						const size = prop.getDataSize();
						const start = j + offset;
						const end = start + size;
						prop.setCurrentData(polyTriangles.slice(start, end));
						prop.pushCurrentData();
						offset += size;
					}
				}
				this.geometry.vertices.push(new Vector(...polyTriangles.slice(j, j + 3)));
				this.geometry.uvs.push(...polyTriangles.slice(j + 3, j + 5));
			}
			if (this.renderer.geometryBuilder) {
				const newIndex = /* @__PURE__ */ new Map();
				this.geometry.edges = this.geometry.edges.map((edge) => edge.map((origIdx) => {
					if (!newIndex.has(origIdx)) {
						const orig = originalVertices[origIdx];
						let newVertIndex = this.geometry.vertices.findIndex((v$1) => orig.x === v$1.x && orig.y === v$1.y && orig.z === v$1.z);
						if (newVertIndex === -1) {
							let closestDist = Infinity;
							let closestIndex = 0;
							for (let i$1 = 0; i$1 < this.geometry.vertices.length; i$1++) {
								const vert = this.geometry.vertices[i$1];
								const dX = orig.x - vert.x;
								const dY = orig.y - vert.y;
								const dZ = orig.z - vert.z;
								const dist = dX * dX + dY * dY + dZ * dZ;
								if (dist < closestDist) {
									closestDist = dist;
									closestIndex = i$1;
								}
							}
							newVertIndex = closestIndex;
						}
						newIndex.set(origIdx, newVertIndex);
					}
					return newIndex.get(origIdx);
				}));
			}
			this.geometry.vertexColors = colors;
		}
		_initTessy() {
			function vertexCallback(data$2, polyVertArray) {
				for (const element$1 of data$2) polyVertArray.push(element$1);
			}
			function begincallback(type$2) {
				if (type$2 !== import_libtess_min.default.primitiveType.GL_TRIANGLES) console.log(`expected TRIANGLES but got type: ${type$2}`);
			}
			function errorcallback(errno) {
				console.log("error callback");
				console.log(`error number: ${errno}`);
			}
			const combinecallback = (coords, data$2, weight) => {
				const result = new Array(this.tessyVertexSize).fill(0);
				for (let i$1 = 0; i$1 < weight.length; i$1++) for (let j = 0; j < result.length; j++) {
					if (weight[i$1] === 0 || !data$2[i$1]) continue;
					result[j] += data$2[i$1][j] * weight[i$1];
				}
				return result;
			};
			function edgeCallback(flag) {}
			const tessy = new import_libtess_min.default.GluTesselator();
			tessy.gluTessCallback(import_libtess_min.default.gluEnum.GLU_TESS_VERTEX_DATA, vertexCallback);
			tessy.gluTessCallback(import_libtess_min.default.gluEnum.GLU_TESS_BEGIN, begincallback);
			tessy.gluTessCallback(import_libtess_min.default.gluEnum.GLU_TESS_ERROR, errorcallback);
			tessy.gluTessCallback(import_libtess_min.default.gluEnum.GLU_TESS_COMBINE, combinecallback);
			tessy.gluTessCallback(import_libtess_min.default.gluEnum.GLU_TESS_EDGE_FLAG, edgeCallback);
			tessy.gluTessProperty(import_libtess_min.default.gluEnum.GLU_TESS_WINDING_RULE, import_libtess_min.default.windingRule.GLU_TESS_WINDING_NONZERO);
			return tessy;
		}
		_triangulate(contours) {
			const z$1 = contours[0] ? contours[0][2] : void 0;
			let allSameZ = true;
			for (const contour of contours) for (let j = 0; j < contour.length; j += this.tessyVertexSize) if (contour[j + 2] !== z$1) {
				allSameZ = false;
				break;
			}
			if (allSameZ) this._tessy.gluTessNormal(0, 0, 1);
			else this._tessy.gluTessNormal(0, 0, 0);
			const triangleVerts = [];
			this._tessy.gluTessBeginPolygon(triangleVerts);
			for (const contour of contours) {
				this._tessy.gluTessBeginContour();
				for (let j = 0; j < contour.length; j += this.tessyVertexSize) {
					const coords = contour.slice(j, j + this.tessyVertexSize);
					this._tessy.gluTessVertex(coords, coords);
				}
				this._tessy.gluTessEndContour();
			}
			this._tessy.gluTessEndPolygon();
			return triangleVerts;
		}
	};
	var GeometryBufferCache = class {
		constructor(renderer$1) {
			this.renderer = renderer$1;
			this.cache = {};
		}
		numCached() {
			return Object.keys(this.cache).length;
		}
		isCached(gid) {
			return this.cache[gid] !== void 0;
		}
		getGeometryByID(gid) {
			return this.cache[gid]?.geometry;
		}
		getCached(model) {
			return this.getCachedID(model.gid);
		}
		getCachedID(gid) {
			return this.cache[gid];
		}
		ensureCached(geometry$1) {
			const gid = geometry$1.gid;
			if (!gid) throw new Error("The p5.Geometry you passed in has no gid property!");
			if (this.isCached(geometry$1.gid)) return this.getCached(geometry$1);
			const gl = this.renderer.GL;
			this.freeBuffers(gid);
			if (Object.keys(this.cache).length > 1e3) {
				const key = Object.keys(this.cache)[0];
				this.freeBuffers(key);
			}
			const buffers = {};
			this.cache[gid] = buffers;
			buffers.geometry = geometry$1;
			let indexBuffer = buffers.indexBuffer;
			if (geometry$1.faces.length) {
				if (!indexBuffer) indexBuffer = buffers.indexBuffer = gl.createBuffer();
				const vals = geometry$1.faces.flat();
				const hasVertexIndicesOverMaxUInt16 = vals.some((v$1) => v$1 > 65535);
				let type$2 = hasVertexIndicesOverMaxUInt16 ? Uint32Array : Uint16Array;
				this.renderer._bindBuffer(indexBuffer, gl.ELEMENT_ARRAY_BUFFER, vals, type$2);
				buffers.indexBufferType = hasVertexIndicesOverMaxUInt16 ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;
			} else if (indexBuffer) {
				gl.deleteBuffer(indexBuffer);
				buffers.indexBuffer = null;
			}
			return buffers;
		}
		freeBuffers(gid) {
			const buffers = this.cache[gid];
			if (!buffers) return;
			delete this.cache[gid];
			const gl = this.renderer.GL;
			if (buffers.indexBuffer) gl.deleteBuffer(buffers.indexBuffer);
			function freeBuffers(defs) {
				for (const def of defs) if (buffers[def.dst]) {
					gl.deleteBuffer(buffers[def.dst]);
					buffers[def.dst] = null;
				}
			}
			freeBuffers(this.renderer.buffers.stroke);
			freeBuffers(this.renderer.buffers.fill);
			freeBuffers(this.renderer.buffers.user);
		}
	};
	const filterParamDefaults = {
		[BLUR]: 3,
		[POSTERIZE]: 4,
		[THRESHOLD]: .5
	};
	function trigonometry(p5$2, fn$1) {
		const DEGREES = fn$1.DEGREES = "degrees";
		const RADIANS = fn$1.RADIANS = "radians";
		fn$1._angleMode = RADIANS;
		fn$1.acos = function(ratio) {
			return this._fromRadians(Math.acos(ratio));
		};
		fn$1.asin = function(ratio) {
			return this._fromRadians(Math.asin(ratio));
		};
		fn$1.atan = function(ratio) {
			return this._fromRadians(Math.atan(ratio));
		};
		fn$1.atan2 = function(y, x$1) {
			return this._fromRadians(Math.atan2(y, x$1));
		};
		fn$1.cos = function(angle) {
			return Math.cos(this._toRadians(angle));
		};
		fn$1.sin = function(angle) {
			return Math.sin(this._toRadians(angle));
		};
		fn$1.tan = function(angle) {
			return Math.tan(this._toRadians(angle));
		};
		fn$1.degrees = (angle) => angle * RAD_TO_DEG;
		fn$1.radians = (angle) => angle * DEG_TO_RAD;
		fn$1.angleMode = function(mode) {
			if (typeof mode === "undefined") return this._angleMode;
			else if (mode === DEGREES || mode === RADIANS) {
				if (mode === this._angleMode) return;
				if (mode === RADIANS) {
					this.pRotationX = this.pRotationX * DEG_TO_RAD;
					this.pRotationY = this.pRotationY * DEG_TO_RAD;
					this.pRotationZ = this.pRotationZ * DEG_TO_RAD;
				} else {
					this.pRotationX = this.pRotationX * RAD_TO_DEG;
					this.pRotationY = this.pRotationY * RAD_TO_DEG;
					this.pRotationZ = this.pRotationZ * RAD_TO_DEG;
				}
				this._angleMode = mode;
			}
		};
		fn$1._toRadians = function(angle) {
			if (this._angleMode === DEGREES) return angle * DEG_TO_RAD;
			return angle;
		};
		fn$1._toDegrees = function(angle) {
			if (this._angleMode === RADIANS) return angle * RAD_TO_DEG;
			return angle;
		};
		fn$1._fromRadians = function(angle) {
			if (this._angleMode === DEGREES) return angle * RAD_TO_DEG;
			return angle;
		};
		fn$1._fromDegrees = function(angle) {
			if (this._angleMode === RADIANS) return angle * DEG_TO_RAD;
			return angle;
		};
	}
	if (typeof p5 !== "undefined") trigonometry(p5, p5.prototype);
	function image$1(p5$2, fn$1) {
		fn$1.createImage = function(width, height) {
			return new p5$2.Image(width, height);
		};
		fn$1.saveCanvas = function(...args) {
			let htmlCanvas, filename, extension, temporaryGraphics;
			if (args[0] instanceof HTMLCanvasElement) {
				htmlCanvas = args[0];
				args.shift();
			} else if (args[0] instanceof Element) {
				htmlCanvas = args[0].elt;
				args.shift();
			} else if (args[0] instanceof Framebuffer) {
				const framebuffer$1 = args[0];
				temporaryGraphics = this.createGraphics(framebuffer$1.width, framebuffer$1.height);
				temporaryGraphics.pixelDensity(framebuffer$1.pixelDensity());
				framebuffer$1.loadPixels();
				temporaryGraphics.loadPixels();
				temporaryGraphics.pixels.set(framebuffer$1.pixels);
				temporaryGraphics.updatePixels();
				htmlCanvas = temporaryGraphics._renderer.canvas;
				args.shift();
			} else htmlCanvas = this._curElement && this._curElement.elt;
			if (args.length >= 1) filename = args[0];
			if (args.length >= 2) extension = args[1];
			extension = extension || fn$1._checkFileExtension(filename, extension)[1] || "png";
			let mimeType;
			switch (extension) {
				default:
					mimeType = "image/png";
					break;
				case "webp":
					mimeType = "image/webp";
					break;
				case "jpeg":
				case "jpg":
					mimeType = "image/jpeg";
					break;
			}
			htmlCanvas.toBlob((blob) => {
				fn$1.downloadFile(blob, filename, extension);
				if (temporaryGraphics) temporaryGraphics.remove();
			}, mimeType);
		};
		fn$1.encodeAndDownloadGif = function(pImg, filename) {
			const props = pImg.gifProperties;
			let loopLimit = props.loopLimit;
			if (loopLimit === 1) loopLimit = null;
			else if (loopLimit === null) loopLimit = 0;
			const buffer = new Uint8Array(pImg.width * pImg.height * props.numFrames);
			const allFramesPixelColors = [];
			const paletteFreqsAndFrames = {};
			for (let i$1 = 0; i$1 < props.numFrames; i$1++) {
				const paletteSet = /* @__PURE__ */ new Set();
				const data$2 = props.frames[i$1].image.data;
				const dataLength = data$2.length;
				const pixelColors = new Uint32Array(pImg.width * pImg.height);
				for (let j = 0, k = 0; j < dataLength; j += 4, k++) {
					const r = data$2[j + 0];
					const g$1 = data$2[j + 1];
					const b$1 = data$2[j + 2];
					const color$2 = r << 16 | g$1 << 8 | b$1 << 0;
					paletteSet.add(color$2);
					pixelColors[k] = color$2;
				}
				const paletteStr = [...paletteSet].sort().toString();
				if (paletteFreqsAndFrames[paletteStr] === void 0) paletteFreqsAndFrames[paletteStr] = {
					freq: 1,
					frames: [i$1]
				};
				else {
					paletteFreqsAndFrames[paletteStr].freq += 1;
					paletteFreqsAndFrames[paletteStr].frames.push(i$1);
				}
				allFramesPixelColors.push(pixelColors);
			}
			let framesUsingGlobalPalette = [];
			const palettesSortedByFreq = Object.keys(paletteFreqsAndFrames).sort(function(a, b$1) {
				return paletteFreqsAndFrames[b$1].freq - paletteFreqsAndFrames[a].freq;
			});
			const globalPalette = palettesSortedByFreq[0].split(",").map((a) => parseInt(a));
			framesUsingGlobalPalette = framesUsingGlobalPalette.concat(paletteFreqsAndFrames[globalPalette].frames);
			const globalPaletteSet = new Set(globalPalette);
			for (let i$1 = 1; i$1 < palettesSortedByFreq.length; i$1++) {
				const difference = palettesSortedByFreq[i$1].split(",").map((a) => parseInt(a)).filter((x$1) => !globalPaletteSet.has(x$1));
				if (globalPalette.length + difference.length <= 256) {
					for (let j = 0; j < difference.length; j++) {
						globalPalette.push(difference[j]);
						globalPaletteSet.add(difference[j]);
					}
					framesUsingGlobalPalette = framesUsingGlobalPalette.concat(paletteFreqsAndFrames[palettesSortedByFreq[i$1]].frames);
				}
			}
			framesUsingGlobalPalette = new Set(framesUsingGlobalPalette);
			const globalIndicesLookup = {};
			for (let i$1 = 0; i$1 < globalPalette.length; i$1++) if (!globalIndicesLookup[globalPalette[i$1]]) globalIndicesLookup[globalPalette[i$1]] = i$1;
			let powof2 = 1;
			while (powof2 < globalPalette.length) powof2 <<= 1;
			globalPalette.length = powof2;
			const opts = {
				loop: loopLimit,
				palette: new Uint32Array(globalPalette)
			};
			const gifWriter = new import_omggif.GifWriter(buffer, pImg.width, pImg.height, opts);
			let previousFrame = {};
			for (let i$1 = 0; i$1 < props.numFrames; i$1++) {
				const localPaletteRequired = !framesUsingGlobalPalette.has(i$1);
				const palette = localPaletteRequired ? [] : globalPalette;
				const pixelPaletteIndex = new Uint8Array(pImg.width * pImg.height);
				const colorIndicesLookup = {};
				const cannotBeTransparent = /* @__PURE__ */ new Set();
				allFramesPixelColors[i$1].forEach((color$2, k) => {
					if (localPaletteRequired) {
						if (colorIndicesLookup[color$2] === void 0) {
							colorIndicesLookup[color$2] = palette.length;
							palette.push(color$2);
						}
						pixelPaletteIndex[k] = colorIndicesLookup[color$2];
					} else pixelPaletteIndex[k] = globalIndicesLookup[color$2];
					if (i$1 > 0) {
						if (allFramesPixelColors[i$1 - 1][k] !== color$2) cannotBeTransparent.add(color$2);
					}
				});
				const frameOpts = {};
				const canBeTransparent = palette.filter((a) => !cannotBeTransparent.has(a));
				if (canBeTransparent.length > 0) {
					const transparent = canBeTransparent[0];
					const transparentIndex = localPaletteRequired ? colorIndicesLookup[transparent] : globalIndicesLookup[transparent];
					if (i$1 > 0) {
						for (let k = 0; k < allFramesPixelColors[i$1].length; k++) if (allFramesPixelColors[i$1 - 1][k] === allFramesPixelColors[i$1][k]) pixelPaletteIndex[k] = transparentIndex;
						frameOpts.transparent = transparentIndex;
						previousFrame.frameOpts.disposal = 1;
					}
				}
				frameOpts.delay = props.frames[i$1].delay / 10;
				if (localPaletteRequired) {
					let powof2$1 = 1;
					while (powof2$1 < palette.length) powof2$1 <<= 1;
					palette.length = powof2$1;
					frameOpts.palette = new Uint32Array(palette);
				}
				if (i$1 > 0) gifWriter.addFrame(0, 0, pImg.width, pImg.height, previousFrame.pixelPaletteIndex, previousFrame.frameOpts);
				previousFrame = {
					pixelPaletteIndex,
					frameOpts
				};
			}
			previousFrame.frameOpts.disposal = 1;
			gifWriter.addFrame(0, 0, pImg.width, pImg.height, previousFrame.pixelPaletteIndex, previousFrame.frameOpts);
			const extension = "gif";
			const blob = new Blob([buffer.slice(0, gifWriter.end())], { type: "image/gif" });
			fn$1.downloadFile(blob, filename, extension);
		};
		fn$1.saveFrames = function(fName, ext, _duration, _fps, callback) {
			let duration$2 = _duration || 3;
			duration$2 = Math.max(Math.min(duration$2, 15), 0);
			duration$2 = duration$2 * 1e3;
			let fps = _fps || 15;
			fps = Math.max(Math.min(fps, 22), 0);
			let count = 0;
			const makeFrame = fn$1._makeFrame;
			const cnv = this._curElement.elt;
			let frames = [];
			const frameFactory = setInterval(() => {
				frames.push(makeFrame(fName + count, ext, cnv));
				count++;
			}, 1e3 / fps);
			setTimeout(() => {
				clearInterval(frameFactory);
				if (callback) callback(frames);
				else for (const f of frames) fn$1.downloadFile(f.imageData, f.filename, f.ext);
				frames = [];
			}, duration$2 + .01);
		};
		fn$1._makeFrame = function(filename, extension, _cnv) {
			let cnv;
			if (this) cnv = this._curElement.elt;
			else cnv = _cnv;
			let mimeType;
			if (!extension) {
				extension = "png";
				mimeType = "image/png";
			} else switch (extension.toLowerCase()) {
				case "png":
					mimeType = "image/png";
					break;
				case "jpeg":
					mimeType = "image/jpeg";
					break;
				case "jpg":
					mimeType = "image/jpeg";
					break;
				default:
					mimeType = "image/png";
					break;
			}
			const downloadMime = "image/octet-stream";
			let imageData = cnv.toDataURL(mimeType);
			imageData = imageData.replace(mimeType, downloadMime);
			const thisFrame = {};
			thisFrame.imageData = imageData;
			thisFrame.filename = filename;
			thisFrame.ext = extension;
			return thisFrame;
		};
	}
	if (typeof p5 !== "undefined") image$1(p5, p5.prototype);
	var HTTPError = class extends Error {
		status;
		response;
		ok;
	};
	async function request(path$1, type$2) {
		try {
			const res = await fetch(path$1);
			if (res.ok) {
				let data$2;
				switch (type$2) {
					case "json":
						data$2 = await res.json();
						break;
					case "text":
						data$2 = await res.text();
						break;
					case "arrayBuffer":
						data$2 = await res.arrayBuffer();
						break;
					case "blob":
						data$2 = await res.blob();
						break;
					case "bytes":
						if (res.bytes) data$2 = await res.bytes();
						else {
							const d$1 = await res.arrayBuffer();
							data$2 = new Uint8Array(d$1);
						}
						break;
					default: throw new Error("Unsupported response type");
				}
				return {
					data: data$2,
					headers: res.headers
				};
			} else {
				const err$1 = new HTTPError(res.statusText);
				err$1.status = res.status;
				err$1.response = res;
				err$1.ok = false;
				throw err$1;
			}
		} catch (err$1) {
			if (err$1 instanceof TypeError) console.log("You may have encountered a CORS error");
			else if (err$1 instanceof HTTPError) console.log("You have encountered a HTTP error");
			else if (err$1 instanceof SyntaxError) console.log("There is an error parsing the response to requested data structure");
			throw err$1;
		}
	}
	function files(p5$2, fn$1) {
		fn$1.loadJSON = async function(path$1, successCallback, errorCallback) {
			try {
				const { data: data$2 } = await request(path$1, "json");
				if (successCallback) return successCallback(data$2);
				return data$2;
			} catch (err$1) {
				p5$2._friendlyFileLoadError(5, path$1);
				if (errorCallback) return errorCallback(err$1);
				else throw err$1;
			}
		};
		fn$1.loadStrings = async function(path$1, successCallback, errorCallback) {
			try {
				let { data: data$2 } = await request(path$1, "text");
				data$2 = data$2.split(/\r?\n/);
				if (successCallback) return successCallback(data$2);
				return data$2;
			} catch (err$1) {
				p5$2._friendlyFileLoadError(3, path$1);
				if (errorCallback) return errorCallback(err$1);
				else throw err$1;
			}
		};
		fn$1.loadTable = async function(path$1, separator, header, successCallback, errorCallback) {
			if (typeof arguments[arguments.length - 1] === "function") if (typeof arguments[arguments.length - 2] === "function") {
				successCallback = arguments[arguments.length - 2];
				errorCallback = arguments[arguments.length - 1];
			} else successCallback = arguments[arguments.length - 1];
			if (typeof separator !== "string") separator = ",";
			if (typeof header === "function") header = false;
			try {
				let { data: data$2 } = await request(path$1, "text");
				let ret = new p5$2.Table();
				data$2 = parse$3(data$2, { separator });
				if (header) ret.columns = data$2.shift();
				else ret.columns = Array(data$2[0].length).fill(null);
				data$2.forEach((line) => {
					const row = new p5$2.TableRow(line);
					ret.addRow(row);
				});
				if (successCallback) return successCallback(ret);
				else return ret;
			} catch (err$1) {
				p5$2._friendlyFileLoadError(2, path$1);
				if (errorCallback) return errorCallback(err$1);
				else throw err$1;
			}
		};
		fn$1.loadXML = async function(path$1, successCallback, errorCallback) {
			try {
				const parser = new DOMParser();
				let { data: data$2 } = await request(path$1, "text");
				const parsedDOM = parser.parseFromString(data$2, "application/xml");
				data$2 = new p5$2.XML(parsedDOM);
				if (successCallback) return successCallback(data$2);
				return data$2;
			} catch (err$1) {
				p5$2._friendlyFileLoadError(1, path$1);
				if (errorCallback) return errorCallback(err$1);
				else throw err$1;
			}
		};
		fn$1.loadBytes = async function(path$1, successCallback, errorCallback) {
			try {
				let { data: data$2 } = await request(path$1, "arrayBuffer");
				data$2 = new Uint8Array(data$2);
				if (successCallback) return successCallback(data$2);
				return data$2;
			} catch (err$1) {
				p5$2._friendlyFileLoadError(6, path$1);
				if (errorCallback) return errorCallback(err$1);
				else throw err$1;
			}
		};
		fn$1.loadBlob = async function(path$1, successCallback, errorCallback) {
			try {
				const { data: data$2 } = await request(path$1, "blob");
				if (successCallback) return successCallback(data$2);
				return data$2;
			} catch (err$1) {
				if (errorCallback) return errorCallback(err$1);
				else throw err$1;
			}
		};
		fn$1.httpGet = async function(path$1, datatype = "text", successCallback, errorCallback) {
			if (typeof datatype === "function") {
				errorCallback = successCallback;
				successCallback = datatype;
				datatype = "text";
			}
			return this.httpDo(path$1, "GET", datatype, successCallback, errorCallback);
		};
		fn$1.httpPost = async function(path$1, data$2, datatype = "text", successCallback, errorCallback) {
			if (typeof data$2 === "function") {
				successCallback = data$2;
				errorCallback = datatype;
				data$2 = void 0;
				datatype = "text";
			} else if (typeof datatype === "function") {
				errorCallback = successCallback;
				successCallback = datatype;
				datatype = "text";
			}
			let reqData = data$2;
			let contentType = "text/plain";
			if (data$2 instanceof p5$2.XML) {
				reqData = data$2.serialize();
				contentType = "application/xml";
			} else if (data$2 instanceof p5$2.Image) {
				reqData = await data$2.toBlob();
				contentType = "image/png";
			} else if (typeof data$2 === "object") {
				reqData = JSON.stringify(data$2);
				contentType = "application/json";
			}
			const requestOptions = {
				method: "POST",
				body: reqData,
				headers: { "Content-Type": contentType }
			};
			if (reqData) requestOptions.body = reqData;
			const req = new Request(path$1, requestOptions);
			return this.httpDo(req, "POST", datatype, successCallback, errorCallback);
		};
		fn$1.httpDo = async function(path$1, method, datatype, successCallback, errorCallback) {
			if (typeof datatype === "function") {
				errorCallback = successCallback;
				successCallback = datatype;
				datatype = void 0;
			}
			if (!datatype) switch (typeof path$1 === "string" ? path$1.split(".").pop() : path$1.url.split(".").pop()) {
				case "json":
					datatype = "json";
					break;
				case "jpg":
				case "jpeg":
				case "png":
				case "webp":
				case "gif":
					datatype = "blob";
					break;
				case "xml":
				case "txt":
				default: datatype = "text";
			}
			const req = new Request(path$1, { method });
			try {
				const { data: data$2 } = await request(req, datatype);
				if (successCallback) return successCallback(data$2);
				else return data$2;
			} catch (err$1) {
				if (errorCallback) return errorCallback(err$1);
				else throw err$1;
			}
		};
		fn$1._pWriters = [];
		fn$1.createWriter = function(name, extension) {
			let newPW;
			for (const i$1 in fn$1._pWriters) if (fn$1._pWriters[i$1].name === name) {
				newPW = new p5$2.PrintWriter(name + this.millis(), extension);
				fn$1._pWriters.push(newPW);
				return newPW;
			}
			newPW = new p5$2.PrintWriter(name, extension);
			fn$1._pWriters.push(newPW);
			return newPW;
		};
		p5$2.PrintWriter = function(filename, extension) {
			let self$1 = this;
			this.name = filename;
			this.content = "";
			this.write = function(data$2) {
				this.content += data$2;
			};
			this.print = function(data$2) {
				this.content += `${data$2}\n`;
			};
			this.clear = function() {
				this.content = "";
			};
			this.close = function() {
				const arr$1 = [];
				arr$1.push(this.content);
				fn$1.writeFile(arr$1, filename, extension);
				for (const i$1 in fn$1._pWriters) if (fn$1._pWriters[i$1].name === this.name) fn$1._pWriters.splice(i$1, 1);
				self$1.clear();
				self$1 = {};
			};
		};
		fn$1.save = function(object$1, _filename, _options) {
			const args = arguments;
			const cnv = this._curElement ? this._curElement.elt : this.elt;
			if (args.length === 0) {
				fn$1.saveCanvas(cnv);
				return;
			} else if (args[0] instanceof Renderer || args[0] instanceof Graphics) {
				fn$1.saveCanvas(args[0].canvas, args[1], args[2]);
				return;
			} else if (args.length === 1 && typeof args[0] === "string") fn$1.saveCanvas(cnv, args[0]);
			else switch (_checkFileExtension(args[1], args[2])[1]) {
				case "json":
					fn$1.saveJSON(args[0], args[1], args[2]);
					return;
				case "txt":
					fn$1.saveStrings(args[0], args[1], args[2]);
					return;
				default: if (args[0] instanceof Array) fn$1.saveStrings(args[0], args[1], args[2]);
				else if (args[0] instanceof p5$2.Table) fn$1.saveTable(args[0], args[1], args[2]);
				else if (args[0] instanceof p5$2.Image) fn$1.saveCanvas(args[0].canvas, args[1]);
				else if (args[0] instanceof p5$2.SoundFile) fn$1.saveSound(args[0], args[1], args[2], args[3]);
			}
		};
		fn$1.saveJSON = function(json, filename, optimize) {
			let stringify$1;
			if (optimize) stringify$1 = JSON.stringify(json);
			else stringify$1 = JSON.stringify(json, void 0, 2);
			this.saveStrings(stringify$1.split("\n"), filename, "json");
		};
		fn$1.saveStrings = function(list$1, filename, extension, isCRLF) {
			const ext = extension || "txt";
			const pWriter = new p5$2.PrintWriter(filename, ext);
			for (let item of list$1) isCRLF ? pWriter.write(item + "\r\n") : pWriter.write(item + "\n");
			pWriter.close();
			pWriter.clear();
		};
		function escapeHelper(content) {
			return content.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
		}
		fn$1.saveTable = function(table$1, filename, options$1) {
			let ext;
			if (options$1 === void 0) {
				ext = filename.substring(filename.lastIndexOf(".") + 1, filename.length);
				if (ext === filename) ext = "csv";
			} else ext = options$1;
			const pWriter = this.createWriter(filename, ext);
			const header = table$1.columns;
			let sep = ",";
			if (ext === "tsv") sep = "	";
			if (ext !== "html") {
				const output = table$1.toString(sep);
				pWriter.write(output);
			} else {
				pWriter.print("<html>");
				pWriter.print("<head>");
				let str = "  <meta http-equiv=\"content-type\" content";
				str += "=\"text/html;charset=utf-8\" />";
				pWriter.print(str);
				pWriter.print("</head>");
				pWriter.print("<body>");
				pWriter.print("  <table>");
				if (header[0] !== "0") {
					pWriter.print("    <tr>");
					for (let k = 0; k < header.length; k++) {
						const e$1 = escapeHelper(header[k]);
						pWriter.print(`      <td>${e$1}`);
						pWriter.print("      </td>");
					}
					pWriter.print("    </tr>");
				}
				for (let row = 0; row < table$1.rows.length; row++) {
					pWriter.print("    <tr>");
					for (let col = 0; col < table$1.columns.length; col++) {
						const htmlEntry = escapeHelper(table$1.rows[row].getString(col));
						pWriter.print(`      <td>${htmlEntry}`);
						pWriter.print("      </td>");
					}
					pWriter.print("    </tr>");
				}
				pWriter.print("  </table>");
				pWriter.print("</body>");
				pWriter.print("</html>");
			}
			pWriter.close();
			pWriter.clear();
		};
		fn$1.writeFile = function(dataToDownload, filename, extension) {
			let type$2 = "application/octet-stream";
			if (fn$1._isSafari()) type$2 = "text/plain";
			const blob = new Blob(dataToDownload, { type: type$2 });
			fn$1.downloadFile(blob, filename, extension);
		};
		fn$1.downloadFile = downloadFile;
		fn$1._checkFileExtension = _checkFileExtension;
		fn$1._isSafari = function() {
			return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
		};
	}
	if (typeof p5 !== "undefined") files(p5, p5.prototype);
	function loadingDisplaying(p5$2, fn$1) {
		fn$1.loadImage = async function(path$1, successCallback, failureCallback) {
			try {
				let pImg = new p5$2.Image(1, 1, this);
				const { data: data$2, headers } = await request(new Request(path$1, {
					method: "GET",
					mode: "cors"
				}), "bytes");
				const contentType = headers.get("content-type");
				if (contentType === null) console.warn("The image you loaded does not have a Content-Type header. If you are using the online editor consider reuploading the asset.");
				if (contentType && contentType.includes("image/gif")) await _createGif(data$2, pImg);
				else {
					const blob = new Blob([data$2]);
					const img = await createImageBitmap(blob);
					pImg.width = pImg.canvas.width = img.width;
					pImg.height = pImg.canvas.height = img.height;
					pImg.drawingContext.drawImage(img, 0, 0);
				}
				pImg.modified = true;
				if (successCallback) return successCallback(pImg);
				else return pImg;
			} catch (err$1) {
				p5$2._friendlyFileLoadError(0, path$1);
				if (typeof failureCallback === "function") return failureCallback(err$1);
				else throw err$1;
			}
		};
		fn$1.saveGif = async function(fileName, duration$2, options$1 = {
			delay: 0,
			units: "seconds",
			silent: false,
			notificationDuration: 0,
			notificationID: "progressBar"
		}) {
			if (typeof fileName !== "string") throw TypeError("fileName parameter must be a string");
			if (typeof duration$2 !== "number") throw TypeError("Duration parameter must be a number");
			const delay = options$1 && options$1.delay || 0;
			const units = options$1 && options$1.units || "seconds";
			const silent = options$1 && options$1.silent || false;
			const notificationDuration = options$1 && options$1.notificationDuration || 0;
			const notificationID = options$1 && options$1.notificationID || "progressBar";
			if (typeof delay !== "number") throw TypeError("Delay parameter must be a number");
			if (units !== "seconds" && units !== "frames") throw TypeError("Units parameter must be either \"frames\" or \"seconds\"");
			if (typeof silent !== "boolean") throw TypeError("Silent parameter must be a boolean");
			if (typeof notificationDuration !== "number") throw TypeError("Notification duration parameter must be a number");
			if (typeof notificationID !== "string") throw TypeError("Notification ID parameter must be a string");
			this._recording = true;
			let _frameRate = this._targetFrameRate;
			if (_frameRate === Infinity || _frameRate === void 0 || _frameRate === 0) _frameRate = 60;
			let gifFrameDelay = 1 / _frameRate * 1e3;
			gifFrameDelay = gifFrameDelay < 20 ? 20 : gifFrameDelay;
			const nFrames = units === "seconds" ? duration$2 * _frameRate : duration$2;
			const nFramesDelay = units === "seconds" ? delay * _frameRate : delay;
			const totalNumberOfFrames = nFrames + nFramesDelay;
			let frameIterator = nFramesDelay;
			this.frameCount = frameIterator;
			const lastPixelDensity = this._renderer._pixelDensity;
			this.pixelDensity(1);
			let frames = [];
			if (document.getElementById(notificationID) !== null) document.getElementById(notificationID).remove();
			let p$1;
			if (!silent) {
				p$1 = this.createP("");
				p$1.id(notificationID);
				p$1.style("font-size", "16px");
				p$1.style("font-family", "Montserrat");
				p$1.style("background-color", "#ffffffa0");
				p$1.style("padding", "8px");
				p$1.style("border-radius", "10px");
				p$1.position(0, 0);
			}
			let pixels$1;
			let gl;
			if (this._renderer instanceof p5$2.RendererGL) {
				gl = this.drawingContext;
				pixels$1 = new Uint8Array(gl.drawingBufferWidth * gl.drawingBufferHeight * 4);
			}
			this.noLoop();
			await Promise.resolve();
			while (frameIterator < totalNumberOfFrames) {
				this.redraw();
				let data$2 = void 0;
				if (this._renderer instanceof p5$2.RendererGL) {
					pixels$1 = new Uint8Array(gl.drawingBufferWidth * gl.drawingBufferHeight * 4);
					gl.readPixels(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixels$1);
					data$2 = _flipPixels(pixels$1, this.width, this.height);
				} else data$2 = this.drawingContext.getImageData(0, 0, this.width, this.height).data;
				frames.push(data$2);
				frameIterator++;
				if (!silent) p$1.html("Saved frame <b>" + frames.length.toString() + "</b> out of " + nFrames.toString());
				await new Promise((resolve) => setTimeout(resolve, 0));
			}
			if (!silent) p$1.html("Frames processed, generating color palette...");
			this.loop();
			this.pixelDensity(lastPixelDensity);
			const gif = (0, import_gifenc.GIFEncoder)();
			const globalPalette = _generateGlobalPalette(frames);
			const paletteCache = {};
			const getIndexedFrame = (frame) => {
				const length = frame.length / 4;
				const index = new Uint8Array(length);
				for (let i$1 = 0; i$1 < length; i$1++) {
					const key = frame[i$1 * 4] << 24 | frame[i$1 * 4 + 1] << 16 | frame[i$1 * 4 + 2] << 8 | frame[i$1 * 4 + 3];
					if (paletteCache[key] === void 0) paletteCache[key] = (0, import_gifenc.nearestColorIndex)(globalPalette, frame.slice(i$1 * 4, (i$1 + 1) * 4));
					index[i$1] = paletteCache[key];
				}
				return index;
			};
			const transparentIndex = globalPalette.length - 1;
			let prevIndexedFrame = [];
			for (let i$1 = 0; i$1 < frames.length; i$1++) {
				const indexedFrame = getIndexedFrame(frames[i$1]);
				const originalIndexedFrame = indexedFrame.slice();
				if (i$1 === 0) gif.writeFrame(indexedFrame, this.width, this.height, {
					palette: globalPalette,
					delay: gifFrameDelay,
					dispose: 1
				});
				else {
					for (let i$2 = 0; i$2 < indexedFrame.length; i$2++) if (indexedFrame[i$2] === prevIndexedFrame[i$2]) indexedFrame[i$2] = transparentIndex;
					gif.writeFrame(indexedFrame, this.width, this.height, {
						delay: gifFrameDelay,
						transparent: true,
						transparentIndex,
						dispose: 1
					});
				}
				prevIndexedFrame = originalIndexedFrame;
				if (!silent) p$1.html("Rendered frame <b>" + i$1.toString() + "</b> out of " + nFrames.toString());
				await new Promise((resolve) => setTimeout(resolve, 0));
			}
			gif.finish();
			const buffer = gif.bytesView();
			const extension = "gif";
			const blob = new Blob([buffer], { type: "image/gif" });
			frames = [];
			this._recording = false;
			this.loop();
			if (!silent) {
				p$1.html("Done. Downloading your gif!🌸");
				if (notificationDuration > 0) setTimeout(() => p$1.remove(), notificationDuration * 1e3);
			}
			fn$1.downloadFile(blob, fileName, extension);
		};
		function _flipPixels(pixels$1, width, height) {
			const halfHeight = parseInt(height / 2);
			const bytesPerRow = width * 4;
			const temp = new Uint8Array(width * 4);
			for (let y = 0; y < halfHeight; ++y) {
				const topOffset = y * bytesPerRow;
				const bottomOffset = (height - y - 1) * bytesPerRow;
				temp.set(pixels$1.subarray(topOffset, topOffset + bytesPerRow));
				pixels$1.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
				pixels$1.set(temp, bottomOffset);
			}
			return pixels$1;
		}
		function _generateGlobalPalette(frames) {
			let allColors = new Uint8Array(frames.length * frames[0].length);
			for (let f = 0; f < frames.length; f++) allColors.set(frames[f], f * frames[0].length);
			let colorPalette = (0, import_gifenc.quantize)(allColors, 256, {
				format: "rgba4444",
				oneBitAlpha: true
			});
			if (colorPalette.length === 256) colorPalette[colorPalette.length - 1] = [
				Math.random() * 255,
				Math.random() * 255,
				Math.random() * 255,
				0
			];
			else colorPalette.push([
				Math.random() * 255,
				Math.random() * 255,
				Math.random() * 255,
				0
			]);
			return colorPalette;
		}
		async function _createGif(arrayBuffer, pImg) {
			const gifReader = new import_omggif.GifReader(arrayBuffer);
			pImg.width = pImg.canvas.width = gifReader.width;
			pImg.height = pImg.canvas.height = gifReader.height;
			const frames = [];
			const numFrames = gifReader.numFrames();
			let framePixels = new Uint8ClampedArray(pImg.width * pImg.height * 4);
			const loadGIFFrameIntoImage = (frameNum, gifReader$1) => {
				try {
					gifReader$1.decodeAndBlitFrameRGBA(frameNum, framePixels);
				} catch (e$1) {
					p5$2._friendlyFileLoadError(8, pImg.src);
					throw e$1;
				}
			};
			for (let j = 0; j < numFrames; j++) {
				const frameInfo = gifReader.frameInfo(j);
				const prevFrameData = pImg.drawingContext.getImageData(0, 0, pImg.width, pImg.height);
				framePixels = prevFrameData.data.slice();
				loadGIFFrameIntoImage(j, gifReader);
				const imageData = new ImageData(framePixels, pImg.width, pImg.height);
				pImg.drawingContext.putImageData(imageData, 0, 0);
				let frameDelay = frameInfo.delay;
				if (frameDelay === 0) frameDelay = 10;
				frames.push({
					image: pImg.drawingContext.getImageData(0, 0, pImg.width, pImg.height),
					delay: frameDelay * 10
				});
				if (frameInfo.disposal === 2) pImg.drawingContext.clearRect(frameInfo.x, frameInfo.y, frameInfo.width, frameInfo.height);
				else if (frameInfo.disposal === 3) pImg.drawingContext.putImageData(prevFrameData, 0, 0, frameInfo.x, frameInfo.y, frameInfo.width, frameInfo.height);
			}
			let loopLimit = gifReader.loopCount();
			if (loopLimit === null) loopLimit = 1;
			else if (loopLimit === 0) loopLimit = null;
			pImg.drawingContext.putImageData(frames[0].image, 0, 0);
			if (frames.length > 1) pImg.gifProperties = {
				displayIndex: 0,
				loopLimit,
				loopCount: 0,
				frames,
				numFrames,
				playing: true,
				timeDisplayed: 0,
				lastChangeTime: 0
			};
			return pImg;
		}
		function _imageContain(xAlign, yAlign, dx, dy, dw, dh, sw, sh) {
			const r = Math.max(sw / dw, sh / dh);
			const [adjusted_dw, adjusted_dh] = [sw / r, sh / r];
			let x$1 = dx;
			let y = dy;
			if (xAlign === CENTER) x$1 += (dw - adjusted_dw) / 2;
			else if (xAlign === RIGHT) x$1 += dw - adjusted_dw;
			if (yAlign === CENTER) y += (dh - adjusted_dh) / 2;
			else if (yAlign === BOTTOM) y += dh - adjusted_dh;
			return {
				x: x$1,
				y,
				w: adjusted_dw,
				h: adjusted_dh
			};
		}
		function _imageCover(xAlign, yAlign, dw, dh, sx, sy, sw, sh) {
			const r = Math.max(dw / sw, dh / sh);
			const [adjusted_sw, adjusted_sh] = [dw / r, dh / r];
			let x$1 = sx;
			let y = sy;
			if (xAlign === CENTER) x$1 += (sw - adjusted_sw) / 2;
			else if (xAlign === RIGHT) x$1 += sw - adjusted_sw;
			if (yAlign === CENTER) y += (sh - adjusted_sh) / 2;
			else if (yAlign === BOTTOM) y += sh - adjusted_sh;
			return {
				x: x$1,
				y,
				w: adjusted_sw,
				h: adjusted_sh
			};
		}
		function _imageFit(fit, xAlign, yAlign, dx, dy, dw, dh, sx, sy, sw, sh) {
			if (fit === COVER) {
				const { x: x$1, y, w, h } = _imageCover(xAlign, yAlign, dw, dh, sx, sy, sw, sh);
				sx = x$1;
				sy = y;
				sw = w;
				sh = h;
			}
			if (fit === CONTAIN) {
				const { x: x$1, y, w, h } = _imageContain(xAlign, yAlign, dx, dy, dw, dh, sw, sh);
				dx = x$1;
				dy = y;
				dw = w;
				dh = h;
			}
			return {
				sx,
				sy,
				sw,
				sh,
				dx,
				dy,
				dw,
				dh
			};
		}
		function _sAssign(sVal, iVal) {
			if (sVal > 0 && sVal < iVal) return sVal;
			else return iVal;
		}
		fn$1.image = function(img, dx, dy, dWidth, dHeight, sx, sy, sWidth, sHeight, fit, xAlign, yAlign) {
			let defW = img.width;
			let defH = img.height;
			yAlign = yAlign || CENTER;
			xAlign = xAlign || CENTER;
			if (img.elt) {
				defW = defW !== void 0 ? defW : img.elt.width;
				defH = defH !== void 0 ? defH : img.elt.height;
			}
			if (img.elt && img.elt.videoWidth && !img.canvas) {
				defW = defW !== void 0 ? defW : img.elt.videoWidth;
				defH = defH !== void 0 ? defH : img.elt.videoHeight;
			}
			let _dx = dx;
			let _dy = dy;
			let _dw = dWidth || defW;
			let _dh = dHeight || defH;
			let _sx = sx || 0;
			let _sy = sy || 0;
			let _sw = sWidth !== void 0 ? sWidth : defW;
			let _sh = sHeight !== void 0 ? sHeight : defH;
			_sw = _sAssign(_sw, defW);
			_sh = _sAssign(_sh, defH);
			let pd = 1;
			if (img.elt && !img.canvas && img.elt.style.width) {
				if (img.elt.videoWidth && !dWidth) pd = img.elt.videoWidth;
				else pd = img.elt.width;
				pd /= parseInt(img.elt.style.width, 10);
			}
			_sx *= pd;
			_sy *= pd;
			_sh *= pd;
			_sw *= pd;
			let vals = canvas.modeAdjust(_dx, _dy, _dw, _dh, this._renderer.states.imageMode);
			vals = _imageFit(fit, xAlign, yAlign, vals.x, vals.y, vals.w, vals.h, _sx, _sy, _sw, _sh);
			this._renderer.image(img, vals.sx, vals.sy, vals.sw, vals.sh, vals.dx, vals.dy, vals.dw, vals.dh);
		};
		fn$1.tint = function(...args) {
			const c = this.color(...args);
			this._renderer.states.setValue("tint", c._getRGBA([
				255,
				255,
				255,
				255
			]));
		};
		fn$1.noTint = function() {
			this._renderer.states.setValue("tint", null);
		};
		fn$1.imageMode = function(m) {
			if (m === CORNER || m === CORNERS || m === CENTER) this._renderer.states.setValue("imageMode", m);
		};
	}
	if (typeof p5 !== "undefined") loadingDisplaying(p5, p5.prototype);
	var Camera = class Camera {
		constructor(renderer$1) {
			this._renderer = renderer$1;
			this.cameraType = "default";
			this.useLinePerspective = true;
			this.cameraMatrix = new Matrix(4);
			this.projMatrix = new Matrix(4);
			this.yScale = 1;
		}
		perspective(fovy, aspect, near, far) {
			this.cameraType = arguments.length > 0 ? "custom" : "default";
			if (typeof fovy === "undefined") {
				fovy = this.defaultCameraFOV;
				this.cameraFOV = fovy;
			} else this.cameraFOV = this._renderer._pInst._toRadians(fovy);
			if (typeof aspect === "undefined") aspect = this.defaultAspectRatio;
			if (typeof near === "undefined") near = this.defaultCameraNear;
			if (typeof far === "undefined") far = this.defaultCameraFar;
			if (near <= 1e-4) {
				near = .01;
				console.log("Avoid perspective near plane values close to or below 0. Setting value to 0.01.");
			}
			if (far < near) console.log("Perspective far plane value is less than near plane value. Nothing will be shown.");
			this.aspectRatio = aspect;
			this.cameraNear = near;
			this.cameraFar = far;
			this.projMatrix = new Matrix(4);
			const f = 1 / Math.tan(this.cameraFOV / 2);
			const nf = 1 / (this.cameraNear - this.cameraFar);
			this.projMatrix.set(f / aspect, 0, 0, 0, 0, -f * this.yScale, 0, 0, 0, 0, (far + near) * nf, -1, 0, 0, 2 * far * near * nf, 0);
			if (this._isActive()) {
				this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
				this._renderer.states.uPMatrix.set(this.projMatrix);
			}
		}
		ortho(left, right, bottom, top, near, far) {
			const source = this.fbo || this._renderer;
			if (left === void 0) left = -source.width / 2;
			if (right === void 0) right = +source.width / 2;
			if (bottom === void 0) bottom = -source.height / 2;
			if (top === void 0) top = +source.height / 2;
			if (near === void 0) near = 0;
			if (far === void 0) far = Math.max(source.width, source.height) + 800;
			this.cameraNear = near;
			this.cameraFar = far;
			const w = right - left;
			const h = top - bottom;
			const d$1 = far - near;
			const x$1 = 2 / w;
			const y = 2 / h * this.yScale;
			const z$1 = -2 / d$1;
			const tx = -(right + left) / w;
			const ty = -(top + bottom) / h;
			const tz = -(far + near) / d$1;
			this.projMatrix = new Matrix(4);
			this.projMatrix.set(x$1, 0, 0, 0, 0, -y, 0, 0, 0, 0, z$1, 0, tx, ty, tz, 1);
			if (this._isActive()) {
				this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
				this._renderer.states.uPMatrix.set(this.projMatrix);
			}
			this.cameraType = "custom";
		}
		frustum(left, right, bottom, top, near, far) {
			if (left === void 0) left = -this._renderer.width * .05;
			if (right === void 0) right = +this._renderer.width * .05;
			if (bottom === void 0) bottom = +this._renderer.height * .05;
			if (top === void 0) top = -this._renderer.height * .05;
			if (near === void 0) near = this.defaultCameraNear;
			if (far === void 0) far = this.defaultCameraFar;
			this.cameraNear = near;
			this.cameraFar = far;
			const w = right - left;
			const h = top - bottom;
			const d$1 = far - near;
			const x$1 = +(2 * near) / w;
			const y = +(2 * near) / h * this.yScale;
			const z$1 = -(2 * far * near) / d$1;
			const tx = (right + left) / w;
			const ty = (top + bottom) / h;
			const tz = -(far + near) / d$1;
			this.projMatrix = new Matrix(4);
			this.projMatrix.set(x$1, 0, 0, 0, 0, -y, 0, 0, tx, ty, tz, -1, 0, 0, z$1, 0);
			if (this._isActive()) {
				this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
				this._renderer.states.uPMatrix.set(this.projMatrix);
			}
			this.cameraType = "custom";
		}
		_rotateView(a, x$1, y, z$1) {
			let centerX = this.centerX;
			let centerY = this.centerY;
			let centerZ = this.centerZ;
			centerX -= this.eyeX;
			centerY -= this.eyeY;
			centerZ -= this.eyeZ;
			const rotation = new Matrix(4);
			rotation.rotate4x4(this._renderer._pInst._toRadians(a), x$1, y, z$1);
			const rotatedCenter = [
				centerX * rotation.mat4[0] + centerY * rotation.mat4[4] + centerZ * rotation.mat4[8],
				centerX * rotation.mat4[1] + centerY * rotation.mat4[5] + centerZ * rotation.mat4[9],
				centerX * rotation.mat4[2] + centerY * rotation.mat4[6] + centerZ * rotation.mat4[10]
			];
			rotatedCenter[0] += this.eyeX;
			rotatedCenter[1] += this.eyeY;
			rotatedCenter[2] += this.eyeZ;
			this.camera(this.eyeX, this.eyeY, this.eyeZ, rotatedCenter[0], rotatedCenter[1], rotatedCenter[2], this.upX, this.upY, this.upZ);
		}
		roll(amount) {
			const local = this._getLocalAxes();
			const newUpVector = Quat.fromAxisAngle(this._renderer._pInst._toRadians(amount), local.z[0], local.z[1], local.z[2]).rotateVector(new Vector(this.upX, this.upY, this.upZ));
			this.camera(this.eyeX, this.eyeY, this.eyeZ, this.centerX, this.centerY, this.centerZ, newUpVector.x, newUpVector.y, newUpVector.z);
		}
		pan(amount) {
			const local = this._getLocalAxes();
			this._rotateView(amount, local.y[0], local.y[1], local.y[2]);
		}
		tilt(amount) {
			const local = this._getLocalAxes();
			this._rotateView(amount, local.x[0], local.x[1], local.x[2]);
		}
		lookAt(x$1, y, z$1) {
			this.camera(this.eyeX, this.eyeY, this.eyeZ, x$1, y, z$1, this.upX, this.upY, this.upZ);
		}
		camera(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {
			if (typeof eyeX === "undefined") {
				eyeX = this.defaultEyeX;
				eyeY = this.defaultEyeY;
				eyeZ = this.defaultEyeZ;
				centerX = eyeX;
				centerY = eyeY;
				centerZ = 0;
				upX = 0;
				upY = 1;
				upZ = 0;
			}
			this.eyeX = eyeX;
			this.eyeY = eyeY;
			this.eyeZ = eyeZ;
			if (typeof centerX !== "undefined") {
				this.centerX = centerX;
				this.centerY = centerY;
				this.centerZ = centerZ;
			}
			if (typeof upX !== "undefined") {
				this.upX = upX;
				this.upY = upY;
				this.upZ = upZ;
			}
			const local = this._getLocalAxes();
			this.cameraMatrix.set(local.x[0], local.y[0], local.z[0], 0, local.x[1], local.y[1], local.z[1], 0, local.x[2], local.y[2], local.z[2], 0, 0, 0, 0, 1);
			const tx = -eyeX;
			const ty = -eyeY;
			const tz = -eyeZ;
			this.cameraMatrix.translate([
				tx,
				ty,
				tz
			]);
			if (this._isActive()) {
				this._renderer.states.setValue("uViewMatrix", this._renderer.states.uViewMatrix.clone());
				this._renderer.states.uViewMatrix.set(this.cameraMatrix);
			}
			return this;
		}
		move(x$1, y, z$1) {
			const local = this._getLocalAxes();
			const dx = [
				local.x[0] * x$1,
				local.x[1] * x$1,
				local.x[2] * x$1
			];
			const dy = [
				local.y[0] * y,
				local.y[1] * y,
				local.y[2] * y
			];
			const dz = [
				local.z[0] * z$1,
				local.z[1] * z$1,
				local.z[2] * z$1
			];
			this.camera(this.eyeX + dx[0] + dy[0] + dz[0], this.eyeY + dx[1] + dy[1] + dz[1], this.eyeZ + dx[2] + dy[2] + dz[2], this.centerX + dx[0] + dy[0] + dz[0], this.centerY + dx[1] + dy[1] + dz[1], this.centerZ + dx[2] + dy[2] + dz[2], this.upX, this.upY, this.upZ);
		}
		setPosition(x$1, y, z$1) {
			const diffX = x$1 - this.eyeX;
			const diffY = y - this.eyeY;
			const diffZ = z$1 - this.eyeZ;
			this.camera(x$1, y, z$1, this.centerX + diffX, this.centerY + diffY, this.centerZ + diffZ, this.upX, this.upY, this.upZ);
		}
		set(cam) {
			for (const keyName of [
				"eyeX",
				"eyeY",
				"eyeZ",
				"centerX",
				"centerY",
				"centerZ",
				"upX",
				"upY",
				"upZ",
				"cameraFOV",
				"aspectRatio",
				"cameraNear",
				"cameraFar",
				"cameraType",
				"yScale",
				"useLinePerspective"
			]) this[keyName] = cam[keyName];
			this.cameraMatrix = cam.cameraMatrix.copy();
			this.projMatrix = cam.projMatrix.copy();
			if (this._isActive()) {
				this._renderer.states.setValue("uModelMatrix", this._renderer.states.uModelMatrix.clone());
				this._renderer.states.setValue("uViewMatrix", this._renderer.states.uViewMatrix.clone());
				this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
				this._renderer.states.uModelMatrix.reset();
				this._renderer.states.uViewMatrix.set(this.cameraMatrix);
				this._renderer.states.uPMatrix.set(this.projMatrix);
			}
		}
		slerp(cam0, cam1, amt) {
			if (amt === 0) {
				this.set(cam0);
				return;
			} else if (amt === 1) {
				this.set(cam1);
				return;
			}
			if (this.projMatrix.mat4[15] !== 0) {
				this.projMatrix.setElement(0, cam0.projMatrix.mat4[0] * Math.pow(cam1.projMatrix.mat4[0] / cam0.projMatrix.mat4[0], amt));
				this.projMatrix.setElement(5, cam0.projMatrix.mat4[5] * Math.pow(cam1.projMatrix.mat4[5] / cam0.projMatrix.mat4[5], amt));
				if (this._isActive()) {
					this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
					this._renderer.states.uPMatrix.mat4 = this.projMatrix.mat4.slice();
				}
			}
			const eye0 = new Vector(cam0.eyeX, cam0.eyeY, cam0.eyeZ);
			const eye1 = new Vector(cam1.eyeX, cam1.eyeY, cam1.eyeZ);
			const center0 = new Vector(cam0.centerX, cam0.centerY, cam0.centerZ);
			const center1 = new Vector(cam1.centerX, cam1.centerY, cam1.centerZ);
			const dist0 = Vector.dist(eye0, center0);
			const dist1 = Vector.dist(eye1, center1);
			const lerpedDist = dist0 * Math.pow(dist1 / dist0, amt);
			const eyeDiff = Vector.sub(eye0, eye1);
			const diffDiff = eye0.copy().sub(eye1).sub(center0).add(center1);
			const divider = diffDiff.magSq();
			let ratio = 1;
			if (divider > 1e-6) {
				ratio = Vector.dot(eyeDiff, diffDiff) / divider;
				ratio = Math.max(0, Math.min(ratio, 1));
			}
			const lerpedMedium = Vector.lerp(Vector.lerp(eye0, center0, ratio), Vector.lerp(eye1, center1, ratio), amt);
			const rotMat0 = cam0.cameraMatrix.createSubMatrix3x3();
			const rotMat1 = cam1.cameraMatrix.createSubMatrix3x3();
			const front0 = rotMat0.row(2);
			const front1 = rotMat1.row(2);
			const up0 = rotMat0.row(1);
			const up1 = rotMat1.row(1);
			const newFront = new Vector();
			const newUp = new Vector();
			const newEye = new Vector();
			const newCenter = new Vector();
			const deltaRot = rotMat1.mult(rotMat0.copy().transpose());
			const diag = deltaRot.diagonal();
			let cosTheta = .5 * (diag[0] + diag[1] + diag[2] - 1);
			if (1 - cosTheta < 1e-7) {
				newFront.set(Vector.lerp(front0, front1, amt)).normalize();
				newEye.set(newFront).mult(ratio * lerpedDist).add(lerpedMedium);
				newCenter.set(newFront).mult((ratio - 1) * lerpedDist).add(lerpedMedium);
				newUp.set(Vector.lerp(up0, up1, amt)).normalize();
				this.camera(newEye.x, newEye.y, newEye.z, newCenter.x, newCenter.y, newCenter.z, newUp.x, newUp.y, newUp.z);
				return;
			}
			let a, b$1, c, sinTheta;
			let invOneMinusCosTheta = 1 / (1 - cosTheta);
			const maxDiag = Math.max(diag[0], diag[1], diag[2]);
			const offDiagSum13 = deltaRot.mat3[1] + deltaRot.mat3[3];
			const offDiagSum26 = deltaRot.mat3[2] + deltaRot.mat3[6];
			const offDiagSum57 = deltaRot.mat3[5] + deltaRot.mat3[7];
			if (maxDiag === diag[0]) {
				a = Math.sqrt((diag[0] - cosTheta) * invOneMinusCosTheta);
				invOneMinusCosTheta /= a;
				b$1 = .5 * offDiagSum13 * invOneMinusCosTheta;
				c = .5 * offDiagSum26 * invOneMinusCosTheta;
				sinTheta = .5 * (deltaRot.mat3[7] - deltaRot.mat3[5]) / a;
			} else if (maxDiag === diag[1]) {
				b$1 = Math.sqrt((diag[1] - cosTheta) * invOneMinusCosTheta);
				invOneMinusCosTheta /= b$1;
				c = .5 * offDiagSum57 * invOneMinusCosTheta;
				a = .5 * offDiagSum13 * invOneMinusCosTheta;
				sinTheta = .5 * (deltaRot.mat3[2] - deltaRot.mat3[6]) / b$1;
			} else {
				c = Math.sqrt((diag[2] - cosTheta) * invOneMinusCosTheta);
				invOneMinusCosTheta /= c;
				a = .5 * offDiagSum26 * invOneMinusCosTheta;
				b$1 = .5 * offDiagSum57 * invOneMinusCosTheta;
				sinTheta = .5 * (deltaRot.mat3[3] - deltaRot.mat3[1]) / c;
			}
			const angle = amt * Math.atan2(sinTheta, cosTheta);
			const cosAngle = Math.cos(angle);
			const sinAngle = Math.sin(angle);
			const oneMinusCosAngle = 1 - cosAngle;
			const ab = a * b$1;
			const bc = b$1 * c;
			const ca$1 = c * a;
			const lerpedRotMat = new Matrix([
				cosAngle + oneMinusCosAngle * a * a,
				oneMinusCosAngle * ab + sinAngle * c,
				oneMinusCosAngle * ca$1 - sinAngle * b$1,
				oneMinusCosAngle * ab - sinAngle * c,
				cosAngle + oneMinusCosAngle * b$1 * b$1,
				oneMinusCosAngle * bc + sinAngle * a,
				oneMinusCosAngle * ca$1 + sinAngle * b$1,
				oneMinusCosAngle * bc - sinAngle * a,
				cosAngle + oneMinusCosAngle * c * c
			]);
			lerpedRotMat.multiplyVec(front0, newFront);
			newEye.set(newFront).mult(ratio * lerpedDist).add(lerpedMedium);
			newCenter.set(newFront).mult((ratio - 1) * lerpedDist).add(lerpedMedium);
			lerpedRotMat.multiplyVec(up0, newUp);
			this.camera(newEye.x, newEye.y, newEye.z, newCenter.x, newCenter.y, newCenter.z, newUp.x, newUp.y, newUp.z);
		}
		_computeCameraDefaultSettings() {
			this.defaultAspectRatio = this._renderer.width / this._renderer.height;
			this.defaultEyeX = 0;
			this.defaultEyeY = 0;
			this.defaultEyeZ = 800;
			this.defaultCameraFOV = 2 * Math.atan(this._renderer.height / 2 / this.defaultEyeZ);
			this.defaultCenterX = 0;
			this.defaultCenterY = 0;
			this.defaultCenterZ = 0;
			this.defaultCameraNear = this.defaultEyeZ * .1;
			this.defaultCameraFar = this.defaultEyeZ * 10;
		}
		_setDefaultCamera() {
			this.cameraFOV = this.defaultCameraFOV;
			this.aspectRatio = this.defaultAspectRatio;
			this.eyeX = this.defaultEyeX;
			this.eyeY = this.defaultEyeY;
			this.eyeZ = this.defaultEyeZ;
			this.centerX = this.defaultCenterX;
			this.centerY = this.defaultCenterY;
			this.centerZ = this.defaultCenterZ;
			this.upX = 0;
			this.upY = 1;
			this.upZ = 0;
			this.cameraNear = this.defaultCameraNear;
			this.cameraFar = this.defaultCameraFar;
			this.perspective();
			this.camera();
			this.cameraType = "default";
		}
		_resize() {
			if (this.cameraType === "default") {
				this._computeCameraDefaultSettings();
				this.cameraFOV = this.defaultCameraFOV;
				this.aspectRatio = this.defaultAspectRatio;
				this.perspective();
			}
		}
		copy() {
			const _cam = new Camera(this._renderer);
			_cam.cameraFOV = this.cameraFOV;
			_cam.aspectRatio = this.aspectRatio;
			_cam.eyeX = this.eyeX;
			_cam.eyeY = this.eyeY;
			_cam.eyeZ = this.eyeZ;
			_cam.centerX = this.centerX;
			_cam.centerY = this.centerY;
			_cam.centerZ = this.centerZ;
			_cam.upX = this.upX;
			_cam.upY = this.upY;
			_cam.upZ = this.upZ;
			_cam.cameraNear = this.cameraNear;
			_cam.cameraFar = this.cameraFar;
			_cam.cameraType = this.cameraType;
			_cam.useLinePerspective = this.useLinePerspective;
			_cam.cameraMatrix = this.cameraMatrix.copy();
			_cam.projMatrix = this.projMatrix.copy();
			_cam.yScale = this.yScale;
			return _cam;
		}
		clone() {
			return this.copy();
		}
		_getLocalAxes() {
			let z0 = this.eyeX - this.centerX;
			let z1 = this.eyeY - this.centerY;
			let z2 = this.eyeZ - this.centerZ;
			const eyeDist = Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
			if (eyeDist !== 0) {
				z0 /= eyeDist;
				z1 /= eyeDist;
				z2 /= eyeDist;
			}
			let y0 = this.upX;
			let y1 = this.upY;
			let y2 = this.upZ;
			let x0 = y1 * z2 - y2 * z1;
			let x1 = -y0 * z2 + y2 * z0;
			let x2 = y0 * z1 - y1 * z0;
			y0 = z1 * x2 - z2 * x1;
			y1 = -z0 * x2 + z2 * x0;
			y2 = z0 * x1 - z1 * x0;
			const xmag = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
			if (xmag !== 0) {
				x0 /= xmag;
				x1 /= xmag;
				x2 /= xmag;
			}
			const ymag = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
			if (ymag !== 0) {
				y0 /= ymag;
				y1 /= ymag;
				y2 /= ymag;
			}
			return {
				x: [
					x0,
					x1,
					x2
				],
				y: [
					y0,
					y1,
					y2
				],
				z: [
					z0,
					z1,
					z2
				]
			};
		}
		_orbit(dTheta, dPhi, dRadius) {
			const diffX = this.eyeX - this.centerX;
			const diffY = this.eyeY - this.centerY;
			const diffZ = this.eyeZ - this.centerZ;
			let camRadius = Math.hypot(diffX, diffY, diffZ);
			const front = new Vector(diffX, diffY, diffZ).normalize();
			const up = new Vector(this.upX, this.upY, this.upZ).normalize();
			const side = Vector.cross(up, front).normalize();
			const vertical = Vector.cross(side, up);
			camRadius *= Math.pow(10, dRadius);
			if (camRadius < this.cameraNear) camRadius = this.cameraNear;
			if (camRadius > this.cameraFar) camRadius = this.cameraFar;
			const camPhi = Math.acos(Math.max(-1, Math.min(1, Vector.dot(front, up)))) + dPhi;
			const camTheta = dTheta;
			if (camPhi <= 0 || camPhi >= Math.PI) {
				this.upX *= -1;
				this.upY *= -1;
				this.upZ *= -1;
			}
			up.mult(Math.cos(camPhi));
			vertical.mult(Math.cos(camTheta) * Math.sin(camPhi));
			side.mult(Math.sin(camTheta) * Math.sin(camPhi));
			front.set(up).add(vertical).add(side);
			this.eyeX = camRadius * front.x + this.centerX;
			this.eyeY = camRadius * front.y + this.centerY;
			this.eyeZ = camRadius * front.z + this.centerZ;
			this.camera(this.eyeX, this.eyeY, this.eyeZ, this.centerX, this.centerY, this.centerZ, this.upX, this.upY, this.upZ);
		}
		_orbitFree(dx, dy, dRadius) {
			const diffX = this.eyeX - this.centerX;
			const diffY = this.eyeY - this.centerY;
			const diffZ = this.eyeZ - this.centerZ;
			let camRadius = Math.hypot(diffX, diffY, diffZ);
			const front = new Vector(diffX, diffY, diffZ).normalize();
			const up = new Vector(this.upX, this.upY, this.upZ);
			const side = Vector.cross(up, front).normalize();
			const down = Vector.cross(front, side);
			const directionAngle = Math.atan2(dy, dx);
			down.mult(Math.sin(directionAngle));
			side.mult(Math.cos(directionAngle)).add(down);
			const rotAngle = Math.sqrt(dx * dx + dy * dy);
			const axis = Vector.cross(front, side);
			camRadius *= Math.pow(10, dRadius);
			if (camRadius < this.cameraNear) camRadius = this.cameraNear;
			if (camRadius > this.cameraFar) camRadius = this.cameraFar;
			const c = Math.cos(rotAngle);
			const s = Math.sin(rotAngle);
			const dotFront = up.dot(front);
			const dotSide = up.dot(side);
			const ux = dotFront * c + dotSide * s;
			const uy = -dotFront * s + dotSide * c;
			const uz = up.dot(axis);
			up.x = ux * front.x + uy * side.x + uz * axis.x;
			up.y = ux * front.y + uy * side.y + uz * axis.y;
			up.z = ux * front.z + uy * side.z + uz * axis.z;
			side.mult(-s);
			front.mult(c).add(side).mult(camRadius);
			this.camera(front.x + this.centerX, front.y + this.centerY, front.z + this.centerZ, this.centerX, this.centerY, this.centerZ, up.x, up.y, up.z);
		}
		_isActive() {
			return this === this._renderer.states.curCamera;
		}
	};
	function camera(p5$2, fn$1) {
		fn$1.camera = function(...args) {
			this._assert3d("camera");
			this._renderer.camera(...args);
			return this;
		};
		fn$1.perspective = function(...args) {
			this._assert3d("perspective");
			this._renderer.perspective(...args);
			return this;
		};
		fn$1.linePerspective = function(enable) {
			if (!(this._renderer instanceof RendererGL)) throw new Error("linePerspective() must be called in WebGL mode.");
			return this._renderer.linePerspective(enable);
		};
		fn$1.ortho = function(...args) {
			this._assert3d("ortho");
			this._renderer.ortho(...args);
			return this;
		};
		fn$1.frustum = function(...args) {
			this._assert3d("frustum");
			this._renderer.frustum(...args);
			return this;
		};
		fn$1.createCamera = function() {
			this._assert3d("createCamera");
			return this._renderer.createCamera();
		};
		fn$1.setCamera = function(cam) {
			this._renderer.setCamera(cam);
		};
		p5$2.Camera = Camera;
		RendererGL.prototype.camera = function(...args) {
			this.states.curCamera.camera(...args);
		};
		RendererGL.prototype.perspective = function(...args) {
			this.states.curCamera.perspective(...args);
		};
		RendererGL.prototype.linePerspective = function(enable) {
			if (enable !== void 0) this.states.curCamera.useLinePerspective = enable;
			else return this.states.curCamera.useLinePerspective;
		};
		RendererGL.prototype.ortho = function(...args) {
			this.states.curCamera.ortho(...args);
		};
		RendererGL.prototype.frustum = function(...args) {
			this.states.curCamera.frustum(...args);
		};
		RendererGL.prototype.createCamera = function() {
			const _cam = new Camera(this);
			_cam._computeCameraDefaultSettings();
			_cam._setDefaultCamera();
			return _cam;
		};
		RendererGL.prototype.setCamera = function(cam) {
			this.states.setValue("curCamera", cam);
			this.states.setValue("uPMatrix", this.states.uPMatrix.clone());
			this.states.uPMatrix.set(cam.projMatrix);
			this.states.setValue("uViewMatrix", this.states.uViewMatrix.clone());
			this.states.uViewMatrix.set(cam.cameraMatrix);
		};
	}
	if (typeof p5 !== "undefined") camera(p5, p5.prototype);
	var Shader = class Shader {
		constructor(renderer$1, vertSrc, fragSrc, options$1 = {}) {
			this._renderer = renderer$1;
			this._vertSrc = vertSrc;
			this._fragSrc = fragSrc;
			this._vertShader = -1;
			this._fragShader = -1;
			this._glProgram = 0;
			this._loadedAttributes = false;
			this.attributes = {};
			this._loadedUniforms = false;
			this.uniforms = {};
			this._bound = false;
			this.samplers = [];
			this.hooks = {
				uniforms: options$1.uniforms || {},
				declarations: options$1.declarations,
				helpers: options$1.helpers || {},
				vertex: options$1.vertex || {},
				fragment: options$1.fragment || {},
				modified: {
					vertex: options$1.modified && options$1.modified.vertex || {},
					fragment: options$1.modified && options$1.modified.fragment || {}
				}
			};
		}
		hookTypes(hookName) {
			let fullSrc = this._vertSrc;
			let body = this.hooks.vertex[hookName];
			if (!body) {
				body = this.hooks.fragment[hookName];
				fullSrc = this._fragSrc;
			}
			if (!body) throw new Error(`Can't find hook ${hookName}!`);
			const nameParts = hookName.split(/\s+/g);
			const functionName = nameParts.pop();
			const returnType = nameParts.pop();
			const returnQualifiers = [...nameParts];
			const parameterMatch = /\(([^\)]*)\)/.exec(body);
			if (!parameterMatch) throw new Error(`Couldn't find function parameters in hook body:\n${body}`);
			const structProperties = (structName) => {
				const structDefMatch = (/* @__PURE__ */ new RegExp(`struct\\s+${structName}\\s*\{([^\}]*)\}`)).exec(fullSrc);
				if (!structDefMatch) return void 0;
				const properties = [];
				for (const defSrc of structDefMatch[1].split(";")) {
					const parts = defSrc.trim().split(/\s+|,/g);
					const typeName = parts.shift();
					const names = [...parts];
					const typeProperties = structProperties(typeName);
					for (const name of names) properties.push({
						name,
						type: {
							typeName,
							qualifiers: [],
							properties: typeProperties
						}
					});
				}
				return properties;
			};
			const parameters = parameterMatch[1].split(",").map((paramString) => {
				const parts = paramString.trim().split(/\s+/g);
				const name = parts.pop();
				const typeName = parts.pop();
				return {
					name,
					type: {
						typeName,
						qualifiers: [...parts],
						properties: structProperties(typeName)
					}
				};
			});
			return {
				name: functionName,
				returnType: {
					typeName: returnType,
					qualifiers: returnQualifiers,
					properties: structProperties(returnType)
				},
				parameters
			};
		}
		shaderSrc(src, shaderType) {
			const main = "void main";
			let [preMain, postMain] = src.split(main);
			let hooks$1 = "";
			let defines = "";
			for (const key in this.hooks.uniforms) hooks$1 += `uniform ${key};\n`;
			if (this.hooks.declarations) hooks$1 += this.hooks.declarations + "\n";
			if (this.hooks[shaderType].declarations) hooks$1 += this.hooks[shaderType].declarations + "\n";
			for (const hookDef in this.hooks.helpers) hooks$1 += `${hookDef}${this.hooks.helpers[hookDef]}\n`;
			for (const hookDef in this.hooks[shaderType]) {
				if (hookDef === "declarations") continue;
				const [hookType, hookName] = hookDef.split(" ");
				if (this.hooks.modified[shaderType][hookDef]) defines += "#define AUGMENTED_HOOK_" + hookName + "\n";
				hooks$1 += hookType + " HOOK_" + hookName + this.hooks[shaderType][hookDef] + "\n";
			}
			if (preMain.indexOf("#define HOOK_DEFINES") !== -1) {
				preMain = preMain.replace("#define HOOK_DEFINES", "\n" + defines + "\n");
				defines = "";
			}
			return preMain + "\n" + defines + hooks$1 + main + postMain;
		}
		version() {
			const match = /#version (.+)$/.exec(this.vertSrc());
			if (match) return match[1];
			else return "100 es";
		}
		vertSrc() {
			return this.shaderSrc(this._vertSrc, "vertex");
		}
		fragSrc() {
			return this.shaderSrc(this._fragSrc, "fragment");
		}
		inspectHooks() {
			console.log("==== Vertex shader hooks: ====");
			for (const key in this.hooks.vertex) console.log((this.hooks.modified.vertex[key] ? "[MODIFIED] " : "") + key + this.hooks.vertex[key]);
			console.log("");
			console.log("==== Fragment shader hooks: ====");
			for (const key in this.hooks.fragment) console.log((this.hooks.modified.fragment[key] ? "[MODIFIED] " : "") + key + this.hooks.fragment[key]);
			console.log("");
			console.log("==== Helper functions: ====");
			for (const key in this.hooks.helpers) console.log(key + this.hooks.helpers[key]);
		}
		modify(hooks$1) {
			const newHooks = {
				vertex: {},
				fragment: {},
				helpers: {}
			};
			for (const key in hooks$1) {
				if (key === "declarations") continue;
				if (key === "uniforms") continue;
				if (key === "vertexDeclarations") newHooks.vertex.declarations = (newHooks.vertex.declarations || "") + "\n" + hooks$1[key];
				else if (key === "fragmentDeclarations") newHooks.fragment.declarations = (newHooks.fragment.declarations || "") + "\n" + hooks$1[key];
				else if (this.hooks.vertex[key]) newHooks.vertex[key] = hooks$1[key];
				else if (this.hooks.fragment[key]) newHooks.fragment[key] = hooks$1[key];
				else newHooks.helpers[key] = hooks$1[key];
			}
			const modifiedVertex = Object.assign({}, this.hooks.modified.vertex);
			const modifiedFragment = Object.assign({}, this.hooks.modified.fragment);
			for (const key in newHooks.vertex || {}) {
				if (key === "declarations") continue;
				modifiedVertex[key] = true;
			}
			for (const key in newHooks.fragment || {}) {
				if (key === "declarations") continue;
				modifiedFragment[key] = true;
			}
			return new Shader(this._renderer, this._vertSrc, this._fragSrc, {
				declarations: (this.hooks.declarations || "") + "\n" + (hooks$1.declarations || ""),
				uniforms: Object.assign({}, this.hooks.uniforms, hooks$1.uniforms || {}),
				fragment: Object.assign({}, this.hooks.fragment, newHooks.fragment || {}),
				vertex: Object.assign({}, this.hooks.vertex, newHooks.vertex || {}),
				helpers: Object.assign({}, this.hooks.helpers, newHooks.helpers || {}),
				modified: {
					vertex: modifiedVertex,
					fragment: modifiedFragment
				}
			});
		}
		init() {
			if (this._glProgram === 0) {
				const gl = this._renderer.GL;
				this._vertShader = gl.createShader(gl.VERTEX_SHADER);
				gl.shaderSource(this._vertShader, this.vertSrc());
				gl.compileShader(this._vertShader);
				if (!gl.getShaderParameter(this._vertShader, gl.COMPILE_STATUS)) {
					const glError = gl.getShaderInfoLog(this._vertShader);
					if (typeof IS_MINIFIED !== "undefined") console.error(glError);
					else throw glError;
					return null;
				}
				this._fragShader = gl.createShader(gl.FRAGMENT_SHADER);
				gl.shaderSource(this._fragShader, this.fragSrc());
				gl.compileShader(this._fragShader);
				if (!gl.getShaderParameter(this._fragShader, gl.COMPILE_STATUS)) {
					const glError = gl.getShaderInfoLog(this._fragShader);
					if (typeof IS_MINIFIED !== "undefined") console.error(glError);
					else throw glError;
					return null;
				}
				this._glProgram = gl.createProgram();
				gl.attachShader(this._glProgram, this._vertShader);
				gl.attachShader(this._glProgram, this._fragShader);
				gl.linkProgram(this._glProgram);
				if (!gl.getProgramParameter(this._glProgram, gl.LINK_STATUS)) p5._friendlyError(`Snap! Error linking shader program: ${gl.getProgramInfoLog(this._glProgram)}`);
				this._loadAttributes();
				this._loadUniforms();
			}
			return this;
		}
		setDefaultUniforms() {
			for (const key in this.hooks.uniforms) {
				const [, name] = key.split(" ");
				const initializer$2 = this.hooks.uniforms[key];
				let value;
				if (initializer$2 instanceof Function) value = initializer$2();
				else value = initializer$2;
				if (value !== void 0 && value !== null) this.setUniform(name, value);
			}
		}
		copyToContext(context) {
			const shader$1 = new Shader(context._renderer, this._vertSrc, this._fragSrc);
			shader$1.ensureCompiledOnContext(context._renderer);
			return shader$1;
		}
		ensureCompiledOnContext(context) {
			if (this._glProgram !== 0 && this._renderer !== context) throw new Error("The shader being run is attached to a different context. Do you need to copy it to this context first with .copyToContext()?");
			else if (this._glProgram === 0) {
				this._renderer = context?._renderer?.filterRenderer?._renderer || context;
				this.init();
			}
		}
		_loadAttributes() {
			if (this._loadedAttributes) return;
			this.attributes = {};
			const gl = this._renderer.GL;
			const numAttributes = gl.getProgramParameter(this._glProgram, gl.ACTIVE_ATTRIBUTES);
			for (let i$1 = 0; i$1 < numAttributes; ++i$1) {
				const attributeInfo = gl.getActiveAttrib(this._glProgram, i$1);
				const name = attributeInfo.name;
				const location$1 = gl.getAttribLocation(this._glProgram, name);
				const attribute = {};
				attribute.name = name;
				attribute.location = location$1;
				attribute.index = i$1;
				attribute.type = attributeInfo.type;
				attribute.size = attributeInfo.size;
				this.attributes[name] = attribute;
			}
			this._loadedAttributes = true;
		}
		_loadUniforms() {
			if (this._loadedUniforms) return;
			const gl = this._renderer.GL;
			const numUniforms = gl.getProgramParameter(this._glProgram, gl.ACTIVE_UNIFORMS);
			let samplerIndex = 0;
			for (let i$1 = 0; i$1 < numUniforms; ++i$1) {
				const uniformInfo = gl.getActiveUniform(this._glProgram, i$1);
				const uniform = {};
				uniform.location = gl.getUniformLocation(this._glProgram, uniformInfo.name);
				uniform.size = uniformInfo.size;
				let uniformName = uniformInfo.name;
				if (uniformInfo.size > 1) uniformName = uniformName.substring(0, uniformName.indexOf("[0]"));
				uniform.name = uniformName;
				uniform.type = uniformInfo.type;
				uniform._cachedData = void 0;
				if (uniform.type === gl.SAMPLER_2D) {
					uniform.samplerIndex = samplerIndex;
					samplerIndex++;
					this.samplers.push(uniform);
				}
				uniform.isArray = uniformInfo.size > 1 || uniform.type === gl.FLOAT_MAT3 || uniform.type === gl.FLOAT_MAT4 || uniform.type === gl.FLOAT_VEC2 || uniform.type === gl.FLOAT_VEC3 || uniform.type === gl.FLOAT_VEC4 || uniform.type === gl.INT_VEC2 || uniform.type === gl.INT_VEC4 || uniform.type === gl.INT_VEC3;
				this.uniforms[uniformName] = uniform;
			}
			this._loadedUniforms = true;
		}
		compile() {}
		bindShader() {
			this.init();
			if (!this._bound) {
				this.useProgram();
				this._bound = true;
			}
		}
		unbindShader() {
			if (this._bound) {
				this.unbindTextures();
				this._bound = false;
			}
			return this;
		}
		bindTextures() {
			const gl = this._renderer.GL;
			const empty$2 = this._renderer._getEmptyTexture();
			for (const uniform of this.samplers) {
				let tex = uniform.texture;
				if (tex === void 0 || false) uniform.texture = tex = empty$2;
				gl.activeTexture(gl.TEXTURE0 + uniform.samplerIndex);
				tex.bindTexture();
				tex.update();
				gl.uniform1i(uniform.location, uniform.samplerIndex);
			}
		}
		updateTextures() {
			for (const uniform of this.samplers) {
				const tex = uniform.texture;
				if (tex) tex.update();
			}
		}
		unbindTextures() {
			const gl = this._renderer.GL;
			const empty$2 = this._renderer._getEmptyTexture();
			for (const uniform of this.samplers) if (uniform.texture?.isFramebufferTexture) {
				gl.activeTexture(gl.TEXTURE0 + uniform.samplerIndex);
				empty$2.bindTexture();
				gl.uniform1i(uniform.location, uniform.samplerIndex);
			}
		}
		useProgram() {
			const gl = this._renderer.GL;
			if (this._renderer._curShader !== this) {
				gl.useProgram(this._glProgram);
				this._renderer._curShader = this;
			}
			return this;
		}
		setUniform(uniformName, data$2) {
			this.init();
			const uniform = this.uniforms[uniformName];
			if (!uniform) return;
			const gl = this._renderer.GL;
			if (uniform.isArray) if (uniform._cachedData && this._renderer._arraysEqual(uniform._cachedData, data$2)) return;
			else uniform._cachedData = data$2.slice(0);
			else if (uniform._cachedData && uniform._cachedData === data$2) return;
			else if (Array.isArray(data$2)) uniform._cachedData = data$2.slice(0);
			else uniform._cachedData = data$2;
			const location$1 = uniform.location;
			this.useProgram();
			switch (uniform.type) {
				case gl.BOOL:
					if (data$2 === true) gl.uniform1i(location$1, 1);
					else gl.uniform1i(location$1, 0);
					break;
				case gl.INT:
					if (uniform.size > 1) data$2.length && gl.uniform1iv(location$1, data$2);
					else gl.uniform1i(location$1, data$2);
					break;
				case gl.FLOAT:
					if (uniform.size > 1) data$2.length && gl.uniform1fv(location$1, data$2);
					else gl.uniform1f(location$1, data$2);
					break;
				case gl.FLOAT_MAT3:
					gl.uniformMatrix3fv(location$1, false, data$2);
					break;
				case gl.FLOAT_MAT4:
					gl.uniformMatrix4fv(location$1, false, data$2);
					break;
				case gl.FLOAT_VEC2:
					if (uniform.size > 1) data$2.length && gl.uniform2fv(location$1, data$2);
					else gl.uniform2f(location$1, data$2[0], data$2[1]);
					break;
				case gl.FLOAT_VEC3:
					if (uniform.size > 1) data$2.length && gl.uniform3fv(location$1, data$2);
					else gl.uniform3f(location$1, data$2[0], data$2[1], data$2[2]);
					break;
				case gl.FLOAT_VEC4:
					if (uniform.size > 1) data$2.length && gl.uniform4fv(location$1, data$2);
					else gl.uniform4f(location$1, data$2[0], data$2[1], data$2[2], data$2[3]);
					break;
				case gl.INT_VEC2:
					if (uniform.size > 1) data$2.length && gl.uniform2iv(location$1, data$2);
					else gl.uniform2i(location$1, data$2[0], data$2[1]);
					break;
				case gl.INT_VEC3:
					if (uniform.size > 1) data$2.length && gl.uniform3iv(location$1, data$2);
					else gl.uniform3i(location$1, data$2[0], data$2[1], data$2[2]);
					break;
				case gl.INT_VEC4:
					if (uniform.size > 1) data$2.length && gl.uniform4iv(location$1, data$2);
					else gl.uniform4i(location$1, data$2[0], data$2[1], data$2[2], data$2[3]);
					break;
				case gl.SAMPLER_2D:
					if (typeof data$2 == "number") {
						if (data$2 < gl.TEXTURE0 || data$2 > gl.TEXTURE31 || data$2 !== Math.ceil(data$2)) {
							console.log("🌸 p5.js says: You're trying to use a number as the data for a texture.Please use a texture.");
							return this;
						}
						gl.activeTexture(data$2);
						gl.uniform1i(location$1, data$2);
					} else {
						gl.activeTexture(gl.TEXTURE0 + uniform.samplerIndex);
						uniform.texture = data$2 instanceof Texture ? data$2 : this._renderer.getTexture(data$2);
						gl.uniform1i(location$1, uniform.samplerIndex);
						if (uniform.texture.src.gifProperties) uniform.texture.src._animateGif(this._renderer._pInst);
					}
					break;
				case gl.SAMPLER_CUBE:
				case gl.SAMPLER_3D:
				case gl.SAMPLER_2D_SHADOW:
				case gl.SAMPLER_2D_ARRAY:
				case gl.SAMPLER_2D_ARRAY_SHADOW:
				case gl.SAMPLER_CUBE_SHADOW:
				case gl.INT_SAMPLER_2D:
				case gl.INT_SAMPLER_3D:
				case gl.INT_SAMPLER_CUBE:
				case gl.INT_SAMPLER_2D_ARRAY:
				case gl.UNSIGNED_INT_SAMPLER_2D:
				case gl.UNSIGNED_INT_SAMPLER_3D:
				case gl.UNSIGNED_INT_SAMPLER_CUBE:
				case gl.UNSIGNED_INT_SAMPLER_2D_ARRAY:
					if (typeof data$2 !== "number") break;
					if (data$2 < gl.TEXTURE0 || data$2 > gl.TEXTURE31 || data$2 !== Math.ceil(data$2)) {
						console.log("🌸 p5.js says: You're trying to use a number as the data for a texture.Please use a texture.");
						break;
					}
					gl.activeTexture(data$2);
					gl.uniform1i(location$1, data$2);
					break;
			}
			return this;
		}
		enableAttrib(attr, size, type$2, normalized, stride, offset) {
			if (attr) {
				if (typeof IS_MINIFIED === "undefined" && this.attributes[attr.name] !== attr) console.warn(`The attribute "${attr.name}"passed to enableAttrib does not belong to this shader.`);
				const loc = attr.location;
				if (loc !== -1) {
					const gl = this._renderer.GL;
					if (!this._renderer.registerEnabled.has(loc)) {
						gl.enableVertexAttribArray(loc);
						this._renderer.registerEnabled.add(loc);
					}
					this._renderer.GL.vertexAttribPointer(loc, size, type$2 || gl.FLOAT, normalized || false, stride || 0, offset || 0);
				}
			}
			return this;
		}
		disableRemainingAttributes() {
			for (const location$1 of this._renderer.registerEnabled.values()) if (!Object.keys(this.attributes).some((key) => this.attributes[key].location === location$1)) {
				this._renderer.GL.disableVertexAttribArray(location$1);
				this._renderer.registerEnabled.delete(location$1);
			}
		}
	};
	function shader(p5$2, fn$1) {
		p5$2.Shader = Shader;
	}
	if (typeof p5 !== "undefined") shader(p5, p5.prototype);
	var filterBaseVert = "precision highp int;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nIN vec3 aPosition;\nIN vec2 aTexCoord;\nOUT vec2 vTexCoord;\n\nvoid main() {\n  // transferring texcoords for the frag shader\n  vTexCoord = aTexCoord;\n\n  // copy position with a fourth coordinate for projection (1.0 is normal)\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n\n  // project to 3D space\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n}\n";
	var lightingShader = "#define PI 3.141592\n\nprecision highp float;\nprecision highp int;\n\nuniform mat4 uViewMatrix;\n\nuniform bool uUseLighting;\n\nuniform int uAmbientLightCount;\nuniform vec3 uAmbientColor[5];\nuniform mat3 uCameraRotation;\nuniform int uDirectionalLightCount;\nuniform vec3 uLightingDirection[5];\nuniform vec3 uDirectionalDiffuseColors[5];\nuniform vec3 uDirectionalSpecularColors[5];\n\nuniform int uPointLightCount;\nuniform vec3 uPointLightLocation[5];\nuniform vec3 uPointLightDiffuseColors[5];	\nuniform vec3 uPointLightSpecularColors[5];\n\nuniform int uSpotLightCount;\nuniform float uSpotLightAngle[5];\nuniform float uSpotLightConc[5];\nuniform vec3 uSpotLightDiffuseColors[5];\nuniform vec3 uSpotLightSpecularColors[5];\nuniform vec3 uSpotLightLocation[5];\nuniform vec3 uSpotLightDirection[5];\n\nuniform bool uSpecular;\nuniform float uShininess;\nuniform float uMetallic;\n\nuniform float uConstantAttenuation;\nuniform float uLinearAttenuation;\nuniform float uQuadraticAttenuation;\n\n// setting from  _setImageLightUniforms()\n// boolean to initiate the calculateImageDiffuse and calculateImageSpecular\nuniform bool uUseImageLight;\n// texture for use in calculateImageDiffuse\nuniform sampler2D environmentMapDiffused;\n// texture for use in calculateImageSpecular\nuniform sampler2D environmentMapSpecular;\n\nconst float specularFactor = 2.0;\nconst float diffuseFactor = 0.73;\n\nstruct LightResult {\n  float specular;\n  float diffuse;\n};\n\nfloat _phongSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n\n  vec3 R = reflect(lightDirection, surfaceNormal);\n  return pow(max(0.0, dot(R, viewDirection)), shininess);\n}\n\nfloat _lambertDiffuse(vec3 lightDirection, vec3 surfaceNormal) {\n  return max(0.0, dot(-lightDirection, surfaceNormal));\n}\n\nLightResult _light(vec3 viewDirection, vec3 normal, vec3 lightVector, float shininess, float metallic) {\n\n  vec3 lightDir = normalize(lightVector);\n\n  //compute our diffuse & specular terms\n  LightResult lr;\n  float specularIntensity = mix(1.0, 0.4, metallic);\n  float diffuseIntensity = mix(1.0, 0.1, metallic);\n  if (uSpecular)\n    lr.specular = (_phongSpecular(lightDir, viewDirection, normal, shininess)) * specularIntensity;\n    lr.diffuse = _lambertDiffuse(lightDir, normal) * diffuseIntensity;\n  return lr;\n}\n\n// converts the range of \"value\" from [min1 to max1] to [min2 to max2]\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec2 mapTextureToNormal( vec3 v ){\n  // x = r sin(phi) cos(theta)   \n  // y = r cos(phi)  \n  // z = r sin(phi) sin(theta)\n  float phi = acos( v.y );\n  // if phi is 0, then there are no x, z components\n  float theta = 0.0;\n  // else \n  theta = acos(v.x / sin(phi));\n  float sinTheta = v.z / sin(phi);\n  if (sinTheta < 0.0) {\n    // Turn it into -theta, but in the 0-2PI range\n    theta = 2.0 * PI - theta;\n  }\n  theta = theta / (2.0 * 3.14159);\n  phi = phi / 3.14159 ;\n  \n  vec2 angles = vec2( fract(theta + 0.25), 1.0 - phi );\n  return angles;\n}\n\n\nvec3 calculateImageDiffuse(vec3 vNormal, vec3 vViewPosition, float metallic){\n  // make 2 seperate builds \n  vec3 worldCameraPosition =  vec3(0.0, 0.0, 0.0);  // hardcoded world camera position\n  vec3 worldNormal = normalize(vNormal * uCameraRotation);\n  vec2 newTexCoor = mapTextureToNormal( worldNormal );\n  vec4 texture = TEXTURE( environmentMapDiffused, newTexCoor );\n  // this is to make the darker sections more dark\n  // png and jpg usually flatten the brightness so it is to reverse that\n  return mix(smoothstep(vec3(0.0), vec3(1.0), texture.xyz), vec3(0.0), metallic);\n}\n\nvec3 calculateImageSpecular(vec3 vNormal, vec3 vViewPosition, float shininess, float metallic){\n  vec3 worldCameraPosition =  vec3(0.0, 0.0, 0.0);\n  vec3 worldNormal = normalize(vNormal);\n  vec3 lightDirection = normalize( vViewPosition - worldCameraPosition );\n  vec3 R = reflect(lightDirection, worldNormal) * uCameraRotation;\n  vec2 newTexCoor = mapTextureToNormal( R );\n#ifdef WEBGL2\n  // In p5js the range of shininess is >= 1,\n  // Therefore roughness range will be ([0,1]*8)*20 or [0, 160]\n  // The factor of 8 is because currently the getSpecularTexture\n  // only calculated 8 different levels of roughness\n  // The factor of 20 is just to spread up this range so that,\n  // [1, max] of shininess is converted to [0,160] of roughness\n  float roughness = 20. / shininess;\n  vec4 outColor = textureLod(environmentMapSpecular, newTexCoor, roughness * 8.);\n#else\n  vec4 outColor = TEXTURE(environmentMapSpecular, newTexCoor);\n#endif\n  // this is to make the darker sections more dark\n  // png and jpg usually flatten the brightness so it is to reverse that\n  return mix(\n    pow(outColor.xyz, vec3(10)),\n    pow(outColor.xyz, vec3(1.2)),\n    metallic \n  );\n}\n\nvoid totalLight(\n  vec3 modelPosition,\n  vec3 normal,\n  float shininess,\n  float metallic,\n  out vec3 totalDiffuse,\n  out vec3 totalSpecular\n) {\n\n  totalSpecular = vec3(0.0);\n\n  if (!uUseLighting) {\n    totalDiffuse = vec3(1.0);\n    return;\n  }\n\n  totalDiffuse = vec3(0.0);\n\n  vec3 viewDirection = normalize(-modelPosition);\n\n  for (int j = 0; j < 5; j++) {\n    if (j < uDirectionalLightCount) {\n      vec3 lightVector = (uViewMatrix * vec4(uLightingDirection[j], 0.0)).xyz;\n      vec3 lightColor = uDirectionalDiffuseColors[j];\n      vec3 specularColor = uDirectionalSpecularColors[j];\n      LightResult result = _light(viewDirection, normal, lightVector, shininess, metallic);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * lightColor * specularColor;\n    }\n\n    if (j < uPointLightCount) {\n      vec3 lightPosition = (uViewMatrix * vec4(uPointLightLocation[j], 1.0)).xyz;\n      vec3 lightVector = modelPosition - lightPosition;\n      //calculate attenuation\n      float lightDistance = length(lightVector);\n      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);\n      vec3 lightColor = lightFalloff * uPointLightDiffuseColors[j];\n      vec3 specularColor = lightFalloff * uPointLightSpecularColors[j];\n\n      LightResult result = _light(viewDirection, normal, lightVector, shininess, metallic);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * lightColor * specularColor;\n    }\n\n    if(j < uSpotLightCount) {\n      vec3 lightPosition = (uViewMatrix * vec4(uSpotLightLocation[j], 1.0)).xyz;\n      vec3 lightVector = modelPosition - lightPosition;\n    \n      float lightDistance = length(lightVector);\n      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);\n\n      vec3 lightDirection = (uViewMatrix * vec4(uSpotLightDirection[j], 0.0)).xyz;\n      float spotDot = dot(normalize(lightVector), normalize(lightDirection));\n      float spotFalloff;\n      if(spotDot < uSpotLightAngle[j]) {\n        spotFalloff = 0.0;\n      }\n      else {\n        spotFalloff = pow(spotDot, uSpotLightConc[j]);\n      }\n      lightFalloff *= spotFalloff;\n\n      vec3 lightColor = uSpotLightDiffuseColors[j];\n      vec3 specularColor = uSpotLightSpecularColors[j];\n     \n      LightResult result = _light(viewDirection, normal, lightVector, shininess, metallic);\n      \n      totalDiffuse += result.diffuse * lightColor * lightFalloff;\n      totalSpecular += result.specular * lightColor * specularColor * lightFalloff;\n    }\n  }\n\n  if( uUseImageLight ){\n    totalDiffuse += calculateImageDiffuse(normal, modelPosition, metallic);\n    totalSpecular += calculateImageSpecular(normal, modelPosition, shininess, metallic);\n  }\n\n  totalDiffuse *= diffuseFactor;\n  totalSpecular *= specularFactor;\n}\n";
	var webgl2CompatibilityShader = "#ifdef WEBGL2\n\n#define IN in\n#define OUT out\n\n#ifdef FRAGMENT_SHADER\nout vec4 outColor;\n#define OUT_COLOR outColor\n#endif\n#define TEXTURE texture\n\n#else\n\n#ifdef FRAGMENT_SHADER\n#define IN varying\n#else\n#define IN attribute\n#endif\n#define OUT varying\n#define TEXTURE texture2D\n\n#ifdef FRAGMENT_SHADER\n#define OUT_COLOR gl_FragColor\n#endif\n\n#endif\n\n#ifdef FRAGMENT_SHADER\nvec4 getTexture(in sampler2D content, vec2 coord) {\n  vec4 color = TEXTURE(content, coord);\n  color.rgb /= color.a;\n  return color;\n}\n#endif\n";
	var normalVert = "IN vec3 aPosition;\nIN vec3 aNormal;\nIN vec2 aTexCoord;\nIN vec4 aVertexColor;\n\n#define HOOK_DEFINES\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat3 uModelNormalMatrix;\nuniform mat3 uCameraNormalMatrix;\n#else\nuniform mat4 uModelViewMatrix;\nuniform mat3 uNormalMatrix;\n#endif\nuniform mat4 uProjectionMatrix;\n\nuniform vec4 uMaterialColor;\nuniform bool uUseVertexColor;\n\nOUT vec3 vVertexNormal;\nOUT highp vec2 vVertTexCoord;\nOUT vec4 vColor;\n\nstruct Vertex {\n  vec3 position;\n  vec3 normal;\n  vec2 texCoord;\n  vec4 color;\n};\n\nvoid main(void) {\n  HOOK_beforeVertex();\n\n  Vertex inputs;\n  inputs.position = aPosition;\n  inputs.normal = aNormal;\n  inputs.texCoord = aTexCoord;\n  inputs.color = (uUseVertexColor && aVertexColor.x >= 0.0) ? aVertexColor : uMaterialColor;\n#ifdef AUGMENTED_HOOK_getObjectInputs\n  inputs = HOOK_getObjectInputs(inputs);\n#endif\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\n  inputs.position = (uModelMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.normal = uModelNormalMatrix * inputs.normal;\n  inputs = HOOK_getWorldInputs(inputs);\n#endif\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\n  // Already multiplied by the model matrix, just apply view\n  inputs.position = (uViewMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.normal = uCameraNormalMatrix * inputs.normal;\n#else\n  // Apply both at once\n  inputs.position = (uModelViewMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.normal = uNormalMatrix * inputs.normal;\n#endif\n#ifdef AUGMENTED_HOOK_getCameraInputs\n  inputs = HOOK_getCameraInputs(inputs);\n#endif\n\n  // Pass varyings to fragment shader\n  vVertTexCoord = inputs.texCoord;\n  vVertexNormal = normalize(inputs.normal);\n  vColor = inputs.color;\n\n  gl_Position = uProjectionMatrix * vec4(inputs.position, 1.);\n\n  HOOK_afterVertex();\n}\n";
	var normalFrag = "IN vec3 vVertexNormal;\nvoid main(void) {\n  HOOK_beforeFragment();\n  OUT_COLOR = HOOK_getFinalColor(vec4(vVertexNormal, 1.0));\n  HOOK_afterFragment();\n}\n";
	var basicFrag = "IN vec4 vColor;\nvoid main(void) {\n  HOOK_beforeFragment();\n  OUT_COLOR = HOOK_getFinalColor(vec4(vColor.rgb, 1.) * vColor.a);\n  HOOK_afterFragment();\n}\n";
	var sphereMappingFrag = "#define PI 3.141592\n\nprecision highp float;\n  \nuniform sampler2D uEnvMap;\nuniform mat3 uNewNormalMatrix;\nuniform float uFovY;\nuniform float uAspect;\n\nvarying vec2 vTexCoord;\n  \nvoid main() {\n    float uFovX = uFovY * uAspect; \n    float angleY = mix(uFovY/2.0,  -uFovY/2.0, vTexCoord.y);\n    float angleX = mix(uFovX/2.0, -uFovX/2.0, vTexCoord.x);\n    vec3 rotatedNormal = vec3( angleX, angleY, 1.0 );\n    rotatedNormal = uNewNormalMatrix * normalize(rotatedNormal);\n    float temp = rotatedNormal.z;\n    rotatedNormal.z = rotatedNormal.x;\n    rotatedNormal.x = -temp;\n    vec2 suv;\n    suv.y = 0.5 + 0.5 * (-rotatedNormal.y);\n    suv.x = atan(rotatedNormal.z, rotatedNormal.x) / (2.0 * PI) + 0.5;\n    vec4 newTexColor = texture2D(uEnvMap, suv.xy);\n    gl_FragColor = newTexColor;\n}\n";
	var lightVert = "// include lighting.glgl\n\nIN vec3 aPosition;\nIN vec3 aNormal;\nIN vec2 aTexCoord;\nIN vec4 aVertexColor;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nuniform bool uUseVertexColor;\nuniform vec4 uMaterialColor;\n\nOUT highp vec2 vVertTexCoord;\nOUT vec3 vDiffuseColor;\nOUT vec3 vSpecularColor;\nOUT vec4 vColor;\n\nvoid main(void) {\n\n  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * viewModelPosition;\n\n  vec3 vertexNormal = normalize(uNormalMatrix * aNormal);\n  vVertTexCoord = aTexCoord;\n\n  totalLight(viewModelPosition.xyz, vertexNormal, vDiffuseColor, vSpecularColor);\n\n  for (int i = 0; i < 8; i++) {\n    if (i < uAmbientLightCount) {\n      vDiffuseColor += uAmbientColor[i];\n    }\n  }\n  \n  vColor = ((uUseVertexColor && aVertexColor.x >= 0.0) ? aVertexColor : uMaterialColor);\n}\n";
	var lightTextureFrag = "uniform vec4 uTint;\nuniform sampler2D uSampler;\nuniform bool isTexture;\nuniform bool uEmissive;\n\nIN highp vec2 vVertTexCoord;\nIN vec3 vDiffuseColor;\nIN vec3 vSpecularColor;\nIN vec4 vColor;\n\nvoid main(void) {\n  if(uEmissive && !isTexture) {\n    OUT_COLOR = vColor;\n  }\n  else {\n    vec4 baseColor = isTexture\n      // Textures come in with premultiplied alpha. To apply tint and still have\n      // premultiplied alpha output, we need to multiply the RGB channels by the\n      // tint RGB, and all channels by the tint alpha.\n      ? TEXTURE(uSampler, vVertTexCoord) * vec4(uTint.rgb/255., 1.) * (uTint.a/255.)\n      // Colors come in with unmultiplied alpha, so we need to multiply the RGB\n      // channels by alpha to convert it to premultiplied alpha.\n      : vec4(vColor.rgb * vColor.a, vColor.a);\n    OUT_COLOR = vec4(baseColor.rgb * vDiffuseColor + vSpecularColor, baseColor.a);\n  }\n}\n";
	var phongVert = "precision highp int;\n\n#define HOOK_DEFINES\n\nIN vec3 aPosition;\nIN vec3 aNormal;\nIN vec2 aTexCoord;\nIN vec4 aVertexColor;\n\nuniform vec3 uAmbientColor[5];\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat3 uModelNormalMatrix;\nuniform mat3 uCameraNormalMatrix;\n#else\nuniform mat4 uModelViewMatrix;\nuniform mat3 uNormalMatrix;\n#endif\nuniform mat4 uProjectionMatrix;\nuniform int uAmbientLightCount;\n\nuniform bool uUseVertexColor;\nuniform vec4 uMaterialColor;\n\nOUT vec3 vNormal;\nOUT vec2 vTexCoord;\nOUT vec3 vViewPosition;\nOUT vec3 vAmbientColor;\nOUT vec4 vColor;\n\nstruct Vertex {\n  vec3 position;\n  vec3 normal;\n  vec2 texCoord;\n  vec4 color;\n};\n\nvoid main(void) {\n  HOOK_beforeVertex();\n\n  Vertex inputs;\n  inputs.position = aPosition;\n  inputs.normal = aNormal;\n  inputs.texCoord = aTexCoord;\n  inputs.color = (uUseVertexColor && aVertexColor.x >= 0.0) ? aVertexColor : uMaterialColor;\n#ifdef AUGMENTED_HOOK_getObjectInputs\n  inputs = HOOK_getObjectInputs(inputs);\n#endif\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\n  inputs.position = (uModelMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.normal = uModelNormalMatrix * inputs.normal;\n  inputs = HOOK_getWorldInputs(inputs);\n#endif\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\n  // Already multiplied by the model matrix, just apply view\n  inputs.position = (uViewMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.normal = uCameraNormalMatrix * inputs.normal;\n#else\n  // Apply both at once\n  inputs.position = (uModelViewMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.normal = uNormalMatrix * inputs.normal;\n#endif\n#ifdef AUGMENTED_HOOK_getCameraInputs\n  inputs = HOOK_getCameraInputs(inputs);\n#endif\n\n  // Pass varyings to fragment shader\n  vViewPosition = inputs.position;\n  vTexCoord = inputs.texCoord;\n  vNormal = inputs.normal;\n  vColor = inputs.color;\n\n  // TODO: this should be a uniform\n  vAmbientColor = vec3(0.0);\n  for (int i = 0; i < 5; i++) {\n    if (i < uAmbientLightCount) {\n      vAmbientColor += uAmbientColor[i];\n    }\n  }\n\n  gl_Position = uProjectionMatrix * vec4(inputs.position, 1.);\n  HOOK_afterVertex();\n}\n";
	var phongFrag = "// include lighting.glsl\nprecision highp int;\n\nuniform bool uHasSetAmbient;\nuniform vec4 uSpecularMatColor;\nuniform vec4 uAmbientMatColor;\nuniform vec4 uEmissiveMatColor;\n\nuniform vec4 uTint;\nuniform sampler2D uSampler;\nuniform bool isTexture;\n\nIN vec3 vNormal;\nIN vec2 vTexCoord;\nIN vec3 vViewPosition;\nIN vec3 vAmbientColor;\nIN vec4 vColor;\n\nstruct ColorComponents {\n  vec3 baseColor;\n  float opacity;\n  vec3 ambientColor;\n  vec3 specularColor;\n  vec3 diffuse;\n  vec3 ambient;\n  vec3 specular;\n  vec3 emissive;\n};\n\nstruct Inputs {\n  vec3 normal;\n  vec2 texCoord;\n  vec3 ambientLight;\n  vec3 ambientMaterial;\n  vec3 specularMaterial;\n  vec3 emissiveMaterial;\n  vec4 color;\n  float shininess;\n  float metalness;\n};\n\nvoid main(void) {\n  HOOK_beforeFragment();\n\n  Inputs inputs;\n  inputs.normal = normalize(vNormal);\n  inputs.texCoord = vTexCoord;\n  inputs.ambientLight = vAmbientColor;\n  inputs.color = isTexture\n      ? TEXTURE(uSampler, vTexCoord) * (vec4(uTint.rgb/255., 1.) * uTint.a/255.)\n      : vColor;\n  if (isTexture && inputs.color.a > 0.0) {\n    // Textures come in with premultiplied alpha. Temporarily unpremultiply it\n    // so hooks users don't have to think about premultiplied alpha.\n    inputs.color.rgb /= inputs.color.a;\n  }\n  inputs.shininess = uShininess;\n  inputs.metalness = uMetallic;\n  inputs.ambientMaterial = uHasSetAmbient ? uAmbientMatColor.rgb : inputs.color.rgb;\n  inputs.specularMaterial = uSpecularMatColor.rgb;\n  inputs.emissiveMaterial = uEmissiveMatColor.rgb;\n  inputs = HOOK_getPixelInputs(inputs);\n\n  vec3 diffuse;\n  vec3 specular;\n  totalLight(vViewPosition, inputs.normal, inputs.shininess, inputs.metalness, diffuse, specular);\n\n  // Calculating final color as result of all lights (plus emissive term).\n\n  vec2 texCoord = inputs.texCoord;\n  vec4 baseColor = inputs.color;\n  ColorComponents c;\n  c.opacity = baseColor.a;\n  c.baseColor = baseColor.rgb;\n  c.ambientColor = inputs.ambientMaterial;\n  c.specularColor = inputs.specularMaterial;\n  c.diffuse = diffuse;\n  c.ambient = inputs.ambientLight;\n  c.specular = specular;\n  c.emissive = inputs.emissiveMaterial;\n  OUT_COLOR = HOOK_getFinalColor(HOOK_combineColors(c));\n  OUT_COLOR.rgb *= OUT_COLOR.a; // Premultiply alpha before rendering\n  HOOK_afterFragment();\n}\n";
	var fontVert = "IN vec3 aPosition;\nIN vec2 aTexCoord;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nuniform vec4 uGlyphRect;\nuniform float uGlyphOffset;\n\nOUT vec2 vTexCoord;\nOUT float w;\n\nvoid main() {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n\n  // scale by the size of the glyph's rectangle\n  positionVec4.xy *= uGlyphRect.zw - uGlyphRect.xy;\n\n  // Expand glyph bounding boxes by 1px on each side to give a bit of room\n  // for antialiasing\n  vec3 newOrigin = (uModelViewMatrix * vec4(0., 0., 0., 1.)).xyz;\n  vec3 newDX = (uModelViewMatrix * vec4(1., 0., 0., 1.)).xyz;\n  vec3 newDY = (uModelViewMatrix * vec4(0., 1., 0., 1.)).xyz;\n  vec2 pixelScale = vec2(\n    1. / length(newOrigin - newDX),\n    1. / length(newOrigin - newDY)\n  );\n  vec2 offset = pixelScale * normalize(aTexCoord - vec2(0.5, 0.5));\n  vec2 textureOffset = offset * (1. / vec2(\n    uGlyphRect.z - uGlyphRect.x,\n    uGlyphRect.w - uGlyphRect.y\n  ));\n\n  // move to the corner of the glyph\n  positionVec4.xy += uGlyphRect.xy;\n\n  // move to the letter's line offset\n  positionVec4.x += uGlyphOffset;\n\n  positionVec4.xy += offset;\n  \n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vTexCoord = aTexCoord + textureOffset;\n  w = gl_Position.w;\n}\n";
	var fontFrag = "#ifndef WEBGL2\n#extension GL_OES_standard_derivatives : enable\n#endif\n\n#if 0\n  // simulate integer math using floats\n	#define int float\n	#define ivec2 vec2\n	#define INT(x) float(x)\n\n	int ifloor(float v) { return floor(v); }\n	ivec2 ifloor(vec2 v) { return floor(v); }\n\n#else\n  // use native integer math\n	precision highp int;\n	#define INT(x) x\n\n	int ifloor(float v) { return int(v); }\n	int ifloor(int v) { return v; }\n	ivec2 ifloor(vec2 v) { return ivec2(v); }\n\n#endif\n\nuniform sampler2D uSamplerStrokes;\nuniform sampler2D uSamplerRowStrokes;\nuniform sampler2D uSamplerRows;\nuniform sampler2D uSamplerColStrokes;\nuniform sampler2D uSamplerCols;\n\nuniform ivec2 uStrokeImageSize;\nuniform ivec2 uCellsImageSize;\nuniform ivec2 uGridImageSize;\n\nuniform ivec2 uGridOffset;\nuniform ivec2 uGridSize;\nuniform vec4 uMaterialColor;\n\nIN vec2 vTexCoord;\n\n// some helper functions\nint ROUND(float v) { return ifloor(v + 0.5); }\nivec2 ROUND(vec2 v) { return ifloor(v + 0.5); }\nfloat saturate(float v) { return clamp(v, 0.0, 1.0); }\nvec2 saturate(vec2 v) { return clamp(v, 0.0, 1.0); }\n\nint mul(float v1, int v2) {\n  return ifloor(v1 * float(v2));\n}\n\nivec2 mul(vec2 v1, ivec2 v2) {\n  return ifloor(v1 * vec2(v2) + 0.5);\n}\n\n// unpack a 16-bit integer from a float vec2\nint getInt16(vec2 v) {\n  ivec2 iv = ROUND(v * 255.0);\n  return iv.x * INT(128) + iv.y;\n}\n\nvec2 pixelScale;\nvec2 coverage = vec2(0.0);\nvec2 weight = vec2(0.5);\nconst float minDistance = 1.0/8192.0;\nconst float hardness = 1.05; // amount of antialias\n\n// the maximum number of curves in a glyph\nconst int N = INT(250);\n\n// retrieves an indexed pixel from a sampler\nvec4 getTexel(sampler2D sampler, int pos, ivec2 size) {\n  int width = size.x;\n  int y = ifloor(pos / width);\n  int x = pos - y * width;  // pos % width\n\n  return TEXTURE(sampler, (vec2(x, y) + 0.5) / vec2(size));\n}\n\nvoid calulateCrossings(vec2 p0, vec2 p1, vec2 p2, out vec2 C1, out vec2 C2) {\n\n  // get the coefficients of the quadratic in t\n  vec2 a = p0 - p1 * 2.0 + p2;\n  vec2 b = p0 - p1;\n  vec2 c = p0 - vTexCoord;\n\n  // found out which values of 't' it crosses the axes\n  vec2 surd = sqrt(max(vec2(0.0), b * b - a * c));\n  vec2 t1 = ((b - surd) / a).yx;\n  vec2 t2 = ((b + surd) / a).yx;\n\n  // approximate straight lines to avoid rounding errors\n  if (abs(a.y) < 0.001)\n    t1.x = t2.x = c.y / (2.0 * b.y);\n\n  if (abs(a.x) < 0.001)\n    t1.y = t2.y = c.x / (2.0 * b.x);\n\n  // plug into quadratic formula to find the corrdinates of the crossings\n  C1 = ((a * t1 - b * 2.0) * t1 + c) * pixelScale;\n  C2 = ((a * t2 - b * 2.0) * t2 + c) * pixelScale;\n}\n\nvoid coverageX(vec2 p0, vec2 p1, vec2 p2) {\n\n  vec2 C1, C2;\n  calulateCrossings(p0, p1, p2, C1, C2);\n\n  // determine on which side of the x-axis the points lie\n  bool y0 = p0.y > vTexCoord.y;\n  bool y1 = p1.y > vTexCoord.y;\n  bool y2 = p2.y > vTexCoord.y;\n\n  // could web be under the curve (after t1)?\n  if (y1 ? !y2 : y0) {\n    // add the coverage for t1\n    coverage.x += saturate(C1.x + 0.5);\n    // calculate the anti-aliasing for t1\n    weight.x = min(weight.x, abs(C1.x));\n  }\n\n  // are we outside the curve (after t2)?\n  if (y1 ? !y0 : y2) {\n    // subtract the coverage for t2\n    coverage.x -= saturate(C2.x + 0.5);\n    // calculate the anti-aliasing for t2\n    weight.x = min(weight.x, abs(C2.x));\n  }\n}\n\n// this is essentially the same as coverageX, but with the axes swapped\nvoid coverageY(vec2 p0, vec2 p1, vec2 p2) {\n\n  vec2 C1, C2;\n  calulateCrossings(p0, p1, p2, C1, C2);\n\n  bool x0 = p0.x > vTexCoord.x;\n  bool x1 = p1.x > vTexCoord.x;\n  bool x2 = p2.x > vTexCoord.x;\n\n  if (x1 ? !x2 : x0) {\n    coverage.y -= saturate(C1.y + 0.5);\n    weight.y = min(weight.y, abs(C1.y));\n  }\n\n  if (x1 ? !x0 : x2) {\n    coverage.y += saturate(C2.y + 0.5);\n    weight.y = min(weight.y, abs(C2.y));\n  }\n}\n\nvoid main() {\n\n  // calculate the pixel scale based on screen-coordinates\n  pixelScale = hardness / fwidth(vTexCoord);\n\n  // which grid cell is this pixel in?\n  ivec2 gridCoord = ifloor(vTexCoord * vec2(uGridSize));\n\n  // intersect curves in this row\n  {\n    // the index into the row info bitmap\n    int rowIndex = gridCoord.y + uGridOffset.y;\n    // fetch the info texel\n    vec4 rowInfo = getTexel(uSamplerRows, rowIndex, uGridImageSize);\n    // unpack the rowInfo\n    int rowStrokeIndex = getInt16(rowInfo.xy);\n    int rowStrokeCount = getInt16(rowInfo.zw);\n\n    for (int iRowStroke = INT(0); iRowStroke < N; iRowStroke++) {\n      if (iRowStroke >= rowStrokeCount)\n        break;\n\n      // each stroke is made up of 3 points: the start and control point\n      // and the start of the next curve.\n      // fetch the indices of this pair of strokes:\n      vec4 strokeIndices = getTexel(uSamplerRowStrokes, rowStrokeIndex++, uCellsImageSize);\n\n      // unpack the stroke index\n      int strokePos = getInt16(strokeIndices.xy);\n\n      // fetch the two strokes\n      vec4 stroke0 = getTexel(uSamplerStrokes, strokePos + INT(0), uStrokeImageSize);\n      vec4 stroke1 = getTexel(uSamplerStrokes, strokePos + INT(1), uStrokeImageSize);\n\n      // calculate the coverage\n      coverageX(stroke0.xy, stroke0.zw, stroke1.xy);\n    }\n  }\n\n  // intersect curves in this column\n  {\n    int colIndex = gridCoord.x + uGridOffset.x;\n    vec4 colInfo = getTexel(uSamplerCols, colIndex, uGridImageSize);\n    int colStrokeIndex = getInt16(colInfo.xy);\n    int colStrokeCount = getInt16(colInfo.zw);\n    \n    for (int iColStroke = INT(0); iColStroke < N; iColStroke++) {\n      if (iColStroke >= colStrokeCount)\n        break;\n\n      vec4 strokeIndices = getTexel(uSamplerColStrokes, colStrokeIndex++, uCellsImageSize);\n\n      int strokePos = getInt16(strokeIndices.xy);\n      vec4 stroke0 = getTexel(uSamplerStrokes, strokePos + INT(0), uStrokeImageSize);\n      vec4 stroke1 = getTexel(uSamplerStrokes, strokePos + INT(1), uStrokeImageSize);\n      coverageY(stroke0.xy, stroke0.zw, stroke1.xy);\n    }\n  }\n\n  weight = saturate(1.0 - weight * 2.0);\n  float distance = max(weight.x + weight.y, minDistance); // manhattan approx.\n  float antialias = abs(dot(coverage, weight) / distance);\n  float cover = min(abs(coverage.x), abs(coverage.y));\n  OUT_COLOR = vec4(uMaterialColor.rgb, 1.) * uMaterialColor.a;\n  OUT_COLOR *= saturate(max(antialias, cover));\n}\n";
	var lineVert = "/*\n  Part of the Processing project - http://processing.org\n  Copyright (c) 2012-15 The Processing Foundation\n  Copyright (c) 2004-12 Ben Fry and Casey Reas\n  Copyright (c) 2001-04 Massachusetts Institute of Technology\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation, version 2.1.\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n  You should have received a copy of the GNU Lesser General\n  Public License along with this library; if not, write to the\n  Free Software Foundation, Inc., 59 Temple Place, Suite 330,\n  Boston, MA  02111-1307  USA\n*/\n\n#define PROCESSING_LINE_SHADER\n\n#define HOOK_DEFINES\n\nprecision highp int;\nprecision highp float;\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\n#else\nuniform mat4 uModelViewMatrix;\n#endif\n\nuniform mat4 uProjectionMatrix;\nuniform float uStrokeWeight;\n\nuniform bool uUseLineColor;\nuniform bool uSimpleLines;\nuniform vec4 uMaterialColor;\n\nuniform vec4 uViewport;\nuniform int uPerspective;\nuniform int uStrokeJoin;\n\nIN vec3 aPosition;\nIN vec3 aTangentIn;\nIN vec3 aTangentOut;\nIN float aSide;\nIN vec4 aVertexColor;\n\nOUT vec4 vColor;\nOUT vec2 vTangent;\nOUT vec2 vCenter;\nOUT vec2 vPosition;\nOUT float vMaxDist;\nOUT float vCap;\nOUT float vJoin;\nOUT float vStrokeWeight;\n\nvec2 lineIntersection(vec2 aPoint, vec2 aDir, vec2 bPoint, vec2 bDir) {\n  // Rotate and translate so a starts at the origin and goes out to the right\n  bPoint -= aPoint;\n  vec2 rotatedBFrom = vec2(\n    bPoint.x*aDir.x + bPoint.y*aDir.y,\n    bPoint.y*aDir.x - bPoint.x*aDir.y\n  );\n  vec2 bTo = bPoint + bDir;\n  vec2 rotatedBTo = vec2(\n    bTo.x*aDir.x + bTo.y*aDir.y,\n    bTo.y*aDir.x - bTo.x*aDir.y\n  );\n  float intersectionDistance =\n    rotatedBTo.x + (rotatedBFrom.x - rotatedBTo.x) * rotatedBTo.y /\n    (rotatedBTo.y - rotatedBFrom.y);\n  return aPoint + aDir * intersectionDistance;\n}\n\nstruct StrokeVertex {\n  vec3 position;\n  vec3 tangentIn;\n  vec3 tangentOut;\n  vec4 color;\n  float weight;\n};\n\nvoid main() {\n  HOOK_beforeVertex();\n\n  if (!uSimpleLines) {\n      // Caps have one of either the in or out tangent set to 0\n      vCap = (aTangentIn == vec3(0.)) != (aTangentOut == vec3(0.)) ? 1. : 0.;\n\n      // Joins have two unique, defined tangents\n      vJoin = (\n          aTangentIn != vec3(0.) &&\n          aTangentOut != vec3(0.) &&\n          aTangentIn != aTangentOut\n      ) ? 1. : 0.;\n  }\n\n  StrokeVertex inputs;\n  inputs.position = aPosition.xyz;\n  inputs.color = uUseLineColor ? aVertexColor : uMaterialColor;\n  inputs.weight = uStrokeWeight;\n  inputs.tangentIn = aTangentIn;\n  inputs.tangentOut = aTangentOut;\n\n#ifdef AUGMENTED_HOOK_getObjectInputs\n  inputs = HOOK_getObjectInputs(inputs);\n#endif\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\n  inputs.position = (uModelMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.tangentIn = (uModelMatrix * vec4(aTangentIn, 0.)).xyz;\n  inputs.tangentOut = (uModelMatrix * vec4(aTangentOut, 0.)).xyz;\n  inputs = HOOK_getWorldInputs(inputs);\n#endif\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\n  // Already multiplied by the model matrix, just apply view\n  inputs.position = (uViewMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.tangentIn = (uViewMatrix * vec4(aTangentIn, 0.)).xyz;\n  inputs.tangentOut = (uViewMatrix * vec4(aTangentOut, 0.)).xyz;\n#else\n  // Apply both at once\n  inputs.position = (uModelViewMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.tangentIn = (uModelViewMatrix * vec4(aTangentIn, 0.)).xyz;\n  inputs.tangentOut = (uModelViewMatrix * vec4(aTangentOut, 0.)).xyz;\n#endif\n#ifdef AUGMENTED_HOOK_getCameraInputs\n  inputs = hook_getCameraInputs(inputs);\n#endif\n\n  vec4 posp = vec4(inputs.position, 1.);\n  vec4 posqIn = vec4(inputs.position + inputs.tangentIn, 1.);\n  vec4 posqOut = vec4(inputs.position + inputs.tangentOut, 1.);\n  vStrokeWeight = inputs.weight;\n\n  float facingCamera = pow(\n    // The word space tangent's z value is 0 if it's facing the camera\n    abs(normalize(posqIn-posp).z),\n\n    // Using pow() here to ramp `facingCamera` up from 0 to 1 really quickly\n    // so most lines get scaled and don't get clipped\n    0.25\n  );\n\n  // Moving vertices slightly toward the camera\n  // to avoid depth-fighting with the fill triangles.\n  // A mix of scaling and offsetting is used based on distance\n  // Discussion here:\n  // https://github.com/processing/p5.js/issues/7200 \n\n  // using a scale <1 moves the lines towards nearby camera\n  // in order to prevent popping effects due to half of\n  // the line disappearing behind the geometry faces.\n  float zDistance = -posp.z; \n  float distanceFactor = smoothstep(0.0, 800.0, zDistance); \n  \n  // Discussed here:\n  // http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&Number=252848  \n  float scale = mix(1., 0.995, facingCamera);\n  float dynamicScale = mix(scale, 1.0, distanceFactor); // Closer = more scale, farther = less\n\n  posp.xyz = posp.xyz * dynamicScale;\n  posqIn.xyz = posqIn.xyz * dynamicScale;\n  posqOut.xyz = posqOut.xyz * dynamicScale;\n\n  // Moving vertices slightly toward camera when far away \n  // https://github.com/processing/p5.js/issues/6956 \n  float zOffset = mix(0., -1., facingCamera);\n  float dynamicZAdjustment = mix(0.0, zOffset, distanceFactor); // Closer = less zAdjustment, farther = more\n\n  posp.z -= dynamicZAdjustment;\n  posqIn.z -= dynamicZAdjustment;\n  posqOut.z -= dynamicZAdjustment;\n  \n  vec4 p = uProjectionMatrix * posp;\n  vec4 qIn = uProjectionMatrix * posqIn;\n  vec4 qOut = uProjectionMatrix * posqOut;\n\n  // formula to convert from clip space (range -1..1) to screen space (range 0..[width or height])\n  // screen_p = (p.xy/p.w + <1,1>) * 0.5 * uViewport.zw\n\n  // prevent division by W by transforming the tangent formula (div by 0 causes\n  // the line to disappear, see https://github.com/processing/processing/issues/5183)\n  // t = screen_q - screen_p\n  //\n  // tangent is normalized and we don't care which aDirection it points to (+-)\n  // t = +- normalize( screen_q - screen_p )\n  // t = +- normalize( (q.xy/q.w+<1,1>)*0.5*uViewport.zw - (p.xy/p.w+<1,1>)*0.5*uViewport.zw )\n  //\n  // extract common factor, <1,1> - <1,1> cancels out\n  // t = +- normalize( (q.xy/q.w - p.xy/p.w) * 0.5 * uViewport.zw )\n  //\n  // convert to common divisor\n  // t = +- normalize( ((q.xy*p.w - p.xy*q.w) / (p.w*q.w)) * 0.5 * uViewport.zw )\n  //\n  // remove the common scalar divisor/factor, not needed due to normalize and +-\n  // (keep uViewport - can't remove because it has different components for x and y\n  //  and corrects for aspect ratio, see https://github.com/processing/processing/issues/5181)\n  // t = +- normalize( (q.xy*p.w - p.xy*q.w) * uViewport.zw )\n\n  vec2 tangentIn = normalize((qIn.xy*p.w - p.xy*qIn.w) * uViewport.zw);\n  vec2 tangentOut = normalize((qOut.xy*p.w - p.xy*qOut.w) * uViewport.zw);\n\n  vec2 curPerspScale;\n  if(uPerspective == 1) {\n    // Perspective ---\n    // convert from world to clip by multiplying with projection scaling factor\n    // to get the right thickness (see https://github.com/processing/processing/issues/5182)\n\n    // The y value of the projection matrix may be flipped if rendering to a Framebuffer.\n    // Multiplying again by its sign here negates the flip to get just the scale.\n    curPerspScale = (uProjectionMatrix * vec4(1, sign(uProjectionMatrix[1][1]), 0, 0)).xy;\n  } else {\n    // No Perspective ---\n    // multiply by W (to cancel out division by W later in the pipeline) and\n    // convert from screen to clip (derived from clip to screen above)\n    curPerspScale = p.w / (0.5 * uViewport.zw);\n  }\n\n  vec2 offset;\n  if (vJoin == 1. && !uSimpleLines) {\n    vTangent = normalize(tangentIn + tangentOut);\n    vec2 normalIn = vec2(-tangentIn.y, tangentIn.x);\n    vec2 normalOut = vec2(-tangentOut.y, tangentOut.x);\n    float side = sign(aSide);\n    float sideEnum = abs(aSide);\n\n    // We generate vertices for joins on either side of the centerline, but\n    // the \"elbow\" side is the only one needing a join. By not setting the\n    // offset for the other side, all its vertices will end up in the same\n    // spot and not render, effectively discarding it.\n    if (sign(dot(tangentOut, vec2(-tangentIn.y, tangentIn.x))) != side) {\n      // Side enums:\n      //   1: the side going into the join\n      //   2: the middle of the join\n      //   3: the side going out of the join\n      if (sideEnum == 2.) {\n        // Calculate the position + tangent on either side of the join, and\n        // find where the lines intersect to find the elbow of the join\n        vec2 c = (posp.xy/posp.w + vec2(1.,1.)) * 0.5 * uViewport.zw;\n        vec2 intersection = lineIntersection(\n          c + (side * normalIn * inputs.weight / 2.),\n          tangentIn,\n          c + (side * normalOut * inputs.weight / 2.),\n          tangentOut\n        );\n        offset = (intersection - c);\n\n        // When lines are thick and the angle of the join approaches 180, the\n        // elbow might be really far from the center. We'll apply a limit to\n        // the magnitude to avoid lines going across the whole screen when this\n        // happens.\n        float mag = length(offset);\n        float maxMag = 3. * inputs.weight;\n        if (mag > maxMag) {\n          offset *= maxMag / mag;\n        }\n      } else if (sideEnum == 1.) {\n        offset = side * normalIn * inputs.weight / 2.;\n      } else if (sideEnum == 3.) {\n        offset = side * normalOut * inputs.weight / 2.;\n      }\n    }\n    if (uStrokeJoin == STROKE_JOIN_BEVEL) {\n      vec2 avgNormal = vec2(-vTangent.y, vTangent.x);\n      vMaxDist = abs(dot(avgNormal, normalIn * inputs.weight / 2.));\n    } else {\n      vMaxDist = inputs.weight / 2.;\n    }\n  } else {\n    vec2 tangent = aTangentIn == vec3(0.) ? tangentOut : tangentIn;\n    vTangent = tangent;\n    vec2 normal = vec2(-tangent.y, tangent.x);\n\n    float normalOffset = sign(aSide);\n    // Caps will have side values of -2 or 2 on the edge of the cap that\n    // extends out from the line\n    float tangentOffset = abs(aSide) - 1.;\n    offset = (normal * normalOffset + tangent * tangentOffset) *\n      inputs.weight * 0.5;\n    vMaxDist = inputs.weight / 2.;\n  }\n\n  vCenter = p.xy;\n  vPosition = vCenter + offset;\n  vColor = inputs.color;\n\n  gl_Position.xy = p.xy + offset.xy * curPerspScale;\n  gl_Position.zw = p.zw;\n  \n  HOOK_afterVertex();\n}\n";
	var lineFrag = "precision highp int;\nprecision highp float;\n\nuniform vec4 uMaterialColor;\nuniform int uStrokeCap;\nuniform int uStrokeJoin;\n\nIN vec4 vColor;\nIN vec2 vTangent;\nIN vec2 vCenter;\nIN vec2 vPosition;\nIN float vStrokeWeight;\nIN float vMaxDist;\nIN float vCap;\nIN float vJoin;\n\nfloat distSquared(vec2 a, vec2 b) {\n  vec2 aToB = b - a;\n  return dot(aToB, aToB);\n}\n\nstruct Inputs {\n  vec4 color;\n  vec2 tangent;\n  vec2 center;\n  vec2 position;\n  float strokeWeight;\n};\n\nvoid main() {\n  HOOK_beforeFragment();\n\n  Inputs inputs;\n  inputs.color = vColor;\n  inputs.tangent = vTangent;\n  inputs.center = vCenter;\n  inputs.position = vPosition;\n  inputs.strokeWeight = vStrokeWeight;\n  inputs = HOOK_getPixelInputs(inputs);\n\n  if (vCap > 0.) {\n    if (\n      uStrokeCap == STROKE_CAP_ROUND &&\n      HOOK_shouldDiscard(distSquared(inputs.position, inputs.center) > inputs.strokeWeight * inputs.strokeWeight * 0.25)\n    ) {\n      discard;\n    } else if (\n      uStrokeCap == STROKE_CAP_SQUARE &&\n      HOOK_shouldDiscard(dot(inputs.position - inputs.center, inputs.tangent) > 0.)\n    ) {\n      discard;\n    // Use full area for PROJECT\n    } else if (HOOK_shouldDiscard(false)) {\n      discard;\n    }\n  } else if (vJoin > 0.) {\n    if (\n      uStrokeJoin == STROKE_JOIN_ROUND &&\n      HOOK_shouldDiscard(distSquared(inputs.position, inputs.center) > inputs.strokeWeight * inputs.strokeWeight * 0.25)\n    ) {\n      discard;\n    } else if (uStrokeJoin == STROKE_JOIN_BEVEL) {\n      vec2 normal = vec2(-inputs.tangent.y, inputs.tangent.x);\n      if (HOOK_shouldDiscard(abs(dot(inputs.position - inputs.center, normal)) > vMaxDist)) {\n        discard;\n      }\n    // Use full area for MITER\n    } else if (HOOK_shouldDiscard(false)) {\n      discard;\n    }\n  }\n  OUT_COLOR = HOOK_getFinalColor(vec4(inputs.color.rgb, 1.) * inputs.color.a);\n  HOOK_afterFragment();\n}\n";
	var pointVert = "IN vec3 aPosition;\nuniform float uPointSize;\nOUT float vStrokeWeight;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvoid main() {\n  HOOK_beforeVertex();\n  vec4 viewModelPosition = vec4(HOOK_getWorldPosition(\n    (uModelViewMatrix * vec4(HOOK_getLocalPosition(aPosition), 1.0)).xyz\n  ), 1.);\n  gl_Position = uProjectionMatrix * viewModelPosition;  \n\n  float pointSize = HOOK_getPointSize(uPointSize);\n\n	gl_PointSize = pointSize;\n	vStrokeWeight = pointSize;\n  HOOK_afterVertex();\n}\n";
	var pointFrag = "precision mediump int;\nuniform vec4 uMaterialColor;\nIN float vStrokeWeight;\n\nvoid main(){\n  HOOK_beforeFragment();\n  float mask = 0.0;\n\n  // make a circular mask using the gl_PointCoord (goes from 0 - 1 on a point)\n  // might be able to get a nicer edge on big strokeweights with smoothstep but slightly less performant\n\n  mask = step(0.98, length(gl_PointCoord * 2.0 - 1.0));\n\n  // if strokeWeight is 1 or less lets just draw a square\n  // this prevents weird artifacting from carving circles when our points are really small\n  // if strokeWeight is larger than 1, we just use it as is\n\n  mask = mix(0.0, mask, clamp(floor(vStrokeWeight - 0.5),0.0,1.0));\n\n  // throw away the borders of the mask\n  // otherwise we get weird alpha blending issues\n\n  if(HOOK_shouldDiscard(mask > 0.98)){\n    discard;\n  }\n\n  OUT_COLOR = HOOK_getFinalColor(vec4(uMaterialColor.rgb, 1.) * uMaterialColor.a);\n  HOOK_afterFragment();\n}\n";
	var imageLightVert = "precision highp float;\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\n\nvarying vec3 localPos;\nvarying vec3 vWorldNormal;\nvarying vec3 vWorldPosition;\nvarying vec2 vTexCoord;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nvoid main() {\n  // Multiply the position by the matrix.\n  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * viewModelPosition;  \n  \n  // orient the normals and pass to the fragment shader\n  vWorldNormal = uNormalMatrix * aNormal;\n  \n  // send the view position to the fragment shader\n  vWorldPosition = (uModelViewMatrix * vec4(aPosition, 1.0)).xyz;\n  \n  localPos = vWorldPosition;\n  vTexCoord = aTexCoord;\n}\n\n\n/*\nin the vertex shader we'll compute the world position and world oriented normal of the vertices and pass those to the fragment shader as varyings.\n*/\n";
	var imageLightDiffusedFrag = "precision highp float;\nvarying vec3 localPos;\n\n// the HDR cubemap converted (can be from an equirectangular environment map.)\nuniform sampler2D environmentMap;\nvarying vec2 vTexCoord;\n\nconst float PI = 3.14159265359;\n\nvec2 nTOE( vec3 v ){\n  // x = r sin(phi) cos(theta)   \n  // y = r cos(phi)  \n  // z = r sin(phi) sin(theta)\n  float phi = acos( v.y );\n  // if phi is 0, then there are no x, z components\n  float theta = 0.0;\n  // else \n  theta = acos(v.x / sin(phi));\n  float sinTheta = v.z / sin(phi);\n  if (sinTheta < 0.0) {\n    // Turn it into -theta, but in the 0-2PI range\n    theta = 2.0 * PI - theta;\n  }\n  theta = theta / (2.0 * 3.14159);\n  phi = phi / 3.14159 ;\n  \n  vec2 angles = vec2( phi, theta );\n  return angles;\n}\n\nfloat random(vec2 p) {\n  vec3 p3  = fract(vec3(p.xyx) * .1031);\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid main()\n{   	 \n	// the sample direction equals the hemisphere's orientation\n  float phi = vTexCoord.x * 2.0 * PI;\n  float theta = vTexCoord.y * PI;\n  float x = sin(theta) * cos(phi);\n  float y = sin(theta) * sin(phi);\n  float z = cos(theta);\n  vec3 normal = vec3( x, y, z);\n\n	// Discretely sampling the hemisphere given the integral's\n  // spherical coordinates translates to the following fragment code:\n	vec3 irradiance = vec3(0.0);  \n	vec3 up	= vec3(0.0, 1.0, 0.0);\n	vec3 right = normalize(cross(up, normal));\n	up = normalize(cross(normal, right));\n\n	//  We specify a fixed sampleDelta delta value to traverse\n  // the hemisphere; decreasing or increasing the sample delta\n  // will increase or decrease the accuracy respectively.\n	const float sampleDelta = 0.100;\n	float nrSamples = 0.0;\n  float randomOffset = random(gl_FragCoord.xy) * sampleDelta;\n	for(float rawPhi = 0.0; rawPhi < 2.0 * PI; rawPhi += sampleDelta)\n	{\n    float phi = rawPhi + randomOffset;\n    for(float rawTheta = 0.0; rawTheta < ( 0.5 ) * PI; rawTheta += sampleDelta)\n    {\n      float theta = rawTheta + randomOffset;\n      // spherical to cartesian (in tangent space) // tangent space to world // add each sample result to irradiance\n      float x = sin(theta) * cos(phi);\n      float y = sin(theta) * sin(phi);\n      float z = cos(theta);\n      vec3 tangentSample = vec3( x, y, z);\n      \n      vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normal;\n        irradiance += (texture2D(environmentMap, nTOE(sampleVec)).xyz) * cos(theta) * sin(theta);\n      nrSamples++;\n    }\n	}\n	// divide by the total number of samples taken, giving us the average sampled irradiance.\n	irradiance = PI * irradiance * (1.0 / float(nrSamples )) ;\n  \n \n	gl_FragColor = vec4(irradiance, 1.0);\n}";
	var imageLightSpecularFrag = "precision highp float;\r\nvarying vec3 localPos;\r\nvarying vec2 vTexCoord;\r\n\r\n// our texture\r\nuniform sampler2D environmentMap;\r\nuniform float roughness;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nfloat VanDerCorput(int bits);\r\nvec2 HammersleyNoBitOps(int i, int N);\r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness);\r\n\r\n\r\nvec2 nTOE( vec3 v ){\r\n  // x = r sin(phi) cos(theta)   \r\n  // y = r cos(phi)  \r\n  // z = r sin(phi) sin(theta)\r\n  float phi = acos( v.y );\r\n  // if phi is 0, then there are no x, z components\r\n  float theta = 0.0;\r\n  // else \r\n  theta = acos(v.x / sin(phi));\r\n  float sinTheta = v.z / sin(phi);\r\n  if (sinTheta < 0.0) {\r\n    // Turn it into -theta, but in the 0-2PI range\r\n    theta = 2.0 * PI - theta;\r\n  }\r\n  theta = theta / (2.0 * 3.14159);\r\n  phi = phi / 3.14159 ;\r\n  \r\n  vec2 angles = vec2( phi, theta );\r\n  return angles;\r\n}\r\n\r\n\r\nvoid main(){\r\n  const int SAMPLE_COUNT = 400; // 4096\r\n  int lowRoughnessLimit = int(pow(2.0,(roughness+0.1)*20.0));\r\n  float totalWeight = 0.0;\r\n  vec3 prefilteredColor = vec3(0.0);\r\n  float phi = vTexCoord.x * 2.0 * PI;\r\n  float theta = vTexCoord.y * PI;\r\n  float x = sin(theta) * cos(phi);\r\n  float y = sin(theta) * sin(phi);\r\n  float z = cos(theta);\r\n  vec3 N = vec3(x,y,z);\r\n  vec3 V = N;\r\n  for (int i = 0; i < SAMPLE_COUNT; ++i)\r\n  {\r\n    // break at smaller sample numbers for low roughness levels\r\n    if(i == lowRoughnessLimit)\r\n    {\r\n      break;\r\n    }\r\n    vec2 Xi = HammersleyNoBitOps(i, SAMPLE_COUNT);\r\n    vec3 H = ImportanceSampleGGX(Xi, N, roughness);\r\n    vec3 L = normalize(2.0 * dot(V, H) * H - V);\r\n\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    if (NdotL > 0.0)\r\n    {\r\n      prefilteredColor += texture2D(environmentMap, nTOE(L)).xyz * NdotL;\r\n      totalWeight += NdotL;\r\n    }\r\n  }\r\n  prefilteredColor = prefilteredColor / totalWeight;\r\n\r\n  gl_FragColor = vec4(prefilteredColor, 1.0);\r\n}\r\n\r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness){\r\n  float a = roughness * roughness;\r\n\r\n  float phi = 2.0 * PI * Xi.x;\r\n  float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));\r\n  float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\r\n  // from spherical coordinates to cartesian coordinates\r\n  vec3 H;\r\n  H.x = cos(phi) * sinTheta;\r\n  H.y = sin(phi) * sinTheta;\r\n  H.z = cosTheta;\r\n\r\n  // from tangent-space vector to world-space sample vector\r\n  vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n  vec3 tangent = normalize(cross(up, N));\r\n  vec3 bitangent = cross(N, tangent);\r\n\r\n  vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r\n  return normalize(sampleVec);\r\n}\r\n\r\n\r\nfloat VanDerCorput(int n, int base)\r\n{\r\n#ifdef WEBGL2\r\n\r\n    uint bits = uint(n);\r\n    bits = (bits << 16u) | (bits >> 16u);\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n\r\n#else\r\n\r\n  float invBase = 1.0 / float(base);\r\n  float denom = 1.0;\r\n  float result = 0.0;\r\n\r\n\r\n  for (int i = 0; i < 32; ++i)\r\n  {\r\n        if (n > 0)\r\n        {\r\n        denom = mod(float(n), 2.0);\r\n        result += denom * invBase;\r\n        invBase = invBase / 2.0;\r\n        n = int(float(n) / 2.0);\r\n        }\r\n  }\r\n\r\n\r\n  return result;\r\n\r\n#endif\r\n}\r\n\r\nvec2 HammersleyNoBitOps(int i, int N)\r\n{\r\n  return vec2(float(i) / float(N), VanDerCorput(i, 2));\r\n}\r\n";
	var filterBaseFrag = "precision highp float;\n\nuniform sampler2D tex0;\nuniform vec2 canvasSize;\nuniform vec2 texelSize;\n\nIN vec2 vTexCoord;\n\nstruct FilterInputs {\n  vec2 texCoord;\n  vec2 canvasSize;\n  vec2 texelSize;\n};\n\nvoid main(void) {\n  FilterInputs inputs;\n  inputs.texCoord = vTexCoord;\n  inputs.canvasSize = canvasSize;\n  inputs.texelSize = texelSize;\n  OUT_COLOR = HOOK_getColor(inputs, tex0);\n  OUT_COLOR.rgb *= outColor.a;\n}\n";
	var filterGrayFrag = "precision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\n\nfloat luma(vec3 color) {\n  // weighted grayscale with luminance values\n  return dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\n\nvoid main() {\n  vec4 tex = texture2D(tex0, vTexCoord);\n  float gray = luma(tex.rgb);\n  gl_FragColor = vec4(gray, gray, gray, tex.a);\n}\n";
	var filterErodeFrag = "// Reduces the bright areas in an image\n\nprecision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\nuniform vec2 texelSize;\n\nfloat luma(vec3 color) {\n  // weighted grayscale with luminance values\n  // weights 77, 151, 28 taken from src/image/filters.js\n  return dot(color, vec3(0.300781, 0.589844, 0.109375));\n}\n\nvoid main() {\n  vec4 color = texture2D(tex0, vTexCoord);\n  float lum = luma(color.rgb);\n\n  // set current color as the darkest neighbor color\n\n  vec4 neighbors[4];\n  neighbors[0] = texture2D(tex0, vTexCoord + vec2( texelSize.x, 0.0));\n  neighbors[1] = texture2D(tex0, vTexCoord + vec2(-texelSize.x, 0.0));\n  neighbors[2] = texture2D(tex0, vTexCoord + vec2(0.0,  texelSize.y));\n  neighbors[3] = texture2D(tex0, vTexCoord + vec2(0.0, -texelSize.y));\n\n  for (int i = 0; i < 4; i++) {\n    vec4 neighborColor = neighbors[i];\n    float neighborLum = luma(neighborColor.rgb);\n\n    if (neighborLum < lum) {\n      color = neighborColor;\n      lum = neighborLum;\n    }\n  }\n\n  gl_FragColor = color;\n}\n";
	var filterDilateFrag = "// Increase the bright areas in an image\n\nprecision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\nuniform vec2 texelSize;\n\nfloat luma(vec3 color) {\n  // weighted grayscale with luminance values\n  // weights 77, 151, 28 taken from src/image/filters.js\n  return dot(color, vec3(0.300781, 0.589844, 0.109375));\n}\n\nvoid main() {\n  vec4 color = texture2D(tex0, vTexCoord);\n  float lum = luma(color.rgb);\n\n  // set current color as the brightest neighbor color\n\n  vec4 neighbors[4];\n  neighbors[0] = texture2D(tex0, vTexCoord + vec2( texelSize.x, 0.0));\n  neighbors[1] = texture2D(tex0, vTexCoord + vec2(-texelSize.x, 0.0));\n  neighbors[2] = texture2D(tex0, vTexCoord + vec2(0.0,  texelSize.y));\n  neighbors[3] = texture2D(tex0, vTexCoord + vec2(0.0, -texelSize.y));\n\n  for (int i = 0; i < 4; i++) {\n    vec4 neighborColor = neighbors[i];\n    float neighborLum = luma(neighborColor.rgb);\n\n    if (neighborLum > lum) {\n      color = neighborColor;\n      lum = neighborLum;\n    }\n  }\n\n  gl_FragColor = color;\n}\n";
	var filterBlurFrag = "precision highp float;\n\n// Two-pass blur filter, unweighted kernel.\n// See also a similar blur at Adam Ferriss' repo of shader examples:\n// https://github.com/aferriss/p5jsShaderExamples/blob/gh-pages/4_image-effects/4-9_single-pass-blur/effect.frag\n\n\nuniform sampler2D tex0;\nvarying vec2 vTexCoord;\nuniform vec2 direction;\nuniform vec2 canvasSize;\nuniform float radius;\n\nfloat random(vec2 p) {\n  vec3 p3  = fract(vec3(p.xyx) * .1031);\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\n// This isn't a real Gaussian weight, it's a quadratic weight. It's what the\n// CPU mode's blur uses though, so we also use it here to match.\nfloat quadWeight(float x, float e) {\n  return pow(e-abs(x), 2.);\n}\n\nvoid main(){\n  vec2 uv = vTexCoord;\n\n  // A reasonable maximum number of samples\n  const float maxSamples = 64.0;\n\n  float numSamples = floor(7. * radius);\n  if (fract(numSamples / 2.) == 0.) {\n    numSamples++;\n  }\n  vec4 avg = vec4(0.0);\n  float total = 0.0;\n\n  // Calculate the spacing to avoid skewing if numSamples > maxSamples\n  float spacing = 1.0;\n  if (numSamples > maxSamples) {\n    spacing = numSamples / maxSamples;\n    numSamples = maxSamples;\n  }\n\n  float randomOffset = (spacing - 1.0) * mix(-0.5, 0.5, random(gl_FragCoord.xy));\n  for (float i = 0.0; i < maxSamples; i++) {\n    if (i >= numSamples) break;\n\n    float sample = i * spacing - (numSamples - 1.0) * 0.5 * spacing + randomOffset;\n    vec2 sampleCoord = uv + vec2(sample, sample) / canvasSize * direction;\n    float weight = quadWeight(sample, (numSamples - 1.0) * 0.5 * spacing);\n\n    avg += weight * texture2D(tex0, sampleCoord);\n    total += weight;\n  }\n\n  avg /= total;\n  gl_FragColor = avg;\n}\n";
	var filterPosterizeFrag = "// Limit color space for a stylized cartoon / poster effect\n\nprecision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\nuniform float filterParameter;\n\nvec3 quantize(vec3 color, float n) {\n  // restrict values to N options/bins\n  // and floor each channel to nearest value\n  //\n  // eg. when N = 5, values = 0.0, 0.25, 0.50, 0.75, 1.0\n  // then quantize (0.1, 0.7, 0.9) -> (0.0, 0.5, 1.0)\n\n  color = color * n;\n  color = floor(color);\n  color = color / (n - 1.0);\n  return color;\n}\n\nvoid main() {\n  vec4 color = texture2D(tex0, vTexCoord);\n\n  vec3 restrictedColor = quantize(color.rgb / color.a, filterParameter);\n\n  gl_FragColor = vec4(restrictedColor.rgb * color.a, color.a);\n}\n";
	var filterOpaqueFrag = "// Set alpha channel to entirely opaque\n\nprecision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\n\nvoid main() {\n  vec4 color = texture2D(tex0, vTexCoord);\n  gl_FragColor = vec4(color.rgb / color.a, 1.0);\n}\n";
	var filterInvertFrag = "// Set each pixel to inverse value\n// Note that original INVERT does not change the opacity, so this follows suit\n\nprecision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\n\nvoid main() {\nvec4 color = texture2D(tex0, vTexCoord);\nvec3 origColor = color.rgb / color.a;\nvec3 invertedColor = vec3(1.0) - origColor;\ngl_FragColor = vec4(invertedColor * color.a, color.a);\n}\n";
	var filterThresholdFrag = "// Convert pixels to either white or black, \n// depending on if their luma is above or below filterParameter\n\nprecision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\nuniform float filterParameter;\n\nfloat luma(vec3 color) {\n  // weighted grayscale with luminance values\n  return dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\n\nvoid main() {\n  vec4 color = texture2D(tex0, vTexCoord);\n  float gray = luma(color.rgb / color.a);\n  // floor() used to match src/image/filters.js\n  float threshold = floor(filterParameter * 255.0) / 255.0;\n  float blackOrWhite = step(threshold, gray);\n  gl_FragColor = vec4(vec3(blackOrWhite) * color.a, color.a);\n}\n";
	var filterShaderVert = "uniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nattribute vec3 aPosition;\n// texcoords only come from p5 to vertex shader\n// so pass texcoords on to the fragment shader in a varying variable\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\n\nvoid main() {\n  // transferring texcoords for the frag shader\n  vTexCoord = aTexCoord;\n\n  // copy position with a fourth coordinate for projection (1.0 is normal)\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n}\n";
	const STROKE_CAP_ENUM = {};
	const STROKE_JOIN_ENUM = {};
	let lineDefs = "";
	const defineStrokeCapEnum = function(key, val$1) {
		lineDefs += `#define STROKE_CAP_${key} ${val$1}\n`;
		STROKE_CAP_ENUM[constants[key]] = val$1;
	};
	const defineStrokeJoinEnum = function(key, val$1) {
		lineDefs += `#define STROKE_JOIN_${key} ${val$1}\n`;
		STROKE_JOIN_ENUM[constants[key]] = val$1;
	};
	defineStrokeCapEnum("ROUND", 0);
	defineStrokeCapEnum("PROJECT", 1);
	defineStrokeCapEnum("SQUARE", 2);
	defineStrokeJoinEnum("ROUND", 0);
	defineStrokeJoinEnum("MITER", 1);
	defineStrokeJoinEnum("BEVEL", 2);
	const defaultShaders = {
		normalVert,
		normalFrag,
		basicFrag,
		sphereMappingFrag,
		lightVert: lightingShader + lightVert,
		lightTextureFrag,
		phongVert,
		phongFrag: lightingShader + phongFrag,
		fontVert,
		fontFrag,
		lineVert: lineDefs + lineVert,
		lineFrag: lineDefs + lineFrag,
		pointVert,
		pointFrag,
		imageLightVert,
		imageLightDiffusedFrag,
		imageLightSpecularFrag,
		filterBaseVert,
		filterBaseFrag
	};
	let sphereMapping = defaultShaders.sphereMappingFrag;
	for (const key in defaultShaders) defaultShaders[key] = webgl2CompatibilityShader + defaultShaders[key];
	const filterShaderFrags = {
		[GRAY]: filterGrayFrag,
		[ERODE]: filterErodeFrag,
		[DILATE]: filterDilateFrag,
		[BLUR]: filterBlurFrag,
		[POSTERIZE]: filterPosterizeFrag,
		[OPAQUE]: filterOpaqueFrag,
		[INVERT]: filterInvertFrag,
		[THRESHOLD]: filterThresholdFrag
	};
	var RendererGL = class RendererGL extends Renderer {
		constructor(pInst, w, h, isMainCanvas, elt, attr) {
			super(pInst, w, h, isMainCanvas);
			this.canvas = this.elt = elt || document.createElement("canvas");
			this._setAttributeDefaults(pInst);
			this._initContext();
			this.GL = this.drawingContext;
			if (this._isMainCanvas) {
				this._pInst._curElement = this;
				this._pInst.canvas = this.canvas;
			} else this.canvas.style.display = "none";
			this.elt.id = "defaultCanvas0";
			this.elt.classList.add("p5Canvas");
			this.wrappedElt = new Element(this.elt, this._pInst);
			for (const p$1 of Object.getOwnPropertyNames(Element.prototype)) if (p$1 !== "constructor" && p$1[0] !== "_") Object.defineProperty(this, p$1, { get() {
				return this.wrappedElt[p$1];
			} });
			const dimensions = this._adjustDimensions(w, h);
			w = dimensions.adjustedWidth;
			h = dimensions.adjustedHeight;
			this.width = w;
			this.height = h;
			this.elt.width = w * this._pixelDensity;
			this.elt.height = h * this._pixelDensity;
			this.elt.style.width = `${w}px`;
			this.elt.style.height = `${h}px`;
			this._origViewport = {
				width: this.GL.drawingBufferWidth,
				height: this.GL.drawingBufferHeight
			};
			this.viewport(this._origViewport.width, this._origViewport.height);
			if (this._pInst._userNode) this._pInst._userNode.appendChild(this.elt);
			else {
				if (document.getElementsByTagName("main").length === 0) {
					let m = document.createElement("main");
					document.body.appendChild(m);
				}
				document.getElementsByTagName("main")[0].appendChild(this.elt);
			}
			this.isP3D = true;
			this.geometryBuilder = void 0;
			this.states.uModelMatrix = new Matrix(4);
			this.states.uViewMatrix = new Matrix(4);
			this.states.uPMatrix = new Matrix(4);
			this.states.curCamera = new Camera(this);
			this.states.uPMatrix.set(this.states.curCamera.projMatrix);
			this.states.uViewMatrix.set(this.states.curCamera.cameraMatrix);
			this.states.enableLighting = false;
			this.states.ambientLightColors = [];
			this.states.specularColors = [
				1,
				1,
				1
			];
			this.states.directionalLightDirections = [];
			this.states.directionalLightDiffuseColors = [];
			this.states.directionalLightSpecularColors = [];
			this.states.pointLightPositions = [];
			this.states.pointLightDiffuseColors = [];
			this.states.pointLightSpecularColors = [];
			this.states.spotLightPositions = [];
			this.states.spotLightDirections = [];
			this.states.spotLightDiffuseColors = [];
			this.states.spotLightSpecularColors = [];
			this.states.spotLightAngle = [];
			this.states.spotLightConc = [];
			this.states.activeImageLight = null;
			this.states.curFillColor = [
				1,
				1,
				1,
				1
			];
			this.states.curAmbientColor = [
				1,
				1,
				1,
				1
			];
			this.states.curSpecularColor = [
				0,
				0,
				0,
				0
			];
			this.states.curEmissiveColor = [
				0,
				0,
				0,
				0
			];
			this.states.curStrokeColor = [
				0,
				0,
				0,
				1
			];
			this.states.curBlendMode = BLEND;
			this.states._hasSetAmbient = false;
			this.states._useSpecularMaterial = false;
			this.states._useEmissiveMaterial = false;
			this.states._useNormalMaterial = false;
			this.states._useShininess = 1;
			this.states._useMetalness = 0;
			this.states.tint = [
				255,
				255,
				255,
				255
			];
			this.states.constantAttenuation = 1;
			this.states.linearAttenuation = 0;
			this.states.quadraticAttenuation = 0;
			this.states._currentNormal = new Vector(0, 0, 1);
			this.states.drawMode = FILL;
			this.states._tex = null;
			this.states.textureMode = IMAGE;
			this.states.textureWrapX = CLAMP;
			this.states.textureWrapY = CLAMP;
			this._isErasing = false;
			this._simpleLines = false;
			this._clipDepths = [];
			this._isClipApplied = false;
			this._stencilTestOn = false;
			this.mixedAmbientLight = [];
			this.mixedSpecularColor = [];
			this.diffusedTextures = /* @__PURE__ */ new Map();
			this.specularTextures = /* @__PURE__ */ new Map();
			this.preEraseBlend = void 0;
			this._cachedBlendMode = void 0;
			this._cachedFillStyle = [
				1,
				1,
				1,
				1
			];
			this._cachedStrokeStyle = [
				0,
				0,
				0,
				1
			];
			if (this.webglVersion === WEBGL2) this.blendExt = this.GL;
			else this.blendExt = this.GL.getExtension("EXT_blend_minmax");
			this._isBlending = false;
			this._useLineColor = false;
			this._useVertexColor = false;
			this.registerEnabled = /* @__PURE__ */ new Set();
			this.states.curCamera._computeCameraDefaultSettings();
			this.states.curCamera._setDefaultCamera();
			this.filterCamera = new Camera(this);
			this.filterCamera._computeCameraDefaultSettings();
			this.filterCamera._setDefaultCamera();
			this.prevTouches = [];
			this.zoomVelocity = 0;
			this.rotateVelocity = new Vector(0, 0);
			this.moveVelocity = new Vector(0, 0);
			this.executeZoom = false;
			this.executeRotateAndMove = false;
			this._drawingFilter = false;
			this._drawingImage = false;
			this.specularShader = void 0;
			this.sphereMapping = void 0;
			this.diffusedShader = void 0;
			this._baseFilterShader = void 0;
			this._defaultLightShader = void 0;
			this._defaultImmediateModeShader = void 0;
			this._defaultNormalShader = void 0;
			this._defaultColorShader = void 0;
			this._defaultPointShader = void 0;
			this.states.userFillShader = void 0;
			this.states.userStrokeShader = void 0;
			this.states.userPointShader = void 0;
			this.states.userImageShader = void 0;
			this.states.curveDetail = 1 / 4;
			this.shapeBuilder = new ShapeBuilder(this);
			this.buffers = {
				fill: [
					new RenderBuffer(3, "vertices", "vertexBuffer", "aPosition", this, this._vToNArray),
					new RenderBuffer(3, "vertexNormals", "normalBuffer", "aNormal", this, this._vToNArray),
					new RenderBuffer(4, "vertexColors", "colorBuffer", "aVertexColor", this),
					new RenderBuffer(3, "vertexAmbients", "ambientBuffer", "aAmbientColor", this),
					new RenderBuffer(2, "uvs", "uvBuffer", "aTexCoord", this, (arr$1) => arr$1.flat())
				],
				stroke: [
					new RenderBuffer(4, "lineVertexColors", "lineColorBuffer", "aVertexColor", this),
					new RenderBuffer(3, "lineVertices", "lineVerticesBuffer", "aPosition", this),
					new RenderBuffer(3, "lineTangentsIn", "lineTangentsInBuffer", "aTangentIn", this),
					new RenderBuffer(3, "lineTangentsOut", "lineTangentsOutBuffer", "aTangentOut", this),
					new RenderBuffer(1, "lineSides", "lineSidesBuffer", "aSide", this)
				],
				text: [new RenderBuffer(3, "vertices", "vertexBuffer", "aPosition", this, this._vToNArray), new RenderBuffer(2, "uvs", "uvBuffer", "aTexCoord", this, (arr$1) => arr$1.flat())],
				point: this.GL.createBuffer(),
				user: []
			};
			this.geometryBufferCache = new GeometryBufferCache(this);
			this.curStrokeCap = ROUND;
			this.curStrokeJoin = ROUND;
			this.textures = /* @__PURE__ */ new Map();
			this.framebuffers = /* @__PURE__ */ new Set();
			this.activeFramebuffers = [];
			this.states.filterShader = void 0;
			this.filterLayer = void 0;
			this.filterLayerTemp = void 0;
			this.defaultFilterShaders = {};
			this.fontInfos = {};
			this._curShader = void 0;
			this.drawShapeCount = 1;
			this.scratchMat3 = new Matrix(3);
			this._userEnabledStencil = false;
			this._internalEnable = this.drawingContext.enable;
			this._internalDisable = this.drawingContext.disable;
			this.drawingContext.enable = (key) => {
				if (key === this.drawingContext.STENCIL_TEST) {
					if (!this._clipping) this._userEnabledStencil = true;
				}
				return this._internalEnable.call(this.drawingContext, key);
			};
			this.drawingContext.disable = (key) => {
				if (key === this.drawingContext.STENCIL_TEST) this._userEnabledStencil = false;
				return this._internalDisable.call(this.drawingContext, key);
			};
			this._validateFaces = false;
		}
		remove() {
			this.wrappedElt.remove();
			this.wrappedElt = null;
			this.canvas = null;
			this.elt = null;
		}
		beginGeometry() {
			if (this.geometryBuilder) throw new Error("It looks like `beginGeometry()` is being called while another p5.Geometry is already being build.");
			this.geometryBuilder = new GeometryBuilder(this);
			this.geometryBuilder.prevFillColor = this.states.fillColor;
			this.fill(new Color([
				-1,
				-1,
				-1,
				-1
			]));
		}
		endGeometry() {
			if (!this.geometryBuilder) throw new Error("Make sure you call beginGeometry() before endGeometry()!");
			const geometry$1 = this.geometryBuilder.finish();
			this.fill(this.geometryBuilder.prevFillColor);
			this.geometryBuilder = void 0;
			return geometry$1;
		}
		buildGeometry(callback) {
			this.beginGeometry();
			callback();
			return this.endGeometry();
		}
		beginShape(...args) {
			super.beginShape(...args);
		}
		curveDetail(d$1) {
			if (d$1 === void 0) return this.states.curveDetail;
			else this.states.setValue("curveDetail", d$1);
		}
		drawShape(shape$1) {
			const visitor = new PrimitiveToVerticesConverter({ curveDetail: this.states.curveDetail });
			shape$1.accept(visitor);
			this.shapeBuilder.constructFromContours(shape$1, visitor.contours);
			if (this.geometryBuilder) this.geometryBuilder.addImmediate(this.shapeBuilder.geometry, this.shapeBuilder.shapeMode, { validateFaces: this._validateFaces });
			else if (this.states.fillColor || this.states.strokeColor) if (this.shapeBuilder.shapeMode === POINTS) this._drawPoints(this.shapeBuilder.geometry.vertices, this.buffers.point);
			else this._drawGeometry(this.shapeBuilder.geometry, {
				mode: this.shapeBuilder.shapeMode,
				count: this.drawShapeCount
			});
			this.drawShapeCount = 1;
		}
		endShape(mode, count) {
			this.drawShapeCount = count;
			super.endShape(mode, count);
		}
		vertexProperty(...args) {
			this.currentShape.vertexProperty(...args);
		}
		normal(xorv, y, z$1) {
			if (xorv instanceof Vector) this.states.setValue("_currentNormal", xorv);
			else this.states.setValue("_currentNormal", new Vector(xorv, y, z$1));
			this.updateShapeVertexProperties();
		}
		model(model, count = 1) {
			if (model.vertices.length > 0) if (this.geometryBuilder) this.geometryBuilder.addRetained(model);
			else {
				if (!this.geometryInHash(model.gid)) {
					model._edgesToVertices();
					this._getOrMakeCachedBuffers(model);
				}
				this._drawGeometry(model, { count });
			}
		}
		_drawGeometry(geometry$1, { mode = TRIANGLES, count = 1 } = {}) {
			for (const propName in geometry$1.userVertexProperties) {
				const prop = geometry$1.userVertexProperties[propName];
				this.buffers.user.push(new RenderBuffer(prop.getDataSize(), prop.getSrcName(), prop.getDstName(), prop.getName(), this));
			}
			if (this.states.fillColor && geometry$1.vertices.length >= 3 && ![LINES, POINTS].includes(mode)) this._drawFills(geometry$1, {
				mode,
				count
			});
			if (this.states.strokeColor && geometry$1.lineVertices.length >= 1) this._drawStrokes(geometry$1, { count });
			this.buffers.user = [];
		}
		_drawGeometryScaled(model, scaleX, scaleY, scaleZ) {
			let originalModelMatrix = this.states.uModelMatrix;
			this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
			try {
				this.states.uModelMatrix.scale(scaleX, scaleY, scaleZ);
				if (this.geometryBuilder) this.geometryBuilder.addRetained(model);
				else this._drawGeometry(model);
			} finally {
				this.states.setValue("uModelMatrix", originalModelMatrix);
			}
		}
		_drawFills(geometry$1, { count, mode } = {}) {
			this._useVertexColor = geometry$1.vertexColors.length > 0;
			const shader$1 = !this._drawingFilter && this.states.userFillShader ? this.states.userFillShader : this._getFillShader();
			shader$1.bindShader();
			this._setGlobalUniforms(shader$1);
			this._setFillUniforms(shader$1);
			shader$1.bindTextures();
			for (const buff of this.buffers.fill) buff._prepareBuffer(geometry$1, shader$1);
			this._prepareUserAttributes(geometry$1, shader$1);
			shader$1.disableRemainingAttributes();
			this._applyColorBlend(this.states.curFillColor, geometry$1.hasFillTransparency());
			this._drawBuffers(geometry$1, {
				mode,
				count
			});
			shader$1.unbindShader();
		}
		_drawStrokes(geometry$1, { count } = {}) {
			const gl = this.GL;
			this._useLineColor = geometry$1.vertexStrokeColors.length > 0;
			const shader$1 = this._getStrokeShader();
			shader$1.bindShader();
			this._setGlobalUniforms(shader$1);
			this._setStrokeUniforms(shader$1);
			shader$1.bindTextures();
			for (const buff of this.buffers.stroke) buff._prepareBuffer(geometry$1, shader$1);
			this._prepareUserAttributes(geometry$1, shader$1);
			shader$1.disableRemainingAttributes();
			this._applyColorBlend(this.states.curStrokeColor, geometry$1.hasStrokeTransparency());
			if (count === 1) gl.drawArrays(gl.TRIANGLES, 0, geometry$1.lineVertices.length / 3);
			else try {
				gl.drawArraysInstanced(gl.TRIANGLES, 0, geometry$1.lineVertices.length / 3, count);
			} catch (e$1) {
				console.log("🌸 p5.js says: Instancing is only supported in WebGL2 mode");
			}
			shader$1.unbindShader();
		}
		_drawPoints(vertices, vertexBuffer) {
			const gl = this.GL;
			const pointShader = this._getPointShader();
			pointShader.bindShader();
			this._setGlobalUniforms(pointShader);
			this._setPointUniforms(pointShader);
			pointShader.bindTextures();
			this._bindBuffer(vertexBuffer, gl.ARRAY_BUFFER, this._vToNArray(vertices), Float32Array, gl.STATIC_DRAW);
			pointShader.enableAttrib(pointShader.attributes.aPosition, 3);
			this._applyColorBlend(this.states.curStrokeColor);
			gl.drawArrays(gl.Points, 0, vertices.length);
			pointShader.unbindShader();
		}
		_prepareUserAttributes(geometry$1, shader$1) {
			for (const buff of this.buffers.user) {
				if (!this._pInst.constructor.disableFriendlyErrors) {
					const prop = geometry$1.userVertexProperties[buff.attr];
					if (prop) {
						const adjustedLength = prop.getSrcArray().length / prop.getDataSize();
						if (adjustedLength > geometry$1.vertices.length) this._pInst.constructor._friendlyError(`One of the geometries has a custom vertex property '${prop.getName()}' with more values than vertices. This is probably caused by directly using the Geometry.vertexProperty() method.`, "vertexProperty()");
						else if (adjustedLength < geometry$1.vertices.length) this._pInst.constructor._friendlyError(`One of the geometries has a custom vertex property '${prop.getName()}' with fewer values than vertices. This is probably caused by directly using the Geometry.vertexProperty() method.`, "vertexProperty()");
					}
				}
				buff._prepareBuffer(geometry$1, shader$1);
			}
		}
		_drawBuffers(geometry$1, { mode = this.GL.TRIANGLES, count }) {
			const gl = this.GL;
			const glBuffers = this.geometryBufferCache.getCached(geometry$1);
			if (!glBuffers) return;
			if (glBuffers.indexBuffer) {
				this._bindBuffer(glBuffers.indexBuffer, gl.ELEMENT_ARRAY_BUFFER);
				if (this._pInst.webglVersion !== WEBGL2 && glBuffers.indexBufferType === gl.UNSIGNED_INT) {
					if (!gl.getExtension("OES_element_index_uint")) throw new Error("Unable to render a 3d model with > 65535 triangles. Your web browser does not support the WebGL Extension OES_element_index_uint.");
				}
				if (count === 1) gl.drawElements(gl.TRIANGLES, geometry$1.faces.length * 3, glBuffers.indexBufferType, 0);
				else try {
					gl.drawElementsInstanced(gl.TRIANGLES, geometry$1.faces.length * 3, glBuffers.indexBufferType, 0, count);
				} catch (e$1) {
					console.log("🌸 p5.js says: Instancing is only supported in WebGL2 mode");
				}
			} else if (count === 1) gl.drawArrays(mode, 0, geometry$1.vertices.length);
			else try {
				gl.drawArraysInstanced(mode, 0, geometry$1.vertices.length, count);
			} catch (e$1) {
				console.log("🌸 p5.js says: Instancing is only supported in WebGL2 mode");
			}
		}
		_getOrMakeCachedBuffers(geometry$1) {
			return this.geometryBufferCache.ensureCached(geometry$1);
		}
		_setAttributeDefaults(pInst) {
			const defaults$1 = {
				alpha: true,
				depth: true,
				stencil: true,
				antialias: navigator.userAgent.toLowerCase().includes("safari"),
				premultipliedAlpha: true,
				preserveDrawingBuffer: true,
				perPixelLighting: true,
				version: 2
			};
			if (pInst._glAttributes === null) pInst._glAttributes = defaults$1;
			else pInst._glAttributes = Object.assign(defaults$1, pInst._glAttributes);
		}
		_initContext() {
			if (this._pInst._glAttributes?.version !== 1) this.drawingContext = this.canvas.getContext("webgl2", this._pInst._glAttributes);
			this.webglVersion = this.drawingContext ? WEBGL2 : WEBGL;
			this._pInst.webglVersion = this.webglVersion;
			if (!this.drawingContext) this.drawingContext = this.canvas.getContext("webgl", this._pInst._glAttributes) || this.canvas.getContext("experimental-webgl", this._pInst._glAttributes);
			if (this.drawingContext === null) throw new Error("Error creating webgl context");
			else {
				const gl = this.drawingContext;
				gl.enable(gl.DEPTH_TEST);
				gl.depthFunc(gl.LEQUAL);
				gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
				gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
				this._viewport = this.drawingContext.getParameter(this.drawingContext.VIEWPORT);
			}
		}
		_getMaxTextureSize() {
			const gl = this.drawingContext;
			return gl.getParameter(gl.MAX_TEXTURE_SIZE);
		}
		_adjustDimensions(width, height) {
			if (!this._maxTextureSize) this._maxTextureSize = this._getMaxTextureSize();
			let maxTextureSize = this._maxTextureSize;
			let maxAllowedPixelDimensions = Math.floor(maxTextureSize / this._pixelDensity);
			let adjustedWidth = Math.min(width, maxAllowedPixelDimensions);
			let adjustedHeight = Math.min(height, maxAllowedPixelDimensions);
			if (adjustedWidth !== width || adjustedHeight !== height) console.warn(`Warning: The requested width/height exceeds hardware limits. Adjusting dimensions to width: ${adjustedWidth}, height: ${adjustedHeight}.`);
			return {
				adjustedWidth,
				adjustedHeight
			};
		}
		_resetContext(options$1, callback) {
			const w = this.width;
			const h = this.height;
			const defaultId = this.canvas.id;
			const isPGraphics = this._pInst instanceof Graphics;
			const prevStyle = {
				position: this.canvas.style.position,
				top: this.canvas.style.top,
				left: this.canvas.style.left
			};
			if (isPGraphics) {
				const pg = this._pInst;
				pg.canvas.parentNode.removeChild(pg.canvas);
				pg.canvas = document.createElement("canvas");
				(pg._pInst._userNode || document.body).appendChild(pg.canvas);
				Element.call(pg, pg.canvas, pg._pInst);
				pg.width = w;
				pg.height = h;
			} else {
				let c = this.canvas;
				if (c) c.parentNode.removeChild(c);
				c = document.createElement("canvas");
				c.id = defaultId;
				if (this._pInst._userNode) this._pInst._userNode.appendChild(c);
				else document.body.appendChild(c);
				this._pInst.canvas = c;
				this.canvas = c;
				this.canvas.style.position = prevStyle.position;
				this.canvas.style.top = prevStyle.top;
				this.canvas.style.left = prevStyle.left;
			}
			const renderer$1 = new RendererGL(this._pInst, w, h, !isPGraphics, this._pInst.canvas);
			this._pInst._renderer = renderer$1;
			renderer$1._applyDefaults();
			if (typeof callback === "function") setTimeout(() => {
				callback.apply(window._renderer, options$1);
			}, 0);
		}
		_update() {
			this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
			this.states.uModelMatrix.reset();
			this.states.setValue("uViewMatrix", this.states.uViewMatrix.clone());
			this.states.uViewMatrix.set(this.states.curCamera.cameraMatrix);
			this.states.setValue("ambientLightColors", []);
			this.states.setValue("specularColors", [
				1,
				1,
				1
			]);
			this.states.setValue("directionalLightDirections", []);
			this.states.setValue("directionalLightDiffuseColors", []);
			this.states.setValue("directionalLightSpecularColors", []);
			this.states.setValue("pointLightPositions", []);
			this.states.setValue("pointLightDiffuseColors", []);
			this.states.setValue("pointLightSpecularColors", []);
			this.states.setValue("spotLightPositions", []);
			this.states.setValue("spotLightDirections", []);
			this.states.setValue("spotLightDiffuseColors", []);
			this.states.setValue("spotLightSpecularColors", []);
			this.states.setValue("spotLightAngle", []);
			this.states.setValue("spotLightConc", []);
			this.states.setValue("enableLighting", false);
			this.states.setValue("tint", [
				255,
				255,
				255,
				255
			]);
			this.GL.clearStencil(0);
			this.GL.clear(this.GL.DEPTH_BUFFER_BIT | this.GL.STENCIL_BUFFER_BIT);
			if (!this._userEnabledStencil) this._internalDisable.call(this.GL, this.GL.STENCIL_TEST);
		}
		background(...args) {
			const _col = this._pInst.color(...args);
			this.clear(..._col._getRGBA());
		}
		get uModelMatrix() {
			return this.states.uModelMatrix;
		}
		get uViewMatrix() {
			return this.states.uViewMatrix;
		}
		get uPMatrix() {
			return this.states.uPMatrix;
		}
		get uMVMatrix() {
			const m = this.uModelMatrix.copy();
			m.mult(this.uViewMatrix);
			return m;
		}
		getWorldToScreenMatrix() {
			const modelMatrix = this.states.uModelMatrix;
			const viewMatrix = this.states.uViewMatrix;
			const projectionMatrix = this.states.uPMatrix;
			const projectedToScreenMatrix = new Matrix(4);
			projectedToScreenMatrix.scale(this.width, this.height, 1);
			projectedToScreenMatrix.translate([
				.5,
				.5,
				.5
			]);
			projectedToScreenMatrix.scale(.5, -.5, .5);
			return modelMatrix.copy().mult(viewMatrix).mult(projectionMatrix).mult(projectedToScreenMatrix);
		}
		fill(...args) {
			super.fill(...args);
			const color$2 = this.states.fillColor;
			this.states.setValue("curFillColor", color$2._array);
			this.states.setValue("drawMode", FILL);
			this.states.setValue("_useNormalMaterial", false);
			this.states.setValue("_tex", null);
		}
		stroke(...args) {
			super.stroke(...args);
			this.states.setValue("curStrokeColor", this.states.strokeColor._array);
		}
		getCommonVertexProperties() {
			return {
				...super.getCommonVertexProperties(),
				stroke: this.states.strokeColor,
				fill: this.states.fillColor,
				normal: this.states._currentNormal
			};
		}
		getSupportedIndividualVertexProperties() {
			return { textureCoordinates: true };
		}
		strokeCap(cap) {
			this.curStrokeCap = cap;
		}
		strokeJoin(join$1) {
			this.curStrokeJoin = join$1;
		}
		getFilterLayer() {
			if (!this.filterLayer) this.filterLayer = new Framebuffer(this);
			return this.filterLayer;
		}
		getFilterLayerTemp() {
			if (!this.filterLayerTemp) this.filterLayerTemp = new Framebuffer(this);
			return this.filterLayerTemp;
		}
		matchSize(fboToMatch, target) {
			if (fboToMatch.width !== target.width || fboToMatch.height !== target.height) fboToMatch.resize(target.width, target.height);
			if (fboToMatch.pixelDensity() !== target.pixelDensity()) fboToMatch.pixelDensity(target.pixelDensity());
		}
		filter(...args) {
			let fbo = this.getFilterLayer();
			let filterParameter = void 0;
			let operation = void 0;
			if (typeof args[0] === "string") {
				operation = args[0];
				filterParameter = operation in filterParamDefaults && args[1] === void 0 ? filterParamDefaults[operation] : args[1];
				if (!(operation in this.defaultFilterShaders)) this.defaultFilterShaders[operation] = new Shader(fbo.renderer, filterShaderVert, filterShaderFrags[operation]);
				this.states.setValue("filterShader", this.defaultFilterShaders[operation]);
			} else this.states.setValue("filterShader", args[0]);
			const target = this.activeFramebuffer() || this;
			this.matchSize(fbo, target);
			fbo.draw(() => this.clear());
			let texelSize = [1 / (target.width * target.pixelDensity()), 1 / (target.height * target.pixelDensity())];
			if (operation === BLUR) {
				const tmp = this.getFilterLayerTemp();
				this.matchSize(tmp, target);
				this.push();
				this.states.setValue("strokeColor", null);
				this.blendMode(BLEND);
				this.shader(this.states.filterShader);
				this.states.filterShader.setUniform("texelSize", texelSize);
				this.states.filterShader.setUniform("canvasSize", [target.width, target.height]);
				this.states.filterShader.setUniform("radius", Math.max(1, filterParameter));
				tmp.draw(() => {
					this.states.filterShader.setUniform("direction", [1, 0]);
					this.states.filterShader.setUniform("tex0", target);
					this.clear();
					this.shader(this.states.filterShader);
					this.noLights();
					this.plane(target.width, target.height);
				});
				fbo.draw(() => {
					this.states.filterShader.setUniform("direction", [0, 1]);
					this.states.filterShader.setUniform("tex0", tmp);
					this.clear();
					this.shader(this.states.filterShader);
					this.noLights();
					this.plane(target.width, target.height);
				});
				this.pop();
			} else fbo.draw(() => {
				this.states.setValue("strokeColor", null);
				this.blendMode(BLEND);
				this.shader(this.states.filterShader);
				this.states.filterShader.setUniform("tex0", target);
				this.states.filterShader.setUniform("texelSize", texelSize);
				this.states.filterShader.setUniform("canvasSize", [target.width, target.height]);
				this.states.filterShader.setUniform("filterParameter", filterParameter);
				this.noLights();
				this.plane(target.width, target.height);
			});
			this.push();
			this.states.setValue("strokeColor", null);
			this.clear();
			this.push();
			this.states.setValue("imageMode", CORNER);
			this.blendMode(BLEND);
			target.filterCamera._resize();
			this.setCamera(target.filterCamera);
			this.resetMatrix();
			this._drawingFilter = true;
			this.image(fbo, 0, 0, this.width, this.height, -target.width / 2, -target.height / 2, target.width, target.height);
			this._drawingFilter = false;
			this.clearDepth();
			this.pop();
			this.pop();
		}
		pixelDensity(newDensity) {
			if (newDensity) return this._pInst.pixelDensity(newDensity);
			return this._pInst.pixelDensity();
		}
		blendMode(mode) {
			if (mode === DARKEST || mode === LIGHTEST || mode === ADD || mode === BLEND || mode === SUBTRACT || mode === SCREEN || mode === EXCLUSION || mode === REPLACE || mode === MULTIPLY || mode === REMOVE) this.states.setValue("curBlendMode", mode);
			else if (mode === BURN || mode === OVERLAY || mode === HARD_LIGHT || mode === SOFT_LIGHT || mode === DODGE) console.warn("BURN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, and DODGE only work for blendMode in 2D mode.");
		}
		erase(opacityFill, opacityStroke) {
			if (!this._isErasing) {
				this.preEraseBlend = this.states.curBlendMode;
				this._isErasing = true;
				this.blendMode(REMOVE);
				this._cachedFillStyle = this.states.curFillColor.slice();
				this.states.setValue("curFillColor", [
					1,
					1,
					1,
					opacityFill / 255
				]);
				this._cachedStrokeStyle = this.states.curStrokeColor.slice();
				this.states.setValue("curStrokeColor", [
					1,
					1,
					1,
					opacityStroke / 255
				]);
			}
		}
		noErase() {
			if (this._isErasing) {
				this.states.setValue("curFillColor", this._cachedFillStyle.slice());
				this.states.setValue("curStrokeColor", this._cachedStrokeStyle.slice());
				this.states.setValue("curBlendMode", this.preEraseBlend);
				this.blendMode(this.preEraseBlend);
				this._isErasing = false;
				this._applyBlendMode();
			}
		}
		drawTarget() {
			return this.activeFramebuffers[this.activeFramebuffers.length - 1] || this;
		}
		beginClip(options$1 = {}) {
			super.beginClip(options$1);
			this.drawTarget()._isClipApplied = true;
			const gl = this.GL;
			gl.clearStencil(0);
			gl.clear(gl.STENCIL_BUFFER_BIT);
			this._internalEnable.call(gl, gl.STENCIL_TEST);
			this._stencilTestOn = true;
			gl.stencilFunc(gl.ALWAYS, 1, 255);
			gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
			gl.disable(gl.DEPTH_TEST);
			this.push();
			this.resetShader();
			if (this.states.fillColor) this.fill(0, 0);
			if (this.states.strokeColor) this.stroke(0, 0);
		}
		endClip() {
			this.pop();
			const gl = this.GL;
			gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
			gl.stencilFunc(this._clipInvert ? gl.EQUAL : gl.NOTEQUAL, 0, 255);
			gl.enable(gl.DEPTH_TEST);
			this._clipDepths.push(this._pushPopDepth);
			super.endClip();
		}
		_clearClip() {
			this.GL.clearStencil(1);
			this.GL.clear(this.GL.STENCIL_BUFFER_BIT);
			if (this._clipDepths.length > 0) this._clipDepths.pop();
			this.drawTarget()._isClipApplied = false;
		}
		_getPixel(x$1, y) {
			const gl = this.GL;
			return readPixelWebGL(gl, null, x$1, y, gl.RGBA, gl.UNSIGNED_BYTE, this._pInst.height * this._pInst.pixelDensity());
		}
		loadPixels() {
			if (this._pInst._glAttributes.preserveDrawingBuffer !== true) {
				console.log("loadPixels only works in WebGL when preserveDrawingBuffer is true.");
				return;
			}
			const pd = this._pixelDensity;
			const gl = this.GL;
			this.pixels = readPixelsWebGL(this.pixels, gl, null, 0, 0, this.width * pd, this.height * pd, gl.RGBA, gl.UNSIGNED_BYTE, this.height * pd);
		}
		updatePixels() {
			const fbo = this._getTempFramebuffer();
			fbo.pixels = this.pixels;
			fbo.updatePixels();
			this.push();
			this.resetMatrix();
			this.clear();
			this.states.setValue("imageMode", CORNER);
			this.image(fbo, 0, 0, fbo.width, fbo.height, -fbo.width / 2, -fbo.height / 2, fbo.width, fbo.height);
			this.pop();
			this.GL.clearDepth(1);
			this.GL.clear(this.GL.DEPTH_BUFFER_BIT);
		}
		_getTempFramebuffer() {
			if (!this._tempFramebuffer) this._tempFramebuffer = new Framebuffer(this, {
				format: UNSIGNED_BYTE,
				useDepth: this._pInst._glAttributes.depth,
				depthFormat: UNSIGNED_INT,
				antialias: this._pInst._glAttributes.antialias
			});
			return this._tempFramebuffer;
		}
		geometryInHash(gid) {
			return this.geometryBufferCache.isCached(gid);
		}
		viewport(w, h) {
			this._viewport = [
				0,
				0,
				w,
				h
			];
			this.GL.viewport(0, 0, w, h);
		}
		resize(w, h) {
			super.resize(w, h);
			const props = {};
			for (const key in this.drawingContext) {
				const val$1 = this.drawingContext[key];
				if (typeof val$1 !== "object" && typeof val$1 !== "function") props[key] = val$1;
			}
			const dimensions = this._adjustDimensions(w, h);
			w = dimensions.adjustedWidth;
			h = dimensions.adjustedHeight;
			this.width = w;
			this.height = h;
			this.canvas.width = w * this._pixelDensity;
			this.canvas.height = h * this._pixelDensity;
			this.canvas.style.width = `${w}px`;
			this.canvas.style.height = `${h}px`;
			this._origViewport = {
				width: this.GL.drawingBufferWidth,
				height: this.GL.drawingBufferHeight
			};
			this.viewport(this._origViewport.width, this._origViewport.height);
			this.states.curCamera._resize();
			if (typeof this.pixels !== "undefined") this.pixels = new Uint8Array(this.GL.drawingBufferWidth * this.GL.drawingBufferHeight * 4);
			for (const framebuffer$1 of this.framebuffers) framebuffer$1._canvasSizeChanged();
			for (const savedKey in props) try {
				this.drawingContext[savedKey] = props[savedKey];
			} catch (err$1) {}
		}
		clear(...args) {
			const _r = args[0] || 0;
			const _g = args[1] || 0;
			const _b = args[2] || 0;
			let _a = args[3] || 0;
			const activeFramebuffer = this.activeFramebuffer();
			if (activeFramebuffer && activeFramebuffer.format === UNSIGNED_BYTE && !activeFramebuffer.antialias && _a === 0) _a = 1e-10;
			this.GL.clearColor(_r * _a, _g * _a, _b * _a, _a);
			this.GL.clearDepth(1);
			this.GL.clear(this.GL.COLOR_BUFFER_BIT | this.GL.DEPTH_BUFFER_BIT);
		}
		clearDepth(depth = 1) {
			this.GL.clearDepth(depth);
			this.GL.clear(this.GL.DEPTH_BUFFER_BIT);
		}
		applyMatrix(a, b$1, c, d$1, e$1, f) {
			this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
			if (arguments.length === 16) Matrix.prototype.apply.apply(this.states.uModelMatrix, arguments);
			else this.states.uModelMatrix.apply([
				a,
				b$1,
				0,
				0,
				c,
				d$1,
				0,
				0,
				0,
				0,
				1,
				0,
				e$1,
				f,
				0,
				1
			]);
		}
		translate(x$1, y, z$1) {
			if (x$1 instanceof Vector) {
				z$1 = x$1.z;
				y = x$1.y;
				x$1 = x$1.x;
			}
			this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
			this.states.uModelMatrix.translate([
				x$1,
				y,
				z$1
			]);
			return this;
		}
		scale(x$1, y, z$1) {
			this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
			this.states.uModelMatrix.scale(x$1, y, z$1);
			return this;
		}
		rotate(rad, axis) {
			if (typeof axis === "undefined") return this.rotateZ(rad);
			this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
			Matrix.prototype.rotate4x4.apply(this.states.uModelMatrix, arguments);
			return this;
		}
		rotateX(rad) {
			this.rotate(rad, 1, 0, 0);
			return this;
		}
		rotateY(rad) {
			this.rotate(rad, 0, 1, 0);
			return this;
		}
		rotateZ(rad) {
			this.rotate(rad, 0, 0, 1);
			return this;
		}
		pop(...args) {
			if (this._clipDepths.length > 0 && this._pushPopDepth === this._clipDepths[this._clipDepths.length - 1]) {
				this._clearClip();
				if (!this._userEnabledStencil) this._internalDisable.call(this.GL, this.GL.STENCIL_TEST);
			}
			super.pop(...args);
			this._applyStencilTestIfClipping();
		}
		_applyStencilTestIfClipping() {
			const drawTarget = this.drawTarget();
			if (drawTarget._isClipApplied !== this._stencilTestOn) if (drawTarget._isClipApplied) {
				this._internalEnable.call(this.GL, this.GL.STENCIL_TEST);
				this._stencilTestOn = true;
			} else {
				if (!this._userEnabledStencil) this._internalDisable.call(this.GL, this.GL.STENCIL_TEST);
				this._stencilTestOn = false;
			}
		}
		resetMatrix() {
			this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
			this.states.uModelMatrix.reset();
			this.states.setValue("uViewMatrix", this.states.uViewMatrix.clone());
			this.states.uViewMatrix.set(this.states.curCamera.cameraMatrix);
			return this;
		}
		_getStrokeShader() {
			const stroke = this.states.userStrokeShader;
			if (stroke) return stroke;
			return this._getLineShader();
		}
		_getSphereMapping(img) {
			if (!this.sphereMapping) this.sphereMapping = this._pInst.createFilterShader(sphereMapping);
			this.scratchMat3.inverseTranspose4x4(this.states.uViewMatrix);
			this.scratchMat3.invert(this.scratchMat3);
			this.sphereMapping.setUniform("uFovY", this.states.curCamera.cameraFOV);
			this.sphereMapping.setUniform("uAspect", this.states.curCamera.aspectRatio);
			this.sphereMapping.setUniform("uNewNormalMatrix", this.scratchMat3.mat3);
			this.sphereMapping.setUniform("uEnvMap", img);
			return this.sphereMapping;
		}
		_getFillShader() {
			if (this._drawingImage) if (this.states.userImageShader && !this._drawingFilter) return this.states.userImageShader;
			else return this._getLightShader();
			else if (this.states.userFillShader) return this.states.userFillShader;
			else if (this.states._useNormalMaterial) return this._getNormalShader();
			else if (this.states.enableLighting || this.states._tex) return this._getLightShader();
			return this._getColorShader();
		}
		_getPointShader() {
			const point = this.states.userPointShader;
			if (!point || !point.isPointShader()) return this._getPointShader();
			return point;
		}
		baseMaterialShader() {
			if (!this._pInst._glAttributes.perPixelLighting) throw new Error("The material shader does not support hooks without perPixelLighting. Try turning it back on.");
			return this._getLightShader();
		}
		_getLightShader() {
			if (!this._defaultLightShader) if (this._pInst._glAttributes.perPixelLighting) this._defaultLightShader = new Shader(this, this._webGL2CompatibilityPrefix("vert", "highp") + defaultShaders.phongVert, this._webGL2CompatibilityPrefix("frag", "highp") + defaultShaders.phongFrag, {
				vertex: {
					"void beforeVertex": "() {}",
					"Vertex getObjectInputs": "(Vertex inputs) { return inputs; }",
					"Vertex getWorldInputs": "(Vertex inputs) { return inputs; }",
					"Vertex getCameraInputs": "(Vertex inputs) { return inputs; }",
					"void afterVertex": "() {}"
				},
				fragment: {
					"void beforeFragment": "() {}",
					"Inputs getPixelInputs": "(Inputs inputs) { return inputs; }",
					"vec4 combineColors": `(ColorComponents components) {
                vec4 color = vec4(0.);
                color.rgb += components.diffuse * components.baseColor;
                color.rgb += components.ambient * components.ambientColor;
                color.rgb += components.specular * components.specularColor;
                color.rgb += components.emissive;
                color.a = components.opacity;
                return color;
              }`,
					"vec4 getFinalColor": "(vec4 color) { return color; }",
					"void afterFragment": "() {}"
				}
			});
			else this._defaultLightShader = new Shader(this, this._webGL2CompatibilityPrefix("vert", "highp") + defaultShaders.lightVert, this._webGL2CompatibilityPrefix("frag", "highp") + defaultShaders.lightTextureFrag);
			return this._defaultLightShader;
		}
		baseNormalShader() {
			return this._getNormalShader();
		}
		_getNormalShader() {
			if (!this._defaultNormalShader) this._defaultNormalShader = new Shader(this, this._webGL2CompatibilityPrefix("vert", "mediump") + defaultShaders.normalVert, this._webGL2CompatibilityPrefix("frag", "mediump") + defaultShaders.normalFrag, {
				vertex: {
					"void beforeVertex": "() {}",
					"Vertex getObjectInputs": "(Vertex inputs) { return inputs; }",
					"Vertex getWorldInputs": "(Vertex inputs) { return inputs; }",
					"Vertex getCameraInputs": "(Vertex inputs) { return inputs; }",
					"void afterVertex": "() {}"
				},
				fragment: {
					"void beforeFragment": "() {}",
					"vec4 getFinalColor": "(vec4 color) { return color; }",
					"void afterFragment": "() {}"
				}
			});
			return this._defaultNormalShader;
		}
		baseColorShader() {
			return this._getColorShader();
		}
		_getColorShader() {
			if (!this._defaultColorShader) this._defaultColorShader = new Shader(this, this._webGL2CompatibilityPrefix("vert", "mediump") + defaultShaders.normalVert, this._webGL2CompatibilityPrefix("frag", "mediump") + defaultShaders.basicFrag, {
				vertex: {
					"void beforeVertex": "() {}",
					"Vertex getObjectInputs": "(Vertex inputs) { return inputs; }",
					"Vertex getWorldInputs": "(Vertex inputs) { return inputs; }",
					"Vertex getCameraInputs": "(Vertex inputs) { return inputs; }",
					"void afterVertex": "() {}"
				},
				fragment: {
					"void beforeFragment": "() {}",
					"vec4 getFinalColor": "(vec4 color) { return color; }",
					"void afterFragment": "() {}"
				}
			});
			return this._defaultColorShader;
		}
		pointShader() {
			return this._getPointShader();
		}
		_getPointShader() {
			if (!this._defaultPointShader) this._defaultPointShader = new Shader(this, this._webGL2CompatibilityPrefix("vert", "mediump") + defaultShaders.pointVert, this._webGL2CompatibilityPrefix("frag", "mediump") + defaultShaders.pointFrag, {
				vertex: {
					"void beforeVertex": "() {}",
					"vec3 getLocalPosition": "(vec3 position) { return position; }",
					"vec3 getWorldPosition": "(vec3 position) { return position; }",
					"float getPointSize": "(float size) { return size; }",
					"void afterVertex": "() {}"
				},
				fragment: {
					"void beforeFragment": "() {}",
					"vec4 getFinalColor": "(vec4 color) { return color; }",
					"bool shouldDiscard": "(bool outside) { return outside; }",
					"void afterFragment": "() {}"
				}
			});
			return this._defaultPointShader;
		}
		baseStrokeShader() {
			return this._getLineShader();
		}
		_getLineShader() {
			if (!this._defaultLineShader) this._defaultLineShader = new Shader(this, this._webGL2CompatibilityPrefix("vert", "mediump") + defaultShaders.lineVert, this._webGL2CompatibilityPrefix("frag", "mediump") + defaultShaders.lineFrag, {
				vertex: {
					"void beforeVertex": "() {}",
					"StrokeVertex getObjectInputs": "(StrokeVertex inputs) { return inputs; }",
					"StrokeVertex getWorldInputs": "(StrokeVertex inputs) { return inputs; }",
					"StrokeVertex getCameraInputs": "(StrokeVertex inputs) { return inputs; }",
					"void afterVertex": "() {}"
				},
				fragment: {
					"void beforeFragment": "() {}",
					"Inputs getPixelInputs": "(Inputs inputs) { return inputs; }",
					"vec4 getFinalColor": "(vec4 color) { return color; }",
					"bool shouldDiscard": "(bool outside) { return outside; }",
					"void afterFragment": "() {}"
				}
			});
			return this._defaultLineShader;
		}
		_getFontShader() {
			if (!this._defaultFontShader) {
				if (this.webglVersion === WEBGL) this.GL.getExtension("OES_standard_derivatives");
				this._defaultFontShader = new Shader(this, this._webGL2CompatibilityPrefix("vert", "highp") + defaultShaders.fontVert, this._webGL2CompatibilityPrefix("frag", "highp") + defaultShaders.fontFrag);
			}
			return this._defaultFontShader;
		}
		baseFilterShader() {
			if (!this._baseFilterShader) this._baseFilterShader = new Shader(this, this._webGL2CompatibilityPrefix("vert", "highp") + defaultShaders.filterBaseVert, this._webGL2CompatibilityPrefix("frag", "highp") + defaultShaders.filterBaseFrag, {
				vertex: {},
				fragment: { "vec4 getColor": `(FilterInputs inputs, in sampler2D canvasContent) {
                return getTexture(canvasContent, inputs.texCoord);
              }` }
			});
			return this._baseFilterShader;
		}
		_webGL2CompatibilityPrefix(shaderType, floatPrecision) {
			let code = "";
			if (this.webglVersion === WEBGL2) code += "#version 300 es\n#define WEBGL2\n";
			if (shaderType === "vert") code += "#define VERTEX_SHADER\n";
			else if (shaderType === "frag") code += "#define FRAGMENT_SHADER\n";
			if (floatPrecision) code += `precision ${floatPrecision} float;\n`;
			return code;
		}
		_getEmptyTexture() {
			if (!this._emptyTexture) {
				const im = new Image(1, 1);
				im.set(0, 0, 255);
				this._emptyTexture = new Texture(this, im);
			}
			return this._emptyTexture;
		}
		getTexture(input) {
			let src = input;
			if (src instanceof Framebuffer) src = src.color;
			const texture$1 = this.textures.get(src);
			if (texture$1) return texture$1;
			const tex = new Texture(this, src);
			this.textures.set(src, tex);
			return tex;
		}
		getDiffusedTexture(input) {
			if (this.diffusedTextures.get(input) != null) return this.diffusedTextures.get(input);
			let newFramebuffer;
			let smallWidth = 200;
			let width = smallWidth;
			let height = Math.floor(smallWidth * (input.height / input.width));
			newFramebuffer = new Framebuffer(this, {
				width,
				height,
				density: 1
			});
			if (!this.diffusedShader) this.diffusedShader = this._pInst.createShader(defaultShaders.imageLightVert, defaultShaders.imageLightDiffusedFrag);
			newFramebuffer.draw(() => {
				this.shader(this.diffusedShader);
				this.diffusedShader.setUniform("environmentMap", input);
				this.states.setValue("strokeColor", null);
				this.noLights();
				this.plane(width, height);
			});
			this.diffusedTextures.set(input, newFramebuffer);
			return newFramebuffer;
		}
		getSpecularTexture(input) {
			if (this.specularTextures.get(input) != null) return this.specularTextures.get(input);
			const size = 512;
			let tex;
			const levels = [];
			const framebuffer$1 = new Framebuffer(this, {
				width: size,
				height: size,
				density: 1
			});
			let count = Math.log(size) / Math.log(2);
			if (!this.specularShader) this.specularShader = this._pInst.createShader(defaultShaders.imageLightVert, defaultShaders.imageLightSpecularFrag);
			for (let w = size; w >= 1; w /= 2) {
				framebuffer$1.resize(w, w);
				let roughness = 1 - Math.log(w) / Math.log(2) / count;
				framebuffer$1.draw(() => {
					this.shader(this.specularShader);
					this.clear();
					this.specularShader.setUniform("environmentMap", input);
					this.specularShader.setUniform("roughness", roughness);
					this.states.setValue("strokeColor", null);
					this.noLights();
					this.plane(w, w);
				});
				levels.push(framebuffer$1.get().drawingContext.getImageData(0, 0, w, w));
			}
			framebuffer$1.remove();
			tex = new MipmapTexture(this, levels, {});
			this.specularTextures.set(input, tex);
			return tex;
		}
		activeFramebuffer() {
			return this.activeFramebuffers[this.activeFramebuffers.length - 1] || null;
		}
		createFramebuffer(options$1) {
			return new Framebuffer(this, options$1);
		}
		_setGlobalUniforms(shader$1) {
			const modelMatrix = this.states.uModelMatrix;
			const viewMatrix = this.states.uViewMatrix;
			const projectionMatrix = this.states.uPMatrix;
			const modelViewMatrix = modelMatrix.copy().mult(viewMatrix);
			shader$1.setUniform("uPerspective", this.states.curCamera.useLinePerspective ? 1 : 0);
			shader$1.setUniform("uViewMatrix", viewMatrix.mat4);
			shader$1.setUniform("uProjectionMatrix", projectionMatrix.mat4);
			shader$1.setUniform("uModelMatrix", modelMatrix.mat4);
			shader$1.setUniform("uModelViewMatrix", modelViewMatrix.mat4);
			if (shader$1.uniforms.uModelViewProjectionMatrix) {
				const modelViewProjectionMatrix = modelViewMatrix.copy();
				modelViewProjectionMatrix.mult(projectionMatrix);
				shader$1.setUniform("uModelViewProjectionMatrix", modelViewProjectionMatrix.mat4);
			}
			if (shader$1.uniforms.uNormalMatrix) {
				this.scratchMat3.inverseTranspose4x4(modelViewMatrix);
				shader$1.setUniform("uNormalMatrix", this.scratchMat3.mat3);
			}
			if (shader$1.uniforms.uModelNormalMatrix) {
				this.scratchMat3.inverseTranspose4x4(this.states.uModelMatrix);
				shader$1.setUniform("uModelNormalMatrix", this.scratchMat3.mat3);
			}
			if (shader$1.uniforms.uCameraNormalMatrix) {
				this.scratchMat3.inverseTranspose4x4(this.states.uViewMatrix);
				shader$1.setUniform("uCameraNormalMatrix", this.scratchMat3.mat3);
			}
			if (shader$1.uniforms.uCameraRotation) {
				this.scratchMat3.inverseTranspose4x4(this.states.uViewMatrix);
				shader$1.setUniform("uCameraRotation", this.scratchMat3.mat3);
			}
			shader$1.setUniform("uViewport", this._viewport);
		}
		_setStrokeUniforms(strokeShader) {
			strokeShader.setUniform("uSimpleLines", this._simpleLines);
			strokeShader.setUniform("uUseLineColor", this._useLineColor);
			strokeShader.setUniform("uMaterialColor", this.states.curStrokeColor);
			strokeShader.setUniform("uStrokeWeight", this.states.strokeWeight);
			strokeShader.setUniform("uStrokeCap", STROKE_CAP_ENUM[this.curStrokeCap]);
			strokeShader.setUniform("uStrokeJoin", STROKE_JOIN_ENUM[this.curStrokeJoin]);
		}
		_setFillUniforms(fillShader) {
			this.mixedSpecularColor = [...this.states.curSpecularColor];
			const empty$2 = this._getEmptyTexture();
			if (this.states._useMetalness > 0) this.mixedSpecularColor = this.mixedSpecularColor.map((mixedSpecularColor, index) => this.states.curFillColor[index] * this.states._useMetalness + mixedSpecularColor * (1 - this.states._useMetalness));
			fillShader.setUniform("uUseVertexColor", this._useVertexColor);
			fillShader.setUniform("uMaterialColor", this.states.curFillColor);
			fillShader.setUniform("isTexture", !!this.states._tex);
			fillShader.setUniform("uSampler", this.states._tex || empty$2);
			fillShader.setUniform("uTint", this.states.tint);
			fillShader.setUniform("uHasSetAmbient", this.states._hasSetAmbient);
			fillShader.setUniform("uAmbientMatColor", this.states.curAmbientColor);
			fillShader.setUniform("uSpecularMatColor", this.mixedSpecularColor);
			fillShader.setUniform("uEmissiveMatColor", this.states.curEmissiveColor);
			fillShader.setUniform("uSpecular", this.states._useSpecularMaterial);
			fillShader.setUniform("uEmissive", this.states._useEmissiveMaterial);
			fillShader.setUniform("uShininess", this.states._useShininess);
			fillShader.setUniform("uMetallic", this.states._useMetalness);
			this._setImageLightUniforms(fillShader);
			fillShader.setUniform("uUseLighting", this.states.enableLighting);
			const pointLightCount = this.states.pointLightDiffuseColors.length / 3;
			fillShader.setUniform("uPointLightCount", pointLightCount);
			fillShader.setUniform("uPointLightLocation", this.states.pointLightPositions);
			fillShader.setUniform("uPointLightDiffuseColors", this.states.pointLightDiffuseColors);
			fillShader.setUniform("uPointLightSpecularColors", this.states.pointLightSpecularColors);
			const directionalLightCount = this.states.directionalLightDiffuseColors.length / 3;
			fillShader.setUniform("uDirectionalLightCount", directionalLightCount);
			fillShader.setUniform("uLightingDirection", this.states.directionalLightDirections);
			fillShader.setUniform("uDirectionalDiffuseColors", this.states.directionalLightDiffuseColors);
			fillShader.setUniform("uDirectionalSpecularColors", this.states.directionalLightSpecularColors);
			const ambientLightCount = this.states.ambientLightColors.length / 3;
			this.mixedAmbientLight = [...this.states.ambientLightColors];
			if (this.states._useMetalness > 0) this.mixedAmbientLight = this.mixedAmbientLight.map((ambientColors) => {
				let mixing = ambientColors - this.states._useMetalness;
				return Math.max(0, mixing);
			});
			fillShader.setUniform("uAmbientLightCount", ambientLightCount);
			fillShader.setUniform("uAmbientColor", this.mixedAmbientLight);
			const spotLightCount = this.states.spotLightDiffuseColors.length / 3;
			fillShader.setUniform("uSpotLightCount", spotLightCount);
			fillShader.setUniform("uSpotLightAngle", this.states.spotLightAngle);
			fillShader.setUniform("uSpotLightConc", this.states.spotLightConc);
			fillShader.setUniform("uSpotLightDiffuseColors", this.states.spotLightDiffuseColors);
			fillShader.setUniform("uSpotLightSpecularColors", this.states.spotLightSpecularColors);
			fillShader.setUniform("uSpotLightLocation", this.states.spotLightPositions);
			fillShader.setUniform("uSpotLightDirection", this.states.spotLightDirections);
			fillShader.setUniform("uConstantAttenuation", this.states.constantAttenuation);
			fillShader.setUniform("uLinearAttenuation", this.states.linearAttenuation);
			fillShader.setUniform("uQuadraticAttenuation", this.states.quadraticAttenuation);
		}
		_setImageLightUniforms(shader$1) {
			shader$1.setUniform("uUseImageLight", this.states.activeImageLight != null);
			if (this.states.activeImageLight) {
				let diffusedLight = this.getDiffusedTexture(this.states.activeImageLight);
				shader$1.setUniform("environmentMapDiffused", diffusedLight);
				let specularLight = this.getSpecularTexture(this.states.activeImageLight);
				shader$1.setUniform("environmentMapSpecular", specularLight);
			}
		}
		_setPointUniforms(pointShader) {
			pointShader.setUniform("uMaterialColor", this.states.curStrokeColor);
			pointShader.setUniform("uPointSize", this.states.strokeWeight * this._pixelDensity);
		}
		_bindBuffer(buffer, target, values, type$2, usage) {
			if (!target) target = this.GL.ARRAY_BUFFER;
			this.GL.bindBuffer(target, buffer);
			if (values !== void 0) {
				let data$2 = values;
				if (values instanceof DataArray) data$2 = values.dataArray();
				else if (!(data$2 instanceof (type$2 || Float32Array))) data$2 = new (type$2 || Float32Array)(data$2);
				this.GL.bufferData(target, data$2, usage || this.GL.STATIC_DRAW);
			}
		}
		_arraysEqual(a, b$1) {
			if (a.length !== b$1.length) return false;
			return a.every((ai, i$1) => ai === b$1[i$1]);
		}
		_isTypedArray(arr$1) {
			return [
				Float32Array,
				Float64Array,
				Int16Array,
				Uint16Array,
				Uint32Array
			].some((x$1) => arr$1 instanceof x$1);
		}
		_vToNArray(arr$1) {
			return arr$1.flatMap((item) => [
				item.x,
				item.y,
				item.z
			]);
		}
	};
	function rendererGL(p5$2, fn$1) {
		p5$2.RendererGL = RendererGL;
		fn$1.setAttributes = function(key, value) {
			if (typeof this._glAttributes === "undefined") {
				console.log("You are trying to use setAttributes on a p5.Graphics object that does not use a WEBGL renderer.");
				return;
			}
			let unchanged = true;
			if (typeof value !== "undefined") {
				if (this._glAttributes === null) this._glAttributes = {};
				if (this._glAttributes[key] !== value) {
					this._glAttributes[key] = value;
					unchanged = false;
				}
			} else if (key instanceof Object) {
				if (this._glAttributes !== key) {
					this._glAttributes = key;
					unchanged = false;
				}
			}
			if (!this._renderer.isP3D || unchanged) return;
			if (!this._setupDone) {
				if (this._renderer.geometryBufferCache.numCached() > 0) {
					p5$2._friendlyError("Sorry, Could not set the attributes, you need to call setAttributes() before calling the other drawing methods in setup()");
					return;
				}
			}
			this._renderer._resetContext();
			if (this._renderer.states.curCamera) this._renderer.states.curCamera._renderer = this._renderer;
		};
		fn$1._assert3d = function(name) {
			if (!this._renderer.isP3D) throw new Error(`${name}() is only supported in WEBGL mode. If you'd like to use 3D graphics and WebGL, see  https://p5js.org/examples/form-3d-primitives.html for more information.`);
		};
		p5$2.renderers[WEBGL] = p5$2.RendererGL;
		p5$2.renderers[WEBGL2] = p5$2.RendererGL;
	}
	function readPixelsWebGL(pixels$1, gl, framebuffer$1, x$1, y, width, height, format, type$2, flipY) {
		const prevFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
		gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer$1);
		const channels = format === gl.RGBA ? 4 : 3;
		const len = width * height * channels;
		const TypedArrayClass = type$2 === gl.UNSIGNED_BYTE ? Uint8Array : Float32Array;
		if (!(pixels$1 instanceof TypedArrayClass) || pixels$1.length !== len) pixels$1 = new TypedArrayClass(len);
		gl.readPixels(x$1, flipY ? flipY - y - height : y, width, height, format, type$2, pixels$1);
		gl.bindFramebuffer(gl.FRAMEBUFFER, prevFramebuffer);
		if (flipY) {
			const halfHeight = Math.floor(height / 2);
			const tmpRow = new TypedArrayClass(width * channels);
			for (let y$1 = 0; y$1 < halfHeight; y$1++) {
				const topOffset = y$1 * width * 4;
				const bottomOffset = (height - y$1 - 1) * width * 4;
				tmpRow.set(pixels$1.subarray(topOffset, topOffset + width * 4));
				pixels$1.copyWithin(topOffset, bottomOffset, bottomOffset + width * 4);
				pixels$1.set(tmpRow, bottomOffset);
			}
		}
		return pixels$1;
	}
	function readPixelWebGL(gl, framebuffer$1, x$1, y, format, type$2, flipY) {
		const prevFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
		gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer$1);
		const channels = format === gl.RGBA ? 4 : 3;
		const pixels$1 = new (type$2 === gl.UNSIGNED_BYTE ? Uint8Array : Float32Array)(channels);
		gl.readPixels(x$1, flipY ? flipY - y - 1 : y, 1, 1, format, type$2, pixels$1);
		gl.bindFramebuffer(gl.FRAMEBUFFER, prevFramebuffer);
		return Array.from(pixels$1);
	}
	if (typeof p5 !== "undefined") rendererGL(p5, p5.prototype);
	function primitives3D(p5$2, fn$1) {
		fn$1.strokeMode = function(mode) {
			if (mode === void 0) return this._renderer._simpleLines ? SIMPLE : FULL;
			else if (mode === SIMPLE) this._renderer._simpleLines = true;
			else if (mode === FULL) this._renderer._simpleLines = false;
			else throw Error("no such parameter");
		};
		fn$1.buildGeometry = function(callback) {
			return this._renderer.buildGeometry(callback);
		};
		fn$1.freeGeometry = function(geometry$1) {
			this._renderer.geometryBufferCache.freeBuffers(geometry$1.gid);
		};
		fn$1.plane = function(width = 50, height = width, detailX = 1, detailY = 1) {
			this._assert3d("plane");
			this._renderer.plane(width, height, detailX, detailY);
			return this;
		};
		fn$1.box = function(width, height, depth, detailX, detailY) {
			this._assert3d("box");
			this._renderer.box(width, height, depth, detailX, detailY);
			return this;
		};
		fn$1.sphere = function(radius = 50, detailX = 24, detailY = 16) {
			this._assert3d("sphere");
			this._renderer.sphere(radius, detailX, detailY);
			return this;
		};
		fn$1.cylinder = function(radius = 50, height = radius, detailX = 24, detailY = 1, bottomCap = true, topCap = true) {
			this._assert3d("cylinder");
			this._renderer.cylinder(radius, height, detailX, detailY, bottomCap, topCap);
			return this;
		};
		fn$1.cone = function(radius = 50, height = radius, detailX = 24, detailY = 1, cap = true) {
			this._assert3d("cone");
			this._renderer.cone(radius, height, detailX, detailY, cap);
			return this;
		};
		fn$1.ellipsoid = function(radiusX = 50, radiusY = radiusX, radiusZ = radiusX, detailX = 24, detailY = 16) {
			this._assert3d("ellipsoid");
			this._renderer.ellipsoid(radiusX, radiusY, radiusZ, detailX, detailY);
			return this;
		};
		fn$1.torus = function(radius, tubeRadius, detailX, detailY) {
			this._assert3d("torus");
			this._renderer.torus(radius, tubeRadius, detailX, detailY);
			return this;
		};
		RendererGL.prototype.point = function(x$1, y, z$1 = 0) {
			const _vertex = [];
			_vertex.push(new Vector(x$1, y, z$1));
			this._drawPoints(_vertex, this.buffers.point);
			return this;
		};
		RendererGL.prototype.triangle = function(args) {
			const x1 = args[0], y1 = args[1];
			const x2 = args[2], y2 = args[3];
			const x3 = args[4], y3 = args[5];
			const gid = "tri";
			if (!this.geometryInHash(gid)) {
				const _triangle = function() {
					const vertices = [];
					vertices.push(new Vector(0, 0, 0));
					vertices.push(new Vector(1, 0, 0));
					vertices.push(new Vector(0, 1, 0));
					this.edges = [
						[0, 1],
						[1, 2],
						[2, 0]
					];
					this.vertices = vertices;
					this.faces = [[
						0,
						1,
						2
					]];
					this.uvs = [
						0,
						0,
						1,
						0,
						1,
						1
					];
				};
				const triGeom = new Geometry(1, 1, _triangle, this);
				triGeom._edgesToVertices();
				triGeom.computeNormals();
				triGeom.gid = gid;
				this.geometryBufferCache.ensureCached(triGeom);
			}
			const uModelMatrix = this.states.uModelMatrix.copy();
			try {
				const orientation = Math.sign(x1 * y2 - x2 * y1 + x2 * y3 - x3 * y2 + x3 * y1 - x1 * y3);
				const mult = new Matrix([
					x2 - x1,
					y2 - y1,
					0,
					0,
					x3 - x1,
					y3 - y1,
					0,
					0,
					0,
					0,
					orientation,
					0,
					x1,
					y1,
					0,
					1
				]).mult(this.states.uModelMatrix);
				this.states.setValue("uModelMatrix", mult);
				this._drawGeometry(this.geometryBufferCache.getGeometryByID(gid));
			} finally {
				this.states.setValue("uModelMatrix", uModelMatrix);
			}
			return this;
		};
		RendererGL.prototype.ellipse = function(args) {
			this.arc(args[0], args[1], args[2], args[3], 0, TWO_PI, OPEN, args[4]);
		};
		RendererGL.prototype.arc = function(...args) {
			const x$1 = args[0];
			const y = args[1];
			const width = args[2];
			const height = args[3];
			const start = args[4];
			const stop = args[5];
			const mode = args[6];
			const detail = args[7] || 25;
			let shape$1;
			let gid;
			if (Math.abs(stop - start) >= TWO_PI) {
				shape$1 = "ellipse";
				gid = `${shape$1}|${detail}|`;
			} else {
				shape$1 = "arc";
				gid = `${shape$1}|${start}|${stop}|${mode}|${detail}|`;
			}
			if (!this.geometryInHash(gid)) {
				const _arc = function() {
					if (start.toFixed(10) !== stop.toFixed(10)) {
						if (mode === PIE || typeof mode === "undefined") {
							this.vertices.push(new Vector(.5, .5, 0));
							this.uvs.push([.5, .5]);
						}
						for (let i$1 = 0; i$1 <= detail; i$1++) {
							const u$1 = i$1 / detail;
							const theta = (stop - start) * u$1 + start;
							const _x = .5 + Math.cos(theta) / 2;
							const _y = .5 + Math.sin(theta) / 2;
							this.vertices.push(new Vector(_x, _y, 0));
							this.uvs.push([_x, _y]);
							if (i$1 < detail - 1) {
								this.faces.push([
									0,
									i$1 + 1,
									i$1 + 2
								]);
								this.edges.push([i$1 + 1, i$1 + 2]);
							}
						}
						switch (mode) {
							case PIE:
								this.faces.push([
									0,
									this.vertices.length - 2,
									this.vertices.length - 1
								]);
								this.edges.push([0, 1]);
								this.edges.push([this.vertices.length - 2, this.vertices.length - 1]);
								this.edges.push([0, this.vertices.length - 1]);
								break;
							case CHORD:
								this.edges.push([0, 1]);
								this.edges.push([0, this.vertices.length - 1]);
								break;
							case OPEN:
								this.edges.push([0, 1]);
								break;
							default:
								this.faces.push([
									0,
									this.vertices.length - 2,
									this.vertices.length - 1
								]);
								this.edges.push([this.vertices.length - 2, this.vertices.length - 1]);
						}
					}
				};
				const arcGeom = new Geometry(detail, 1, _arc, this);
				arcGeom.computeNormals();
				if (detail <= 50) arcGeom._edgesToVertices(arcGeom);
				else if (this.states.strokeColor) console.log(`Cannot apply a stroke to an ${shape$1} with more than 50 detail`);
				arcGeom.gid = gid;
				this.geometryBufferCache.ensureCached(arcGeom);
			}
			const uModelMatrix = this.states.uModelMatrix;
			this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
			try {
				this.states.uModelMatrix.translate([
					x$1,
					y,
					0
				]);
				this.states.uModelMatrix.scale(width, height, 1);
				this._drawGeometry(this.geometryBufferCache.getGeometryByID(gid));
			} finally {
				this.states.setValue("uModelMatrix", uModelMatrix);
			}
			return this;
		};
		RendererGL.prototype.rect = function(args) {
			const x$1 = args[0];
			const y = args[1];
			const width = args[2];
			const height = args[3];
			if (typeof args[4] === "undefined") {
				const perPixelLighting = this._pInst._glAttributes.perPixelLighting;
				const detailX = args[4] || (perPixelLighting ? 1 : 24);
				const detailY = args[5] || (perPixelLighting ? 1 : 16);
				const gid = `rect|${detailX}|${detailY}`;
				if (!this.geometryInHash(gid)) {
					const _rect = function() {
						for (let i$1 = 0; i$1 <= this.detailY; i$1++) {
							const v$1 = i$1 / this.detailY;
							for (let j = 0; j <= this.detailX; j++) {
								const u$1 = j / this.detailX;
								const p$1 = new Vector(u$1, v$1, 0);
								this.vertices.push(p$1);
								this.uvs.push(u$1, v$1);
							}
						}
						if (detailX > 0 && detailY > 0) this.edges = [
							[0, detailX],
							[detailX, (detailX + 1) * (detailY + 1) - 1],
							[(detailX + 1) * (detailY + 1) - 1, (detailX + 1) * detailY],
							[(detailX + 1) * detailY, 0]
						];
					};
					const rectGeom = new Geometry(detailX, detailY, _rect, this);
					rectGeom.computeFaces().computeNormals()._edgesToVertices();
					rectGeom.gid = gid;
					this.geometryBufferCache.ensureCached(rectGeom);
				}
				const uModelMatrix = this.states.uModelMatrix;
				this.states.setValue("uModelMatrix", this.states.uModelMatrix.copy());
				try {
					this.states.uModelMatrix.translate([
						x$1,
						y,
						0
					]);
					this.states.uModelMatrix.scale(width, height, 1);
					this._drawGeometry(this.geometryBufferCache.getGeometryByID(gid));
				} finally {
					this.states.setValue("uModelMatrix", uModelMatrix);
				}
			} else {
				let tl = args[4];
				let tr = typeof args[5] === "undefined" ? tl : args[5];
				let br = typeof args[6] === "undefined" ? tr : args[6];
				let bl = typeof args[7] === "undefined" ? br : args[7];
				let a = x$1;
				let b$1 = y;
				let c = width;
				let d$1 = height;
				c += a;
				d$1 += b$1;
				if (a > c) {
					const temp = a;
					a = c;
					c = temp;
				}
				if (b$1 > d$1) {
					const temp = b$1;
					b$1 = d$1;
					d$1 = temp;
				}
				const maxRounding = Math.min((c - a) / 2, (d$1 - b$1) / 2);
				if (tl > maxRounding) tl = maxRounding;
				if (tr > maxRounding) tr = maxRounding;
				if (br > maxRounding) br = maxRounding;
				if (bl > maxRounding) bl = maxRounding;
				let x1 = a;
				let y1 = b$1;
				let x2 = c;
				let y2 = d$1;
				const prevMode = this.states.textureMode;
				this.states.setValue("textureMode", NORMAL);
				const prevOrder = this.bezierOrder();
				this.bezierOrder(2);
				this.beginShape();
				const addUVs = (x$2, y$1) => [
					x$2,
					y$1,
					(x$2 - x1) / width,
					(y$1 - y1) / height
				];
				if (tr !== 0) {
					this.vertex(...addUVs(x2 - tr, y1));
					this.bezierVertex(...addUVs(x2, y1));
					this.bezierVertex(...addUVs(x2, y1 + tr));
				} else this.vertex(...addUVs(x2, y1));
				if (br !== 0) {
					this.vertex(...addUVs(x2, y2 - br));
					this.bezierVertex(...addUVs(x2, y2));
					this.bezierVertex(...addUVs(x2 - br, y2));
				} else this.vertex(...addUVs(x2, y2));
				if (bl !== 0) {
					this.vertex(...addUVs(x1 + bl, y2));
					this.bezierVertex(...addUVs(x1, y2));
					this.bezierVertex(...addUVs(x1, y2 - bl));
				} else this.vertex(...addUVs(x1, y2));
				if (tl !== 0) {
					this.vertex(...addUVs(x1, y1 + tl));
					this.bezierVertex(...addUVs(x1, y1));
					this.bezierVertex(...addUVs(x1 + tl, y1));
				} else this.vertex(...addUVs(x1, y1));
				this.endShape(CLOSE);
				this.states.setValue("textureMode", prevMode);
				this.bezierOrder(prevOrder);
			}
			return this;
		};
		RendererGL.prototype.quad = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, detailX = 2, detailY = 2) {
			const gid = `quad|${x1}|${y1}|${z1}|${x2}|${y2}|${z2}|${x3}|${y3}|${z3}|${x4}|${y4}|${z4}|${detailX}|${detailY}`;
			if (!this.geometryInHash(gid)) {
				const quadGeom = new Geometry(detailX, detailY, function() {
					let xRes = 1 / (this.detailX - 1);
					let yRes = 1 / (this.detailY - 1);
					for (let y = 0; y < this.detailY; y++) for (let x$1 = 0; x$1 < this.detailX; x$1++) {
						let pctx = x$1 * xRes;
						let pcty = y * yRes;
						let linePt0x = (1 - pcty) * x1 + pcty * x4;
						let linePt0y = (1 - pcty) * y1 + pcty * y4;
						let linePt0z = (1 - pcty) * z1 + pcty * z4;
						let linePt1x = (1 - pcty) * x2 + pcty * x3;
						let linePt1y = (1 - pcty) * y2 + pcty * y3;
						let linePt1z = (1 - pcty) * z2 + pcty * z3;
						let ptx = (1 - pctx) * linePt0x + pctx * linePt1x;
						let pty = (1 - pctx) * linePt0y + pctx * linePt1y;
						let ptz = (1 - pctx) * linePt0z + pctx * linePt1z;
						this.vertices.push(new Vector(ptx, pty, ptz));
						this.uvs.push([pctx, pcty]);
					}
				}, this);
				quadGeom.faces = [];
				for (let y = 0; y < detailY - 1; y++) for (let x$1 = 0; x$1 < detailX - 1; x$1++) {
					let pt0 = x$1 + y * detailX;
					let pt1 = x$1 + 1 + y * detailX;
					let pt2 = x$1 + 1 + (y + 1) * detailX;
					let pt3 = x$1 + (y + 1) * detailX;
					quadGeom.faces.push([
						pt0,
						pt1,
						pt2
					]);
					quadGeom.faces.push([
						pt0,
						pt2,
						pt3
					]);
				}
				quadGeom.computeNormals();
				quadGeom.edges.length = 0;
				const vertexOrder = [
					0,
					2,
					3,
					1
				];
				for (let i$1 = 0; i$1 < vertexOrder.length; i$1++) {
					const startVertex = vertexOrder[i$1];
					const endVertex = vertexOrder[(i$1 + 1) % vertexOrder.length];
					quadGeom.edges.push([startVertex, endVertex]);
				}
				quadGeom._edgesToVertices();
				quadGeom.gid = gid;
				this.geometryBufferCache.ensureCached(quadGeom);
			}
			this._drawGeometry(this.geometryBufferCache.getGeometryByID(gid));
			return this;
		};
		RendererGL.prototype.bezier = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
			if (arguments.length === 8) {
				y4 = y3;
				x4 = x3;
				y3 = z2;
				x3 = y2;
				y2 = x2;
				x2 = z1;
				z1 = z2 = z3 = z4 = 0;
			}
			this.bezierOrder();
			this.bezierOrder(3);
			this.beginShape();
			this.vertex(x1, y1, z1);
			this.bezierVertex(x2, y2, z2);
			this.bezierVertex(x3, y3, z3);
			this.bezierVertex(x4, y4, z4);
			this.endShape();
		};
		RendererGL.prototype.curve = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
			if (arguments.length === 8) {
				x4 = x3;
				y4 = y3;
				x3 = y2;
				y3 = x2;
				x2 = z1;
				y2 = x2;
				z1 = z2 = z3 = z4 = 0;
			}
			this.beginShape();
			this.splineVertex(x1, y1, z1);
			this.splineVertex(x2, y2, z2);
			this.splineVertex(x3, y3, z3);
			this.splineVertex(x4, y4, z4);
			this.endShape();
		};
		RendererGL.prototype.line = function(...args) {
			if (args.length === 6) {
				this.beginShape(LINES);
				this.vertex(args[0], args[1], args[2]);
				this.vertex(args[3], args[4], args[5]);
				this.endShape();
			} else if (args.length === 4) {
				this.beginShape(LINES);
				this.vertex(args[0], args[1], 0);
				this.vertex(args[2], args[3], 0);
				this.endShape();
			}
			return this;
		};
		RendererGL.prototype.image = function(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
			if (this._isErasing) this.blendMode(this._cachedBlendMode);
			this.push();
			this.noLights();
			this.states.setValue("strokeColor", null);
			this.texture(img);
			this.states.setValue("textureMode", NORMAL);
			let u0 = 0;
			if (sx <= img.width) u0 = sx / img.width;
			let u1 = 1;
			if (sx + sWidth <= img.width) u1 = (sx + sWidth) / img.width;
			let v0 = 0;
			if (sy <= img.height) v0 = sy / img.height;
			let v1 = 1;
			if (sy + sHeight <= img.height) v1 = (sy + sHeight) / img.height;
			this._drawingImage = true;
			this.beginShape();
			this.vertex(dx, dy, 0, u0, v0);
			this.vertex(dx + dWidth, dy, 0, u1, v0);
			this.vertex(dx + dWidth, dy + dHeight, 0, u1, v1);
			this.vertex(dx, dy + dHeight, 0, u0, v1);
			this.endShape(CLOSE);
			this._drawingImage = false;
			this.pop();
			if (this._isErasing) this.blendMode(REMOVE);
		};
		const _truncatedCone = function(bottomRadius, topRadius, height, detailX, detailY, bottomCap, topCap) {
			bottomRadius = bottomRadius <= 0 ? 1 : bottomRadius;
			topRadius = topRadius < 0 ? 0 : topRadius;
			height = height <= 0 ? bottomRadius : height;
			detailX = detailX < 3 ? 3 : detailX;
			detailY = detailY < 1 ? 1 : detailY;
			bottomCap = bottomCap === void 0 ? true : bottomCap;
			topCap = topCap === void 0 ? topRadius !== 0 : topCap;
			const start = bottomCap ? -2 : 0;
			const end = detailY + (topCap ? 2 : 0);
			const slant = Math.atan2(bottomRadius - topRadius, height);
			const sinSlant = Math.sin(slant);
			const cosSlant = Math.cos(slant);
			let yy, ii, jj;
			for (yy = start; yy <= end; ++yy) {
				let v$1 = yy / detailY;
				let y = height * v$1;
				let ringRadius;
				if (yy < 0) {
					y = 0;
					v$1 = 0;
					ringRadius = bottomRadius;
				} else if (yy > detailY) {
					y = height;
					v$1 = 1;
					ringRadius = topRadius;
				} else ringRadius = bottomRadius + (topRadius - bottomRadius) * v$1;
				if (yy === -2 || yy === detailY + 2) ringRadius = 0;
				y -= height / 2;
				for (ii = 0; ii < detailX; ++ii) {
					const u$1 = ii / (detailX - 1);
					const ur = 2 * Math.PI * u$1;
					const sur = Math.sin(ur);
					const cur = Math.cos(ur);
					this.vertices.push(new Vector(sur * ringRadius, y, cur * ringRadius));
					let vertexNormal;
					if (yy < 0) vertexNormal = new Vector(0, -1, 0);
					else if (yy > detailY && topRadius) vertexNormal = new Vector(0, 1, 0);
					else vertexNormal = new Vector(sur * cosSlant, sinSlant, cur * cosSlant);
					this.vertexNormals.push(vertexNormal);
					this.uvs.push(u$1, v$1);
				}
			}
			let startIndex = 0;
			if (bottomCap) {
				for (jj = 0; jj < detailX; ++jj) {
					const nextjj = (jj + 1) % detailX;
					this.faces.push([
						startIndex + jj,
						startIndex + detailX + nextjj,
						startIndex + detailX + jj
					]);
				}
				startIndex += detailX * 2;
			}
			for (yy = 0; yy < detailY; ++yy) {
				for (ii = 0; ii < detailX; ++ii) {
					const nextii = (ii + 1) % detailX;
					this.faces.push([
						startIndex + ii,
						startIndex + nextii,
						startIndex + detailX + nextii
					]);
					this.faces.push([
						startIndex + ii,
						startIndex + detailX + nextii,
						startIndex + detailX + ii
					]);
				}
				startIndex += detailX;
			}
			if (topCap) {
				startIndex += detailX;
				for (ii = 0; ii < detailX; ++ii) this.faces.push([
					startIndex + ii,
					startIndex + (ii + 1) % detailX,
					startIndex + detailX
				]);
			}
		};
		RendererGL.prototype.plane = function(width = 50, height = width, detailX = 1, detailY = 1) {
			const gid = `plane|${detailX}|${detailY}`;
			if (!this.geometryInHash(gid)) {
				const _plane = function() {
					let u$1, v$1, p$1;
					for (let i$1 = 0; i$1 <= this.detailY; i$1++) {
						v$1 = i$1 / this.detailY;
						for (let j = 0; j <= this.detailX; j++) {
							u$1 = j / this.detailX;
							p$1 = new Vector(u$1 - .5, v$1 - .5, 0);
							this.vertices.push(p$1);
							this.uvs.push(u$1, v$1);
						}
					}
				};
				const planeGeom = new Geometry(detailX, detailY, _plane, this);
				planeGeom.computeFaces().computeNormals();
				if (detailX <= 1 && detailY <= 1) planeGeom._makeTriangleEdges()._edgesToVertices();
				else if (this.states.strokeColor) console.log("Cannot draw stroke on plane objects with more than 1 detailX or 1 detailY");
				planeGeom.gid = gid;
				this.geometryBufferCache.ensureCached(planeGeom);
			}
			this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(gid), width, height, 1);
		};
		RendererGL.prototype.box = function(width = 50, height = width, depth = height, detailX, detailY) {
			const perPixelLighting = this.attributes && this.attributes.perPixelLighting;
			if (typeof detailX === "undefined") detailX = perPixelLighting ? 1 : 4;
			if (typeof detailY === "undefined") detailY = perPixelLighting ? 1 : 4;
			const gid = `box|${detailX}|${detailY}`;
			if (!this.geometryInHash(gid)) {
				const _box = function() {
					const cubeIndices = [
						[
							0,
							4,
							2,
							6
						],
						[
							1,
							3,
							5,
							7
						],
						[
							0,
							1,
							4,
							5
						],
						[
							2,
							6,
							3,
							7
						],
						[
							0,
							2,
							1,
							3
						],
						[
							4,
							5,
							6,
							7
						]
					];
					this.edges = [
						[0, 1],
						[1, 3],
						[3, 2],
						[6, 7],
						[8, 9],
						[9, 11],
						[14, 15],
						[16, 17],
						[17, 19],
						[18, 19],
						[20, 21],
						[22, 23]
					];
					cubeIndices.forEach((cubeIndex, i$1) => {
						const v$1 = i$1 * 4;
						for (let j = 0; j < 4; j++) {
							const d$1 = cubeIndex[j];
							const octant = new Vector(((d$1 & 1) * 2 - 1) / 2, ((d$1 & 2) - 1) / 2, ((d$1 & 4) / 2 - 1) / 2);
							this.vertices.push(octant);
							this.uvs.push(j & 1, (j & 2) / 2);
						}
						this.faces.push([
							v$1,
							v$1 + 1,
							v$1 + 2
						]);
						this.faces.push([
							v$1 + 2,
							v$1 + 1,
							v$1 + 3
						]);
					});
				};
				const boxGeom = new Geometry(detailX, detailY, _box, this);
				boxGeom.computeNormals();
				if (detailX <= 4 && detailY <= 4) boxGeom._edgesToVertices();
				else if (this.states.strokeColor) console.log("Cannot draw stroke on box objects with more than 4 detailX or 4 detailY");
				boxGeom.gid = gid;
				this.geometryBufferCache.ensureCached(boxGeom);
			}
			this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(gid), width, height, depth);
		};
		RendererGL.prototype.sphere = function(radius = 50, detailX = 24, detailY = 16) {
			this.ellipsoid(radius, radius, radius, detailX, detailY);
		};
		RendererGL.prototype.ellipsoid = function(radiusX = 50, radiusY = radiusX, radiusZ = radiusX, detailX = 24, detailY = 16) {
			const gid = `ellipsoid|${detailX}|${detailY}`;
			if (!this.geometryInHash(gid)) {
				const _ellipsoid = function() {
					for (let i$1 = 0; i$1 <= this.detailY; i$1++) {
						const v$1 = i$1 / this.detailY;
						const phi = Math.PI * v$1 - Math.PI / 2;
						const cosPhi = Math.cos(phi);
						const sinPhi = Math.sin(phi);
						for (let j = 0; j <= this.detailX; j++) {
							const u$1 = j / this.detailX;
							const theta = 2 * Math.PI * u$1;
							const cosTheta = Math.cos(theta);
							const sinTheta = Math.sin(theta);
							const p$1 = new p5$2.Vector(cosPhi * sinTheta, sinPhi, cosPhi * cosTheta);
							this.vertices.push(p$1);
							this.vertexNormals.push(p$1);
							this.uvs.push(u$1, v$1);
						}
					}
				};
				const ellipsoidGeom = new Geometry(detailX, detailY, _ellipsoid, this);
				ellipsoidGeom.computeFaces();
				if (detailX <= 24 && detailY <= 24) ellipsoidGeom._makeTriangleEdges()._edgesToVertices();
				else if (this.states.strokeColor) console.log("Cannot draw stroke on ellipsoids with more than 24 detailX or 24 detailY");
				ellipsoidGeom.gid = gid;
				this.geometryBufferCache.ensureCached(ellipsoidGeom);
			}
			this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(gid), radiusX, radiusY, radiusZ);
		};
		RendererGL.prototype.cylinder = function(radius = 50, height = radius, detailX = 24, detailY = 1, bottomCap = true, topCap = true) {
			const gid = `cylinder|${detailX}|${detailY}|${bottomCap}|${topCap}`;
			if (!this.geometryInHash(gid)) {
				const cylinderGeom = new p5$2.Geometry(detailX, detailY, function() {
					_truncatedCone.call(this, 1, 1, 1, detailX, detailY, bottomCap, topCap);
				}, this);
				if (detailX <= 24 && detailY <= 16) cylinderGeom._makeTriangleEdges()._edgesToVertices();
				else if (this.states.strokeColor) console.log("Cannot draw stroke on cylinder objects with more than 24 detailX or 16 detailY");
				cylinderGeom.gid = gid;
				this.geometryBufferCache.ensureCached(cylinderGeom);
			}
			this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(gid), radius, height, radius);
		};
		RendererGL.prototype.cone = function(radius = 50, height = radius, detailX = 24, detailY = 1, cap = true) {
			const gid = `cone|${detailX}|${detailY}|${cap}`;
			if (!this.geometryInHash(gid)) {
				const coneGeom = new Geometry(detailX, detailY, function() {
					_truncatedCone.call(this, 1, 0, 1, detailX, detailY, cap, false);
				}, this);
				if (detailX <= 24 && detailY <= 16) coneGeom._makeTriangleEdges()._edgesToVertices();
				else if (this.states.strokeColor) console.log("Cannot draw stroke on cone objects with more than 24 detailX or 16 detailY");
				coneGeom.gid = gid;
				this.geometryBufferCache.ensureCached(coneGeom);
			}
			this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(gid), radius, height, radius);
		};
		RendererGL.prototype.torus = function(radius = 50, tubeRadius = 10, detailX = 24, detailY = 16) {
			if (radius === 0) return;
			if (tubeRadius === 0) return;
			const tubeRatio = (tubeRadius / radius).toPrecision(4);
			const gid = `torus|${tubeRatio}|${detailX}|${detailY}`;
			if (!this.geometryInHash(gid)) {
				const _torus = function() {
					for (let i$1 = 0; i$1 <= this.detailY; i$1++) {
						const v$1 = i$1 / this.detailY;
						const phi = 2 * Math.PI * v$1;
						const cosPhi = Math.cos(phi);
						const sinPhi = Math.sin(phi);
						const r = 1 + tubeRatio * cosPhi;
						for (let j = 0; j <= this.detailX; j++) {
							const u$1 = j / this.detailX;
							const theta = 2 * Math.PI * u$1;
							const cosTheta = Math.cos(theta);
							const sinTheta = Math.sin(theta);
							const p$1 = new Vector(r * cosTheta, r * sinTheta, tubeRatio * sinPhi);
							const n$2 = new Vector(cosPhi * cosTheta, cosPhi * sinTheta, sinPhi);
							this.vertices.push(p$1);
							this.vertexNormals.push(n$2);
							this.uvs.push(u$1, v$1);
						}
					}
				};
				const torusGeom = new Geometry(detailX, detailY, _torus, this);
				torusGeom.computeFaces();
				if (detailX <= 24 && detailY <= 16) torusGeom._makeTriangleEdges()._edgesToVertices();
				else if (this.states.strokeColor) console.log("Cannot draw strokes on torus object with more than 24 detailX or 16 detailY");
				torusGeom.gid = gid;
				this.geometryBufferCache.ensureCached(torusGeom);
			}
			this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(gid), radius, radius, radius);
		};
		fn$1.curveDetail = function(d$1) {
			if (!(this._renderer instanceof RendererGL)) throw new Error("curveDetail() only works in WebGL mode. Did you mean to call createCanvas(width, height, WEBGL)?");
			return this._renderer.curveDetail(d$1);
		};
	}
	if (typeof p5 !== "undefined") primitives3D(p5, p5.prototype);
	function light(p5$2, fn$1) {
		fn$1.ambientLight = function(v1, v2, v3, a) {
			this._assert3d("ambientLight");
			this._renderer.ambientLight(...arguments);
			return this;
		};
		fn$1.specularColor = function(v1, v2, v3) {
			this._assert3d("specularColor");
			this._renderer.specularColor(...arguments);
			return this;
		};
		fn$1.directionalLight = function(v1, v2, v3, x$1, y, z$1) {
			this._assert3d("directionalLight");
			this._renderer.directionalLight(...arguments);
			return this;
		};
		fn$1.pointLight = function(v1, v2, v3, x$1, y, z$1) {
			this._assert3d("pointLight");
			this._renderer.pointLight(...arguments);
			return this;
		};
		fn$1.imageLight = function(img) {
			this._renderer.imageLight(img);
		};
		fn$1.panorama = function(img) {
			this.filter(this._renderer._getSphereMapping(img));
		};
		fn$1.lights = function() {
			this._assert3d("lights");
			this._renderer.lights();
			return this;
		};
		fn$1.lightFalloff = function(constantAttenuation, linearAttenuation, quadraticAttenuation) {
			this._assert3d("lightFalloff");
			this._renderer.lightFalloff(constantAttenuation, linearAttenuation, quadraticAttenuation);
			return this;
		};
		fn$1.spotLight = function(v1, v2, v3, x$1, y, z$1, nx, ny, nz, angle, concentration) {
			this._assert3d("spotLight");
			this._renderer.spotLight(...arguments);
			return this;
		};
		fn$1.noLights = function(...args) {
			this._assert3d("noLights");
			this._renderer.noLights();
			return this;
		};
		RendererGL.prototype.ambientLight = function(v1, v2, v3, a) {
			const color$2 = this._pInst.color(...arguments);
			this.states.setValue("ambientLightColors", [...this.states.ambientLightColors]);
			this.states.ambientLightColors.push(color$2._array[0], color$2._array[1], color$2._array[2]);
			this.states.setValue("enableLighting", true);
		};
		RendererGL.prototype.specularColor = function(v1, v2, v3) {
			const color$2 = this._pInst.color(...arguments);
			this.states.setValue("specularColors", [
				color$2._array[0],
				color$2._array[1],
				color$2._array[2]
			]);
		};
		RendererGL.prototype.directionalLight = function(v1, v2, v3, x$1, y, z$1) {
			let color$2;
			if (v1 instanceof Color) color$2 = v1;
			else color$2 = this._pInst.color(v1, v2, v3);
			let _x, _y, _z;
			const v$1 = arguments[arguments.length - 1];
			if (typeof v$1 === "number") {
				_x = arguments[arguments.length - 3];
				_y = arguments[arguments.length - 2];
				_z = arguments[arguments.length - 1];
			} else {
				_x = v$1.x;
				_y = v$1.y;
				_z = v$1.z;
			}
			const l = Math.sqrt(_x * _x + _y * _y + _z * _z);
			this.states.setValue("directionalLightDirections", [...this.states.directionalLightDirections]);
			this.states.directionalLightDirections.push(_x / l, _y / l, _z / l);
			this.states.setValue("directionalLightDiffuseColors", [...this.states.directionalLightDiffuseColors]);
			this.states.directionalLightDiffuseColors.push(color$2._array[0], color$2._array[1], color$2._array[2]);
			this.states.setValue("directionalLightSpecularColors", [...this.states.directionalLightSpecularColors]);
			Array.prototype.push.apply(this.states.directionalLightSpecularColors, this.states.specularColors);
			this.states.setValue("enableLighting", true);
		};
		RendererGL.prototype.pointLight = function(v1, v2, v3, x$1, y, z$1) {
			let color$2;
			if (v1 instanceof Color) color$2 = v1;
			else color$2 = this._pInst.color(v1, v2, v3);
			let _x, _y, _z;
			const v$1 = arguments[arguments.length - 1];
			if (typeof v$1 === "number") {
				_x = arguments[arguments.length - 3];
				_y = arguments[arguments.length - 2];
				_z = arguments[arguments.length - 1];
			} else {
				_x = v$1.x;
				_y = v$1.y;
				_z = v$1.z;
			}
			this.states.setValue("pointLightPositions", [...this.states.pointLightPositions]);
			this.states.pointLightPositions.push(_x, _y, _z);
			this.states.setValue("pointLightDiffuseColors", [...this.states.pointLightDiffuseColors]);
			this.states.pointLightDiffuseColors.push(color$2._array[0], color$2._array[1], color$2._array[2]);
			this.states.setValue("pointLightSpecularColors", [...this.states.pointLightSpecularColors]);
			Array.prototype.push.apply(this.states.pointLightSpecularColors, this.states.specularColors);
			this.states.setValue("enableLighting", true);
		};
		RendererGL.prototype.imageLight = function(img) {
			this.states.setValue("activeImageLight", img);
			this.states.setValue("enableLighting", true);
		};
		RendererGL.prototype.lights = function() {
			const grayColor = this._pInst.color("rgb(128,128,128)");
			this.ambientLight(grayColor);
			this.directionalLight(grayColor, 0, 0, -1);
		};
		RendererGL.prototype.lightFalloff = function(constantAttenuation, linearAttenuation, quadraticAttenuation) {
			if (constantAttenuation < 0) {
				constantAttenuation = 0;
				console.warn("Value of constant argument in lightFalloff() should be never be negative. Set to 0.");
			}
			if (linearAttenuation < 0) {
				linearAttenuation = 0;
				console.warn("Value of linear argument in lightFalloff() should be never be negative. Set to 0.");
			}
			if (quadraticAttenuation < 0) {
				quadraticAttenuation = 0;
				console.warn("Value of quadratic argument in lightFalloff() should be never be negative. Set to 0.");
			}
			if (constantAttenuation === 0 && linearAttenuation === 0 && quadraticAttenuation === 0) {
				constantAttenuation = 1;
				console.warn("Either one of the three arguments in lightFalloff() should be greater than zero. Set constant argument to 1.");
			}
			this.states.setValue("constantAttenuation", constantAttenuation);
			this.states.setValue("linearAttenuation", linearAttenuation);
			this.states.setValue("quadraticAttenuation", quadraticAttenuation);
		};
		RendererGL.prototype.spotLight = function(v1, v2, v3, x$1, y, z$1, nx, ny, nz, angle, concentration) {
			let color$2, position, direction;
			const length = arguments.length;
			switch (length) {
				case 11:
				case 10:
					color$2 = this._pInst.color(v1, v2, v3);
					position = new Vector(x$1, y, z$1);
					direction = new Vector(nx, ny, nz);
					break;
				case 9:
					if (v1 instanceof Color) {
						color$2 = v1;
						position = new Vector(v2, v3, x$1);
						direction = new Vector(y, z$1, nx);
						angle = ny;
						concentration = nz;
					} else if (x$1 instanceof Vector) {
						color$2 = this._pInst.color(v1, v2, v3);
						position = x$1;
						direction = new Vector(y, z$1, nx);
						angle = ny;
						concentration = nz;
					} else if (nx instanceof Vector) {
						color$2 = this._pInst.color(v1, v2, v3);
						position = new Vector(x$1, y, z$1);
						direction = nx;
						angle = ny;
						concentration = nz;
					} else {
						color$2 = this._pInst.color(v1, v2, v3);
						position = new Vector(x$1, y, z$1);
						direction = new Vector(nx, ny, nz);
					}
					break;
				case 8:
					if (v1 instanceof Color) {
						color$2 = v1;
						position = new Vector(v2, v3, x$1);
						direction = new Vector(y, z$1, nx);
						angle = ny;
					} else if (x$1 instanceof Vector) {
						color$2 = this._pInst.color(v1, v2, v3);
						position = x$1;
						direction = new Vector(y, z$1, nx);
						angle = ny;
					} else {
						color$2 = this._pInst.color(v1, v2, v3);
						position = new Vector(x$1, y, z$1);
						direction = nx;
						angle = ny;
					}
					break;
				case 7:
					if (v1 instanceof Color && v2 instanceof Vector) {
						color$2 = v1;
						position = v2;
						direction = new Vector(v3, x$1, y);
						angle = z$1;
						concentration = nx;
					} else if (v1 instanceof Color && y instanceof Vector) {
						color$2 = v1;
						position = new Vector(v2, v3, x$1);
						direction = y;
						angle = z$1;
						concentration = nx;
					} else if (x$1 instanceof Vector && y instanceof Vector) {
						color$2 = this._pInst.color(v1, v2, v3);
						position = x$1;
						direction = y;
						angle = z$1;
						concentration = nx;
					} else if (v1 instanceof Color) {
						color$2 = v1;
						position = new Vector(v2, v3, x$1);
						direction = new Vector(y, z$1, nx);
					} else if (x$1 instanceof Vector) {
						color$2 = this._pInst.color(v1, v2, v3);
						position = x$1;
						direction = new Vector(y, z$1, nx);
					} else {
						color$2 = this._pInst.color(v1, v2, v3);
						position = new Vector(x$1, y, z$1);
						direction = nx;
					}
					break;
				case 6:
					if (x$1 instanceof Vector && y instanceof Vector) {
						color$2 = this._pInst.color(v1, v2, v3);
						position = x$1;
						direction = y;
						angle = z$1;
					} else if (v1 instanceof Color && y instanceof Vector) {
						color$2 = v1;
						position = new Vector(v2, v3, x$1);
						direction = y;
						angle = z$1;
					} else if (v1 instanceof Color && v2 instanceof Vector) {
						color$2 = v1;
						position = v2;
						direction = new Vector(v3, x$1, y);
						angle = z$1;
					}
					break;
				case 5:
					if (v1 instanceof Color && v2 instanceof Vector && v3 instanceof Vector) {
						color$2 = v1;
						position = v2;
						direction = v3;
						angle = x$1;
						concentration = y;
					} else if (x$1 instanceof Vector && y instanceof Vector) {
						color$2 = this._pInst.color(v1, v2, v3);
						position = x$1;
						direction = y;
					} else if (v1 instanceof Color && y instanceof Vector) {
						color$2 = v1;
						position = new Vector(v2, v3, x$1);
						direction = y;
					} else if (v1 instanceof Color && v2 instanceof Vector) {
						color$2 = v1;
						position = v2;
						direction = new Vector(v3, x$1, y);
					}
					break;
				case 4:
					color$2 = v1;
					position = v2;
					direction = v3;
					angle = x$1;
					break;
				case 3:
					color$2 = v1;
					position = v2;
					direction = v3;
					break;
				default:
					console.warn(`Sorry, input for spotlight() is not in prescribed format. Too ${length < 3 ? "few" : "many"} arguments were provided`);
					return;
			}
			this.states.setValue("spotLightDiffuseColors", [
				color$2._array[0],
				color$2._array[1],
				color$2._array[2]
			]);
			this.states.setValue("spotLightSpecularColors", [...this.states.specularColors]);
			this.states.setValue("spotLightPositions", [
				position.x,
				position.y,
				position.z
			]);
			direction.normalize();
			this.states.setValue("spotLightDirections", [
				direction.x,
				direction.y,
				direction.z
			]);
			if (angle === void 0) angle = Math.PI / 3;
			if (concentration !== void 0 && concentration < 1) {
				concentration = 1;
				console.warn("Value of concentration needs to be greater than 1. Setting it to 1");
			} else if (concentration === void 0) concentration = 100;
			angle = this._pInst._toRadians(angle);
			this.states.setValue("spotLightAngle", [Math.cos(angle)]);
			this.states.setValue("spotLightConc", [concentration]);
			this.states.setValue("enableLighting", true);
		};
		RendererGL.prototype.noLights = function() {
			this.states.setValue("activeImageLight", null);
			this.states.setValue("enableLighting", false);
			this.states.setValue("ambientLightColors", []);
			this.states.setValue("specularColors", [
				1,
				1,
				1
			]);
			this.states.setValue("directionalLightDirections", []);
			this.states.setValue("directionalLightDiffuseColors", []);
			this.states.setValue("directionalLightSpecularColors", []);
			this.states.setValue("pointLightPositions", []);
			this.states.setValue("pointLightDiffuseColors", []);
			this.states.setValue("pointLightSpecularColors", []);
			this.states.setValue("spotLightPositions", []);
			this.states.setValue("spotLightDirections", []);
			this.states.setValue("spotLightDiffuseColors", []);
			this.states.setValue("spotLightSpecularColors", []);
			this.states.setValue("spotLightAngle", []);
			this.states.setValue("spotLightConc", []);
			this.states.setValue("constantAttenuation", 1);
			this.states.setValue("linearAttenuation", 0);
			this.states.setValue("quadraticAttenuation", 0);
			this.states.setValue("_useShininess", 1);
			this.states.setValue("_useMetalness", 0);
		};
	}
	if (typeof p5 !== "undefined") light(p5, p5.prototype);
	function material(p5$2, fn$1) {
		fn$1.loadShader = async function(vertFilename, fragFilename, successCallback, failureCallback) {
			const loadedShader = new Shader();
			try {
				loadedShader._vertSrc = (await request(vertFilename, "text")).data;
				loadedShader._fragSrc = (await request(fragFilename, "text")).data;
				if (successCallback) return successCallback(loadedShader);
				else return loadedShader;
			} catch (err$1) {
				if (failureCallback) return failureCallback(err$1);
				else throw err$1;
			}
		};
		fn$1.createShader = function(vertSrc, fragSrc, options$1) {
			return new Shader(this._renderer, vertSrc, fragSrc, options$1);
		};
		fn$1.loadFilterShader = async function(fragFilename, successCallback, failureCallback) {
			try {
				const fragString = await (await this.loadStrings(fragFilename)).join("\n");
				const loadedShader = this.createFilterShader(fragString, true);
				if (successCallback) successCallback(loadedShader);
				return loadedShader;
			} catch (err$1) {
				if (failureCallback) failureCallback(err$1);
				else console.error(err$1);
			}
		};
		fn$1.createFilterShader = function(fragSrc, skipContextCheck = false) {
			let vertSrc = fragSrc.includes("#version 300 es") ? `#version 300 es
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;

      in vec3 aPosition;
      in vec2 aTexCoord;
      out vec2 vTexCoord;

      void main() {
        // transferring texcoords for the frag shader
        vTexCoord = aTexCoord;

        // copy position with a fourth coordinate for projection (1.0 is normal)
        vec4 positionVec4 = vec4(aPosition, 1.0);

        // project to 3D space
        gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
      }
    ` : `
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;

      attribute vec3 aPosition;
      // texcoords only come from p5 to vertex shader
      // so pass texcoords on to the fragment shader in a varying variable
      attribute vec2 aTexCoord;
      varying vec2 vTexCoord;

      void main() {
        // transferring texcoords for the frag shader
        vTexCoord = aTexCoord;

        // copy position with a fourth coordinate for projection (1.0 is normal)
        vec4 positionVec4 = vec4(aPosition, 1.0);

        // project to 3D space
        gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
      }
    `;
			const shader$1 = new Shader(this._renderer, vertSrc, fragSrc);
			if (!skipContextCheck) if (this._renderer.GL) shader$1.ensureCompiledOnContext(this._renderer);
			else shader$1.ensureCompiledOnContext(this);
			return shader$1;
		};
		fn$1.shader = function(s) {
			this._assert3d("shader");
			this._renderer.shader(s);
			return this;
		};
		fn$1.strokeShader = function(s) {
			this._assert3d("strokeShader");
			this._renderer.strokeShader(s);
			return this;
		};
		fn$1.imageShader = function(s) {
			this._assert3d("imageShader");
			this._renderer.imageShader(s);
			return this;
		};
		fn$1.baseMaterialShader = function() {
			this._assert3d("baseMaterialShader");
			return this._renderer.baseMaterialShader();
		};
		fn$1.baseFilterShader = function() {
			return (this._renderer.filterRenderer || this._renderer).baseFilterShader();
		};
		fn$1.baseNormalShader = function() {
			this._assert3d("baseNormalShader");
			return this._renderer.baseNormalShader();
		};
		fn$1.baseColorShader = function() {
			this._assert3d("baseColorShader");
			return this._renderer.baseColorShader();
		};
		fn$1.baseStrokeShader = function() {
			this._assert3d("baseStrokeShader");
			return this._renderer.baseStrokeShader();
		};
		fn$1.resetShader = function() {
			this._renderer.resetShader();
			return this;
		};
		fn$1.texture = function(tex) {
			this._assert3d("texture");
			if (tex.gifProperties) tex._animateGif(this);
			this._renderer.texture(tex);
			return this;
		};
		fn$1.textureMode = function(mode) {
			if (mode !== IMAGE && mode !== NORMAL) console.warn(`You tried to set ${mode} textureMode only supports IMAGE & NORMAL `);
			else this._renderer.states.setValue("textureMode", mode);
		};
		fn$1.textureWrap = function(wrapX, wrapY = wrapX) {
			this._renderer.states.setValue("textureWrapX", wrapX);
			this._renderer.states.setValue("textureWrapY", wrapY);
			for (const texture$1 of this._renderer.textures.values()) texture$1.setWrapMode(wrapX, wrapY);
		};
		fn$1.normalMaterial = function(...args) {
			this._assert3d("normalMaterial");
			this._renderer.normalMaterial(...args);
			return this;
		};
		fn$1.ambientMaterial = function(v1, v2, v3) {
			this._assert3d("ambientMaterial");
			const color$2 = fn$1.color.apply(this, arguments);
			this._renderer.states.setValue("_hasSetAmbient", true);
			this._renderer.states.setValue("curAmbientColor", color$2._array);
			this._renderer.states.setValue("_useNormalMaterial", false);
			this._renderer.states.setValue("enableLighting", true);
			if (!this._renderer.states.fillColor) this._renderer.states.setValue("fillColor", new Color([
				1,
				1,
				1
			]));
			return this;
		};
		fn$1.emissiveMaterial = function(v1, v2, v3, a) {
			this._assert3d("emissiveMaterial");
			const color$2 = fn$1.color.apply(this, arguments);
			this._renderer.states.setValue("curEmissiveColor", color$2._array);
			this._renderer.states.setValue("_useEmissiveMaterial", true);
			this._renderer.states.setValue("_useNormalMaterial", false);
			this._renderer.states.setValue("enableLighting", true);
			return this;
		};
		fn$1.specularMaterial = function(v1, v2, v3, alpha) {
			this._assert3d("specularMaterial");
			const color$2 = fn$1.color.apply(this, arguments);
			this._renderer.states.setValue("curSpecularColor", color$2._array);
			this._renderer.states.setValue("_useSpecularMaterial", true);
			this._renderer.states.setValue("_useNormalMaterial", false);
			this._renderer.states.setValue("enableLighting", true);
			return this;
		};
		fn$1.shininess = function(shine) {
			this._assert3d("shininess");
			this._renderer.shininess(shine);
			return this;
		};
		fn$1.metalness = function(metallic) {
			this._assert3d("metalness");
			this._renderer.metalness(metallic);
			return this;
		};
		RendererGL.prototype._applyColorBlend = function(colors, hasTransparency) {
			const gl = this.GL;
			const isTexture = this.states.drawMode === TEXTURE;
			const doBlend = hasTransparency || this.states.userFillShader || this.states.userStrokeShader || this.states.userPointShader || isTexture || this.states.curBlendMode !== BLEND || colors[colors.length - 1] < 1 || this._isErasing;
			if (doBlend !== this._isBlending) {
				if (doBlend || this.states.curBlendMode !== BLEND && this.states.curBlendMode !== ADD) gl.enable(gl.BLEND);
				else gl.disable(gl.BLEND);
				gl.depthMask(true);
				this._isBlending = doBlend;
			}
			this._applyBlendMode();
			return colors;
		};
		RendererGL.prototype._applyBlendMode = function() {
			if (this._cachedBlendMode === this.states.curBlendMode) return;
			const gl = this.GL;
			switch (this.states.curBlendMode) {
				case BLEND:
					gl.blendEquation(gl.FUNC_ADD);
					gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
					break;
				case ADD:
					gl.blendEquation(gl.FUNC_ADD);
					gl.blendFunc(gl.ONE, gl.ONE);
					break;
				case REMOVE:
					gl.blendEquation(gl.FUNC_ADD);
					gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
					break;
				case MULTIPLY:
					gl.blendEquation(gl.FUNC_ADD);
					gl.blendFunc(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA);
					break;
				case SCREEN:
					gl.blendEquation(gl.FUNC_ADD);
					gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);
					break;
				case EXCLUSION:
					gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
					gl.blendFuncSeparate(gl.ONE_MINUS_DST_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE);
					break;
				case REPLACE:
					gl.blendEquation(gl.FUNC_ADD);
					gl.blendFunc(gl.ONE, gl.ZERO);
					break;
				case SUBTRACT:
					gl.blendEquationSeparate(gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD);
					gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
					break;
				case DARKEST:
					if (this.blendExt) {
						gl.blendEquationSeparate(this.blendExt.MIN || this.blendExt.MIN_EXT, gl.FUNC_ADD);
						gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
					} else console.warn("blendMode(DARKEST) does not work in your browser in WEBGL mode.");
					break;
				case LIGHTEST:
					if (this.blendExt) {
						gl.blendEquationSeparate(this.blendExt.MAX || this.blendExt.MAX_EXT, gl.FUNC_ADD);
						gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
					} else console.warn("blendMode(LIGHTEST) does not work in your browser in WEBGL mode.");
					break;
				default:
					console.error("Oops! Somehow RendererGL set curBlendMode to an unsupported mode.");
					break;
			}
			this._cachedBlendMode = this.states.curBlendMode;
		};
		RendererGL.prototype.shader = function(s) {
			this.states.setValue("userFillShader", s);
			this.states.setValue("_useNormalMaterial", false);
			s.ensureCompiledOnContext(this);
			s.setDefaultUniforms();
		};
		RendererGL.prototype.strokeShader = function(s) {
			this.states.setValue("userStrokeShader", s);
			s.ensureCompiledOnContext(this);
			s.setDefaultUniforms();
		};
		RendererGL.prototype.imageShader = function(s) {
			this.states.setValue("userImageShader", s);
			s.ensureCompiledOnContext(this);
			s.setDefaultUniforms();
		};
		RendererGL.prototype.resetShader = function() {
			this.states.setValue("userFillShader", null);
			this.states.setValue("userStrokeShader", null);
			this.states.setValue("userImageShader", null);
		};
		RendererGL.prototype.texture = function(tex) {
			this.states.setValue("drawMode", TEXTURE);
			this.states.setValue("_useNormalMaterial", false);
			this.states.setValue("_tex", tex);
			this.states.setValue("fillColor", new Color([
				1,
				1,
				1
			]));
		};
		RendererGL.prototype.normalMaterial = function(...args) {
			this.states.setValue("drawMode", FILL);
			this.states.setValue("_useSpecularMaterial", false);
			this.states.setValue("_useEmissiveMaterial", false);
			this.states.setValue("_useNormalMaterial", true);
			this.states.setValue("curFillColor", [
				1,
				1,
				1,
				1
			]);
			this.states.setValue("fillColor", new Color([
				1,
				1,
				1
			]));
			this.states.setValue("strokeColor", null);
		};
		RendererGL.prototype.shininess = function(shine) {
			if (shine < 1) shine = 1;
			this.states.setValue("_useShininess", shine);
		};
		RendererGL.prototype.metalness = function(metallic) {
			const metalMix = 1 - Math.exp(-metallic / 100);
			this.states.setValue("_useMetalness", metalMix);
		};
	}
	if (typeof p5 !== "undefined") loading(p5, p5.prototype);
	var Graphics = class {
		constructor(w, h, renderer$1, pInst, canvas$1) {
			const r = renderer$1 || P2D;
			this._pInst = pInst;
			this._renderer = new renderers[r](this, w, h, false, canvas$1);
			this._initializeInstanceVariables(this);
			this._renderer._applyDefaults();
			return this;
		}
		get deltaTime() {
			return this._pInst.deltaTime;
		}
		get canvas() {
			return this._renderer?.canvas;
		}
		get drawingContext() {
			return this._renderer.drawingContext;
		}
		get width() {
			return this._renderer?.width;
		}
		get height() {
			return this._renderer?.height;
		}
		get pixels() {
			return this._renderer?.pixels;
		}
		pixelDensity(val$1) {
			let returnValue;
			if (typeof val$1 === "number") {
				if (val$1 !== this._renderer._pixelDensity) this._renderer._pixelDensity = val$1;
				returnValue = this;
				this.resizeCanvas(this.width, this.height, true);
			} else returnValue = this._renderer._pixelDensity;
			return returnValue;
		}
		resizeCanvas(w, h) {
			this._renderer.resize(w, h);
		}
		reset() {
			this._renderer.resetMatrix();
			if (this._renderer.isP3D) this._renderer._update();
		}
		remove() {
			this._renderer.remove();
			this._renderer = void 0;
		}
		createFramebuffer(options$1) {
			return new Framebuffer(this._renderer, options$1);
		}
		_assert3d(name) {
			if (!this._renderer.isP3D) throw new Error(`${name}() is only supported in WEBGL mode. If you'd like to use 3D graphics and WebGL, see  https://p5js.org/examples/form-3d-primitives.html for more information.`);
		}
		_initializeInstanceVariables() {
			this._accessibleOutputs = {
				text: false,
				grid: false,
				textLabel: false,
				gridLabel: false
			};
			this._styles = [];
			this._downKeys = {};
		}
	};
	function graphics(p5$2, fn$1) {
		p5$2.Graphics = Graphics;
		primitives(p5$2, p5$2.Graphics.prototype);
		attributes(p5$2, p5$2.Graphics.prototype);
		curves(p5$2, p5$2.Graphics.prototype);
		vertex(p5$2, p5$2.Graphics.prototype);
		customShapes(p5$2, p5$2.Graphics.prototype);
		setting(p5$2, p5$2.Graphics.prototype);
		loadingDisplaying(p5$2, p5$2.Graphics.prototype);
		image$1(p5$2, p5$2.Graphics.prototype);
		pixels(p5$2, p5$2.Graphics.prototype);
		transform$1(p5$2, p5$2.Graphics.prototype);
		primitives3D(p5$2, p5$2.Graphics.prototype);
		light(p5$2, p5$2.Graphics.prototype);
		material(p5$2, p5$2.Graphics.prototype);
		creatingReading(p5$2, p5$2.Graphics.prototype);
		trigonometry(p5$2, p5$2.Graphics.prototype);
	}
	var Texture = class {
		constructor(renderer$1, obj, settings) {
			this._renderer = renderer$1;
			const gl = this._renderer.GL;
			settings = settings || {};
			this.src = obj;
			this.glTex = void 0;
			this.glTarget = gl.TEXTURE_2D;
			this.glFormat = settings.format || gl.RGBA;
			this.mipmaps = false;
			this.glMinFilter = settings.minFilter || gl.LINEAR;
			this.glMagFilter = settings.magFilter || gl.LINEAR;
			this.glWrapS = settings.wrapS || gl.CLAMP_TO_EDGE;
			this.glWrapT = settings.wrapT || gl.CLAMP_TO_EDGE;
			this.glDataType = settings.dataType || gl.UNSIGNED_BYTE;
			const support = checkWebGLCapabilities(renderer$1);
			if (this.glFormat === gl.HALF_FLOAT && !support.halfFloat) {
				console.log("This device does not support dataType HALF_FLOAT. Falling back to FLOAT.");
				this.glDataType = gl.FLOAT;
			}
			if (this.glFormat === gl.HALF_FLOAT && (this.glMinFilter === gl.LINEAR || this.glMagFilter === gl.LINEAR) && !support.halfFloatLinear) {
				console.log("This device does not support linear filtering for dataType FLOAT. Falling back to NEAREST.");
				if (this.glMinFilter === gl.LINEAR) this.glMinFilter = gl.NEAREST;
				if (this.glMagFilter === gl.LINEAR) this.glMagFilter = gl.NEAREST;
			}
			if (this.glFormat === gl.FLOAT && !support.float) {
				console.log("This device does not support dataType FLOAT. Falling back to UNSIGNED_BYTE.");
				this.glDataType = gl.UNSIGNED_BYTE;
			}
			if (this.glFormat === gl.FLOAT && (this.glMinFilter === gl.LINEAR || this.glMagFilter === gl.LINEAR) && !support.floatLinear) {
				console.log("This device does not support linear filtering for dataType FLOAT. Falling back to NEAREST.");
				if (this.glMinFilter === gl.LINEAR) this.glMinFilter = gl.NEAREST;
				if (this.glMagFilter === gl.LINEAR) this.glMagFilter = gl.NEAREST;
			}
			this.isSrcMediaElement = false;
			this._videoPrevUpdateTime = 0;
			this.isSrcHTMLElement = typeof Element !== "undefined" && obj instanceof Element && !(obj instanceof Graphics) && !(obj instanceof Renderer);
			this.isSrcP5Image = obj instanceof Image;
			this.isSrcP5Graphics = obj instanceof Graphics;
			this.isSrcP5Renderer = obj instanceof Renderer;
			this.isImageData = typeof ImageData !== "undefined" && obj instanceof ImageData;
			this.isFramebufferTexture = obj instanceof FramebufferTexture;
			const textureData = this._getTextureDataFromSource();
			this.width = textureData.width;
			this.height = textureData.height;
			this.init(textureData);
			return this;
		}
		remove() {
			if (this.glTex) {
				this._renderer.GL.deleteTexture(this.glTex);
				this.glTex = void 0;
			}
		}
		_getTextureDataFromSource() {
			let textureData;
			if (this.isFramebufferTexture) textureData = this.src.rawTexture();
			else if (this.isSrcP5Image) textureData = this.src.canvas;
			else if (this.isSrcMediaElement || this.isSrcHTMLElement) {
				if (this.src._ensureCanvas) this.src._ensureCanvas();
				textureData = this.src.elt;
			} else if (this.isSrcP5Graphics || this.isSrcP5Renderer) textureData = this.src.canvas;
			else if (this.isImageData) textureData = this.src;
			return textureData;
		}
		init(data$2) {
			const gl = this._renderer.GL;
			if (!this.isFramebufferTexture) this.glTex = gl.createTexture();
			this.glWrapS = this._renderer.states.textureWrapX;
			this.glWrapT = this._renderer.states.textureWrapY;
			this.setWrapMode(this.glWrapS, this.glWrapT);
			this.bindTexture();
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.glMagFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.glMinFilter);
			if (this.isFramebufferTexture);
			else if (this.width === 0 || this.height === 0 || this.isSrcMediaElement && !this.src.loadedmetadata) {
				const tmpdata = new Uint8Array([
					1,
					1,
					1,
					1
				]);
				gl.texImage2D(this.glTarget, 0, gl.RGBA, 1, 1, 0, this.glFormat, this.glDataType, tmpdata);
			} else gl.texImage2D(this.glTarget, 0, this.glFormat, this.glFormat, this.glDataType, data$2);
		}
		update() {
			const data$2 = this.src;
			if (data$2.width === 0 || data$2.height === 0) return false;
			if (this.isFramebufferTexture) {
				this.src.update();
				return false;
			}
			const textureData = this._getTextureDataFromSource();
			let updated = false;
			const gl = this._renderer.GL;
			if (textureData.width !== this.width || textureData.height !== this.height) {
				updated = true;
				this.width = textureData.width || data$2.width;
				this.height = textureData.height || data$2.height;
				if (this.isSrcP5Image) data$2.setModified(false);
				else if (this.isSrcMediaElement || this.isSrcHTMLElement) data$2.setModified && data$2.setModified(true);
			} else if (this.isSrcP5Image) {
				if (data$2.isModified()) {
					updated = true;
					data$2.setModified(false);
				}
			} else if (this.isSrcMediaElement) {
				if (data$2.isModified()) {
					updated = true;
					data$2.setModified(false);
				} else if (data$2.loadedmetadata) {
					if (this._videoPrevUpdateTime !== data$2.time()) {
						this._videoPrevUpdateTime = data$2.time();
						updated = true;
					}
				}
			} else if (this.isImageData) {
				if (data$2._dirty) {
					data$2._dirty = false;
					updated = true;
				}
			} else updated = true;
			if (updated) {
				this.bindTexture();
				gl.texImage2D(this.glTarget, 0, this.glFormat, this.glFormat, this.glDataType, textureData);
			}
			return updated;
		}
		bindTexture() {
			this._renderer.GL.bindTexture(this.glTarget, this.getTexture());
			return this;
		}
		unbindTexture() {
			this._renderer.GL.bindTexture(this.glTarget, null);
		}
		getTexture() {
			if (this.isFramebufferTexture) return this.src.rawTexture();
			else return this.glTex;
		}
		setInterpolation(downScale, upScale) {
			const gl = this._renderer.GL;
			this.glMinFilter = this.glFilter(downScale);
			this.glMagFilter = this.glFilter(upScale);
			this.bindTexture();
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.glMinFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.glMagFilter);
			this.unbindTexture();
		}
		glFilter(filter) {
			const gl = this._renderer.GL;
			if (filter === NEAREST) return gl.NEAREST;
			else return gl.LINEAR;
		}
		setWrapMode(wrapX, wrapY) {
			const gl = this._renderer.GL;
			const isPowerOfTwo = (x$1) => (x$1 & x$1 - 1) === 0;
			const textureData = this._getTextureDataFromSource();
			let wrapWidth;
			let wrapHeight;
			if (textureData.naturalWidth && textureData.naturalHeight) {
				wrapWidth = textureData.naturalWidth;
				wrapHeight = textureData.naturalHeight;
			} else {
				wrapWidth = this.width;
				wrapHeight = this.height;
			}
			const widthPowerOfTwo = isPowerOfTwo(wrapWidth);
			const heightPowerOfTwo = isPowerOfTwo(wrapHeight);
			if (wrapX === REPEAT) if (this._renderer.webglVersion === WEBGL2 || widthPowerOfTwo && heightPowerOfTwo) this.glWrapS = gl.REPEAT;
			else {
				console.warn("You tried to set the wrap mode to REPEAT but the texture size is not a power of two. Setting to CLAMP instead");
				this.glWrapS = gl.CLAMP_TO_EDGE;
			}
			else if (wrapX === MIRROR) if (this._renderer.webglVersion === WEBGL2 || widthPowerOfTwo && heightPowerOfTwo) this.glWrapS = gl.MIRRORED_REPEAT;
			else {
				console.warn("You tried to set the wrap mode to MIRROR but the texture size is not a power of two. Setting to CLAMP instead");
				this.glWrapS = gl.CLAMP_TO_EDGE;
			}
			else this.glWrapS = gl.CLAMP_TO_EDGE;
			if (wrapY === REPEAT) if (this._renderer.webglVersion === WEBGL2 || widthPowerOfTwo && heightPowerOfTwo) this.glWrapT = gl.REPEAT;
			else {
				console.warn("You tried to set the wrap mode to REPEAT but the texture size is not a power of two. Setting to CLAMP instead");
				this.glWrapT = gl.CLAMP_TO_EDGE;
			}
			else if (wrapY === MIRROR) if (this._renderer.webglVersion === WEBGL2 || widthPowerOfTwo && heightPowerOfTwo) this.glWrapT = gl.MIRRORED_REPEAT;
			else {
				console.warn("You tried to set the wrap mode to MIRROR but the texture size is not a power of two. Setting to CLAMP instead");
				this.glWrapT = gl.CLAMP_TO_EDGE;
			}
			else this.glWrapT = gl.CLAMP_TO_EDGE;
			this.bindTexture();
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this.glWrapS);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this.glWrapT);
			this.unbindTexture();
		}
	};
	var MipmapTexture = class extends Texture {
		constructor(renderer$1, levels, settings) {
			super(renderer$1, levels, settings);
			const gl = this._renderer.GL;
			if (this.glMinFilter === gl.LINEAR) this.glMinFilter = gl.LINEAR_MIPMAP_LINEAR;
		}
		glFilter(_filter) {
			return this._renderer.GL.LINEAR_MIPMAP_LINEAR;
		}
		_getTextureDataFromSource() {
			return this.src;
		}
		init(levels) {
			const gl = this._renderer.GL;
			this.glTex = gl.createTexture();
			this.bindTexture();
			for (let level = 0; level < levels.length; level++) gl.texImage2D(this.glTarget, level, this.glFormat, this.glFormat, this.glDataType, levels[level]);
			this.glMinFilter = gl.LINEAR_MIPMAP_LINEAR;
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.glMagFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.glMinFilter);
			this.unbindTexture();
		}
		update() {}
	};
	function texture(p5$2, fn$1) {
		p5$2.Texture = Texture;
		p5$2.MipmapTexture = MipmapTexture;
	}
	function checkWebGLCapabilities({ GL, webglVersion }) {
		const gl = GL;
		const supportsFloat = webglVersion === WEBGL2 ? gl.getExtension("EXT_color_buffer_float") && gl.getExtension("EXT_float_blend") : gl.getExtension("OES_texture_float");
		const supportsFloatLinear = supportsFloat && gl.getExtension("OES_texture_float_linear");
		const supportsHalfFloat = webglVersion === WEBGL2 ? gl.getExtension("EXT_color_buffer_float") : gl.getExtension("OES_texture_half_float");
		return {
			float: supportsFloat,
			floatLinear: supportsFloatLinear,
			halfFloat: supportsHalfFloat,
			halfFloatLinear: supportsHalfFloat && gl.getExtension("OES_texture_half_float_linear")
		};
	}
	if (typeof p5 !== "undefined") texture(p5, p5.prototype);
	const constrain = (n$2, low, high) => Math.max(Math.min(n$2, high), low);
	var FramebufferCamera = class extends Camera {
		constructor(framebuffer$1) {
			super(framebuffer$1.renderer);
			this.fbo = framebuffer$1;
			this.yScale = -1;
		}
		_computeCameraDefaultSettings() {
			super._computeCameraDefaultSettings();
			this.defaultAspectRatio = this.fbo.width / this.fbo.height;
			this.defaultCameraFOV = 2 * Math.atan(this.fbo.height / 2 / this.defaultEyeZ);
		}
	};
	var FramebufferTexture = class {
		constructor(framebuffer$1, property) {
			this.framebuffer = framebuffer$1;
			this.property = property;
		}
		get width() {
			return this.framebuffer.width * this.framebuffer.density;
		}
		get height() {
			return this.framebuffer.height * this.framebuffer.density;
		}
		update() {
			this.framebuffer._update(this.property);
		}
		rawTexture() {
			return this.framebuffer[this.property];
		}
	};
	var Framebuffer = class {
		constructor(renderer$1, settings = {}) {
			this.renderer = renderer$1;
			this.renderer.framebuffers.add(this);
			this._isClipApplied = false;
			this.dirty = {
				colorTexture: false,
				depthTexture: false
			};
			this.pixels = [];
			this.format = settings.format || UNSIGNED_BYTE;
			this.channels = settings.channels || (this.renderer._pInst._glAttributes.alpha ? RGBA : RGB);
			this.useDepth = settings.depth === void 0 ? true : settings.depth;
			this.depthFormat = settings.depthFormat || FLOAT;
			this.textureFiltering = settings.textureFiltering || LINEAR;
			if (settings.antialias === void 0) this.antialiasSamples = this.renderer._pInst._glAttributes.antialias ? 2 : 0;
			else if (typeof settings.antialias === "number") this.antialiasSamples = settings.antialias;
			else this.antialiasSamples = settings.antialias ? 2 : 0;
			this.antialias = this.antialiasSamples > 0;
			if (this.antialias && this.renderer.webglVersion !== WEBGL2) {
				console.warn("Antialiasing is unsupported in a WebGL 1 context");
				this.antialias = false;
			}
			this.density = settings.density || this.renderer._pixelDensity;
			const gl = this.renderer.GL;
			this.gl = gl;
			if (settings.width && settings.height) {
				const dimensions = this.renderer._adjustDimensions(settings.width, settings.height);
				this.width = dimensions.adjustedWidth;
				this.height = dimensions.adjustedHeight;
				this._autoSized = false;
			} else {
				if (settings.width === void 0 !== (settings.height === void 0)) console.warn("Please supply both width and height for a framebuffer to give it a size. Only one was given, so the framebuffer will match the size of its canvas.");
				this.width = this.renderer.width;
				this.height = this.renderer.height;
				this._autoSized = true;
			}
			this._checkIfFormatsAvailable();
			if (settings.stencil && !this.useDepth) console.warn("A stencil buffer can only be used if also using depth. Since the framebuffer has no depth buffer, the stencil buffer will be ignored.");
			this.useStencil = this.useDepth && (settings.stencil === void 0 ? true : settings.stencil);
			this.framebuffer = gl.createFramebuffer();
			if (!this.framebuffer) throw new Error("Unable to create a framebuffer");
			if (this.antialias) {
				this.aaFramebuffer = gl.createFramebuffer();
				if (!this.aaFramebuffer) throw new Error("Unable to create a framebuffer for antialiasing");
			}
			this._recreateTextures();
			const prevCam = this.renderer.states.curCamera;
			this.defaultCamera = this.createCamera();
			this.filterCamera = this.createCamera();
			this.renderer.states.setValue("curCamera", prevCam);
			this.draw(() => this.renderer.clear());
		}
		resize(width, height) {
			this._autoSized = false;
			const dimensions = this.renderer._adjustDimensions(width, height);
			width = dimensions.adjustedWidth;
			height = dimensions.adjustedHeight;
			this.width = width;
			this.height = height;
			this._handleResize();
		}
		pixelDensity(density) {
			if (density) {
				this._autoSized = false;
				this.density = density;
				this._handleResize();
			} else return this.density;
		}
		autoSized(autoSized) {
			if (autoSized === void 0) return this._autoSized;
			else {
				this._autoSized = autoSized;
				this._handleResize();
			}
		}
		_checkIfFormatsAvailable() {
			const gl = this.gl;
			if (this.useDepth && this.renderer.webglVersion === WEBGL && !gl.getExtension("WEBGL_depth_texture")) {
				console.warn("Unable to create depth textures in this environment. Falling back to a framebuffer without depth.");
				this.useDepth = false;
			}
			if (this.useDepth && this.renderer.webglVersion === WEBGL && this.depthFormat === FLOAT) {
				console.warn("FLOAT depth format is unavailable in WebGL 1. Defaulting to UNSIGNED_INT.");
				this.depthFormat = UNSIGNED_INT;
			}
			if (![
				UNSIGNED_BYTE,
				FLOAT,
				HALF_FLOAT
			].includes(this.format)) {
				console.warn("Unknown Framebuffer format. Please use UNSIGNED_BYTE, FLOAT, or HALF_FLOAT. Defaulting to UNSIGNED_BYTE.");
				this.format = UNSIGNED_BYTE;
			}
			if (this.useDepth && ![UNSIGNED_INT, FLOAT].includes(this.depthFormat)) {
				console.warn("Unknown Framebuffer depth format. Please use UNSIGNED_INT or FLOAT. Defaulting to FLOAT.");
				this.depthFormat = FLOAT;
			}
			const support = checkWebGLCapabilities(this.renderer);
			if (!support.float && this.format === FLOAT) {
				console.warn("This environment does not support FLOAT textures. Falling back to UNSIGNED_BYTE.");
				this.format = UNSIGNED_BYTE;
			}
			if (this.useDepth && !support.float && this.depthFormat === FLOAT) {
				console.warn("This environment does not support FLOAT depth textures. Falling back to UNSIGNED_INT.");
				this.depthFormat = UNSIGNED_INT;
			}
			if (!support.halfFloat && this.format === HALF_FLOAT) {
				console.warn("This environment does not support HALF_FLOAT textures. Falling back to UNSIGNED_BYTE.");
				this.format = UNSIGNED_BYTE;
			}
			if (this.channels === RGB && [FLOAT, HALF_FLOAT].includes(this.format)) {
				console.warn("FLOAT and HALF_FLOAT formats do not work cross-platform with only RGB channels. Falling back to RGBA.");
				this.channels = RGBA;
			}
		}
		_recreateTextures() {
			const gl = this.gl;
			this._updateSize();
			const prevBoundTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
			const prevBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
			const colorTexture = gl.createTexture();
			if (!colorTexture) throw new Error("Unable to create color texture");
			gl.bindTexture(gl.TEXTURE_2D, colorTexture);
			const colorFormat = this._glColorFormat();
			gl.texImage2D(gl.TEXTURE_2D, 0, colorFormat.internalFormat, this.width * this.density, this.height * this.density, 0, colorFormat.format, colorFormat.type, null);
			this.colorTexture = colorTexture;
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorTexture, 0);
			if (this.useDepth) {
				const depthTexture = gl.createTexture();
				if (!depthTexture) throw new Error("Unable to create depth texture");
				const depthFormat = this._glDepthFormat();
				gl.bindTexture(gl.TEXTURE_2D, depthTexture);
				gl.texImage2D(gl.TEXTURE_2D, 0, depthFormat.internalFormat, this.width * this.density, this.height * this.density, 0, depthFormat.format, depthFormat.type, null);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, this.useStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);
				this.depthTexture = depthTexture;
			}
			if (this.antialias) {
				this.colorRenderbuffer = gl.createRenderbuffer();
				gl.bindRenderbuffer(gl.RENDERBUFFER, this.colorRenderbuffer);
				gl.renderbufferStorageMultisample(gl.RENDERBUFFER, Math.max(0, Math.min(this.antialiasSamples, gl.getParameter(gl.MAX_SAMPLES))), colorFormat.internalFormat, this.width * this.density, this.height * this.density);
				if (this.useDepth) {
					const depthFormat = this._glDepthFormat();
					this.depthRenderbuffer = gl.createRenderbuffer();
					gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthRenderbuffer);
					gl.renderbufferStorageMultisample(gl.RENDERBUFFER, Math.max(0, Math.min(this.antialiasSamples, gl.getParameter(gl.MAX_SAMPLES))), depthFormat.internalFormat, this.width * this.density, this.height * this.density);
				}
				gl.bindFramebuffer(gl.FRAMEBUFFER, this.aaFramebuffer);
				gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this.colorRenderbuffer);
				if (this.useDepth) gl.framebufferRenderbuffer(gl.FRAMEBUFFER, this.useStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depthRenderbuffer);
			}
			if (this.useDepth) {
				this.depth = new FramebufferTexture(this, "depthTexture");
				const depthFilter = gl.NEAREST;
				this.depthP5Texture = new Texture(this.renderer, this.depth, {
					minFilter: depthFilter,
					magFilter: depthFilter
				});
				this.renderer.textures.set(this.depth, this.depthP5Texture);
			}
			this.color = new FramebufferTexture(this, "colorTexture");
			const filter = this.textureFiltering === LINEAR ? gl.LINEAR : gl.NEAREST;
			this.colorP5Texture = new Texture(this.renderer, this.color, {
				minFilter: filter,
				magFilter: filter
			});
			this.renderer.textures.set(this.color, this.colorP5Texture);
			gl.bindTexture(gl.TEXTURE_2D, prevBoundTexture);
			gl.bindFramebuffer(gl.FRAMEBUFFER, prevBoundFramebuffer);
		}
		_glColorFormat() {
			let type$2, format, internalFormat;
			const gl = this.gl;
			if (this.format === FLOAT) type$2 = gl.FLOAT;
			else if (this.format === HALF_FLOAT) type$2 = this.renderer.webglVersion === WEBGL2 ? gl.HALF_FLOAT : gl.getExtension("OES_texture_half_float").HALF_FLOAT_OES;
			else type$2 = gl.UNSIGNED_BYTE;
			if (this.channels === RGBA) format = gl.RGBA;
			else format = gl.RGB;
			if (this.renderer.webglVersion === WEBGL2) internalFormat = {
				[gl.FLOAT]: { [gl.RGBA]: gl.RGBA32F },
				[gl.HALF_FLOAT]: { [gl.RGBA]: gl.RGBA16F },
				[gl.UNSIGNED_BYTE]: {
					[gl.RGBA]: gl.RGBA8,
					[gl.RGB]: gl.RGB8
				}
			}[type$2][format];
			else if (this.format === HALF_FLOAT) internalFormat = gl.RGBA;
			else internalFormat = format;
			return {
				internalFormat,
				format,
				type: type$2
			};
		}
		_glDepthFormat() {
			let type$2, format, internalFormat;
			const gl = this.gl;
			if (this.useStencil) if (this.depthFormat === FLOAT) type$2 = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
			else if (this.renderer.webglVersion === WEBGL2) type$2 = gl.UNSIGNED_INT_24_8;
			else type$2 = gl.getExtension("WEBGL_depth_texture").UNSIGNED_INT_24_8_WEBGL;
			else if (this.depthFormat === FLOAT) type$2 = gl.FLOAT;
			else type$2 = gl.UNSIGNED_INT;
			if (this.useStencil) format = gl.DEPTH_STENCIL;
			else format = gl.DEPTH_COMPONENT;
			if (this.useStencil) if (this.depthFormat === FLOAT) internalFormat = gl.DEPTH32F_STENCIL8;
			else if (this.renderer.webglVersion === WEBGL2) internalFormat = gl.DEPTH24_STENCIL8;
			else internalFormat = gl.DEPTH_STENCIL;
			else if (this.renderer.webglVersion === WEBGL2) if (this.depthFormat === FLOAT) internalFormat = gl.DEPTH_COMPONENT32F;
			else internalFormat = gl.DEPTH_COMPONENT24;
			else internalFormat = gl.DEPTH_COMPONENT;
			return {
				internalFormat,
				format,
				type: type$2
			};
		}
		_updateSize() {
			if (this._autoSized) {
				this.width = this.renderer.width;
				this.height = this.renderer.height;
				this.density = this.renderer._pixelDensity;
			}
		}
		_canvasSizeChanged() {
			if (this._autoSized) this._handleResize();
		}
		_handleResize() {
			const oldColor = this.color;
			const oldDepth = this.depth;
			const oldColorRenderbuffer = this.colorRenderbuffer;
			const oldDepthRenderbuffer = this.depthRenderbuffer;
			this._deleteTexture(oldColor);
			if (oldDepth) this._deleteTexture(oldDepth);
			const gl = this.gl;
			if (oldColorRenderbuffer) gl.deleteRenderbuffer(oldColorRenderbuffer);
			if (oldDepthRenderbuffer) gl.deleteRenderbuffer(oldDepthRenderbuffer);
			this._recreateTextures();
			this.defaultCamera._resize();
		}
		createCamera() {
			const cam = new FramebufferCamera(this);
			cam._computeCameraDefaultSettings();
			cam._setDefaultCamera();
			return cam;
		}
		_deleteTexture(texture$1) {
			this.gl.deleteTexture(texture$1.rawTexture());
			this.renderer.textures.delete(texture$1);
		}
		remove() {
			const gl = this.gl;
			this._deleteTexture(this.color);
			if (this.depth) this._deleteTexture(this.depth);
			gl.deleteFramebuffer(this.framebuffer);
			if (this.aaFramebuffer) gl.deleteFramebuffer(this.aaFramebuffer);
			if (this.depthRenderbuffer) gl.deleteRenderbuffer(this.depthRenderbuffer);
			if (this.colorRenderbuffer) gl.deleteRenderbuffer(this.colorRenderbuffer);
			this.renderer.framebuffers.delete(this);
		}
		begin() {
			this.prevFramebuffer = this.renderer.activeFramebuffer();
			if (this.prevFramebuffer) this.prevFramebuffer._beforeEnd();
			this.renderer.activeFramebuffers.push(this);
			this._beforeBegin();
			this.renderer.push();
			this.renderer.states.setValue("curCamera", this.defaultCamera);
			this.renderer.states.setValue("uPMatrix", this.renderer.states.uPMatrix.clone());
			this.renderer.states.uPMatrix.set(this.defaultCamera.projMatrix);
			this.renderer.states.setValue("uViewMatrix", this.renderer.states.uViewMatrix.clone());
			this.renderer.states.uViewMatrix.set(this.defaultCamera.cameraMatrix);
			this.renderer.resetMatrix();
			this.renderer.states.uViewMatrix.set(this.renderer.states.curCamera.cameraMatrix);
			this.renderer.states.uModelMatrix.reset();
			this.renderer._applyStencilTestIfClipping();
		}
		_framebufferToBind() {
			if (this.antialias) return this.aaFramebuffer;
			else return this.framebuffer;
		}
		_update(property) {
			if (this.dirty[property] && this.antialias) {
				const gl = this.gl;
				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.aaFramebuffer);
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.framebuffer);
				const partsToCopy = { colorTexture: [gl.COLOR_BUFFER_BIT, this.colorP5Texture.glMagFilter] };
				if (this.useDepth) partsToCopy.depthTexture = [gl.DEPTH_BUFFER_BIT, this.depthP5Texture.glMagFilter];
				const [flag, filter] = partsToCopy[property];
				gl.blitFramebuffer(0, 0, this.width * this.density, this.height * this.density, 0, 0, this.width * this.density, this.height * this.density, flag, filter);
				this.dirty[property] = false;
				const activeFbo = this.renderer.activeFramebuffer();
				if (activeFbo) gl.bindFramebuffer(gl.FRAMEBUFFER, activeFbo._framebufferToBind());
				else gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			}
		}
		_beforeBegin() {
			const gl = this.gl;
			gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebufferToBind());
			this.renderer.viewport(this.width * this.density, this.height * this.density);
		}
		_beforeEnd() {
			if (this.antialias) this.dirty = {
				colorTexture: true,
				depthTexture: true
			};
		}
		end() {
			const gl = this.gl;
			this.renderer.pop();
			if (this.renderer.activeFramebuffers.pop() !== this) throw new Error("It looks like you've called end() while another Framebuffer is active.");
			this._beforeEnd();
			if (this.prevFramebuffer) this.prevFramebuffer._beforeBegin();
			else {
				gl.bindFramebuffer(gl.FRAMEBUFFER, null);
				this.renderer.viewport(this.renderer._origViewport.width, this.renderer._origViewport.height);
			}
			this.renderer._applyStencilTestIfClipping();
		}
		draw(callback) {
			this.begin();
			callback();
			this.end();
		}
		loadPixels() {
			this._update("colorTexture");
			const gl = this.gl;
			const prevFramebuffer = this.renderer.activeFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
			const colorFormat = this._glColorFormat();
			this.pixels = readPixelsWebGL(this.pixels, gl, this.framebuffer, 0, 0, this.width * this.density, this.height * this.density, colorFormat.format, colorFormat.type);
			if (prevFramebuffer) gl.bindFramebuffer(gl.FRAMEBUFFER, prevFramebuffer._framebufferToBind());
			else gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
		get(x$1, y, w, h) {
			this._update("colorTexture");
			const colorFormat = this._glColorFormat();
			if (x$1 === void 0 && y === void 0) {
				x$1 = 0;
				y = 0;
				w = this.width;
				h = this.height;
			} else if (w === void 0 && h === void 0) {
				if (x$1 < 0 || y < 0 || x$1 >= this.width || y >= this.height) {
					console.warn("The x and y values passed to p5.Framebuffer.get are outside of its range and will be clamped.");
					x$1 = constrain(x$1, 0, this.width - 1);
					y = constrain(y, 0, this.height - 1);
				}
				return readPixelWebGL(this.gl, this.framebuffer, x$1 * this.density, y * this.density, colorFormat.format, colorFormat.type);
			}
			x$1 = constrain(x$1, 0, this.width - 1);
			y = constrain(y, 0, this.height - 1);
			w = constrain(w, 1, this.width - x$1);
			h = constrain(h, 1, this.height - y);
			const rawData = readPixelsWebGL(void 0, this.gl, this.framebuffer, x$1 * this.density, y * this.density, w * this.density, h * this.density, colorFormat.format, colorFormat.type);
			const fullData = new Uint8ClampedArray(w * h * this.density * this.density * 4);
			fullData.fill(255);
			const channels = colorFormat.type === this.gl.RGB ? 3 : 4;
			for (let y$1 = 0; y$1 < h * this.density; y$1++) for (let x$2 = 0; x$2 < w * this.density; x$2++) for (let channel = 0; channel < 4; channel++) {
				const idx = (y$1 * w * this.density + x$2) * 4 + channel;
				if (channel < channels) fullData[idx] = rawData[channels === 4 ? idx : (y$1 * w * this.density + x$2) * channels + channel];
			}
			const region = new Image(w * this.density, h * this.density);
			region.imageData = region.canvas.getContext("2d").createImageData(region.width, region.height);
			region.imageData.data.set(fullData);
			region.pixels = region.imageData.data;
			region.updatePixels();
			if (this.density !== 1) region.resize(w, h);
			return region;
		}
		updatePixels() {
			const gl = this.gl;
			this.colorP5Texture.bindTexture();
			const colorFormat = this._glColorFormat();
			const channels = colorFormat.format === gl.RGBA ? 4 : 3;
			const len = this.width * this.height * this.density * this.density * channels;
			const TypedArrayClass = colorFormat.type === gl.UNSIGNED_BYTE ? Uint8Array : Float32Array;
			if (!(this.pixels instanceof TypedArrayClass) || this.pixels.length !== len) throw new Error("The pixels array has not been set correctly. Please call loadPixels() before updatePixels().");
			gl.texImage2D(gl.TEXTURE_2D, 0, colorFormat.internalFormat, this.width * this.density, this.height * this.density, 0, colorFormat.format, colorFormat.type, this.pixels);
			this.colorP5Texture.unbindTexture();
			this.dirty.colorTexture = false;
			const prevFramebuffer = this.renderer.activeFramebuffer();
			if (this.antialias) {
				this.begin();
				this.renderer.push();
				this.renderer.states.setValue("imageMode", CORNER);
				this.renderer.setCamera(this.filterCamera);
				this.renderer.resetMatrix();
				this.renderer.states.setValue("strokeColor", null);
				this.renderer.clear();
				this.renderer._drawingFilter = true;
				this.renderer.image(this, 0, 0, this.width, this.height, -this.renderer.width / 2, -this.renderer.height / 2, this.renderer.width, this.renderer.height);
				this.renderer._drawingFilter = false;
				this.renderer.pop();
				if (this.useDepth) {
					gl.clearDepth(1);
					gl.clear(gl.DEPTH_BUFFER_BIT);
				}
				this.end();
			} else {
				gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
				if (this.useDepth) {
					gl.clearDepth(1);
					gl.clear(gl.DEPTH_BUFFER_BIT);
				}
				if (prevFramebuffer) gl.bindFramebuffer(gl.FRAMEBUFFER, prevFramebuffer._framebufferToBind());
				else gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			}
		}
	};
	function framebuffer(p5$2, fn$1) {
		p5$2.FramebufferCamera = FramebufferCamera;
		p5$2.FramebufferTexture = FramebufferTexture;
		p5$2.Framebuffer = Framebuffer;
	}
	if (typeof p5 !== "undefined") framebuffer(p5, p5.prototype);
	let renderers;
	function rendering(p5$2, fn$1) {
		renderers = p5$2.renderers = {};
		fn$1.createCanvas = function(w, h, renderer$1, ...args) {
			let selectedRenderer = P2D;
			if (Reflect.ownKeys(renderers).includes(renderer$1)) selectedRenderer = renderer$1;
			else args.unshift(renderer$1);
			if (this._renderer) this._renderer.remove();
			this._renderer = new renderers[selectedRenderer](this, w, h, true, ...args);
			this._defaultGraphicsCreated = true;
			this._elements.push(this._renderer);
			this._renderer._applyDefaults();
			if (!Object.hasOwn(this, "pixels")) Object.defineProperty(this, "pixels", { get() {
				return this._renderer?.pixels;
			} });
			return this._renderer;
		};
		fn$1.resizeCanvas = function(w, h, noRedraw) {
			if (this._renderer) {
				this._renderer.resize(w, h);
				if (!noRedraw) this.redraw();
			}
			if (this._addAccsOutput()) this._updateAccsOutput();
		};
		fn$1.noCanvas = function() {
			if (this.canvas) this.canvas.parentNode.removeChild(this.canvas);
		};
		fn$1.createGraphics = function(w, h, ...args) {
			if (args[0] instanceof HTMLCanvasElement) {
				args[1] = args[0];
				args[0] = P2D;
			}
			return new p5$2.Graphics(w, h, args[0], this, args[1]);
		};
		fn$1.createFramebuffer = function(options$1) {
			return new Framebuffer(this._renderer, options$1);
		};
		fn$1.clearDepth = function(depth) {
			this._assert3d("clearDepth");
			this._renderer.clearDepth(depth);
		};
	}
	if (typeof p5 !== "undefined") rendering(p5, p5.prototype);
	var FilterRenderer2D = class {
		constructor(pInst) {
			this.pInst = pInst;
			this.canvas = document.createElement("canvas");
			this.canvas.width = pInst.width;
			this.canvas.height = pInst.height;
			let webglVersion = WEBGL2;
			this.gl = this.canvas.getContext("webgl2");
			if (!this.gl) {
				webglVersion = WEBGL;
				this.gl = this.canvas.getContext("webgl");
			}
			if (!this.gl) {
				console.error("WebGL not supported, cannot apply filter.");
				return;
			}
			this._renderer = {
				GL: this.gl,
				registerEnabled: /* @__PURE__ */ new Set(),
				_curShader: null,
				_emptyTexture: null,
				webglVersion,
				states: {
					textureWrapX: this.gl.CLAMP_TO_EDGE,
					textureWrapY: this.gl.CLAMP_TO_EDGE
				},
				_arraysEqual: (a, b$1) => JSON.stringify(a) === JSON.stringify(b$1),
				_getEmptyTexture: () => {
					if (!this._emptyTexture) {
						const im = new Image(1, 1);
						im.set(0, 0, 255);
						this._emptyTexture = new Texture(this._renderer, im);
					}
					return this._emptyTexture;
				}
			};
			this._baseFilterShader = void 0;
			this.filterShaderSources = {
				[BLUR]: filterBlurFrag,
				[INVERT]: filterInvertFrag,
				[THRESHOLD]: filterThresholdFrag,
				[ERODE]: filterErodeFrag,
				[GRAY]: filterGrayFrag,
				[DILATE]: filterDilateFrag,
				[POSTERIZE]: filterPosterizeFrag,
				[OPAQUE]: filterOpaqueFrag
			};
			this.filterShaders = {};
			this.operation = null;
			this.filterParameter = 1;
			this.customShader = null;
			this._shader = null;
			this.vertexBuffer = this.gl.createBuffer();
			this.texcoordBuffer = this.gl.createBuffer();
			this.vertices = new Float32Array([
				-1,
				-1,
				1,
				-1,
				-1,
				1,
				1,
				1
			]);
			this.texcoords = new Float32Array([
				0,
				1,
				1,
				1,
				0,
				0,
				1,
				0
			]);
			this._bindBufferData(this.vertexBuffer, this.gl.ARRAY_BUFFER, this.vertices);
			this._bindBufferData(this.texcoordBuffer, this.gl.ARRAY_BUFFER, this.texcoords);
		}
		_webGL2CompatibilityPrefix(shaderType, floatPrecision) {
			let code = "";
			if (this._renderer.webglVersion === WEBGL2) code += "#version 300 es\n#define WEBGL2\n";
			if (shaderType === "vert") code += "#define VERTEX_SHADER\n";
			else if (shaderType === "frag") code += "#define FRAGMENT_SHADER\n";
			if (floatPrecision) code += `precision ${floatPrecision} float;\n`;
			return code;
		}
		baseFilterShader() {
			if (!this._baseFilterShader) this._baseFilterShader = new Shader(this._renderer, this._webGL2CompatibilityPrefix("vert", "highp") + webgl2CompatibilityShader + filterBaseVert, this._webGL2CompatibilityPrefix("frag", "highp") + webgl2CompatibilityShader + filterBaseFrag, {
				vertex: {},
				fragment: { "vec4 getColor": `(FilterInputs inputs, in sampler2D canvasContent) {
                return getTexture(canvasContent, inputs.texCoord);
              }` }
			});
			return this._baseFilterShader;
		}
		setOperation(operation, filterParameter, customShader = null) {
			this.operation = operation;
			this.filterParameter = filterParameter;
			if (operation in filterParamDefaults && filterParameter === void 0) this.filterParameter = filterParamDefaults[operation];
			this.customShader = customShader;
			this._initializeShader();
		}
		_initializeShader() {
			if (this.customShader) {
				this._shader = this.customShader;
				return;
			}
			if (!this.operation) {
				console.error("No operation set for FilterRenderer2D, cannot initialize shader.");
				return;
			}
			if (this.filterShaders[this.operation]) {
				this._shader = this.filterShaders[this.operation];
				return;
			}
			const fragShaderSrc = this.filterShaderSources[this.operation];
			if (!fragShaderSrc) {
				console.error("No shader available for this operation:", this.operation);
				return;
			}
			const newShader = new Shader(this._renderer, filterShaderVert, fragShaderSrc);
			this.filterShaders[this.operation] = newShader;
			this._shader = newShader;
		}
		_bindBufferData(buffer, target, values) {
			const gl = this.gl;
			gl.bindBuffer(target, buffer);
			gl.bufferData(target, values, gl.STATIC_DRAW);
		}
		get canvasTexture() {
			if (!this._canvasTexture) this._canvasTexture = new Texture(this._renderer, this.pInst.wrappedElt);
			return this._canvasTexture;
		}
		_renderPass() {
			const gl = this.gl;
			this._shader.bindShader();
			const pixelDensity = this.pInst.pixelDensity ? this.pInst.pixelDensity() : 1;
			const texelSize = [1 / (this.pInst.width * pixelDensity), 1 / (this.pInst.height * pixelDensity)];
			const canvasTexture = this.canvasTexture;
			this._shader.setUniform("tex0", canvasTexture);
			this._shader.setUniform("texelSize", texelSize);
			this._shader.setUniform("canvasSize", [this.pInst.width, this.pInst.height]);
			this._shader.setUniform("radius", Math.max(1, this.filterParameter));
			this._shader.setUniform("filterParameter", this.filterParameter);
			this._shader.setDefaultUniforms();
			this.pInst.states.setValue("rectMode", CORNER);
			this.pInst.states.setValue("imageMode", CORNER);
			this.pInst.blendMode(BLEND);
			this.pInst.resetMatrix();
			const identityMatrix = [
				1,
				0,
				0,
				0,
				0,
				1,
				0,
				0,
				0,
				0,
				1,
				0,
				0,
				0,
				0,
				1
			];
			this._shader.setUniform("uModelViewMatrix", identityMatrix);
			this._shader.setUniform("uProjectionMatrix", identityMatrix);
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
			this._shader.enableAttrib(this._shader.attributes.aPosition, 2);
			gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
			this._shader.enableAttrib(this._shader.attributes.aTexCoord, 2);
			this._shader.bindTextures();
			this._shader.disableRemainingAttributes();
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			this._shader.unbindShader();
		}
		applyFilter() {
			if (!this._shader) {
				console.error("Cannot apply filter: shader not initialized.");
				return;
			}
			this.pInst.push();
			this.pInst.resetMatrix();
			if (this.operation === BLUR && !this.customShader) {
				this._shader.setUniform("direction", [1, 0]);
				this._renderPass();
				this.pInst.clear();
				this.pInst.drawingContext.drawImage(this.canvas, 0, 0, this.pInst.width, this.pInst.height);
				this._shader.setUniform("direction", [0, 1]);
				this._renderPass();
				this.pInst.clear();
				this.pInst.drawingContext.drawImage(this.canvas, 0, 0, this.pInst.width, this.pInst.height);
			} else {
				this._renderPass();
				this.pInst.clear();
				this.pInst.blendMode(BLEND);
				this.pInst.drawingContext.drawImage(this.canvas, 0, 0, this.pInst.width, this.pInst.height);
			}
			this.pInst.pop();
		}
	};
	const styleEmpty = "rgba(0,0,0,0)";
	var Renderer2D = class extends Renderer {
		constructor(pInst, w, h, isMainCanvas, elt, attributes$1 = {}) {
			super(pInst, w, h, isMainCanvas);
			this.canvas = this.elt = elt || document.createElement("canvas");
			if (isMainCanvas) {
				this._pInst._curElement = this;
				this._pInst.canvas = this.canvas;
			} else this.canvas.style.display = "none";
			this.elt.id = "defaultCanvas0";
			this.elt.classList.add("p5Canvas");
			for (const p$1 of Object.getOwnPropertyNames(Element.prototype)) if (p$1 !== "constructor" && p$1[0] !== "_") Object.defineProperty(this, p$1, { get() {
				return this.wrappedElt[p$1];
			} });
			this.elt.width = w * this._pixelDensity;
			this.elt.height = h * this._pixelDensity;
			this.elt.style.width = `${w}px`;
			this.elt.style.height = `${h}px`;
			if (this._pInst._userNode) this._pInst._userNode.appendChild(this.elt);
			else {
				if (document.getElementsByTagName("main").length === 0) {
					let m = document.createElement("main");
					document.body.appendChild(m);
				}
				document.getElementsByTagName("main")[0].appendChild(this.elt);
			}
			this.drawingContext = this.canvas.getContext("2d", attributes$1);
			if (attributes$1.colorSpace === "display-p3") this.states.colorMode = RGBHDR;
			this.scale(this._pixelDensity, this._pixelDensity);
			if (!this.filterRenderer) this.filterRenderer = new FilterRenderer2D(this);
			this.wrappedElt = new Element(this.elt, this._pInst);
			this.clipPath = null;
		}
		remove() {
			this.wrappedElt.remove();
			this.wrappedElt = null;
			this.canvas = null;
			this.elt = null;
		}
		getFilterGraphicsLayer() {
			if (!this.filterGraphicsLayer) {
				const pInst = this._pInst;
				this.filterGraphicsLayer = new Graphics(this.width, this.height, WEBGL, pInst);
			}
			if (this.filterGraphicsLayer.width !== this.width || this.filterGraphicsLayer.height !== this.height) this.filterGraphicsLayer.resizeCanvas(this.width, this.height);
			if (this.filterGraphicsLayer.pixelDensity() !== this._pInst.pixelDensity()) this.filterGraphicsLayer.pixelDensity(this._pInst.pixelDensity());
			return this.filterGraphicsLayer;
		}
		_applyDefaults() {
			this.states.setValue("_cachedFillStyle", void 0);
			this.states.setValue("_cachedStrokeStyle", void 0);
			this._cachedBlendMode = BLEND;
			this._setFill(_DEFAULT_FILL);
			this._setStroke(_DEFAULT_STROKE);
			this.drawingContext.lineCap = ROUND;
			this.drawingContext.font = "normal 12px sans-serif";
		}
		resize(w, h) {
			super.resize(w, h);
			const props = {};
			for (const key in this.drawingContext) {
				const val$1 = this.drawingContext[key];
				if (typeof val$1 !== "object" && typeof val$1 !== "function") props[key] = val$1;
			}
			this.canvas.width = w * this._pixelDensity;
			this.canvas.height = h * this._pixelDensity;
			this.canvas.style.width = `${w}px`;
			this.canvas.style.height = `${h}px`;
			this.drawingContext.scale(this._pixelDensity, this._pixelDensity);
			for (const savedKey in props) try {
				this.drawingContext[savedKey] = props[savedKey];
			} catch (err$1) {}
		}
		background(...args) {
			this.push();
			this.resetMatrix();
			if (args[0] instanceof Image) if (args[1] >= 0) {
				const img = args[0];
				this.drawingContext.globalAlpha = args[1] / 255;
				this._pInst.image(img, 0, 0, this.width, this.height);
			} else this._pInst.image(args[0], 0, 0, this.width, this.height);
			else {
				const color$2 = this._pInst.color(...args);
				if (this._pInst._addAccsOutput?.()) this._pInst._accsBackground?.(color$2._getRGBA([
					255,
					255,
					255,
					255
				]));
				const newFill = color$2.toString();
				this._setFill(newFill);
				if (this._isErasing) this.blendMode(this._cachedBlendMode);
				this.drawingContext.fillRect(0, 0, this.width, this.height);
				if (this._isErasing) this._pInst.erase();
			}
			this.pop();
		}
		clear() {
			this.drawingContext.save();
			this.resetMatrix();
			this.drawingContext.clearRect(0, 0, this.width, this.height);
			this.drawingContext.restore();
		}
		fill(...args) {
			super.fill(...args);
			const color$2 = this.states.fillColor;
			this._setFill(color$2.toString());
			if (this._pInst._addAccsOutput?.()) this._pInst._accsCanvasColors?.("fill", color$2._getRGBA([
				255,
				255,
				255,
				255
			]));
		}
		stroke(...args) {
			super.stroke(...args);
			const color$2 = this.states.strokeColor;
			this._setStroke(color$2.toString());
			if (this._pInst._addAccsOutput?.()) this._pInst._accsCanvasColors?.("stroke", color$2._getRGBA([
				255,
				255,
				255,
				255
			]));
		}
		erase(opacityFill, opacityStroke) {
			if (!this._isErasing) {
				this.states.setValue("_cachedFillStyle", this.drawingContext.fillStyle);
				const newFill = this._pInst.color(255, opacityFill).toString();
				this.drawingContext.fillStyle = newFill;
				this.states.setValue("_cachedStrokeStyle", this.drawingContext.strokeStyle);
				const newStroke = this._pInst.color(255, opacityStroke).toString();
				this.drawingContext.strokeStyle = newStroke;
				const tempBlendMode = this._cachedBlendMode;
				this.blendMode(REMOVE);
				this._cachedBlendMode = tempBlendMode;
				this._isErasing = true;
			}
		}
		noErase() {
			if (this._isErasing) {
				this.drawingContext.fillStyle = this.states._cachedFillStyle;
				this.drawingContext.strokeStyle = this.states._cachedStrokeStyle;
				this.blendMode(this._cachedBlendMode);
				this._isErasing = false;
			}
		}
		drawShape(shape$1) {
			const visitor = new PrimitiveToPath2DConverter({ strokeWeight: this.states.strokeWeight });
			shape$1.accept(visitor);
			if (this._clipping) {
				this.clipPath.addPath(visitor.path);
				this.clipPath.closePath();
			} else {
				if (this.states.fillColor) this.drawingContext.fill(visitor.path);
				if (this.states.strokeColor) this.drawingContext.stroke(visitor.path);
			}
		}
		beginClip(options$1 = {}) {
			super.beginClip(options$1);
			this.states.setValue("_cachedFillStyle", this.drawingContext.fillStyle);
			const newFill = this._pInst.color(255, 0).toString();
			this.drawingContext.fillStyle = newFill;
			this.states.setValue("_cachedStrokeStyle", this.drawingContext.strokeStyle);
			const newStroke = this._pInst.color(255, 0).toString();
			this.drawingContext.strokeStyle = newStroke;
			const tempBlendMode = this._cachedBlendMode;
			this.blendMode(BLEND);
			this._cachedBlendMode = tempBlendMode;
			this.clipPath = new Path2D();
			if (this._clipInvert) {
				this.clipPath.moveTo(-2 * this.width, -2 * this.height);
				this.clipPath.lineTo(-2 * this.width, 2 * this.height);
				this.clipPath.lineTo(2 * this.width, 2 * this.height);
				this.clipPath.lineTo(2 * this.width, -2 * this.height);
				this.clipPath.closePath();
			}
		}
		endClip() {
			this.drawingContext.clip(this.clipPath);
			this.clipPath = null;
			super.endClip();
			this.drawingContext.fillStyle = this.states._cachedFillStyle;
			this.drawingContext.strokeStyle = this.states._cachedStrokeStyle;
			this.blendMode(this._cachedBlendMode);
		}
		image(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
			let cnv;
			if (img.gifProperties) img._animateGif(this._pInst);
			try {
				if (img instanceof MediaElement) img._ensureCanvas();
				if (this.states.tint && img.canvas) cnv = this._getTintedImageCanvas(img);
				if (!cnv) cnv = img.canvas || img.elt;
				let s = 1;
				if (img.width && img.width > 0) s = cnv.width / img.width;
				if (this._isErasing) this.blendMode(this._cachedBlendMode);
				this.drawingContext.drawImage(cnv, s * sx, s * sy, s * sWidth, s * sHeight, dx, dy, dWidth, dHeight);
				if (this._isErasing) this._pInst.erase();
			} catch (e$1) {
				if (e$1.name !== "NS_ERROR_NOT_AVAILABLE") throw e$1;
			}
		}
		_getTintedImageCanvas(img) {
			if (!img.canvas) return img;
			if (!img.tintCanvas) img.tintCanvas = document.createElement("canvas");
			if (img.tintCanvas.width !== img.canvas.width) img.tintCanvas.width = img.canvas.width;
			if (img.tintCanvas.height !== img.canvas.height) img.tintCanvas.height = img.canvas.height;
			const ctx = img.tintCanvas.getContext("2d");
			ctx.save();
			ctx.clearRect(0, 0, img.canvas.width, img.canvas.height);
			if (this.states.tint[0] < 255 || this.states.tint[1] < 255 || this.states.tint[2] < 255) {
				ctx.drawImage(img.canvas, 0, 0);
				ctx.globalCompositeOperation = "luminosity";
				ctx.drawImage(img.canvas, 0, 0);
				ctx.globalCompositeOperation = "color";
				ctx.drawImage(img.canvas, 0, 0);
				ctx.globalCompositeOperation = "multiply";
				ctx.fillStyle = `rgb(${this.states.tint.slice(0, 3).join(", ")})`;
				ctx.fillRect(0, 0, img.canvas.width, img.canvas.height);
				ctx.globalCompositeOperation = "destination-in";
				ctx.globalAlpha = this.states.tint[3] / 255;
				ctx.drawImage(img.canvas, 0, 0);
			} else {
				ctx.globalAlpha = this.states.tint[3] / 255;
				ctx.drawImage(img.canvas, 0, 0);
			}
			ctx.restore();
			return img.tintCanvas;
		}
		blendMode(mode) {
			if (mode === SUBTRACT) console.warn("blendMode(SUBTRACT) only works in WEBGL mode.");
			else if (mode === BLEND || mode === REMOVE || mode === DARKEST || mode === LIGHTEST || mode === DIFFERENCE || mode === MULTIPLY || mode === EXCLUSION || mode === SCREEN || mode === REPLACE || mode === OVERLAY || mode === HARD_LIGHT || mode === SOFT_LIGHT || mode === DODGE || mode === BURN || mode === ADD) {
				this._cachedBlendMode = mode;
				this.drawingContext.globalCompositeOperation = mode;
			} else throw new Error(`Mode ${mode} not recognized.`);
		}
		blend(...args) {
			const currBlend = this.drawingContext.globalCompositeOperation;
			const blendMode = args[args.length - 1];
			const copyArgs = Array.prototype.slice.call(args, 0, args.length - 1);
			this.drawingContext.globalCompositeOperation = blendMode;
			p5$1.prototype.copy.apply(this, copyArgs);
			this.drawingContext.globalCompositeOperation = currBlend;
		}
		_getPixel(x$1, y) {
			let imageData, index;
			imageData = this.drawingContext.getImageData(x$1, y, 1, 1).data;
			index = 0;
			return [
				imageData[index + 0],
				imageData[index + 1],
				imageData[index + 2],
				imageData[index + 3]
			];
		}
		loadPixels() {
			const pd = this._pixelDensity;
			const w = this.width * pd;
			const h = this.height * pd;
			const imageData = this.drawingContext.getImageData(0, 0, w, h);
			this.imageData = imageData;
			this.pixels = imageData.data;
		}
		set(x$1, y, imgOrCol) {
			x$1 = Math.floor(x$1);
			y = Math.floor(y);
			if (imgOrCol instanceof Image) {
				this.drawingContext.save();
				this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
				this.drawingContext.scale(this._pixelDensity, this._pixelDensity);
				this.drawingContext.clearRect(x$1, y, imgOrCol.width, imgOrCol.height);
				this.drawingContext.drawImage(imgOrCol.canvas, x$1, y);
				this.drawingContext.restore();
			} else {
				let r = 0, g$1 = 0, b$1 = 0, a = 0;
				let idx = 4 * (y * this._pixelDensity * (this.width * this._pixelDensity) + x$1 * this._pixelDensity);
				if (!this.imageData) this.loadPixels();
				if (typeof imgOrCol === "number") {
					if (idx < this.pixels.length) {
						r = imgOrCol;
						g$1 = imgOrCol;
						b$1 = imgOrCol;
						a = 255;
					}
				} else if (Array.isArray(imgOrCol)) {
					if (imgOrCol.length < 4) throw new Error("pixel array must be of the form [R, G, B, A]");
					if (idx < this.pixels.length) {
						r = imgOrCol[0];
						g$1 = imgOrCol[1];
						b$1 = imgOrCol[2];
						a = imgOrCol[3];
					}
				} else if (imgOrCol instanceof p5$1.Color) {
					if (idx < this.pixels.length) [r, g$1, b$1, a] = imgOrCol._getRGBA([
						255,
						255,
						255,
						255
					]);
				}
				for (let i$1 = 0; i$1 < this._pixelDensity; i$1++) for (let j = 0; j < this._pixelDensity; j++) {
					idx = 4 * ((y * this._pixelDensity + j) * this.width * this._pixelDensity + (x$1 * this._pixelDensity + i$1));
					this.pixels[idx] = r;
					this.pixels[idx + 1] = g$1;
					this.pixels[idx + 2] = b$1;
					this.pixels[idx + 3] = a;
				}
			}
		}
		updatePixels(x$1, y, w, h) {
			const pd = this._pixelDensity;
			if (x$1 === void 0 && y === void 0 && w === void 0 && h === void 0) {
				x$1 = 0;
				y = 0;
				w = this.width;
				h = this.height;
			}
			x$1 *= pd;
			y *= pd;
			w *= pd;
			h *= pd;
			if (this.gifProperties) this.gifProperties.frames[this.gifProperties.displayIndex].image = this.imageData;
			this.drawingContext.putImageData(this.imageData, 0, 0, x$1, y, w, h);
		}
		arc(x$1, y, w, h, start, stop, mode) {
			const ctx = this.clipPa || this.drawingContext;
			const centerX = x$1 + w / 2, centerY = y + h / 2, radiusX = w / 2, radiusY = h / 2;
			const createPieSlice = !(mode === CHORD || mode === OPEN || (stop - start) % TWO_PI === 0);
			if (this.states.fillColor) {
				if (!this._clipping) ctx.beginPath();
				ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, start, stop);
				if (createPieSlice) ctx.lineTo(centerX, centerY);
				ctx.closePath();
				if (!this._clipping) ctx.fill();
			}
			if (this.states.strokeColor) {
				if (!this._clipping) ctx.beginPath();
				ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, start, stop);
				if (mode === PIE && createPieSlice) ctx.lineTo(centerX, centerY);
				if (mode === PIE || mode === CHORD) ctx.closePath();
				if (!this._clipping) ctx.stroke();
			}
			return this;
		}
		ellipse(args) {
			const ctx = this.clipPath || this.drawingContext;
			const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
			const x$1 = parseFloat(args[0]), y = parseFloat(args[1]), w = parseFloat(args[2]), h = parseFloat(args[3]);
			if (doFill && !doStroke) {
				if (this._getFill() === styleEmpty) return this;
			} else if (!doFill && doStroke) {
				if (this._getStroke() === styleEmpty) return this;
			}
			const centerX = x$1 + w / 2, centerY = y + h / 2, radiusX = w / 2, radiusY = h / 2;
			if (!this._clipping) ctx.beginPath();
			ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
			ctx.closePath();
			if (!this._clipping && doFill) ctx.fill();
			if (!this._clipping && doStroke) ctx.stroke();
		}
		line(x1, y1, x2, y2) {
			const ctx = this.clipPath || this.drawingContext;
			if (!this.states.strokeColor) return this;
			else if (this._getStroke() === styleEmpty) return this;
			if (!this._clipping) ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.lineTo(x2, y2);
			ctx.stroke();
			return this;
		}
		point(x$1, y) {
			const ctx = this.clipPath || this.drawingContext;
			if (!this.states.strokeColor) return this;
			else if (this._getStroke() === styleEmpty) return this;
			const s = this._getStroke();
			const f = this._getFill();
			if (!this._clipping) this._setFill(s);
			if (!this._clipping) ctx.beginPath();
			ctx.arc(x$1, y, ctx.lineWidth / 2, 0, TWO_PI, false);
			if (!this._clipping) {
				ctx.fill();
				this._setFill(f);
			}
		}
		quad(x1, y1, x2, y2, x3, y3, x4, y4) {
			const ctx = this.clipPath || this.drawingContext;
			const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
			if (doFill && !doStroke) {
				if (this._getFill() === styleEmpty) return this;
			} else if (!doFill && doStroke) {
				if (this._getStroke() === styleEmpty) return this;
			}
			if (!this._clipping) ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.lineTo(x2, y2);
			ctx.lineTo(x3, y3);
			ctx.lineTo(x4, y4);
			ctx.closePath();
			if (!this._clipping && doFill) ctx.fill();
			if (!this._clipping && doStroke) ctx.stroke();
			return this;
		}
		rect(args) {
			const x$1 = args[0];
			const y = args[1];
			const w = args[2];
			const h = args[3];
			let tl = args[4];
			let tr = args[5];
			let br = args[6];
			let bl = args[7];
			const ctx = this.clipPath || this.drawingContext;
			const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
			if (doFill && !doStroke) {
				if (this._getFill() === styleEmpty) return this;
			} else if (!doFill && doStroke) {
				if (this._getStroke() === styleEmpty) return this;
			}
			if (!this._clipping) ctx.beginPath();
			if (typeof tl === "undefined") ctx.rect(x$1, y, w, h);
			else {
				if (typeof tr === "undefined") tr = tl;
				if (typeof br === "undefined") br = tr;
				if (typeof bl === "undefined") bl = br;
				const absW = Math.abs(w);
				const absH = Math.abs(h);
				const hw = absW / 2;
				const hh = absH / 2;
				if (absW < 2 * tl) tl = hw;
				if (absH < 2 * tl) tl = hh;
				if (absW < 2 * tr) tr = hw;
				if (absH < 2 * tr) tr = hh;
				if (absW < 2 * br) br = hw;
				if (absH < 2 * br) br = hh;
				if (absW < 2 * bl) bl = hw;
				if (absH < 2 * bl) bl = hh;
				ctx.roundRect(x$1, y, w, h, [
					tl,
					tr,
					br,
					bl
				]);
			}
			if (!this._clipping && this.states.fillColor) ctx.fill();
			if (!this._clipping && this.states.strokeColor) ctx.stroke();
			return this;
		}
		triangle(args) {
			const ctx = this.clipPath || this.drawingContext;
			const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
			const x1 = args[0], y1 = args[1];
			const x2 = args[2], y2 = args[3];
			const x3 = args[4], y3 = args[5];
			if (doFill && !doStroke) {
				if (this._getFill() === styleEmpty) return this;
			} else if (!doFill && doStroke) {
				if (this._getStroke() === styleEmpty) return this;
			}
			if (!this._clipping) ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.lineTo(x2, y2);
			ctx.lineTo(x3, y3);
			ctx.closePath();
			if (!this._clipping && doFill) ctx.fill();
			if (!this._clipping && doStroke) ctx.stroke();
		}
		strokeCap(cap) {
			if (cap === ROUND || cap === SQUARE || cap === PROJECT) this.drawingContext.lineCap = cap;
			return this;
		}
		strokeJoin(join$1) {
			if (join$1 === ROUND || join$1 === BEVEL || join$1 === MITER) this.drawingContext.lineJoin = join$1;
			return this;
		}
		strokeWeight(w) {
			super.strokeWeight(w);
			if (typeof w === "undefined" || w === 0) this.drawingContext.lineWidth = 1e-4;
			else this.drawingContext.lineWidth = w;
			return this;
		}
		_getFill() {
			if (!this.states._cachedFillStyle) this.states.setValue("_cachedFillStyle", this.drawingContext.fillStyle);
			return this.states._cachedFillStyle;
		}
		_setFill(fillStyle) {
			if (fillStyle !== this.states._cachedFillStyle) {
				this.drawingContext.fillStyle = fillStyle;
				this.states.setValue("_cachedFillStyle", fillStyle);
			}
		}
		_getStroke() {
			if (!this.states._cachedStrokeStyle) this.states.setValue("_cachedStrokeStyle", this.drawingContext.strokeStyle);
			return this.states._cachedStrokeStyle;
		}
		_setStroke(strokeStyle) {
			if (strokeStyle !== this.states._cachedStrokeStyle) {
				this.drawingContext.strokeStyle = strokeStyle;
				this.states.setValue("_cachedStrokeStyle", strokeStyle);
			}
		}
		applyMatrix(a, b$1, c, d$1, e$1, f) {
			this.drawingContext.transform(a, b$1, c, d$1, e$1, f);
		}
		getWorldToScreenMatrix() {
			return new Matrix(new DOMMatrix().scale(1 / this._pixelDensity).multiply(this.drawingContext.getTransform()).toFloat32Array());
		}
		resetMatrix() {
			this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
			this.drawingContext.scale(this._pixelDensity, this._pixelDensity);
			return this;
		}
		rotate(rad) {
			this.drawingContext.rotate(rad);
		}
		scale(x$1, y) {
			this.drawingContext.scale(x$1, y);
			return this;
		}
		translate(x$1, y) {
			if (x$1 instanceof p5$1.Vector) {
				y = x$1.y;
				x$1 = x$1.x;
			}
			this.drawingContext.translate(x$1, y);
			return this;
		}
		push() {
			this.drawingContext.save();
			return super.push();
		}
		pop(style) {
			this.drawingContext.restore();
			super.pop(style);
		}
	};
	function renderer2D(p5$2, fn$1) {
		p5$2.Renderer2D = Renderer2D;
		p5$2.renderers[P2D] = Renderer2D;
		p5$2.renderers["p2d-hdr"] = new Proxy(Renderer2D, { construct(target, [pInst, w, h, isMainCanvas, elt]) {
			return new target(pInst, w, h, isMainCanvas, elt, { colorSpace: "display-p3" });
		} });
	}
	var p5$1 = class p5$1 {
		static VERSION = VERSION;
		static instance = null;
		static lifecycleHooks = {
			presetup: [],
			postsetup: [],
			predraw: [],
			postdraw: [],
			remove: []
		};
		static _checkForUserDefinedFunctions = () => {};
		static _friendlyFileLoadError = () => {};
		constructor(sketch, node) {
			this.hitCriticalError = false;
			this._setupDone = false;
			this._userNode = node;
			this._curElement = null;
			this._elements = [];
			this._glAttributes = null;
			this._requestAnimId = 0;
			this._isGlobal = false;
			this._loop = true;
			this._startListener = null;
			this._initializeInstanceVariables();
			this._events = {
				pointerdown: null,
				pointerup: null,
				pointermove: null,
				dragend: null,
				dragover: null,
				click: null,
				dblclick: null,
				mouseover: null,
				mouseout: null,
				keydown: null,
				keyup: null,
				keypress: null,
				wheel: null,
				resize: null,
				blur: null
			};
			this._millisStart = -1;
			this._recording = false;
			this._lcg_random_state = null;
			this._gaussian_previous = false;
			if (window.DeviceOrientationEvent) this._events.deviceorientation = null;
			if (window.DeviceMotionEvent && !window._isNodeWebkit) this._events.devicemotion = null;
			this._updateWindowSize();
			const bindGlobal = (property) => {
				Object.defineProperty(window, property, {
					configurable: true,
					enumerable: true,
					get: () => {
						if (typeof this[property] === "function") return this[property].bind(this);
						else return this[property];
					},
					set: (newValue) => {
						Object.defineProperty(window, property, {
							configurable: true,
							enumerable: true,
							value: newValue,
							writable: true
						});
						if (!p5$1.disableFriendlyErrors) console.log(`You just changed the value of "${property}", which was a p5 global value. This could cause problems later if you're not careful.`);
					}
				});
			};
			if (!sketch) {
				this._isGlobal = true;
				if (window.hitCriticalError) return;
				p5$1.instance = this;
				for (const p$1 of Object.getOwnPropertyNames(p5$1.prototype)) {
					if (p$1[0] === "_") continue;
					bindGlobal(p$1);
				}
				const protectedProperties = ["constructor", "length"];
				for (const p$1 in this) if (this.hasOwnProperty(p$1)) {
					if (p$1[0] === "_" || protectedProperties.includes(p$1)) continue;
					bindGlobal(p$1);
				}
			} else {
				sketch(this);
				p5$1._checkForUserDefinedFunctions(this);
			}
			for (const e$1 in this._events) {
				const f = this[`_on${e$1}`];
				if (f) {
					const m = f.bind(this);
					window.addEventListener(e$1, m, { passive: false });
					this._events[e$1] = m;
				}
			}
			const focusHandler = () => {
				this.focused = true;
			};
			const blurHandler = () => {
				this.focused = false;
			};
			window.addEventListener("focus", focusHandler);
			window.addEventListener("blur", blurHandler);
			p5$1.lifecycleHooks.remove.push(function() {
				window.removeEventListener("focus", focusHandler);
				window.removeEventListener("blur", blurHandler);
			});
			if (document.readyState === "complete") this.#_start();
			else {
				this._startListener = this.#_start.bind(this);
				window.addEventListener("load", this._startListener, false);
			}
		}
		get pixels() {
			return this._renderer.pixels;
		}
		get drawingContext() {
			return this._renderer.drawingContext;
		}
		static registerAddon(addon) {
			const lifecycles = {};
			addon(p5$1, p5$1.prototype, lifecycles);
			const validLifecycles = Object.keys(p5$1.lifecycleHooks);
			for (const name of validLifecycles) if (typeof lifecycles[name] === "function") p5$1.lifecycleHooks[name].push(lifecycles[name]);
		}
		async #_start() {
			if (this.hitCriticalError) return;
			if (this._userNode) {
				if (typeof this._userNode === "string") this._userNode = document.getElementById(this._userNode);
			}
			await this.#_setup();
			if (this.hitCriticalError) return;
			if (!this._recording) this._draw();
		}
		async #_setup() {
			await this._runLifecycleHook("presetup");
			if (this.hitCriticalError) return;
			this.createCanvas(100, 100, P2D);
			this._millisStart = window.performance.now();
			const context = this._isGlobal ? window : this;
			if (typeof context.setup === "function") await context.setup();
			if (this.hitCriticalError) return;
			const canvases = document.getElementsByTagName("canvas");
			if (Object.keys(this._events).some((event) => event.startsWith("pointer"))) for (const k of canvases) k.style.touchAction = "none";
			for (const k of canvases) if (k.dataset.hidden === "true") {
				k.style.visibility = "";
				delete k.dataset.hidden;
			}
			this._lastTargetFrameTime = window.performance.now();
			this._lastRealFrameTime = window.performance.now();
			this._setupDone = true;
			if (this._accessibleOutputs.grid || this._accessibleOutputs.text) this._updateAccsOutput();
			await this._runLifecycleHook("postsetup");
			this._millisStart = window.performance.now();
		}
		async _draw(requestAnimationFrameTimestamp) {
			if (this.hitCriticalError) return;
			const now = requestAnimationFrameTimestamp || window.performance.now();
			const timeSinceLastFrame = now - this._lastTargetFrameTime;
			const targetTimeBetweenFrames = 1e3 / this._targetFrameRate;
			if (!this._loop || timeSinceLastFrame >= targetTimeBetweenFrames - 5) {
				this.deltaTime = now - this._lastRealFrameTime;
				this._frameRate = 1e3 / this.deltaTime;
				await this.redraw();
				this._lastTargetFrameTime = Math.max(this._lastTargetFrameTime + targetTimeBetweenFrames, now);
				this._lastRealFrameTime = now;
				if (typeof this._updateMouseCoords !== "undefined") {
					this._updateMouseCoords();
					this.movedX = 0;
					this.movedY = 0;
				}
			}
			if (this._loop) this._requestAnimId = window.requestAnimationFrame(this._draw.bind(this));
		}
		async remove() {
			if (this._startListener) window.removeEventListener("load", this._startListener, false);
			if (this._curElement) {
				this._loop = false;
				if (this._requestAnimId) window.cancelAnimationFrame(this._requestAnimId);
				for (const ev in this._events) window.removeEventListener(ev, this._events[ev]);
				for (const e$1 of this._elements) {
					if (e$1.elt && e$1.elt.parentNode) e$1.elt.parentNode.removeChild(e$1.elt);
					for (const elt_ev in e$1._events) e$1.elt.removeEventListener(elt_ev, e$1._events[elt_ev]);
				}
				await this._runLifecycleHook("remove");
			}
			if (this._isGlobal) {
				for (const p$1 in p5$1.prototype) try {
					delete window[p$1];
				} catch (x$1) {
					window[p$1] = void 0;
				}
				for (const p2 in this) if (this.hasOwnProperty(p2)) try {
					delete window[p2];
				} catch (x$1) {
					window[p2] = void 0;
				}
				p5$1.instance = null;
			}
		}
		async _runLifecycleHook(hookName) {
			for (const hook of p5$1.lifecycleHooks[hookName]) await hook.call(this);
		}
		_initializeInstanceVariables() {
			this._accessibleOutputs = {
				text: false,
				grid: false,
				textLabel: false,
				gridLabel: false
			};
			this._styles = [];
			this._downKeys = {};
			this._downKeyCodes = {};
		}
	};
	for (const k in constants) p5$1.prototype[k] = constants[k];
	p5$1.disableFriendlyErrors = false;
	p5$1.registerAddon(transform$1);
	p5$1.registerAddon(structure);
	p5$1.registerAddon(environment);
	p5$1.registerAddon(rendering);
	p5$1.registerAddon(renderer);
	p5$1.registerAddon(renderer2D);
	p5$1.registerAddon(graphics);
	function shape(p5$2) {
		p5$2.registerAddon(primitives);
		p5$2.registerAddon(attributes);
		p5$2.registerAddon(curves);
		p5$2.registerAddon(vertex);
		p5$2.registerAddon(customShapes);
	}
	function describe(p5$2, fn$1) {
		const descContainer = "_Description";
		const fallbackDescId = "_fallbackDesc";
		const fallbackTableId = "_fallbackTable";
		const fallbackTableElId = "_fte_";
		const labelContainer = "_Label";
		const labelDescId = "_labelDesc";
		const labelTableId = "_labelTable";
		const labelTableElId = "_lte_";
		fn$1.describe = function(text$1, display) {
			if (typeof text$1 !== "string") return;
			const cnvId = this.canvas.id;
			text$1 = _descriptionText(text$1);
			if (!this.dummyDOM) this.dummyDOM = document.getElementById(cnvId).parentNode;
			if (!this.descriptions) this.descriptions = {};
			if (this.descriptions.fallback) {
				if (this.descriptions.fallback.innerHTML !== text$1) this.descriptions.fallback.innerHTML = text$1;
			} else this._describeHTML("fallback", text$1);
			if (display === this.LABEL) if (this.descriptions.label) {
				if (this.descriptions.label.innerHTML !== text$1) this.descriptions.label.innerHTML = text$1;
			} else this._describeHTML("label", text$1);
		};
		fn$1.describeElement = function(name, text$1, display) {
			if (typeof text$1 !== "string" || typeof name !== "string") return;
			const cnvId = this.canvas.id;
			text$1 = _descriptionText(text$1);
			let elementName = _elementName(name);
			name = name.replace(/[^a-zA-Z0-9]/g, "");
			let inner = `<th scope="row">${elementName}</th><td>${text$1}</td>`;
			if (!this.dummyDOM) this.dummyDOM = document.getElementById(cnvId).parentNode;
			if (!this.descriptions) this.descriptions = { fallbackElements: {} };
			else if (!this.descriptions.fallbackElements) this.descriptions.fallbackElements = {};
			if (this.descriptions.fallbackElements[name]) {
				if (this.descriptions.fallbackElements[name].innerHTML !== inner) this.descriptions.fallbackElements[name].innerHTML = inner;
			} else this._describeElementHTML("fallback", name, inner);
			if (display === this.LABEL) {
				if (!this.descriptions.labelElements) this.descriptions.labelElements = {};
				if (this.descriptions.labelElements[name]) {
					if (this.descriptions.labelElements[name].innerHTML !== inner) this.descriptions.labelElements[name].innerHTML = inner;
				} else this._describeElementHTML("label", name, inner);
			}
		};
		function _descriptionText(text$1) {
			if (text$1 === "label" || text$1 === "fallback") throw new Error("description should not be LABEL or FALLBACK");
			if (!text$1.endsWith(".") && !text$1.endsWith(";") && !text$1.endsWith(",") && !text$1.endsWith("?") && !text$1.endsWith("!")) text$1 = text$1 + ".";
			return text$1;
		}
		fn$1._describeHTML = function(type$2, text$1) {
			const cnvId = this.canvas.id;
			if (type$2 === "fallback") {
				if (!this.dummyDOM.querySelector(`#${cnvId + descContainer}`)) {
					let html = `<div id="${cnvId}${descContainer}" role="region" aria-label="Canvas Description"><p id="${cnvId}${fallbackDescId}"></p></div>`;
					if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`)) this.dummyDOM.querySelector(`#${cnvId}`).innerHTML = html;
					else this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`).insertAdjacentHTML("beforebegin", html);
				} else this.dummyDOM.querySelector("#" + cnvId + fallbackTableId).insertAdjacentHTML("beforebegin", `<p id="${cnvId + fallbackDescId}"></p>`);
				this.descriptions.fallback = this.dummyDOM.querySelector(`#${cnvId}${fallbackDescId}`);
				this.descriptions.fallback.innerHTML = text$1;
				return;
			} else if (type$2 === "label") {
				if (!this.dummyDOM.querySelector(`#${cnvId + labelContainer}`)) {
					let html = `<div id="${cnvId}${labelContainer}" class="p5Label"><p id="${cnvId}${labelDescId}"></p></div>`;
					if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`)) this.dummyDOM.querySelector("#" + cnvId).insertAdjacentHTML("afterend", html);
					else this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`).insertAdjacentHTML("beforebegin", html);
				} else if (this.dummyDOM.querySelector(`#${cnvId + labelTableId}`)) this.dummyDOM.querySelector(`#${cnvId + labelTableId}`).insertAdjacentHTML("beforebegin", `<p id="${cnvId}${labelDescId}"></p>`);
				this.descriptions.label = this.dummyDOM.querySelector("#" + cnvId + labelDescId);
				this.descriptions.label.innerHTML = text$1;
				return;
			}
		};
		function _elementName(name) {
			if (name === "label" || name === "fallback") throw new Error("element name should not be LABEL or FALLBACK");
			if (name.endsWith(".") || name.endsWith(";") || name.endsWith(",")) name = name.replace(/.$/, ":");
			else if (!name.endsWith(":")) name = name + ":";
			return name;
		}
		fn$1._describeElementHTML = function(type$2, name, text$1) {
			const cnvId = this.canvas.id;
			if (type$2 === "fallback") {
				if (!this.dummyDOM.querySelector(`#${cnvId + descContainer}`)) {
					let html = `<div id="${cnvId}${descContainer}" role="region" aria-label="Canvas Description"><table id="${cnvId}${fallbackTableId}"><caption>Canvas elements and their descriptions</caption></table></div>`;
					if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`)) this.dummyDOM.querySelector("#" + cnvId).innerHTML = html;
					else this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`).insertAdjacentHTML("beforebegin", html);
				} else if (!this.dummyDOM.querySelector("#" + cnvId + fallbackTableId)) this.dummyDOM.querySelector("#" + cnvId + fallbackDescId).insertAdjacentHTML("afterend", `<table id="${cnvId}${fallbackTableId}"><caption>Canvas elements and their descriptions</caption></table>`);
				let tableRow$1 = document.createElement("tr");
				tableRow$1.id = cnvId + fallbackTableElId + name;
				this.dummyDOM.querySelector("#" + cnvId + fallbackTableId).appendChild(tableRow$1);
				this.descriptions.fallbackElements[name] = this.dummyDOM.querySelector(`#${cnvId}${fallbackTableElId}${name}`);
				this.descriptions.fallbackElements[name].innerHTML = text$1;
				return;
			} else if (type$2 === "label") {
				if (!this.dummyDOM.querySelector(`#${cnvId + labelContainer}`)) {
					let html = `<div id="${cnvId}${labelContainer}" class="p5Label"><table id="${cnvId}${labelTableId}"></table></div>`;
					if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`)) this.dummyDOM.querySelector("#" + cnvId).insertAdjacentHTML("afterend", html);
					else this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`).insertAdjacentHTML("beforebegin", html);
				} else if (!this.dummyDOM.querySelector(`#${cnvId + labelTableId}`)) this.dummyDOM.querySelector("#" + cnvId + labelDescId).insertAdjacentHTML("afterend", `<table id="${cnvId + labelTableId}"></table>`);
				let tableRow$1 = document.createElement("tr");
				tableRow$1.id = cnvId + labelTableElId + name;
				this.dummyDOM.querySelector("#" + cnvId + labelTableId).appendChild(tableRow$1);
				this.descriptions.labelElements[name] = this.dummyDOM.querySelector(`#${cnvId}${labelTableElId}${name}`);
				this.descriptions.labelElements[name].innerHTML = text$1;
			}
		};
	}
	if (typeof p5 !== "undefined") describe(p5, p5.prototype);
	function gridOutput(p5$2, fn$1) {
		fn$1._updateGridOutput = function(idT) {
			if (!this.dummyDOM.querySelector(`#${idT}_summary`)) return;
			let current = this._accessibleOutputs[idT];
			let innerShapeDetails = _gridShapeDetails(idT, this.ingredients.shapes);
			let innerSummary = _gridSummary(innerShapeDetails.numShapes, this.ingredients.colors.background, this.width, this.height);
			let innerMap = _gridMap(idT, this.ingredients.shapes);
			if (innerSummary !== current.summary.innerHTML) current.summary.innerHTML = innerSummary;
			if (innerMap !== current.map.innerHTML) current.map.innerHTML = innerMap;
			if (innerShapeDetails.details !== current.shapeDetails.innerHTML) current.shapeDetails.innerHTML = innerShapeDetails.details;
			this._accessibleOutputs[idT] = current;
		};
		function _gridMap(idT, ingredients) {
			let shapeNumber = 0;
			let table$1 = "";
			let cells = Array.from(Array(10), () => Array(10));
			for (let x$1 in ingredients) for (let y in ingredients[x$1]) {
				let fill;
				if (x$1 !== "line") fill = `<a href="#${idT}shape${shapeNumber}">${ingredients[x$1][y].color} ${x$1}</a>`;
				else fill = `<a href="#${idT}shape${shapeNumber}">${ingredients[x$1][y].color} ${x$1} midpoint</a>`;
				if (ingredients[x$1][y].loc.locY < cells.length && ingredients[x$1][y].loc.locX < cells[ingredients[x$1][y].loc.locY].length) {
					if (!cells[ingredients[x$1][y].loc.locY][ingredients[x$1][y].loc.locX]) cells[ingredients[x$1][y].loc.locY][ingredients[x$1][y].loc.locX] = fill;
					else cells[ingredients[x$1][y].loc.locY][ingredients[x$1][y].loc.locX] = cells[ingredients[x$1][y].loc.locY][ingredients[x$1][y].loc.locX] + "  " + fill;
					shapeNumber++;
				}
			}
			for (let _r in cells) {
				let row = "<tr>";
				for (let c in cells[_r]) {
					row = row + "<td>";
					if (cells[_r][c] !== void 0) row = row + cells[_r][c];
					row = row + "</td>";
				}
				table$1 = table$1 + row + "</tr>";
			}
			return table$1;
		}
		function _gridSummary(numShapes, background, width, height) {
			let text$1 = `${background} canvas, ${width} by ${height} pixels, contains ${numShapes[0]}`;
			if (numShapes[0] === 1) text$1 = `${text$1} shape: ${numShapes[1]}`;
			else text$1 = `${text$1} shapes: ${numShapes[1]}`;
			return text$1;
		}
		function _gridShapeDetails(idT, ingredients) {
			let shapeDetails = "";
			let shapes = "";
			let totalShapes = 0;
			for (let x$1 in ingredients) {
				let shapeNum = 0;
				for (let y in ingredients[x$1]) {
					let line = `<li id="${idT}shape${totalShapes}">${ingredients[x$1][y].color} ${x$1},`;
					if (x$1 === "line") line = line + ` location = ${ingredients[x$1][y].pos}, length = ${ingredients[x$1][y].length} pixels`;
					else {
						line = line + ` location = ${ingredients[x$1][y].pos}`;
						if (x$1 !== "point") line = line + `, area = ${ingredients[x$1][y].area} %`;
						line = line + "</li>";
					}
					shapeDetails = shapeDetails + line;
					shapeNum++;
					totalShapes++;
				}
				if (shapeNum > 1) shapes = `${shapes} ${shapeNum} ${x$1}s`;
				else shapes = `${shapes} ${shapeNum} ${x$1}`;
			}
			return {
				numShapes: [totalShapes, shapes],
				details: shapeDetails
			};
		}
	}
	if (typeof p5 !== "undefined") gridOutput(p5, p5.prototype);
	function textOutput(p5$2, fn$1) {
		fn$1._updateTextOutput = function(idT) {
			if (!this.dummyDOM.querySelector(`#${idT}_summary`)) return;
			let current = this._accessibleOutputs[idT];
			let innerList = _shapeList(idT, this.ingredients.shapes);
			let innerSummary = _textSummary(innerList.numShapes, this.ingredients.colors.background, this.width, this.height);
			let innerShapeDetails = _shapeDetails(idT, this.ingredients.shapes);
			if (innerSummary !== current.summary.innerHTML) current.summary.innerHTML = innerSummary;
			if (innerList.listShapes !== current.list.innerHTML) current.list.innerHTML = innerList.listShapes;
			if (innerShapeDetails !== current.shapeDetails.innerHTML) current.shapeDetails.innerHTML = innerShapeDetails;
			this._accessibleOutputs[idT] = current;
		};
		function _textSummary(numShapes, background, width, height) {
			let text$1 = `Your output is a, ${width} by ${height} pixels, ${background} canvas containing the following`;
			if (numShapes === 1) text$1 = `${text$1} shape:`;
			else text$1 = `${text$1} ${numShapes} shapes:`;
			return text$1;
		}
		function _shapeDetails(idT, ingredients) {
			let shapeDetails = "";
			let shapeNumber = 0;
			for (let x$1 in ingredients) for (let y in ingredients[x$1]) {
				let row = `<tr id="${idT}shape${shapeNumber}"><th>${ingredients[x$1][y].color} ${x$1}</th>`;
				if (x$1 === "line") row = row + `<td>location = ${ingredients[x$1][y].pos}</td><td>length = ${ingredients[x$1][y].length} pixels</td></tr>`;
				else {
					row = row + `<td>location = ${ingredients[x$1][y].pos}</td>`;
					if (x$1 !== "point") row = row + `<td> area = ${ingredients[x$1][y].area}%</td>`;
					row = row + "</tr>";
				}
				shapeDetails = shapeDetails + row;
				shapeNumber++;
			}
			return shapeDetails;
		}
		function _shapeList(idT, ingredients) {
			let shapeList = "";
			let shapeNumber = 0;
			for (let x$1 in ingredients) for (let y in ingredients[x$1]) {
				let _line = `<li><a href="#${idT}shape${shapeNumber}">${ingredients[x$1][y].color} ${x$1}</a>`;
				if (x$1 === "line") _line = _line + `, ${ingredients[x$1][y].pos}, ${ingredients[x$1][y].length} pixels long.</li>`;
				else {
					_line = _line + `, at ${ingredients[x$1][y].pos}`;
					if (x$1 !== "point") _line = _line + `, covering ${ingredients[x$1][y].area}% of the canvas`;
					_line = _line + ".</li>";
				}
				shapeList = shapeList + _line;
				shapeNumber++;
			}
			return {
				numShapes: shapeNumber,
				listShapes: shapeList
			};
		}
	}
	if (typeof p5 !== "undefined") textOutput(p5, p5.prototype);
	function outputs(p5$2, fn$1) {
		fn$1.textOutput = function(display) {
			if (this._accessibleOutputs.text) return;
			else {
				this._accessibleOutputs.text = true;
				this._createOutput("textOutput", "Fallback");
				if (display === this.LABEL) {
					this._accessibleOutputs.textLabel = true;
					this._createOutput("textOutput", "Label");
				}
			}
		};
		fn$1.gridOutput = function(display) {
			if (this._accessibleOutputs.grid) return;
			else {
				this._accessibleOutputs.grid = true;
				this._createOutput("gridOutput", "Fallback");
				if (display === this.LABEL) {
					this._accessibleOutputs.gridLabel = true;
					this._createOutput("gridOutput", "Label");
				}
			}
		};
		fn$1._addAccsOutput = function() {
			if (!this._accessibleOutputs) this._accessibleOutputs = {
				text: false,
				grid: false,
				textLabel: false,
				gridLabel: false
			};
			return this._accessibleOutputs.grid || this._accessibleOutputs.text;
		};
		fn$1._createOutput = function(type$2, display) {
			let cnvId = this.canvas.id;
			if (!this.ingredients) this.ingredients = {
				shapes: {},
				colors: {
					background: "white",
					fill: "white",
					stroke: "black"
				},
				pShapes: "",
				pBackground: ""
			};
			if (!this.dummyDOM) this.dummyDOM = document.getElementById(cnvId).parentNode;
			let cIdT, container, inner;
			let query = "";
			if (display === "Fallback") {
				cIdT = cnvId + type$2;
				container = cnvId + "accessibleOutput";
				if (!this.dummyDOM.querySelector(`#${container}`)) if (!this.dummyDOM.querySelector(`#${cnvId}_Description`)) this.dummyDOM.querySelector(`#${cnvId}`).innerHTML = `<div id="${container}" role="region" aria-label="Canvas Outputs"></div>`;
				else this.dummyDOM.querySelector(`#${cnvId}_Description`).insertAdjacentHTML("afterend", `<div id="${container}" role="region" aria-label="Canvas Outputs"></div>`);
			} else if (display === "Label") {
				query = display;
				cIdT = cnvId + type$2 + display;
				container = cnvId + "accessibleOutput" + display;
				if (!this.dummyDOM.querySelector(`#${container}`)) if (!this.dummyDOM.querySelector(`#${cnvId}_Label`)) this.dummyDOM.querySelector(`#${cnvId}`).insertAdjacentHTML("afterend", `<div id="${container}"></div>`);
				else this.dummyDOM.querySelector(`#${cnvId}_Label`).insertAdjacentHTML("afterend", `<div id="${container}"></div>`);
			}
			this._accessibleOutputs[cIdT] = {};
			if (type$2 === "textOutput") {
				query = `#${cnvId}gridOutput${query}`;
				inner = `<div id="${cIdT}">Text Output<div id="${cIdT}Summary" aria-label="text output summary"><p id="${cIdT}_summary"></p><ul id="${cIdT}_list"></ul></div><table id="${cIdT}_shapeDetails" summary="text output shape details"></table></div>`;
				if (this.dummyDOM.querySelector(query)) this.dummyDOM.querySelector(query).insertAdjacentHTML("beforebegin", inner);
				else this.dummyDOM.querySelector(`#${container}`).innerHTML = inner;
				this._accessibleOutputs[cIdT].list = this.dummyDOM.querySelector(`#${cIdT}_list`);
			} else if (type$2 === "gridOutput") {
				query = `#${cnvId}textOutput${query}`;
				inner = `<div id="${cIdT}">Grid Output<p id="${cIdT}_summary" aria-label="grid output summary"><table id="${cIdT}_map" summary="grid output content"></table><ul id="${cIdT}_shapeDetails" aria-label="grid output shape details"></ul></div>`;
				if (this.dummyDOM.querySelector(query)) this.dummyDOM.querySelector(query).insertAdjacentHTML("afterend", inner);
				else this.dummyDOM.querySelector(`#${container}`).innerHTML = inner;
				this._accessibleOutputs[cIdT].map = this.dummyDOM.querySelector(`#${cIdT}_map`);
			}
			this._accessibleOutputs[cIdT].shapeDetails = this.dummyDOM.querySelector(`#${cIdT}_shapeDetails`);
			this._accessibleOutputs[cIdT].summary = this.dummyDOM.querySelector(`#${cIdT}_summary`);
		};
		fn$1._updateAccsOutput = function() {
			let cnvId = this.canvas.id;
			if (JSON.stringify(this.ingredients.shapes) !== this.ingredients.pShapes || this.ingredients.colors.background !== this.ingredients.pBackground) {
				this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes);
				if (this._accessibleOutputs.text) this._updateTextOutput(cnvId + "textOutput");
				if (this._accessibleOutputs.grid) this._updateGridOutput(cnvId + "gridOutput");
				if (this._accessibleOutputs.textLabel) this._updateTextOutput(cnvId + "textOutputLabel");
				if (this._accessibleOutputs.gridLabel) this._updateGridOutput(cnvId + "gridOutputLabel");
			}
		};
		fn$1._accsBackground = function(args) {
			this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes);
			this.ingredients.pBackground = this.ingredients.colors.background;
			this.ingredients.shapes = {};
			if (this.ingredients.colors.backgroundRGBA !== args) {
				this.ingredients.colors.backgroundRGBA = args;
				this.ingredients.colors.background = this._rgbColorName(args);
			}
		};
		fn$1._accsCanvasColors = function(f, args) {
			if (f === "fill") {
				if (this.ingredients.colors.fillRGBA !== args) {
					this.ingredients.colors.fillRGBA = args;
					this.ingredients.colors.fill = this._rgbColorName(args);
				}
			} else if (f === "stroke") {
				if (this.ingredients.colors.strokeRGBA !== args) {
					this.ingredients.colors.strokeRGBA = args;
					this.ingredients.colors.stroke = this._rgbColorName(args);
				}
			}
		};
		fn$1._accsOutput = function(f, args) {
			if (f === "ellipse" && args[2] === args[3]) f = "circle";
			else if (f === "rectangle" && args[2] === args[3]) f = "square";
			let include = {};
			let add = true;
			let middle = _getMiddle(f, args);
			if (f === "line") {
				include.color = this.ingredients.colors.stroke;
				include.length = Math.round(Math.hypot(args[2] - args[0], args[3] - args[1]));
				let p1 = this._getPos(args[0], [1]);
				let p2 = this._getPos(args[2], [3]);
				include.loc = _canvasLocator(middle, this.width, this.height);
				if (p1 === p2) include.pos = `at ${p1}`;
				else include.pos = `from ${p1} to ${p2}`;
			} else {
				if (f === "point") include.color = this.ingredients.colors.stroke;
				else {
					include.color = this.ingredients.colors.fill;
					include.area = this._getArea(f, args);
				}
				include.pos = this._getPos(...middle);
				include.loc = _canvasLocator(middle, this.width, this.height);
			}
			if (!this.ingredients.shapes[f]) this.ingredients.shapes[f] = [include];
			else {
				for (let y in this.ingredients.shapes[f]) if (JSON.stringify(this.ingredients.shapes[f][y]) === JSON.stringify(include)) add = false;
				if (add === true) this.ingredients.shapes[f].push(include);
			}
		};
		function _getMiddle(f, args) {
			let x$1, y;
			if (f === "rectangle" || f === "ellipse" || f === "arc" || f === "circle" || f === "square") {
				x$1 = Math.round(args[0] + args[2] / 2);
				y = Math.round(args[1] + args[3] / 2);
			} else if (f === "triangle") {
				x$1 = (args[0] + args[2] + args[4]) / 3;
				y = (args[1] + args[3] + args[5]) / 3;
			} else if (f === "quadrilateral") {
				x$1 = (args[0] + args[2] + args[4] + args[6]) / 4;
				y = (args[1] + args[3] + args[5] + args[7]) / 4;
			} else if (f === "line") {
				x$1 = (args[0] + args[2]) / 2;
				y = (args[1] + args[3]) / 2;
			} else {
				x$1 = args[0];
				y = args[1];
			}
			return [x$1, y];
		}
		fn$1._getPos = function(x$1, y) {
			const { x: transformedX, y: transformedY } = this.worldToScreen(new p5$2.Vector(x$1, y));
			const canvasWidth = this.width;
			const canvasHeight = this.height;
			if (transformedX < .4 * canvasWidth) if (transformedY < .4 * canvasHeight) return "top left";
			else if (transformedY > .6 * canvasHeight) return "bottom left";
			else return "mid left";
			else if (transformedX > .6 * canvasWidth) if (transformedY < .4 * canvasHeight) return "top right";
			else if (transformedY > .6 * canvasHeight) return "bottom right";
			else return "mid right";
			else if (transformedY < .4 * canvasHeight) return "top middle";
			else if (transformedY > .6 * canvasHeight) return "bottom middle";
			else return "middle";
		};
		function _canvasLocator(args, canvasWidth, canvasHeight) {
			const noRows = 10;
			const noCols = 10;
			let locX = Math.floor(args[0] / canvasWidth * noRows);
			let locY = Math.floor(args[1] / canvasHeight * noCols);
			if (locX === noRows) locX = locX - 1;
			if (locY === noCols) locY = locY - 1;
			return {
				locX,
				locY
			};
		}
		fn$1._getArea = function(objectType, shapeArgs) {
			let objectArea = 0;
			if (objectType === "arc") {
				const arcSizeInRadians = ((shapeArgs[5] - shapeArgs[4]) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
				objectArea = arcSizeInRadians * shapeArgs[2] * shapeArgs[3] / 8;
				if (shapeArgs[6] === "open" || shapeArgs[6] === "chord") {
					const Ax = shapeArgs[0];
					const Ay = shapeArgs[1];
					const Bx = shapeArgs[0] + shapeArgs[2] / 2 * Math.cos(shapeArgs[4]).toFixed(2);
					const By = shapeArgs[1] + shapeArgs[3] / 2 * Math.sin(shapeArgs[4]).toFixed(2);
					const Cx = shapeArgs[0] + shapeArgs[2] / 2 * Math.cos(shapeArgs[5]).toFixed(2);
					const Cy = shapeArgs[1] + shapeArgs[3] / 2 * Math.sin(shapeArgs[5]).toFixed(2);
					const areaOfExtraTriangle = Math.abs(Ax * (By - Cy) + Bx * (Cy - Ay) + Cx * (Ay - By)) / 2;
					if (arcSizeInRadians > Math.PI) objectArea = objectArea + areaOfExtraTriangle;
					else objectArea = objectArea - areaOfExtraTriangle;
				}
			} else if (objectType === "ellipse" || objectType === "circle") objectArea = 3.14 * shapeArgs[2] / 2 * shapeArgs[3] / 2;
			else if (objectType === "line") objectArea = 0;
			else if (objectType === "point") objectArea = 0;
			else if (objectType === "quadrilateral") objectArea = Math.abs((shapeArgs[6] + shapeArgs[0]) * (shapeArgs[7] - shapeArgs[1]) + (shapeArgs[0] + shapeArgs[2]) * (shapeArgs[1] - shapeArgs[3]) + (shapeArgs[2] + shapeArgs[4]) * (shapeArgs[3] - shapeArgs[5]) + (shapeArgs[4] + shapeArgs[6]) * (shapeArgs[5] - shapeArgs[7])) / 2;
			else if (objectType === "rectangle" || objectType === "square") objectArea = shapeArgs[2] * shapeArgs[3];
			else if (objectType === "triangle") objectArea = Math.abs(shapeArgs[0] * (shapeArgs[3] - shapeArgs[5]) + shapeArgs[2] * (shapeArgs[5] - shapeArgs[1]) + shapeArgs[4] * (shapeArgs[1] - shapeArgs[3])) / 2;
			const canvasWidth = this.width * this._renderer._pixelDensity;
			const canvasHeight = this.height * this._renderer._pixelDensity;
			const canvasCorners = [
				new DOMPoint(0, 0),
				new DOMPoint(canvasWidth, 0),
				new DOMPoint(canvasWidth, canvasHeight),
				new DOMPoint(0, canvasHeight)
			];
			const invertedTransform = (this._renderer.isP3D ? new DOMMatrix(this._renderer.uMVMatrix.mat4) : this.drawingContext.getTransform()).inverse();
			const tc = canvasCorners.map((corner) => corner.matrixTransform(invertedTransform));
			const transformedCanvasArea = Math.abs((tc[3].x + tc[0].x) * (tc[3].y - tc[0].y) + (tc[0].x + tc[1].x) * (tc[0].y - tc[1].y) + (tc[1].x + tc[2].x) * (tc[1].y - tc[2].y) + (tc[2].x + tc[3].x) * (tc[2].y - tc[3].y)) / 2;
			return Math.round(objectArea * 100 / transformedCanvasArea);
		};
	}
	if (typeof p5 !== "undefined") outputs(p5, p5.prototype);
	p5$1.ColorConversion = {
		_hsbaToHSLA(hsba) {
			const hue = hsba[0];
			let sat = hsba[1];
			const val$1 = hsba[2];
			const li = (2 - sat) * val$1 / 2;
			if (li !== 0) if (li === 1) sat = 0;
			else if (li < .5) sat = sat / (2 - sat);
			else sat = sat * val$1 / (2 - li * 2);
			return [
				hue,
				sat,
				li,
				hsba[3]
			];
		},
		_hsbaToRGBA(hsba) {
			const hue = hsba[0] * 6;
			const sat = hsba[1];
			const val$1 = hsba[2];
			let RGBA$1 = [];
			if (sat === 0) RGBA$1 = [
				val$1,
				val$1,
				val$1,
				hsba[3]
			];
			else {
				const sector = Math.floor(hue);
				const tint1 = val$1 * (1 - sat);
				const tint2 = val$1 * (1 - sat * (hue - sector));
				const tint3 = val$1 * (1 - sat * (1 + sector - hue));
				let red, green, blue;
				if (sector === 1) {
					red = tint2;
					green = val$1;
					blue = tint1;
				} else if (sector === 2) {
					red = tint1;
					green = val$1;
					blue = tint3;
				} else if (sector === 3) {
					red = tint1;
					green = tint2;
					blue = val$1;
				} else if (sector === 4) {
					red = tint3;
					green = tint1;
					blue = val$1;
				} else if (sector === 5) {
					red = val$1;
					green = tint1;
					blue = tint2;
				} else {
					red = val$1;
					green = tint3;
					blue = tint1;
				}
				RGBA$1 = [
					red,
					green,
					blue,
					hsba[3]
				];
			}
			return RGBA$1;
		},
		_hslaToHSBA(hsla) {
			const hue = hsla[0];
			let sat = hsla[1];
			const li = hsla[2];
			let val$1;
			if (li < .5) val$1 = (1 + sat) * li;
			else val$1 = li + sat - li * sat;
			sat = 2 * (val$1 - li) / val$1;
			return [
				hue,
				sat,
				val$1,
				hsla[3]
			];
		},
		_hslaToRGBA(hsla) {
			const hue = hsla[0] * 6;
			const sat = hsla[1];
			const li = hsla[2];
			let RGBA$1 = [];
			if (sat === 0) RGBA$1 = [
				li,
				li,
				li,
				hsla[3]
			];
			else {
				let val$1;
				if (li < .5) val$1 = (1 + sat) * li;
				else val$1 = li + sat - li * sat;
				const zest = 2 * li - val$1;
				const hzvToRGB = (hue$1, zest$1, val$2) => {
					if (hue$1 < 0) hue$1 += 6;
					else if (hue$1 >= 6) hue$1 -= 6;
					if (hue$1 < 1) return zest$1 + (val$2 - zest$1) * hue$1;
					else if (hue$1 < 3) return val$2;
					else if (hue$1 < 4) return zest$1 + (val$2 - zest$1) * (4 - hue$1);
					else return zest$1;
				};
				RGBA$1 = [
					hzvToRGB(hue + 2, zest, val$1),
					hzvToRGB(hue, zest, val$1),
					hzvToRGB(hue - 2, zest, val$1),
					hsla[3]
				];
			}
			return RGBA$1;
		},
		_rgbaToHSBA(rgba) {
			const red = rgba[0];
			const green = rgba[1];
			const blue = rgba[2];
			const val$1 = Math.max(red, green, blue);
			const chroma = val$1 - Math.min(red, green, blue);
			let hue, sat;
			if (chroma === 0) {
				hue = 0;
				sat = 0;
			} else {
				sat = chroma / val$1;
				if (red === val$1) hue = (green - blue) / chroma;
				else if (green === val$1) hue = 2 + (blue - red) / chroma;
				else if (blue === val$1) hue = 4 + (red - green) / chroma;
				if (hue < 0) hue += 6;
				else if (hue >= 6) hue -= 6;
			}
			return [
				hue / 6,
				sat,
				val$1,
				rgba[3]
			];
		},
		_rgbaToHSLA(rgba) {
			const red = rgba[0];
			const green = rgba[1];
			const blue = rgba[2];
			const val$1 = Math.max(red, green, blue);
			const min = Math.min(red, green, blue);
			const li = val$1 + min;
			const chroma = val$1 - min;
			let hue, sat;
			if (chroma === 0) {
				hue = 0;
				sat = 0;
			} else {
				if (li < 1) sat = chroma / li;
				else sat = chroma / (2 - li);
				if (red === val$1) hue = (green - blue) / chroma;
				else if (green === val$1) hue = 2 + (blue - red) / chroma;
				else if (blue === val$1) hue = 4 + (red - green) / chroma;
				if (hue < 0) hue += 6;
				else if (hue >= 6) hue -= 6;
			}
			return [
				hue / 6,
				sat,
				li / 2,
				rgba[3]
			];
		}
	};
	var color_conversion = p5$1.ColorConversion;
	function colorNamer(p5$2, fn$1) {
		let originalHSB;
		const colorExceptions = [
			{
				h: 0,
				s: 0,
				b: .8275,
				name: "gray"
			},
			{
				h: 0,
				s: 0,
				b: .8627,
				name: "gray"
			},
			{
				h: 0,
				s: 0,
				b: .7529,
				name: "gray"
			},
			{
				h: .0167,
				s: .1176,
				b: 1,
				name: "light pink"
			}
		];
		const colorLookUp = [
			{
				h: 0,
				s: 0,
				b: 0,
				name: "black"
			},
			{
				h: 0,
				s: 0,
				b: .5,
				name: "gray"
			},
			{
				h: 0,
				s: 0,
				b: 1,
				name: "white"
			},
			{
				h: 0,
				s: .5,
				b: .5,
				name: "dark maroon"
			},
			{
				h: 0,
				s: .5,
				b: 1,
				name: "salmon pink"
			},
			{
				h: 0,
				s: 1,
				b: 0,
				name: "black"
			},
			{
				h: 0,
				s: 1,
				b: .5,
				name: "dark red"
			},
			{
				h: 0,
				s: 1,
				b: 1,
				name: "red"
			},
			{
				h: 5,
				s: 0,
				b: 1,
				name: "very light peach"
			},
			{
				h: 5,
				s: .5,
				b: .5,
				name: "brown"
			},
			{
				h: 5,
				s: .5,
				b: 1,
				name: "peach"
			},
			{
				h: 5,
				s: 1,
				b: .5,
				name: "brick red"
			},
			{
				h: 5,
				s: 1,
				b: 1,
				name: "crimson"
			},
			{
				h: 10,
				s: 0,
				b: 1,
				name: "light peach"
			},
			{
				h: 10,
				s: .5,
				b: .5,
				name: "brown"
			},
			{
				h: 10,
				s: .5,
				b: 1,
				name: "light orange"
			},
			{
				h: 10,
				s: 1,
				b: .5,
				name: "brown"
			},
			{
				h: 10,
				s: 1,
				b: 1,
				name: "orange"
			},
			{
				h: 15,
				s: 0,
				b: 1,
				name: "very light yellow"
			},
			{
				h: 15,
				s: .5,
				b: .5,
				name: "olive green"
			},
			{
				h: 15,
				s: .5,
				b: 1,
				name: "light yellow"
			},
			{
				h: 15,
				s: 1,
				b: 0,
				name: "dark olive green"
			},
			{
				h: 15,
				s: 1,
				b: .5,
				name: "olive green"
			},
			{
				h: 15,
				s: 1,
				b: 1,
				name: "yellow"
			},
			{
				h: 20,
				s: 0,
				b: 1,
				name: "very light yellow"
			},
			{
				h: 20,
				s: .5,
				b: .5,
				name: "olive green"
			},
			{
				h: 20,
				s: .5,
				b: 1,
				name: "light yellow green"
			},
			{
				h: 20,
				s: 1,
				b: 0,
				name: "dark olive green"
			},
			{
				h: 20,
				s: 1,
				b: .5,
				name: "dark yellow green"
			},
			{
				h: 20,
				s: 1,
				b: 1,
				name: "yellow green"
			},
			{
				h: 25,
				s: .5,
				b: .5,
				name: "dark yellow green"
			},
			{
				h: 25,
				s: .5,
				b: 1,
				name: "light green"
			},
			{
				h: 25,
				s: 1,
				b: .5,
				name: "dark green"
			},
			{
				h: 25,
				s: 1,
				b: 1,
				name: "green"
			},
			{
				h: 30,
				s: .5,
				b: 1,
				name: "light green"
			},
			{
				h: 30,
				s: 1,
				b: .5,
				name: "dark green"
			},
			{
				h: 30,
				s: 1,
				b: 1,
				name: "green"
			},
			{
				h: 35,
				s: 0,
				b: .5,
				name: "light green"
			},
			{
				h: 35,
				s: 0,
				b: 1,
				name: "very light green"
			},
			{
				h: 35,
				s: .5,
				b: .5,
				name: "dark green"
			},
			{
				h: 35,
				s: .5,
				b: 1,
				name: "light green"
			},
			{
				h: 35,
				s: 1,
				b: 0,
				name: "very dark green"
			},
			{
				h: 35,
				s: 1,
				b: .5,
				name: "dark green"
			},
			{
				h: 35,
				s: 1,
				b: 1,
				name: "green"
			},
			{
				h: 40,
				s: 0,
				b: 1,
				name: "very light green"
			},
			{
				h: 40,
				s: .5,
				b: .5,
				name: "dark green"
			},
			{
				h: 40,
				s: .5,
				b: 1,
				name: "light green"
			},
			{
				h: 40,
				s: 1,
				b: .5,
				name: "dark green"
			},
			{
				h: 40,
				s: 1,
				b: 1,
				name: "green"
			},
			{
				h: 45,
				s: .5,
				b: 1,
				name: "light turquoise"
			},
			{
				h: 45,
				s: 1,
				b: .5,
				name: "dark turquoise"
			},
			{
				h: 45,
				s: 1,
				b: 1,
				name: "turquoise"
			},
			{
				h: 50,
				s: 0,
				b: 1,
				name: "light sky blue"
			},
			{
				h: 50,
				s: .5,
				b: .5,
				name: "dark cyan"
			},
			{
				h: 50,
				s: .5,
				b: 1,
				name: "light cyan"
			},
			{
				h: 50,
				s: 1,
				b: .5,
				name: "dark cyan"
			},
			{
				h: 50,
				s: 1,
				b: 1,
				name: "cyan"
			},
			{
				h: 55,
				s: 0,
				b: 1,
				name: "light sky blue"
			},
			{
				h: 55,
				s: .5,
				b: 1,
				name: "light sky blue"
			},
			{
				h: 55,
				s: 1,
				b: .5,
				name: "dark blue"
			},
			{
				h: 55,
				s: 1,
				b: 1,
				name: "sky blue"
			},
			{
				h: 60,
				s: 0,
				b: .5,
				name: "gray"
			},
			{
				h: 60,
				s: 0,
				b: 1,
				name: "very light blue"
			},
			{
				h: 60,
				s: .5,
				b: .5,
				name: "blue"
			},
			{
				h: 60,
				s: .5,
				b: 1,
				name: "light blue"
			},
			{
				h: 60,
				s: 1,
				b: .5,
				name: "navy blue"
			},
			{
				h: 60,
				s: 1,
				b: 1,
				name: "blue"
			},
			{
				h: 65,
				s: 0,
				b: 1,
				name: "lavender"
			},
			{
				h: 65,
				s: .5,
				b: .5,
				name: "navy blue"
			},
			{
				h: 65,
				s: .5,
				b: 1,
				name: "light purple"
			},
			{
				h: 65,
				s: 1,
				b: .5,
				name: "dark navy blue"
			},
			{
				h: 65,
				s: 1,
				b: 1,
				name: "blue"
			},
			{
				h: 70,
				s: 0,
				b: 1,
				name: "lavender"
			},
			{
				h: 70,
				s: .5,
				b: .5,
				name: "navy blue"
			},
			{
				h: 70,
				s: .5,
				b: 1,
				name: "lavender blue"
			},
			{
				h: 70,
				s: 1,
				b: .5,
				name: "dark navy blue"
			},
			{
				h: 70,
				s: 1,
				b: 1,
				name: "blue"
			},
			{
				h: 75,
				s: .5,
				b: 1,
				name: "lavender"
			},
			{
				h: 75,
				s: 1,
				b: .5,
				name: "dark purple"
			},
			{
				h: 75,
				s: 1,
				b: 1,
				name: "purple"
			},
			{
				h: 80,
				s: .5,
				b: 1,
				name: "pinkish purple"
			},
			{
				h: 80,
				s: 1,
				b: .5,
				name: "dark purple"
			},
			{
				h: 80,
				s: 1,
				b: 1,
				name: "purple"
			},
			{
				h: 85,
				s: 0,
				b: 1,
				name: "light pink"
			},
			{
				h: 85,
				s: .5,
				b: .5,
				name: "purple"
			},
			{
				h: 85,
				s: .5,
				b: 1,
				name: "light fuchsia"
			},
			{
				h: 85,
				s: 1,
				b: .5,
				name: "dark fuchsia"
			},
			{
				h: 85,
				s: 1,
				b: 1,
				name: "fuchsia"
			},
			{
				h: 90,
				s: .5,
				b: .5,
				name: "dark fuchsia"
			},
			{
				h: 90,
				s: .5,
				b: 1,
				name: "hot pink"
			},
			{
				h: 90,
				s: 1,
				b: .5,
				name: "dark fuchsia"
			},
			{
				h: 90,
				s: 1,
				b: 1,
				name: "fuchsia"
			},
			{
				h: 95,
				s: 0,
				b: 1,
				name: "pink"
			},
			{
				h: 95,
				s: .5,
				b: 1,
				name: "light pink"
			},
			{
				h: 95,
				s: 1,
				b: .5,
				name: "dark magenta"
			},
			{
				h: 95,
				s: 1,
				b: 1,
				name: "magenta"
			}
		];
		function _calculateColor(hsb) {
			let colortext;
			if (hsb[0] !== 0) {
				hsb[0] = Math.round(hsb[0] * 100);
				let hue = hsb[0].toString().split("");
				const last$1 = hue.length - 1;
				hue[last$1] = parseInt(hue[last$1]);
				if (hue[last$1] < 2.5) hue[last$1] = 0;
				else if (hue[last$1] >= 2.5 && hue[last$1] < 7.5) hue[last$1] = 5;
				if (hue.length === 2) {
					hue[0] = parseInt(hue[0]);
					if (hue[last$1] >= 7.5) {
						hue[last$1] = 0;
						hue[0] = hue[0] + 1;
					}
					hsb[0] = hue[0] * 10 + hue[1];
				} else if (hue[last$1] >= 7.5) hsb[0] = 10;
				else hsb[0] = hue[last$1];
			}
			hsb[2] = hsb[2] / 255;
			for (let i$1 = hsb.length - 1; i$1 >= 1; i$1--) if (hsb[i$1] <= .25) hsb[i$1] = 0;
			else if (hsb[i$1] > .25 && hsb[i$1] < .75) hsb[i$1] = .5;
			else hsb[i$1] = 1;
			if (hsb[0] === 0 && hsb[1] === 0 && hsb[2] === 1) {
				for (let i$1 = 2; i$1 >= 0; i$1--) originalHSB[i$1] = Math.round(originalHSB[i$1] * 1e4) / 1e4;
				for (let e$1 = 0; e$1 < colorExceptions.length; e$1++) if (colorExceptions[e$1].h === originalHSB[0] && colorExceptions[e$1].s === originalHSB[1] && colorExceptions[e$1].b === originalHSB[2]) {
					colortext = colorExceptions[e$1].name;
					break;
				} else colortext = "white";
			} else for (let i$1 = 0; i$1 < colorLookUp.length; i$1++) if (colorLookUp[i$1].h === hsb[0] && colorLookUp[i$1].s === hsb[1] && colorLookUp[i$1].b === hsb[2]) {
				colortext = colorLookUp[i$1].name;
				break;
			}
			return colortext;
		}
		fn$1._rgbColorName = function(arg) {
			let hsb = color_conversion._rgbaToHSBA(arg);
			originalHSB = hsb;
			return _calculateColor([
				hsb[0],
				hsb[1],
				hsb[2]
			]);
		};
	}
	if (typeof p5 !== "undefined") colorNamer(p5, p5.prototype);
	function accessibility(p5$2) {
		p5$2.registerAddon(describe);
		p5$2.registerAddon(gridOutput);
		p5$2.registerAddon(textOutput);
		p5$2.registerAddon(outputs);
		p5$2.registerAddon(colorNamer);
	}
	function color(p5$2) {
		p5$2.registerAddon(creatingReading);
		p5$2.registerAddon(color$1);
		p5$2.registerAddon(setting);
	}
	function _typeof(o) {
		"@babel/helpers - typeof";
		return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$1) {
			return typeof o$1;
		} : function(o$1) {
			return o$1 && "function" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? "symbol" : typeof o$1;
		}, _typeof(o);
	}
	function toPrimitive(t$1, r) {
		if ("object" != _typeof(t$1) || !t$1) return t$1;
		var e$1 = t$1[Symbol.toPrimitive];
		if (void 0 !== e$1) {
			var i$1 = e$1.call(t$1, r || "default");
			if ("object" != _typeof(i$1)) return i$1;
			throw new TypeError("@@toPrimitive must return a primitive value.");
		}
		return ("string" === r ? String : Number)(t$1);
	}
	function toPropertyKey(t$1) {
		var i$1 = toPrimitive(t$1, "string");
		return "symbol" == _typeof(i$1) ? i$1 : i$1 + "";
	}
	function _defineProperty(e$1, r, t$1) {
		return (r = toPropertyKey(r)) in e$1 ? Object.defineProperty(e$1, r, {
			value: t$1,
			enumerable: !0,
			configurable: !0,
			writable: !0
		}) : e$1[r] = t$1, e$1;
	}
	function _objectSpread(e$1) {
		for (var r = 1; r < arguments.length; r++) {
			var t$1 = null != arguments[r] ? Object(arguments[r]) : {}, o = Object.keys(t$1);
			"function" == typeof Object.getOwnPropertySymbols && o.push.apply(o, Object.getOwnPropertySymbols(t$1).filter(function(e$2) {
				return Object.getOwnPropertyDescriptor(t$1, e$2).enumerable;
			})), o.forEach(function(r$1) {
				_defineProperty(e$1, r$1, t$1[r$1]);
			});
		}
		return e$1;
	}
	function _classCallCheck(a, n$2) {
		if (!(a instanceof n$2)) throw new TypeError("Cannot call a class as a function");
	}
	function _defineProperties(e$1, r) {
		for (var t$1 = 0; t$1 < r.length; t$1++) {
			var o = r[t$1];
			o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e$1, toPropertyKey(o.key), o);
		}
	}
	function _createClass(e$1, r, t$1) {
		return r && _defineProperties(e$1.prototype, r), t$1 && _defineProperties(e$1, t$1), Object.defineProperty(e$1, "prototype", { writable: !1 }), e$1;
	}
	function _assertThisInitialized(e$1) {
		if (void 0 === e$1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e$1;
	}
	function _possibleConstructorReturn(t$1, e$1) {
		if (e$1 && ("object" == _typeof(e$1) || "function" == typeof e$1)) return e$1;
		if (void 0 !== e$1) throw new TypeError("Derived constructors may only return object or undefined");
		return _assertThisInitialized(t$1);
	}
	function _getPrototypeOf(t$1) {
		return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t$2) {
			return t$2.__proto__ || Object.getPrototypeOf(t$2);
		}, _getPrototypeOf(t$1);
	}
	function _setPrototypeOf(t$1, e$1) {
		return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t$2, e$2) {
			return t$2.__proto__ = e$2, t$2;
		}, _setPrototypeOf(t$1, e$1);
	}
	function _inherits(t$1, e$1) {
		if ("function" != typeof e$1 && null !== e$1) throw new TypeError("Super expression must either be null or a function");
		t$1.prototype = Object.create(e$1 && e$1.prototype, { constructor: {
			value: t$1,
			writable: !0,
			configurable: !0
		} }), Object.defineProperty(t$1, "prototype", { writable: !1 }), e$1 && _setPrototypeOf(t$1, e$1);
	}
	var consoleLogger = {
		type: "logger",
		log: function log(args) {
			this.output("log", args);
		},
		warn: function warn(args) {
			this.output("warn", args);
		},
		error: function error$1(args) {
			this.output("error", args);
		},
		output: function output(type$2, args) {
			if (console && console[type$2]) console[type$2].apply(console, args);
		}
	};
	var baseLogger = new (function() {
		function Logger(concreteLogger) {
			var options$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
			_classCallCheck(this, Logger);
			this.init(concreteLogger, options$1);
		}
		_createClass(Logger, [
			{
				key: "init",
				value: function init(concreteLogger) {
					var options$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
					this.prefix = options$1.prefix || "i18next:";
					this.logger = concreteLogger || consoleLogger;
					this.options = options$1;
					this.debug = options$1.debug;
				}
			},
			{
				key: "setDebug",
				value: function setDebug(bool) {
					this.debug = bool;
				}
			},
			{
				key: "log",
				value: function log() {
					for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
					return this.forward(args, "log", "", true);
				}
			},
			{
				key: "warn",
				value: function warn() {
					for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
					return this.forward(args, "warn", "", true);
				}
			},
			{
				key: "error",
				value: function error$1() {
					for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
					return this.forward(args, "error", "");
				}
			},
			{
				key: "deprecate",
				value: function deprecate() {
					for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];
					return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
				}
			},
			{
				key: "forward",
				value: function forward(args, lvl, prefix, debugOnly) {
					if (debugOnly && !this.debug) return null;
					if (typeof args[0] === "string") args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
					return this.logger[lvl](args);
				}
			},
			{
				key: "create",
				value: function create$1(moduleName) {
					return new Logger(this.logger, _objectSpread({}, { prefix: "".concat(this.prefix, ":").concat(moduleName, ":") }, this.options));
				}
			}
		]);
		return Logger;
	}())();
	var EventEmitter = function() {
		function EventEmitter$1() {
			_classCallCheck(this, EventEmitter$1);
			this.observers = {};
		}
		_createClass(EventEmitter$1, [
			{
				key: "on",
				value: function on(events$1, listener) {
					var _this = this;
					events$1.split(" ").forEach(function(event) {
						_this.observers[event] = _this.observers[event] || [];
						_this.observers[event].push(listener);
					});
					return this;
				}
			},
			{
				key: "off",
				value: function off(event, listener) {
					if (!this.observers[event]) return;
					if (!listener) {
						delete this.observers[event];
						return;
					}
					this.observers[event] = this.observers[event].filter(function(l) {
						return l !== listener;
					});
				}
			},
			{
				key: "emit",
				value: function emit(event) {
					for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
					if (this.observers[event]) [].concat(this.observers[event]).forEach(function(observer) {
						observer.apply(void 0, args);
					});
					if (this.observers["*"]) [].concat(this.observers["*"]).forEach(function(observer) {
						observer.apply(observer, [event].concat(args));
					});
				}
			}
		]);
		return EventEmitter$1;
	}();
	function defer() {
		var res;
		var rej;
		var promise = new Promise(function(resolve, reject) {
			res = resolve;
			rej = reject;
		});
		promise.resolve = res;
		promise.reject = rej;
		return promise;
	}
	function makeString(object$1) {
		if (object$1 == null) return "";
		return "" + object$1;
	}
	function copy(a, s, t$1) {
		a.forEach(function(m) {
			if (s[m]) t$1[m] = s[m];
		});
	}
	function getLastOfPath(object$1, path$1, Empty) {
		function cleanKey(key$1) {
			return key$1 && key$1.indexOf("###") > -1 ? key$1.replace(/###/g, ".") : key$1;
		}
		function canNotTraverseDeeper() {
			return !object$1 || typeof object$1 === "string";
		}
		var stack = typeof path$1 !== "string" ? [].concat(path$1) : path$1.split(".");
		while (stack.length > 1) {
			if (canNotTraverseDeeper()) return {};
			var key = cleanKey(stack.shift());
			if (!object$1[key] && Empty) object$1[key] = new Empty();
			if (Object.prototype.hasOwnProperty.call(object$1, key)) object$1 = object$1[key];
			else object$1 = {};
		}
		if (canNotTraverseDeeper()) return {};
		return {
			obj: object$1,
			k: cleanKey(stack.shift())
		};
	}
	function setPath(object$1, path$1, newValue) {
		var _getLastOfPath = getLastOfPath(object$1, path$1, Object), obj = _getLastOfPath.obj, k = _getLastOfPath.k;
		obj[k] = newValue;
	}
	function pushPath(object$1, path$1, newValue, concat) {
		var _getLastOfPath2 = getLastOfPath(object$1, path$1, Object), obj = _getLastOfPath2.obj, k = _getLastOfPath2.k;
		obj[k] = obj[k] || [];
		if (concat) obj[k] = obj[k].concat(newValue);
		if (!concat) obj[k].push(newValue);
	}
	function getPath(object$1, path$1) {
		var _getLastOfPath3 = getLastOfPath(object$1, path$1), obj = _getLastOfPath3.obj, k = _getLastOfPath3.k;
		if (!obj) return void 0;
		return obj[k];
	}
	function getPathWithDefaults(data$2, defaultData, key) {
		var value = getPath(data$2, key);
		if (value !== void 0) return value;
		return getPath(defaultData, key);
	}
	function deepExtend(target, source, overwrite) {
		for (var prop in source) if (prop !== "__proto__" && prop !== "constructor") if (prop in target) if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
			if (overwrite) target[prop] = source[prop];
		} else deepExtend(target[prop], source[prop], overwrite);
		else target[prop] = source[prop];
		return target;
	}
	function regexEscape(str) {
		return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
	}
	var _entityMap = {
		"&": "&amp;",
		"<": "&lt;",
		">": "&gt;",
		"\"": "&quot;",
		"'": "&#39;",
		"/": "&#x2F;"
	};
	function escape(data$2) {
		if (typeof data$2 === "string") return data$2.replace(/[&<>"'\/]/g, function(s) {
			return _entityMap[s];
		});
		return data$2;
	}
	var isIE10 = typeof window !== "undefined" && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
	var ResourceStore = function(_EventEmitter) {
		_inherits(ResourceStore$1, _EventEmitter);
		function ResourceStore$1(data$2) {
			var _this;
			var options$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
				ns: ["translation"],
				defaultNS: "translation"
			};
			_classCallCheck(this, ResourceStore$1);
			_this = _possibleConstructorReturn(this, _getPrototypeOf(ResourceStore$1).call(this));
			if (isIE10) EventEmitter.call(_assertThisInitialized(_this));
			_this.data = data$2 || {};
			_this.options = options$1;
			if (_this.options.keySeparator === void 0) _this.options.keySeparator = ".";
			return _this;
		}
		_createClass(ResourceStore$1, [
			{
				key: "addNamespaces",
				value: function addNamespaces(ns) {
					if (this.options.ns.indexOf(ns) < 0) this.options.ns.push(ns);
				}
			},
			{
				key: "removeNamespaces",
				value: function removeNamespaces(ns) {
					var index = this.options.ns.indexOf(ns);
					if (index > -1) this.options.ns.splice(index, 1);
				}
			},
			{
				key: "getResource",
				value: function getResource(lng, ns, key) {
					var options$1 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
					var keySeparator = options$1.keySeparator !== void 0 ? options$1.keySeparator : this.options.keySeparator;
					var path$1 = [lng, ns];
					if (key && typeof key !== "string") path$1 = path$1.concat(key);
					if (key && typeof key === "string") path$1 = path$1.concat(keySeparator ? key.split(keySeparator) : key);
					if (lng.indexOf(".") > -1) path$1 = lng.split(".");
					return getPath(this.data, path$1);
				}
			},
			{
				key: "addResource",
				value: function addResource(lng, ns, key, value) {
					var options$1 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : { silent: false };
					var keySeparator = this.options.keySeparator;
					if (keySeparator === void 0) keySeparator = ".";
					var path$1 = [lng, ns];
					if (key) path$1 = path$1.concat(keySeparator ? key.split(keySeparator) : key);
					if (lng.indexOf(".") > -1) {
						path$1 = lng.split(".");
						value = ns;
						ns = path$1[1];
					}
					this.addNamespaces(ns);
					setPath(this.data, path$1, value);
					if (!options$1.silent) this.emit("added", lng, ns, key, value);
				}
			},
			{
				key: "addResources",
				value: function addResources(lng, ns, resources) {
					var options$1 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : { silent: false };
					for (var m in resources) if (typeof resources[m] === "string" || Object.prototype.toString.apply(resources[m]) === "[object Array]") this.addResource(lng, ns, m, resources[m], { silent: true });
					if (!options$1.silent) this.emit("added", lng, ns, resources);
				}
			},
			{
				key: "addResourceBundle",
				value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
					var options$1 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : { silent: false };
					var path$1 = [lng, ns];
					if (lng.indexOf(".") > -1) {
						path$1 = lng.split(".");
						deep = resources;
						resources = ns;
						ns = path$1[1];
					}
					this.addNamespaces(ns);
					var pack = getPath(this.data, path$1) || {};
					if (deep) deepExtend(pack, resources, overwrite);
					else pack = _objectSpread({}, pack, resources);
					setPath(this.data, path$1, pack);
					if (!options$1.silent) this.emit("added", lng, ns, resources);
				}
			},
			{
				key: "removeResourceBundle",
				value: function removeResourceBundle(lng, ns) {
					if (this.hasResourceBundle(lng, ns)) delete this.data[lng][ns];
					this.removeNamespaces(ns);
					this.emit("removed", lng, ns);
				}
			},
			{
				key: "hasResourceBundle",
				value: function hasResourceBundle(lng, ns) {
					return this.getResource(lng, ns) !== void 0;
				}
			},
			{
				key: "getResourceBundle",
				value: function getResourceBundle(lng, ns) {
					if (!ns) ns = this.options.defaultNS;
					if (this.options.compatibilityAPI === "v1") return _objectSpread({}, {}, this.getResource(lng, ns));
					return this.getResource(lng, ns);
				}
			},
			{
				key: "getDataByLanguage",
				value: function getDataByLanguage(lng) {
					return this.data[lng];
				}
			},
			{
				key: "toJSON",
				value: function toJSON() {
					return this.data;
				}
			}
		]);
		return ResourceStore$1;
	}(EventEmitter);
	var postProcessor = {
		processors: {},
		addPostProcessor: function addPostProcessor(module$1) {
			this.processors[module$1.name] = module$1;
		},
		handle: function handle(processors, value, key, options$1, translator$1) {
			var _this = this;
			processors.forEach(function(processor) {
				if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options$1, translator$1);
			});
			return value;
		}
	};
	var checkedLoadedFor = {};
	var Translator = function(_EventEmitter) {
		_inherits(Translator$1, _EventEmitter);
		function Translator$1(services) {
			var _this;
			var options$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
			_classCallCheck(this, Translator$1);
			_this = _possibleConstructorReturn(this, _getPrototypeOf(Translator$1).call(this));
			if (isIE10) EventEmitter.call(_assertThisInitialized(_this));
			copy([
				"resourceStore",
				"languageUtils",
				"pluralResolver",
				"interpolator",
				"backendConnector",
				"i18nFormat",
				"utils"
			], services, _assertThisInitialized(_this));
			_this.options = options$1;
			if (_this.options.keySeparator === void 0) _this.options.keySeparator = ".";
			_this.logger = baseLogger.create("translator");
			return _this;
		}
		_createClass(Translator$1, [
			{
				key: "changeLanguage",
				value: function changeLanguage(lng) {
					if (lng) this.language = lng;
				}
			},
			{
				key: "exists",
				value: function exists(key) {
					var options$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { interpolation: {} };
					var resolved = this.resolve(key, options$1);
					return resolved && resolved.res !== void 0;
				}
			},
			{
				key: "extractFromKey",
				value: function extractFromKey(key, options$1) {
					var nsSeparator = options$1.nsSeparator !== void 0 ? options$1.nsSeparator : this.options.nsSeparator;
					if (nsSeparator === void 0) nsSeparator = ":";
					var keySeparator = options$1.keySeparator !== void 0 ? options$1.keySeparator : this.options.keySeparator;
					var namespaces = options$1.ns || this.options.defaultNS;
					if (nsSeparator && key.indexOf(nsSeparator) > -1) {
						var m = key.match(this.interpolator.nestingRegexp);
						if (m && m.length > 0) return {
							key,
							namespaces
						};
						var parts = key.split(nsSeparator);
						if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
						key = parts.join(keySeparator);
					}
					if (typeof namespaces === "string") namespaces = [namespaces];
					return {
						key,
						namespaces
					};
				}
			},
			{
				key: "translate",
				value: function translate(keys, options$1, lastKey) {
					var _this2 = this;
					if (_typeof(options$1) !== "object" && this.options.overloadTranslationOptionHandler) options$1 = this.options.overloadTranslationOptionHandler(arguments);
					if (!options$1) options$1 = {};
					if (keys === void 0 || keys === null) return "";
					if (!Array.isArray(keys)) keys = [String(keys)];
					var keySeparator = options$1.keySeparator !== void 0 ? options$1.keySeparator : this.options.keySeparator;
					var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options$1), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
					var namespace = namespaces[namespaces.length - 1];
					var lng = options$1.lng || this.language;
					var appendNamespaceToCIMode = options$1.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
					if (lng && lng.toLowerCase() === "cimode") {
						if (appendNamespaceToCIMode) return namespace + (options$1.nsSeparator || this.options.nsSeparator) + key;
						return key;
					}
					var resolved = this.resolve(keys, options$1);
					var res = resolved && resolved.res;
					var resUsedKey = resolved && resolved.usedKey || key;
					var resExactUsedKey = resolved && resolved.exactUsedKey || key;
					var resType = Object.prototype.toString.apply(res);
					var noObject = [
						"[object Number]",
						"[object Function]",
						"[object RegExp]"
					];
					var joinArrays = options$1.joinArrays !== void 0 ? options$1.joinArrays : this.options.joinArrays;
					var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
					if (handleAsObjectInI18nFormat && res && typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number" && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
						if (!options$1.returnObjects && !this.options.returnObjects) {
							this.logger.warn("accessing an object - but returnObjects options is not enabled!");
							return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, options$1) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
						}
						if (keySeparator) {
							var resTypeIsArray = resType === "[object Array]";
							var copy$1 = resTypeIsArray ? [] : {};
							var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
							for (var m in res) if (Object.prototype.hasOwnProperty.call(res, m)) {
								var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
								copy$1[m] = this.translate(deepKey, _objectSpread({}, options$1, {
									joinArrays: false,
									ns: namespaces
								}));
								if (copy$1[m] === deepKey) copy$1[m] = res[m];
							}
							res = copy$1;
						}
					} else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
						res = res.join(joinArrays);
						if (res) res = this.extendTranslation(res, keys, options$1, lastKey);
					} else {
						var usedDefault = false;
						var usedKey = false;
						var needsPluralHandling = options$1.count !== void 0 && typeof options$1.count !== "string";
						var hasDefaultValue = Translator$1.hasDefaultValue(options$1);
						var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options$1.count) : "";
						var defaultValue = options$1["defaultValue".concat(defaultValueSuffix)] || options$1.defaultValue;
						if (!this.isValidLookup(res) && hasDefaultValue) {
							usedDefault = true;
							res = defaultValue;
						}
						if (!this.isValidLookup(res)) {
							usedKey = true;
							res = key;
						}
						var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
						if (usedKey || usedDefault || updateMissing) {
							this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
							if (keySeparator) {
								var fk = this.resolve(key, _objectSpread({}, options$1, { keySeparator: false }));
								if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
							}
							var lngs = [];
							var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options$1.lng || this.language);
							if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) for (var i$1 = 0; i$1 < fallbackLngs.length; i$1++) lngs.push(fallbackLngs[i$1]);
							else if (this.options.saveMissingTo === "all") lngs = this.languageUtils.toResolveHierarchy(options$1.lng || this.language);
							else lngs.push(options$1.lng || this.language);
							var send = function send$1(l, k, fallbackValue) {
								if (_this2.options.missingKeyHandler) _this2.options.missingKeyHandler(l, namespace, k, updateMissing ? fallbackValue : res, updateMissing, options$1);
								else if (_this2.backendConnector && _this2.backendConnector.saveMissing) _this2.backendConnector.saveMissing(l, namespace, k, updateMissing ? fallbackValue : res, updateMissing, options$1);
								_this2.emit("missingKey", l, namespace, k, res);
							};
							if (this.options.saveMissing) if (this.options.saveMissingPlurals && needsPluralHandling) lngs.forEach(function(language) {
								_this2.pluralResolver.getSuffixes(language).forEach(function(suffix) {
									send([language], key + suffix, options$1["defaultValue".concat(suffix)] || defaultValue);
								});
							});
							else send(lngs, key, defaultValue);
						}
						res = this.extendTranslation(res, keys, options$1, resolved, lastKey);
						if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key);
						if (usedKey && this.options.parseMissingKeyHandler) res = this.options.parseMissingKeyHandler(res);
					}
					return res;
				}
			},
			{
				key: "extendTranslation",
				value: function extendTranslation(res, key, options$1, resolved, lastKey) {
					var _this3 = this;
					if (this.i18nFormat && this.i18nFormat.parse) res = this.i18nFormat.parse(res, options$1, resolved.usedLng, resolved.usedNS, resolved.usedKey, { resolved });
					else if (!options$1.skipInterpolation) {
						if (options$1.interpolation) this.interpolator.init(_objectSpread({}, options$1, { interpolation: _objectSpread({}, this.options.interpolation, options$1.interpolation) }));
						var skipOnVariables = options$1.interpolation && options$1.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
						var nestBef;
						if (skipOnVariables) {
							var nb = res.match(this.interpolator.nestingRegexp);
							nestBef = nb && nb.length;
						}
						var data$2 = options$1.replace && typeof options$1.replace !== "string" ? options$1.replace : options$1;
						if (this.options.interpolation.defaultVariables) data$2 = _objectSpread({}, this.options.interpolation.defaultVariables, data$2);
						res = this.interpolator.interpolate(res, data$2, options$1.lng || this.language, options$1);
						if (skipOnVariables) {
							var na$1 = res.match(this.interpolator.nestingRegexp);
							var nestAft = na$1 && na$1.length;
							if (nestBef < nestAft) options$1.nest = false;
						}
						if (options$1.nest !== false) res = this.interpolator.nest(res, function() {
							for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
							if (lastKey && lastKey[0] === args[0] && !options$1.context) {
								_this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
								return null;
							}
							return _this3.translate.apply(_this3, args.concat([key]));
						}, options$1);
						if (options$1.interpolation) this.interpolator.reset();
					}
					var postProcess = options$1.postProcess || this.options.postProcess;
					var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
					if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options$1.applyPostProcessor !== false) res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread({ i18nResolved: resolved }, options$1) : options$1, this);
					return res;
				}
			},
			{
				key: "resolve",
				value: function resolve(keys) {
					var _this4 = this;
					var options$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
					var found;
					var usedKey;
					var exactUsedKey;
					var usedLng;
					var usedNS;
					if (typeof keys === "string") keys = [keys];
					keys.forEach(function(k) {
						if (_this4.isValidLookup(found)) return;
						var extracted = _this4.extractFromKey(k, options$1);
						var key = extracted.key;
						usedKey = key;
						var namespaces = extracted.namespaces;
						if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);
						var needsPluralHandling = options$1.count !== void 0 && typeof options$1.count !== "string";
						var needsContextHandling = options$1.context !== void 0 && typeof options$1.context === "string" && options$1.context !== "";
						var codes = options$1.lngs ? options$1.lngs : _this4.languageUtils.toResolveHierarchy(options$1.lng || _this4.language, options$1.fallbackLng);
						namespaces.forEach(function(ns) {
							if (_this4.isValidLookup(found)) return;
							usedNS = ns;
							if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
								checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;
								_this4.logger.warn("key \"".concat(usedKey, "\" for languages \"").concat(codes.join(", "), "\" won't get resolved as namespace \"").concat(usedNS, "\" was not yet loaded"), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
							}
							codes.forEach(function(code) {
								if (_this4.isValidLookup(found)) return;
								usedLng = code;
								var finalKey = key;
								var finalKeys = [finalKey];
								if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options$1);
								else {
									var pluralSuffix;
									if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options$1.count);
									if (needsPluralHandling && needsContextHandling) finalKeys.push(finalKey + pluralSuffix);
									if (needsContextHandling) finalKeys.push(finalKey += "".concat(_this4.options.contextSeparator).concat(options$1.context));
									if (needsPluralHandling) finalKeys.push(finalKey += pluralSuffix);
								}
								var possibleKey;
								while (possibleKey = finalKeys.pop()) if (!_this4.isValidLookup(found)) {
									exactUsedKey = possibleKey;
									found = _this4.getResource(code, ns, possibleKey, options$1);
								}
							});
						});
					});
					return {
						res: found,
						usedKey,
						exactUsedKey,
						usedLng,
						usedNS
					};
				}
			},
			{
				key: "isValidLookup",
				value: function isValidLookup(res) {
					return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
				}
			},
			{
				key: "getResource",
				value: function getResource(code, ns, key) {
					var options$1 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
					if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options$1);
					return this.resourceStore.getResource(code, ns, key, options$1);
				}
			}
		], [{
			key: "hasDefaultValue",
			value: function hasDefaultValue(options$1) {
				var prefix = "defaultValue";
				for (var option in options$1) if (Object.prototype.hasOwnProperty.call(options$1, option) && prefix === option.substring(0, prefix.length) && void 0 !== options$1[option]) return true;
				return false;
			}
		}]);
		return Translator$1;
	}(EventEmitter);
	function capitalize(string$2) {
		return string$2.charAt(0).toUpperCase() + string$2.slice(1);
	}
	var LanguageUtil = function() {
		function LanguageUtil$1(options$1) {
			_classCallCheck(this, LanguageUtil$1);
			this.options = options$1;
			this.whitelist = this.options.supportedLngs || false;
			this.supportedLngs = this.options.supportedLngs || false;
			this.logger = baseLogger.create("languageUtils");
		}
		_createClass(LanguageUtil$1, [
			{
				key: "getScriptPartFromCode",
				value: function getScriptPartFromCode(code) {
					if (!code || code.indexOf("-") < 0) return null;
					var p$1 = code.split("-");
					if (p$1.length === 2) return null;
					p$1.pop();
					if (p$1[p$1.length - 1].toLowerCase() === "x") return null;
					return this.formatLanguageCode(p$1.join("-"));
				}
			},
			{
				key: "getLanguagePartFromCode",
				value: function getLanguagePartFromCode(code) {
					if (!code || code.indexOf("-") < 0) return code;
					var p$1 = code.split("-");
					return this.formatLanguageCode(p$1[0]);
				}
			},
			{
				key: "formatLanguageCode",
				value: function formatLanguageCode(code) {
					if (typeof code === "string" && code.indexOf("-") > -1) {
						var specialCases = [
							"hans",
							"hant",
							"latn",
							"cyrl",
							"cans",
							"mong",
							"arab"
						];
						var p$1 = code.split("-");
						if (this.options.lowerCaseLng) p$1 = p$1.map(function(part) {
							return part.toLowerCase();
						});
						else if (p$1.length === 2) {
							p$1[0] = p$1[0].toLowerCase();
							p$1[1] = p$1[1].toUpperCase();
							if (specialCases.indexOf(p$1[1].toLowerCase()) > -1) p$1[1] = capitalize(p$1[1].toLowerCase());
						} else if (p$1.length === 3) {
							p$1[0] = p$1[0].toLowerCase();
							if (p$1[1].length === 2) p$1[1] = p$1[1].toUpperCase();
							if (p$1[0] !== "sgn" && p$1[2].length === 2) p$1[2] = p$1[2].toUpperCase();
							if (specialCases.indexOf(p$1[1].toLowerCase()) > -1) p$1[1] = capitalize(p$1[1].toLowerCase());
							if (specialCases.indexOf(p$1[2].toLowerCase()) > -1) p$1[2] = capitalize(p$1[2].toLowerCase());
						}
						return p$1.join("-");
					}
					return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
				}
			},
			{
				key: "isWhitelisted",
				value: function isWhitelisted(code) {
					this.logger.deprecate("languageUtils.isWhitelisted", "function \"isWhitelisted\" will be renamed to \"isSupportedCode\" in the next major - please make sure to rename it's usage asap.");
					return this.isSupportedCode(code);
				}
			},
			{
				key: "isSupportedCode",
				value: function isSupportedCode(code) {
					if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) code = this.getLanguagePartFromCode(code);
					return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
				}
			},
			{
				key: "getBestMatchFromCodes",
				value: function getBestMatchFromCodes(codes) {
					var _this = this;
					if (!codes) return null;
					var found;
					codes.forEach(function(code) {
						if (found) return;
						var cleanedLng = _this.formatLanguageCode(code);
						if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) found = cleanedLng;
					});
					if (!found && this.options.supportedLngs) codes.forEach(function(code) {
						if (found) return;
						var lngOnly = _this.getLanguagePartFromCode(code);
						if (_this.isSupportedCode(lngOnly)) return found = lngOnly;
						found = _this.options.supportedLngs.find(function(supportedLng) {
							if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;
						});
					});
					if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
					return found;
				}
			},
			{
				key: "getFallbackCodes",
				value: function getFallbackCodes(fallbacks, code) {
					if (!fallbacks) return [];
					if (typeof fallbacks === "function") fallbacks = fallbacks(code);
					if (typeof fallbacks === "string") fallbacks = [fallbacks];
					if (Object.prototype.toString.apply(fallbacks) === "[object Array]") return fallbacks;
					if (!code) return fallbacks["default"] || [];
					var found = fallbacks[code];
					if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
					if (!found) found = fallbacks[this.formatLanguageCode(code)];
					if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
					if (!found) found = fallbacks["default"];
					return found || [];
				}
			},
			{
				key: "toResolveHierarchy",
				value: function toResolveHierarchy(code, fallbackCode) {
					var _this2 = this;
					var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
					var codes = [];
					var addCode = function addCode$1(c) {
						if (!c) return;
						if (_this2.isSupportedCode(c)) codes.push(c);
						else _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c));
					};
					if (typeof code === "string" && code.indexOf("-") > -1) {
						if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
						if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
						if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
					} else if (typeof code === "string") addCode(this.formatLanguageCode(code));
					fallbackCodes.forEach(function(fc) {
						if (codes.indexOf(fc) < 0) addCode(_this2.formatLanguageCode(fc));
					});
					return codes;
				}
			}
		]);
		return LanguageUtil$1;
	}();
	var sets = [
		{
			lngs: [
				"ach",
				"ak",
				"am",
				"arn",
				"br",
				"fil",
				"gun",
				"ln",
				"mfe",
				"mg",
				"mi",
				"oc",
				"pt",
				"pt-BR",
				"tg",
				"tl",
				"ti",
				"tr",
				"uz",
				"wa"
			],
			nr: [1, 2],
			fc: 1
		},
		{
			lngs: [
				"af",
				"an",
				"ast",
				"az",
				"bg",
				"bn",
				"ca",
				"da",
				"de",
				"dev",
				"el",
				"en",
				"eo",
				"es",
				"et",
				"eu",
				"fi",
				"fo",
				"fur",
				"fy",
				"gl",
				"gu",
				"ha",
				"hi",
				"hu",
				"hy",
				"ia",
				"it",
				"kn",
				"ku",
				"lb",
				"mai",
				"ml",
				"mn",
				"mr",
				"nah",
				"nap",
				"nb",
				"ne",
				"nl",
				"nn",
				"no",
				"nso",
				"pa",
				"pap",
				"pms",
				"ps",
				"pt-PT",
				"rm",
				"sco",
				"se",
				"si",
				"so",
				"son",
				"sq",
				"sv",
				"sw",
				"ta",
				"te",
				"tk",
				"ur",
				"yo"
			],
			nr: [1, 2],
			fc: 2
		},
		{
			lngs: [
				"ay",
				"bo",
				"cgg",
				"fa",
				"ht",
				"id",
				"ja",
				"jbo",
				"ka",
				"kk",
				"km",
				"ko",
				"ky",
				"lo",
				"ms",
				"sah",
				"su",
				"th",
				"tt",
				"ug",
				"vi",
				"wo",
				"zh"
			],
			nr: [1],
			fc: 3
		},
		{
			lngs: [
				"be",
				"bs",
				"cnr",
				"dz",
				"hr",
				"ru",
				"sr",
				"uk"
			],
			nr: [
				1,
				2,
				5
			],
			fc: 4
		},
		{
			lngs: ["ar"],
			nr: [
				0,
				1,
				2,
				3,
				11,
				100
			],
			fc: 5
		},
		{
			lngs: ["cs", "sk"],
			nr: [
				1,
				2,
				5
			],
			fc: 6
		},
		{
			lngs: ["csb", "pl"],
			nr: [
				1,
				2,
				5
			],
			fc: 7
		},
		{
			lngs: ["cy"],
			nr: [
				1,
				2,
				3,
				8
			],
			fc: 8
		},
		{
			lngs: ["fr"],
			nr: [1, 2],
			fc: 9
		},
		{
			lngs: ["ga"],
			nr: [
				1,
				2,
				3,
				7,
				11
			],
			fc: 10
		},
		{
			lngs: ["gd"],
			nr: [
				1,
				2,
				3,
				20
			],
			fc: 11
		},
		{
			lngs: ["is"],
			nr: [1, 2],
			fc: 12
		},
		{
			lngs: ["jv"],
			nr: [0, 1],
			fc: 13
		},
		{
			lngs: ["kw"],
			nr: [
				1,
				2,
				3,
				4
			],
			fc: 14
		},
		{
			lngs: ["lt"],
			nr: [
				1,
				2,
				10
			],
			fc: 15
		},
		{
			lngs: ["lv"],
			nr: [
				1,
				2,
				0
			],
			fc: 16
		},
		{
			lngs: ["mk"],
			nr: [1, 2],
			fc: 17
		},
		{
			lngs: ["mnk"],
			nr: [
				0,
				1,
				2
			],
			fc: 18
		},
		{
			lngs: ["mt"],
			nr: [
				1,
				2,
				11,
				20
			],
			fc: 19
		},
		{
			lngs: ["or"],
			nr: [2, 1],
			fc: 2
		},
		{
			lngs: ["ro"],
			nr: [
				1,
				2,
				20
			],
			fc: 20
		},
		{
			lngs: ["sl"],
			nr: [
				5,
				1,
				2,
				3
			],
			fc: 21
		},
		{
			lngs: ["he", "iw"],
			nr: [
				1,
				2,
				20,
				21
			],
			fc: 22
		}
	];
	var _rulesPluralsTypes = {
		1: function _(n$2) {
			return Number(n$2 > 1);
		},
		2: function _(n$2) {
			return Number(n$2 != 1);
		},
		3: function _(n$2) {
			return 0;
		},
		4: function _(n$2) {
			return Number(n$2 % 10 == 1 && n$2 % 100 != 11 ? 0 : n$2 % 10 >= 2 && n$2 % 10 <= 4 && (n$2 % 100 < 10 || n$2 % 100 >= 20) ? 1 : 2);
		},
		5: function _(n$2) {
			return Number(n$2 == 0 ? 0 : n$2 == 1 ? 1 : n$2 == 2 ? 2 : n$2 % 100 >= 3 && n$2 % 100 <= 10 ? 3 : n$2 % 100 >= 11 ? 4 : 5);
		},
		6: function _(n$2) {
			return Number(n$2 == 1 ? 0 : n$2 >= 2 && n$2 <= 4 ? 1 : 2);
		},
		7: function _(n$2) {
			return Number(n$2 == 1 ? 0 : n$2 % 10 >= 2 && n$2 % 10 <= 4 && (n$2 % 100 < 10 || n$2 % 100 >= 20) ? 1 : 2);
		},
		8: function _(n$2) {
			return Number(n$2 == 1 ? 0 : n$2 == 2 ? 1 : n$2 != 8 && n$2 != 11 ? 2 : 3);
		},
		9: function _(n$2) {
			return Number(n$2 >= 2);
		},
		10: function _(n$2) {
			return Number(n$2 == 1 ? 0 : n$2 == 2 ? 1 : n$2 < 7 ? 2 : n$2 < 11 ? 3 : 4);
		},
		11: function _(n$2) {
			return Number(n$2 == 1 || n$2 == 11 ? 0 : n$2 == 2 || n$2 == 12 ? 1 : n$2 > 2 && n$2 < 20 ? 2 : 3);
		},
		12: function _(n$2) {
			return Number(n$2 % 10 != 1 || n$2 % 100 == 11);
		},
		13: function _(n$2) {
			return Number(n$2 !== 0);
		},
		14: function _(n$2) {
			return Number(n$2 == 1 ? 0 : n$2 == 2 ? 1 : n$2 == 3 ? 2 : 3);
		},
		15: function _(n$2) {
			return Number(n$2 % 10 == 1 && n$2 % 100 != 11 ? 0 : n$2 % 10 >= 2 && (n$2 % 100 < 10 || n$2 % 100 >= 20) ? 1 : 2);
		},
		16: function _(n$2) {
			return Number(n$2 % 10 == 1 && n$2 % 100 != 11 ? 0 : n$2 !== 0 ? 1 : 2);
		},
		17: function _(n$2) {
			return Number(n$2 == 1 || n$2 % 10 == 1 && n$2 % 100 != 11 ? 0 : 1);
		},
		18: function _(n$2) {
			return Number(n$2 == 0 ? 0 : n$2 == 1 ? 1 : 2);
		},
		19: function _(n$2) {
			return Number(n$2 == 1 ? 0 : n$2 == 0 || n$2 % 100 > 1 && n$2 % 100 < 11 ? 1 : n$2 % 100 > 10 && n$2 % 100 < 20 ? 2 : 3);
		},
		20: function _(n$2) {
			return Number(n$2 == 1 ? 0 : n$2 == 0 || n$2 % 100 > 0 && n$2 % 100 < 20 ? 1 : 2);
		},
		21: function _(n$2) {
			return Number(n$2 % 100 == 1 ? 1 : n$2 % 100 == 2 ? 2 : n$2 % 100 == 3 || n$2 % 100 == 4 ? 3 : 0);
		},
		22: function _(n$2) {
			return Number(n$2 == 1 ? 0 : n$2 == 2 ? 1 : (n$2 < 0 || n$2 > 10) && n$2 % 10 == 0 ? 2 : 3);
		}
	};
	function createRules() {
		var rules = {};
		sets.forEach(function(set$1) {
			set$1.lngs.forEach(function(l) {
				rules[l] = {
					numbers: set$1.nr,
					plurals: _rulesPluralsTypes[set$1.fc]
				};
			});
		});
		return rules;
	}
	var PluralResolver = function() {
		function PluralResolver$1(languageUtils) {
			var options$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
			_classCallCheck(this, PluralResolver$1);
			this.languageUtils = languageUtils;
			this.options = options$1;
			this.logger = baseLogger.create("pluralResolver");
			this.rules = createRules();
		}
		_createClass(PluralResolver$1, [
			{
				key: "addRule",
				value: function addRule(lng, obj) {
					this.rules[lng] = obj;
				}
			},
			{
				key: "getRule",
				value: function getRule(code) {
					return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
				}
			},
			{
				key: "needsPlural",
				value: function needsPlural(code) {
					var rule = this.getRule(code);
					return rule && rule.numbers.length > 1;
				}
			},
			{
				key: "getPluralFormsOfKey",
				value: function getPluralFormsOfKey(code, key) {
					return this.getSuffixes(code).map(function(suffix) {
						return key + suffix;
					});
				}
			},
			{
				key: "getSuffixes",
				value: function getSuffixes(code) {
					var _this = this;
					var rule = this.getRule(code);
					if (!rule) return [];
					return rule.numbers.map(function(number$2) {
						return _this.getSuffix(code, number$2);
					});
				}
			},
			{
				key: "getSuffix",
				value: function getSuffix(code, count) {
					var _this2 = this;
					var rule = this.getRule(code);
					if (rule) {
						var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
						var suffix = rule.numbers[idx];
						if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
							if (suffix === 2) suffix = "plural";
							else if (suffix === 1) suffix = "";
						}
						var returnSuffix = function returnSuffix$1() {
							return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
						};
						if (this.options.compatibilityJSON === "v1") {
							if (suffix === 1) return "";
							if (typeof suffix === "number") return "_plural_".concat(suffix.toString());
							return returnSuffix();
						} else if (this.options.compatibilityJSON === "v2") return returnSuffix();
						else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) return returnSuffix();
						return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
					}
					this.logger.warn("no plural rule found for: ".concat(code));
					return "";
				}
			}
		]);
		return PluralResolver$1;
	}();
	var Interpolator = function() {
		function Interpolator$1() {
			var options$1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
			_classCallCheck(this, Interpolator$1);
			this.logger = baseLogger.create("interpolator");
			this.options = options$1;
			this.format = options$1.interpolation && options$1.interpolation.format || function(value) {
				return value;
			};
			this.init(options$1);
		}
		_createClass(Interpolator$1, [
			{
				key: "init",
				value: function init() {
					var options$1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
					if (!options$1.interpolation) options$1.interpolation = { escapeValue: true };
					var iOpts = options$1.interpolation;
					this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape;
					this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
					this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
					this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
					this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
					this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
					this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
					this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
					this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
					this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
					this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
					this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
					this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
					this.resetRegExp();
				}
			},
			{
				key: "reset",
				value: function reset() {
					if (this.options) this.init(this.options);
				}
			},
			{
				key: "resetRegExp",
				value: function resetRegExp() {
					var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
					this.regexp = new RegExp(regexpStr, "g");
					var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
					this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
					var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
					this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
				}
			},
			{
				key: "interpolate",
				value: function interpolate$1(str, data$2, lng, options$1) {
					var _this = this;
					var match;
					var value;
					var replaces;
					var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
					function regexSafe(val$1) {
						return val$1.replace(/\$/g, "$$$$");
					}
					var handleFormat = function handleFormat$1(key) {
						if (key.indexOf(_this.formatSeparator) < 0) {
							var path$1 = getPathWithDefaults(data$2, defaultData, key);
							return _this.alwaysFormat ? _this.format(path$1, void 0, lng) : path$1;
						}
						var p$1 = key.split(_this.formatSeparator);
						var k = p$1.shift().trim();
						var f = p$1.join(_this.formatSeparator).trim();
						return _this.format(getPathWithDefaults(data$2, defaultData, k), f, lng, options$1);
					};
					this.resetRegExp();
					var missingInterpolationHandler = options$1 && options$1.missingInterpolationHandler || this.options.missingInterpolationHandler;
					var skipOnVariables = options$1 && options$1.interpolation && options$1.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
					[{
						regex: this.regexpUnescape,
						safeValue: function safeValue(val$1) {
							return regexSafe(val$1);
						}
					}, {
						regex: this.regexp,
						safeValue: function safeValue(val$1) {
							return _this.escapeValue ? regexSafe(_this.escape(val$1)) : regexSafe(val$1);
						}
					}].forEach(function(todo) {
						replaces = 0;
						while (match = todo.regex.exec(str)) {
							value = handleFormat(match[1].trim());
							if (value === void 0) if (typeof missingInterpolationHandler === "function") {
								var temp = missingInterpolationHandler(str, match, options$1);
								value = typeof temp === "string" ? temp : "";
							} else if (skipOnVariables) {
								value = match[0];
								continue;
							} else {
								_this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
								value = "";
							}
							else if (typeof value !== "string" && !_this.useRawValueToEscape) value = makeString(value);
							str = str.replace(match[0], todo.safeValue(value));
							todo.regex.lastIndex = 0;
							replaces++;
							if (replaces >= _this.maxReplaces) break;
						}
					});
					return str;
				}
			},
			{
				key: "nest",
				value: function nest(str, fc) {
					var _this2 = this;
					var options$1 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
					var match;
					var value;
					var clonedOptions = _objectSpread({}, options$1);
					clonedOptions.applyPostProcessor = false;
					delete clonedOptions.defaultValue;
					function handleHasOptions(key, inheritedOptions) {
						var sep = this.nestingOptionsSeparator;
						if (key.indexOf(sep) < 0) return key;
						var c = key.split(new RegExp("".concat(sep, "[ ]*{")));
						var optionsString = "{".concat(c[1]);
						key = c[0];
						optionsString = this.interpolate(optionsString, clonedOptions);
						optionsString = optionsString.replace(/'/g, "\"");
						try {
							clonedOptions = JSON.parse(optionsString);
							if (inheritedOptions) clonedOptions = _objectSpread({}, inheritedOptions, clonedOptions);
						} catch (e$1) {
							this.logger.warn("failed parsing options string in nesting for key ".concat(key), e$1);
							return "".concat(key).concat(sep).concat(optionsString);
						}
						delete clonedOptions.defaultValue;
						return key;
					}
					while (match = this.nestingRegexp.exec(str)) {
						var formatters = [];
						var doReduce = false;
						if (match[0].includes(this.formatSeparator) && !/{.*}/.test(match[1])) {
							var r = match[1].split(this.formatSeparator).map(function(elem) {
								return elem.trim();
							});
							match[1] = r.shift();
							formatters = r;
							doReduce = true;
						}
						value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
						if (value && match[0] === str && typeof value !== "string") return value;
						if (typeof value !== "string") value = makeString(value);
						if (!value) {
							this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
							value = "";
						}
						if (doReduce) value = formatters.reduce(function(v$1, f) {
							return _this2.format(v$1, f, options$1.lng, options$1);
						}, value.trim());
						str = str.replace(match[0], value);
						this.regexp.lastIndex = 0;
					}
					return str;
				}
			}
		]);
		return Interpolator$1;
	}();
	function remove(arr$1, what) {
		var found = arr$1.indexOf(what);
		while (found !== -1) {
			arr$1.splice(found, 1);
			found = arr$1.indexOf(what);
		}
	}
	var Connector = function(_EventEmitter) {
		_inherits(Connector$1, _EventEmitter);
		function Connector$1(backend, store, services) {
			var _this;
			var options$1 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
			_classCallCheck(this, Connector$1);
			_this = _possibleConstructorReturn(this, _getPrototypeOf(Connector$1).call(this));
			if (isIE10) EventEmitter.call(_assertThisInitialized(_this));
			_this.backend = backend;
			_this.store = store;
			_this.services = services;
			_this.languageUtils = services.languageUtils;
			_this.options = options$1;
			_this.logger = baseLogger.create("backendConnector");
			_this.state = {};
			_this.queue = [];
			if (_this.backend && _this.backend.init) _this.backend.init(services, options$1.backend, options$1);
			return _this;
		}
		_createClass(Connector$1, [
			{
				key: "queueLoad",
				value: function queueLoad(languages$1, namespaces, options$1, callback) {
					var _this2 = this;
					var toLoad = [];
					var pending = [];
					var toLoadLanguages = [];
					var toLoadNamespaces = [];
					languages$1.forEach(function(lng) {
						var hasAllNamespaces = true;
						namespaces.forEach(function(ns) {
							var name = "".concat(lng, "|").concat(ns);
							if (!options$1.reload && _this2.store.hasResourceBundle(lng, ns)) _this2.state[name] = 2;
							else if (_this2.state[name] < 0);
							else if (_this2.state[name] === 1) {
								if (pending.indexOf(name) < 0) pending.push(name);
							} else {
								_this2.state[name] = 1;
								hasAllNamespaces = false;
								if (pending.indexOf(name) < 0) pending.push(name);
								if (toLoad.indexOf(name) < 0) toLoad.push(name);
								if (toLoadNamespaces.indexOf(ns) < 0) toLoadNamespaces.push(ns);
							}
						});
						if (!hasAllNamespaces) toLoadLanguages.push(lng);
					});
					if (toLoad.length || pending.length) this.queue.push({
						pending,
						loaded: {},
						errors: [],
						callback
					});
					return {
						toLoad,
						pending,
						toLoadLanguages,
						toLoadNamespaces
					};
				}
			},
			{
				key: "loaded",
				value: function loaded(name, err$1, data$2) {
					var s = name.split("|");
					var lng = s[0];
					var ns = s[1];
					if (err$1) this.emit("failedLoading", lng, ns, err$1);
					if (data$2) this.store.addResourceBundle(lng, ns, data$2);
					this.state[name] = err$1 ? -1 : 2;
					var loaded$1 = {};
					this.queue.forEach(function(q) {
						pushPath(q.loaded, [lng], ns);
						remove(q.pending, name);
						if (err$1) q.errors.push(err$1);
						if (q.pending.length === 0 && !q.done) {
							Object.keys(q.loaded).forEach(function(l) {
								if (!loaded$1[l]) loaded$1[l] = [];
								if (q.loaded[l].length) q.loaded[l].forEach(function(ns$1) {
									if (loaded$1[l].indexOf(ns$1) < 0) loaded$1[l].push(ns$1);
								});
							});
							q.done = true;
							if (q.errors.length) q.callback(q.errors);
							else q.callback();
						}
					});
					this.emit("loaded", loaded$1);
					this.queue = this.queue.filter(function(q) {
						return !q.done;
					});
				}
			},
			{
				key: "read",
				value: function read(lng, ns, fcName) {
					var _this3 = this;
					var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
					var wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 350;
					var callback = arguments.length > 5 ? arguments[5] : void 0;
					if (!lng.length) return callback(null, {});
					return this.backend[fcName](lng, ns, function(err$1, data$2) {
						if (err$1 && data$2 && tried < 5) {
							setTimeout(function() {
								_this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
							}, wait);
							return;
						}
						callback(err$1, data$2);
					});
				}
			},
			{
				key: "prepareLoading",
				value: function prepareLoading(languages$1, namespaces) {
					var _this4 = this;
					var options$1 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
					var callback = arguments.length > 3 ? arguments[3] : void 0;
					if (!this.backend) {
						this.logger.warn("No backend was added via i18next.use. Will not load resources.");
						return callback && callback();
					}
					if (typeof languages$1 === "string") languages$1 = this.languageUtils.toResolveHierarchy(languages$1);
					if (typeof namespaces === "string") namespaces = [namespaces];
					var toLoad = this.queueLoad(languages$1, namespaces, options$1, callback);
					if (!toLoad.toLoad.length) {
						if (!toLoad.pending.length) callback();
						return null;
					}
					toLoad.toLoad.forEach(function(name) {
						_this4.loadOne(name);
					});
				}
			},
			{
				key: "load",
				value: function load(languages$1, namespaces, callback) {
					this.prepareLoading(languages$1, namespaces, {}, callback);
				}
			},
			{
				key: "reload",
				value: function reload(languages$1, namespaces, callback) {
					this.prepareLoading(languages$1, namespaces, { reload: true }, callback);
				}
			},
			{
				key: "loadOne",
				value: function loadOne(name) {
					var _this5 = this;
					var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
					var s = name.split("|");
					var lng = s[0];
					var ns = s[1];
					this.read(lng, ns, "read", void 0, void 0, function(err$1, data$2) {
						if (err$1) _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err$1);
						if (!err$1 && data$2) _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data$2);
						_this5.loaded(name, err$1, data$2);
					});
				}
			},
			{
				key: "saveMissing",
				value: function saveMissing(languages$1, namespace, key, fallbackValue, isUpdate) {
					var options$1 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
					if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
						this.logger.warn("did not save key \"".concat(key, "\" as the namespace \"").concat(namespace, "\" was not yet loaded"), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
						return;
					}
					if (key === void 0 || key === null || key === "") return;
					if (this.backend && this.backend.create) this.backend.create(languages$1, namespace, key, fallbackValue, null, _objectSpread({}, options$1, { isUpdate }));
					if (!languages$1 || !languages$1[0]) return;
					this.store.addResource(languages$1[0], namespace, key, fallbackValue);
				}
			}
		]);
		return Connector$1;
	}(EventEmitter);
	function get() {
		return {
			debug: false,
			initImmediate: true,
			ns: ["translation"],
			defaultNS: ["translation"],
			fallbackLng: ["dev"],
			fallbackNS: false,
			whitelist: false,
			nonExplicitWhitelist: false,
			supportedLngs: false,
			nonExplicitSupportedLngs: false,
			load: "all",
			preload: false,
			simplifyPluralSuffix: true,
			keySeparator: ".",
			nsSeparator: ":",
			pluralSeparator: "_",
			contextSeparator: "_",
			partialBundledLanguages: false,
			saveMissing: false,
			updateMissing: false,
			saveMissingTo: "fallback",
			saveMissingPlurals: true,
			missingKeyHandler: false,
			missingInterpolationHandler: false,
			postProcess: false,
			postProcessPassResolved: false,
			returnNull: true,
			returnEmptyString: true,
			returnObjects: false,
			joinArrays: false,
			returnedObjectHandler: false,
			parseMissingKeyHandler: false,
			appendNamespaceToMissingKey: false,
			appendNamespaceToCIMode: false,
			overloadTranslationOptionHandler: function handle(args) {
				var ret = {};
				if (_typeof(args[1]) === "object") ret = args[1];
				if (typeof args[1] === "string") ret.defaultValue = args[1];
				if (typeof args[2] === "string") ret.tDescription = args[2];
				if (_typeof(args[2]) === "object" || _typeof(args[3]) === "object") {
					var options$1 = args[3] || args[2];
					Object.keys(options$1).forEach(function(key) {
						ret[key] = options$1[key];
					});
				}
				return ret;
			},
			interpolation: {
				escapeValue: true,
				format: function format(value, _format, lng, options$1) {
					return value;
				},
				prefix: "{{",
				suffix: "}}",
				formatSeparator: ",",
				unescapePrefix: "-",
				nestingPrefix: "$t(",
				nestingSuffix: ")",
				nestingOptionsSeparator: ",",
				maxReplaces: 1e3,
				skipOnVariables: false
			}
		};
	}
	function transformOptions(options$1) {
		if (typeof options$1.ns === "string") options$1.ns = [options$1.ns];
		if (typeof options$1.fallbackLng === "string") options$1.fallbackLng = [options$1.fallbackLng];
		if (typeof options$1.fallbackNS === "string") options$1.fallbackNS = [options$1.fallbackNS];
		if (options$1.whitelist) {
			if (options$1.whitelist && options$1.whitelist.indexOf("cimode") < 0) options$1.whitelist = options$1.whitelist.concat(["cimode"]);
			options$1.supportedLngs = options$1.whitelist;
		}
		if (options$1.nonExplicitWhitelist) options$1.nonExplicitSupportedLngs = options$1.nonExplicitWhitelist;
		if (options$1.supportedLngs && options$1.supportedLngs.indexOf("cimode") < 0) options$1.supportedLngs = options$1.supportedLngs.concat(["cimode"]);
		return options$1;
	}
	function noop() {}
	var i18next_default = new (function(_EventEmitter) {
		_inherits(I18n, _EventEmitter);
		function I18n() {
			var _this;
			var options$1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
			var callback = arguments.length > 1 ? arguments[1] : void 0;
			_classCallCheck(this, I18n);
			_this = _possibleConstructorReturn(this, _getPrototypeOf(I18n).call(this));
			if (isIE10) EventEmitter.call(_assertThisInitialized(_this));
			_this.options = transformOptions(options$1);
			_this.services = {};
			_this.logger = baseLogger;
			_this.modules = { external: [] };
			if (callback && !_this.isInitialized && !options$1.isClone) {
				if (!_this.options.initImmediate) {
					_this.init(options$1, callback);
					return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
				}
				setTimeout(function() {
					_this.init(options$1, callback);
				}, 0);
			}
			return _this;
		}
		_createClass(I18n, [
			{
				key: "init",
				value: function init() {
					var _this2 = this;
					var options$1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
					var callback = arguments.length > 1 ? arguments[1] : void 0;
					if (typeof options$1 === "function") {
						callback = options$1;
						options$1 = {};
					}
					if (options$1.whitelist && !options$1.supportedLngs) this.logger.deprecate("whitelist", "option \"whitelist\" will be renamed to \"supportedLngs\" in the next major - please make sure to rename this option asap.");
					if (options$1.nonExplicitWhitelist && !options$1.nonExplicitSupportedLngs) this.logger.deprecate("whitelist", "options \"nonExplicitWhitelist\" will be renamed to \"nonExplicitSupportedLngs\" in the next major - please make sure to rename this option asap.");
					this.options = _objectSpread({}, get(), this.options, transformOptions(options$1));
					this.format = this.options.interpolation.format;
					if (!callback) callback = noop;
					function createClassOnDemand(ClassOrObject) {
						if (!ClassOrObject) return null;
						if (typeof ClassOrObject === "function") return new ClassOrObject();
						return ClassOrObject;
					}
					if (!this.options.isClone) {
						if (this.modules.logger) baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
						else baseLogger.init(null, this.options);
						var lu = new LanguageUtil(this.options);
						this.store = new ResourceStore(this.options.resources, this.options);
						var s = this.services;
						s.logger = baseLogger;
						s.resourceStore = this.store;
						s.languageUtils = lu;
						s.pluralResolver = new PluralResolver(lu, {
							prepend: this.options.pluralSeparator,
							compatibilityJSON: this.options.compatibilityJSON,
							simplifyPluralSuffix: this.options.simplifyPluralSuffix
						});
						s.interpolator = new Interpolator(this.options);
						s.utils = { hasLoadedNamespace: this.hasLoadedNamespace.bind(this) };
						s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
						s.backendConnector.on("*", function(event) {
							for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
							_this2.emit.apply(_this2, [event].concat(args));
						});
						if (this.modules.languageDetector) {
							s.languageDetector = createClassOnDemand(this.modules.languageDetector);
							s.languageDetector.init(s, this.options.detection, this.options);
						}
						if (this.modules.i18nFormat) {
							s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
							if (s.i18nFormat.init) s.i18nFormat.init(this);
						}
						this.translator = new Translator(this.services, this.options);
						this.translator.on("*", function(event) {
							for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) args[_key2 - 1] = arguments[_key2];
							_this2.emit.apply(_this2, [event].concat(args));
						});
						this.modules.external.forEach(function(m) {
							if (m.init) m.init(_this2);
						});
					}
					if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
						var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
						if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
					}
					if (!this.services.languageDetector && !this.options.lng) this.logger.warn("init: no languageDetector is used and no lng is defined");
					[
						"getResource",
						"hasResourceBundle",
						"getResourceBundle",
						"getDataByLanguage"
					].forEach(function(fcName) {
						_this2[fcName] = function() {
							var _this2$store;
							return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
						};
					});
					[
						"addResource",
						"addResources",
						"addResourceBundle",
						"removeResourceBundle"
					].forEach(function(fcName) {
						_this2[fcName] = function() {
							var _this2$store2;
							(_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
							return _this2;
						};
					});
					var deferred = defer();
					var load = function load$1() {
						var finish = function finish$1(err$1, t$1) {
							if (_this2.isInitialized) _this2.logger.warn("init: i18next is already initialized. You should call init just once!");
							_this2.isInitialized = true;
							if (!_this2.options.isClone) _this2.logger.log("initialized", _this2.options);
							_this2.emit("initialized", _this2.options);
							deferred.resolve(t$1);
							callback(err$1, t$1);
						};
						if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized) return finish(null, _this2.t.bind(_this2));
						_this2.changeLanguage(_this2.options.lng, finish);
					};
					if (this.options.resources || !this.options.initImmediate) load();
					else setTimeout(load, 0);
					return deferred;
				}
			},
			{
				key: "loadResources",
				value: function loadResources(language) {
					var _this3 = this;
					var usedCallback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
					var usedLng = typeof language === "string" ? language : this.language;
					if (typeof language === "function") usedCallback = language;
					if (!this.options.resources || this.options.partialBundledLanguages) {
						if (usedLng && usedLng.toLowerCase() === "cimode") return usedCallback();
						var toLoad = [];
						var append = function append$1(lng) {
							if (!lng) return;
							_this3.services.languageUtils.toResolveHierarchy(lng).forEach(function(l) {
								if (toLoad.indexOf(l) < 0) toLoad.push(l);
							});
						};
						if (!usedLng) this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(function(l) {
							return append(l);
						});
						else append(usedLng);
						if (this.options.preload) this.options.preload.forEach(function(l) {
							return append(l);
						});
						this.services.backendConnector.load(toLoad, this.options.ns, usedCallback);
					} else usedCallback(null);
				}
			},
			{
				key: "reloadResources",
				value: function reloadResources(lngs, ns, callback) {
					var deferred = defer();
					if (!lngs) lngs = this.languages;
					if (!ns) ns = this.options.ns;
					if (!callback) callback = noop;
					this.services.backendConnector.reload(lngs, ns, function(err$1) {
						deferred.resolve();
						callback(err$1);
					});
					return deferred;
				}
			},
			{
				key: "use",
				value: function use(module$1) {
					if (!module$1) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
					if (!module$1.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
					if (module$1.type === "backend") this.modules.backend = module$1;
					if (module$1.type === "logger" || module$1.log && module$1.warn && module$1.error) this.modules.logger = module$1;
					if (module$1.type === "languageDetector") this.modules.languageDetector = module$1;
					if (module$1.type === "i18nFormat") this.modules.i18nFormat = module$1;
					if (module$1.type === "postProcessor") postProcessor.addPostProcessor(module$1);
					if (module$1.type === "3rdParty") this.modules.external.push(module$1);
					return this;
				}
			},
			{
				key: "changeLanguage",
				value: function changeLanguage(lng, callback) {
					var _this4 = this;
					this.isLanguageChangingTo = lng;
					var deferred = defer();
					this.emit("languageChanging", lng);
					var done = function done$1(err$1, l) {
						if (l) {
							_this4.language = l;
							_this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
							_this4.translator.changeLanguage(l);
							_this4.isLanguageChangingTo = void 0;
							_this4.emit("languageChanged", l);
							_this4.logger.log("languageChanged", l);
						} else _this4.isLanguageChangingTo = void 0;
						deferred.resolve(function() {
							return _this4.t.apply(_this4, arguments);
						});
						if (callback) callback(err$1, function() {
							return _this4.t.apply(_this4, arguments);
						});
					};
					var setLng = function setLng$1(lngs) {
						var l = typeof lngs === "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
						if (l) {
							if (!_this4.language) {
								_this4.language = l;
								_this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
							}
							if (!_this4.translator.language) _this4.translator.changeLanguage(l);
							if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);
						}
						_this4.loadResources(l, function(err$1) {
							done(err$1, l);
						});
					};
					if (!lng && this.services.languageDetector && !this.services.languageDetector.async) setLng(this.services.languageDetector.detect());
					else if (!lng && this.services.languageDetector && this.services.languageDetector.async) this.services.languageDetector.detect(setLng);
					else setLng(lng);
					return deferred;
				}
			},
			{
				key: "getFixedT",
				value: function getFixedT(lng, ns) {
					var _this5 = this;
					var fixedT = function fixedT$1(key, opts) {
						var options$1;
						if (_typeof(opts) !== "object") {
							for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) rest[_key3 - 2] = arguments[_key3];
							options$1 = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
						} else options$1 = _objectSpread({}, opts);
						options$1.lng = options$1.lng || fixedT$1.lng;
						options$1.lngs = options$1.lngs || fixedT$1.lngs;
						options$1.ns = options$1.ns || fixedT$1.ns;
						return _this5.t(key, options$1);
					};
					if (typeof lng === "string") fixedT.lng = lng;
					else fixedT.lngs = lng;
					fixedT.ns = ns;
					return fixedT;
				}
			},
			{
				key: "t",
				value: function t$1() {
					var _this$translator;
					return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
				}
			},
			{
				key: "exists",
				value: function exists() {
					var _this$translator2;
					return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
				}
			},
			{
				key: "setDefaultNamespace",
				value: function setDefaultNamespace(ns) {
					this.options.defaultNS = ns;
				}
			},
			{
				key: "hasLoadedNamespace",
				value: function hasLoadedNamespace(ns) {
					var _this6 = this;
					var options$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
					if (!this.isInitialized) {
						this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
						return false;
					}
					if (!this.languages || !this.languages.length) {
						this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
						return false;
					}
					var lng = this.languages[0];
					var fallbackLng = this.options ? this.options.fallbackLng : false;
					var lastLng = this.languages[this.languages.length - 1];
					if (lng.toLowerCase() === "cimode") return true;
					var loadNotPending = function loadNotPending$1(l, n$2) {
						var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n$2)];
						return loadState === -1 || loadState === 2;
					};
					if (options$1.precheck) {
						var preResult = options$1.precheck(this, loadNotPending);
						if (preResult !== void 0) return preResult;
					}
					if (this.hasResourceBundle(lng, ns)) return true;
					if (!this.services.backendConnector.backend) return true;
					if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
					return false;
				}
			},
			{
				key: "loadNamespaces",
				value: function loadNamespaces(ns, callback) {
					var _this7 = this;
					var deferred = defer();
					if (!this.options.ns) {
						callback && callback();
						return Promise.resolve();
					}
					if (typeof ns === "string") ns = [ns];
					ns.forEach(function(n$2) {
						if (_this7.options.ns.indexOf(n$2) < 0) _this7.options.ns.push(n$2);
					});
					this.loadResources(function(err$1) {
						deferred.resolve();
						if (callback) callback(err$1);
					});
					return deferred;
				}
			},
			{
				key: "loadLanguages",
				value: function loadLanguages(lngs, callback) {
					var deferred = defer();
					if (typeof lngs === "string") lngs = [lngs];
					var preloaded = this.options.preload || [];
					var newLngs = lngs.filter(function(lng) {
						return preloaded.indexOf(lng) < 0;
					});
					if (!newLngs.length) {
						if (callback) callback();
						return Promise.resolve();
					}
					this.options.preload = preloaded.concat(newLngs);
					this.loadResources(function(err$1) {
						deferred.resolve();
						if (callback) callback(err$1);
					});
					return deferred;
				}
			},
			{
				key: "dir",
				value: function dir(lng) {
					if (!lng) lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;
					if (!lng) return "rtl";
					return [
						"ar",
						"shu",
						"sqr",
						"ssh",
						"xaa",
						"yhd",
						"yud",
						"aao",
						"abh",
						"abv",
						"acm",
						"acq",
						"acw",
						"acx",
						"acy",
						"adf",
						"ads",
						"aeb",
						"aec",
						"afb",
						"ajp",
						"apc",
						"apd",
						"arb",
						"arq",
						"ars",
						"ary",
						"arz",
						"auz",
						"avl",
						"ayh",
						"ayl",
						"ayn",
						"ayp",
						"bbz",
						"pga",
						"he",
						"iw",
						"ps",
						"pbt",
						"pbu",
						"pst",
						"prp",
						"prd",
						"ug",
						"ur",
						"ydd",
						"yds",
						"yih",
						"ji",
						"yi",
						"hbo",
						"men",
						"xmn",
						"fa",
						"jpr",
						"peo",
						"pes",
						"prs",
						"dv",
						"sam"
					].indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? "rtl" : "ltr";
				}
			},
			{
				key: "createInstance",
				value: function createInstance() {
					return new I18n(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, arguments.length > 1 ? arguments[1] : void 0);
				}
			},
			{
				key: "cloneInstance",
				value: function cloneInstance() {
					var _this8 = this;
					var options$1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
					var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
					var mergedOptions = _objectSpread({}, this.options, options$1, { isClone: true });
					var clone$2 = new I18n(mergedOptions);
					[
						"store",
						"services",
						"language"
					].forEach(function(m) {
						clone$2[m] = _this8[m];
					});
					clone$2.services = _objectSpread({}, this.services);
					clone$2.services.utils = { hasLoadedNamespace: clone$2.hasLoadedNamespace.bind(clone$2) };
					clone$2.translator = new Translator(clone$2.services, clone$2.options);
					clone$2.translator.on("*", function(event) {
						for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) args[_key4 - 1] = arguments[_key4];
						clone$2.emit.apply(clone$2, [event].concat(args));
					});
					clone$2.init(mergedOptions, callback);
					clone$2.translator.options = clone$2.options;
					clone$2.translator.backendConnector.services.utils = { hasLoadedNamespace: clone$2.hasLoadedNamespace.bind(clone$2) };
					return clone$2;
				}
			}
		]);
		return I18n;
	}(EventEmitter))();
	var arr = [];
	var each = arr.forEach;
	var slice = arr.slice;
	function defaults(obj) {
		each.call(slice.call(arguments, 1), function(source) {
			if (source) {
				for (var prop in source) if (obj[prop] === void 0) obj[prop] = source[prop];
			}
		});
		return obj;
	}
	var cookie = {
		create: function create$1(name, value, minutes, domain) {
			var cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : { path: "/" };
			var expires;
			if (minutes) {
				var date$2 = /* @__PURE__ */ new Date();
				date$2.setTime(date$2.getTime() + minutes * 60 * 1e3);
				expires = "; expires=" + date$2.toUTCString();
			} else expires = "";
			domain = domain ? "domain=" + domain + ";" : "";
			cookieOptions = Object.keys(cookieOptions).reduce(function(acc, key) {
				return acc + ";" + key.replace(/([A-Z])/g, function($1) {
					return "-" + $1.toLowerCase();
				}) + "=" + cookieOptions[key];
			}, "");
			document.cookie = name + "=" + encodeURIComponent(value) + expires + ";" + domain + cookieOptions;
		},
		read: function read(name) {
			var nameEQ = name + "=";
			var ca$1 = document.cookie.split(";");
			for (var i$1 = 0; i$1 < ca$1.length; i$1++) {
				var c = ca$1[i$1];
				while (c.charAt(0) === " ") c = c.substring(1, c.length);
				if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
			}
			return null;
		},
		remove: function remove$1(name) {
			this.create(name, "", -1);
		}
	};
	var cookie$1 = {
		name: "cookie",
		lookup: function lookup(options$1) {
			var found;
			if (options$1.lookupCookie && typeof document !== "undefined") {
				var c = cookie.read(options$1.lookupCookie);
				if (c) found = c;
			}
			return found;
		},
		cacheUserLanguage: function cacheUserLanguage(lng, options$1) {
			if (options$1.lookupCookie && typeof document !== "undefined") cookie.create(options$1.lookupCookie, lng, options$1.cookieMinutes, options$1.cookieDomain, options$1.cookieOptions);
		}
	};
	var querystring = {
		name: "querystring",
		lookup: function lookup(options$1) {
			var found;
			if (typeof window !== "undefined") {
				var params = window.location.search.substring(1).split("&");
				for (var i$1 = 0; i$1 < params.length; i$1++) {
					var pos = params[i$1].indexOf("=");
					if (pos > 0) {
						if (params[i$1].substring(0, pos) === options$1.lookupQuerystring) found = params[i$1].substring(pos + 1);
					}
				}
			}
			return found;
		}
	};
	var hasLocalStorageSupport;
	try {
		hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
		var testKey = "i18next.translate.boo";
		window.localStorage.setItem(testKey, "foo");
		window.localStorage.removeItem(testKey);
	} catch (e$1) {
		hasLocalStorageSupport = false;
	}
	var localStorage$1 = {
		name: "localStorage",
		lookup: function lookup(options$1) {
			var found;
			if (options$1.lookupLocalStorage && hasLocalStorageSupport) {
				var lng = window.localStorage.getItem(options$1.lookupLocalStorage);
				if (lng) found = lng;
			}
			return found;
		},
		cacheUserLanguage: function cacheUserLanguage(lng, options$1) {
			if (options$1.lookupLocalStorage && hasLocalStorageSupport) window.localStorage.setItem(options$1.lookupLocalStorage, lng);
		}
	};
	var hasSessionStorageSupport;
	try {
		hasSessionStorageSupport = window !== "undefined" && window.sessionStorage !== null;
		var testKey$1 = "i18next.translate.boo";
		window.sessionStorage.setItem(testKey$1, "foo");
		window.sessionStorage.removeItem(testKey$1);
	} catch (e$1) {
		hasSessionStorageSupport = false;
	}
	var sessionStorage = {
		name: "sessionStorage",
		lookup: function lookup(options$1) {
			var found;
			if (options$1.lookupsessionStorage && hasSessionStorageSupport) {
				var lng = window.sessionStorage.getItem(options$1.lookupsessionStorage);
				if (lng) found = lng;
			}
			return found;
		},
		cacheUserLanguage: function cacheUserLanguage(lng, options$1) {
			if (options$1.lookupsessionStorage && hasSessionStorageSupport) window.sessionStorage.setItem(options$1.lookupsessionStorage, lng);
		}
	};
	var navigator$1 = {
		name: "navigator",
		lookup: function lookup(options$1) {
			var found = [];
			if (typeof navigator !== "undefined") {
				if (navigator.languages) for (var i$1 = 0; i$1 < navigator.languages.length; i$1++) found.push(navigator.languages[i$1]);
				if (navigator.userLanguage) found.push(navigator.userLanguage);
				if (navigator.language) found.push(navigator.language);
			}
			return found.length > 0 ? found : void 0;
		}
	};
	var htmlTag = {
		name: "htmlTag",
		lookup: function lookup(options$1) {
			var found;
			var htmlTag$1 = options$1.htmlTag || (typeof document !== "undefined" ? document.documentElement : null);
			if (htmlTag$1 && typeof htmlTag$1.getAttribute === "function") found = htmlTag$1.getAttribute("lang");
			return found;
		}
	};
	var path = {
		name: "path",
		lookup: function lookup(options$1) {
			var found;
			if (typeof window !== "undefined") {
				var language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
				if (language instanceof Array) if (typeof options$1.lookupFromPathIndex === "number") {
					if (typeof language[options$1.lookupFromPathIndex] !== "string") return;
					found = language[options$1.lookupFromPathIndex].replace("/", "");
				} else found = language[0].replace("/", "");
			}
			return found;
		}
	};
	var subdomain = {
		name: "subdomain",
		lookup: function lookup(options$1) {
			var found;
			if (typeof window !== "undefined") {
				var language = window.location.href.match(/(?:http[s]*\:\/\/)*(.*?)\.(?=[^\/]*\..{2,5})/gi);
				if (language instanceof Array) if (typeof options$1.lookupFromSubdomainIndex === "number") found = language[options$1.lookupFromSubdomainIndex].replace("http://", "").replace("https://", "").replace(".", "");
				else found = language[0].replace("http://", "").replace("https://", "").replace(".", "");
			}
			return found;
		}
	};
	function getDefaults() {
		return {
			order: [
				"querystring",
				"cookie",
				"localStorage",
				"sessionStorage",
				"navigator",
				"htmlTag"
			],
			lookupQuerystring: "lng",
			lookupCookie: "i18next",
			lookupLocalStorage: "i18nextLng",
			caches: ["localStorage"],
			excludeCacheFor: ["cimode"],
			checkWhitelist: true,
			checkForSimilarInWhitelist: false
		};
	}
	var Browser = /* @__PURE__ */ function() {
		function Browser$1(services) {
			var options$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
			_classCallCheck(this, Browser$1);
			this.type = "languageDetector";
			this.detectors = {};
			this.init(services, options$1);
		}
		_createClass(Browser$1, [
			{
				key: "init",
				value: function init(services) {
					var options$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
					var i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
					this.services = services;
					this.options = defaults(options$1, this.options || {}, getDefaults());
					if (this.options.checkForSimilarInWhitelist) this.options.checkWhitelist = true;
					if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
					this.i18nOptions = i18nOptions;
					this.addDetector(cookie$1);
					this.addDetector(querystring);
					this.addDetector(localStorage$1);
					this.addDetector(sessionStorage);
					this.addDetector(navigator$1);
					this.addDetector(htmlTag);
					this.addDetector(path);
					this.addDetector(subdomain);
				}
			},
			{
				key: "addDetector",
				value: function addDetector(detector) {
					this.detectors[detector.name] = detector;
				}
			},
			{
				key: "detect",
				value: function detect(detectionOrder) {
					var _this = this;
					if (!detectionOrder) detectionOrder = this.options.order;
					var detected = [];
					detectionOrder.forEach(function(detectorName) {
						if (_this.detectors[detectorName]) {
							var lookup = _this.detectors[detectorName].lookup(_this.options);
							if (lookup && typeof lookup === "string") lookup = [lookup];
							if (lookup) detected = detected.concat(lookup);
						}
					});
					var found;
					detected.forEach(function(lng) {
						if (found) return;
						var cleanedLng = _this.services.languageUtils.formatLanguageCode(lng);
						if (!_this.options.checkWhitelist || _this.services.languageUtils.isWhitelisted(cleanedLng)) found = cleanedLng;
						if (!found && _this.options.checkForSimilarInWhitelist) found = _this.getSimilarInWhitelist(cleanedLng);
					});
					if (!found) {
						var fallbacks = this.i18nOptions.fallbackLng;
						if (typeof fallbacks === "string") fallbacks = [fallbacks];
						if (!fallbacks) fallbacks = [];
						if (Object.prototype.toString.apply(fallbacks) === "[object Array]") found = fallbacks[0];
						else found = fallbacks[0] || fallbacks["default"] && fallbacks["default"][0];
					}
					return found;
				}
			},
			{
				key: "cacheUserLanguage",
				value: function cacheUserLanguage(lng, caches) {
					var _this2 = this;
					if (!caches) caches = this.options.caches;
					if (!caches) return;
					if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
					caches.forEach(function(cacheName) {
						if (_this2.detectors[cacheName]) _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
					});
				}
			},
			{
				key: "getSimilarInWhitelist",
				value: function getSimilarInWhitelist(cleanedLng) {
					var _this3 = this;
					if (!this.i18nOptions.whitelist) return;
					if (cleanedLng.includes("-")) {
						var prefix = cleanedLng.split("-")[0];
						var cleanedPrefix = this.services.languageUtils.formatLanguageCode(prefix);
						if (this.services.languageUtils.isWhitelisted(cleanedPrefix)) return cleanedPrefix;
						cleanedLng = cleanedPrefix;
					}
					var similar = this.i18nOptions.whitelist.find(function(whitelistLng) {
						var cleanedWhitelistLng = _this3.services.languageUtils.formatLanguageCode(whitelistLng);
						if (cleanedWhitelistLng.startsWith(cleanedLng)) return cleanedWhitelistLng;
					});
					if (similar) return similar;
				}
			}
		]);
		return Browser$1;
	}();
	Browser.type = "languageDetector";
	var i18nextBrowserLanguageDetector_default = Browser;
	var translation_default = { fes: {
		"autoplay": "The media that tried to play (with '{{src}}') wasn't allowed to by this browser, most likely due to the browser's autoplay policy.\n\n+ More info: {{url}}",
		"checkUserDefinedFns": "It seems that you may have accidentally written {{name}} instead of {{actualName}}. Please correct it if it's not intentional.",
		"fileLoadError": {
			"bytes": "It looks like there was a problem loading your file. {{suggestion}}",
			"font": "It looks like there was a problem loading your font. {{suggestion}}",
			"gif": "There was some trouble loading your GIF. Make sure that your GIF is using 87a or 89a encoding.",
			"image": "It looks like there was a problem loading your image. {{suggestion}}",
			"json": "It looks like there was a problem loading your JSON file. {{suggestion}}",
			"large": "If your large file isn't fetched successfully, we recommend splitting the file into smaller segments and fetching those.",
			"strings": "It looks like there was a problem loading your text file. {{suggestion}}",
			"suggestion": "Try checking if the file path ({{filePath}}) is correct, hosting the file online, or running a local server.\n\n+ More info: {{url}}",
			"table": "It looks like there was a problem loading your table file. {{suggestion}}",
			"xml": "It looks like there was a problem loading your XML file. {{suggestion}}"
		},
		"friendlyParamError": {
			"type_EMPTY_VAR": "{{location}} {{func}}() was expecting {{formatType}} for the {{position}} parameter, received an empty variable instead. If not intentional, this is often a problem with scope.\n\n+ More info: {{url}}",
			"type_TOO_FEW_ARGUMENTS": "{{location}} {{func}}() was expecting at least {{minParams}} arguments, but received only {{argCount}}.",
			"type_TOO_MANY_ARGUMENTS": "{{location}} {{func}}() was expecting no more than {{maxParams}} arguments, but received {{argCount}}.",
			"type_WRONG_TYPE": "{{location}} {{func}}() was expecting {{formatType}} for the {{position}} parameter, received {{argType}} instead."
		},
		"globalErrors": {
			"reference": {
				"cannotAccess": "\n{{location}} \"{{symbol}}\" is used before declaration. Make sure you have declared the variable before using it.\n\n+ More info: {{url}}",
				"notDefined": "\n{{location}} \"{{symbol}}\" is not defined in the current scope. If you have defined it in your code, you should check its scope, spelling, and letter-casing (JavaScript is case-sensitive).\n\n+ More info: {{url}}"
			},
			"stackSubseq": "└[{{location}}] \n	 Called from line {{line}} in {{func}}()\n",
			"stackTop": "┌[{{location}}] \n	 Error at line {{line}} in {{func}}()\n",
			"syntax": {
				"badReturnOrYield": "\nSyntax Error - return lies outside of a function. Make sure you’re not missing any brackets, so that return lies inside a function.\n\n+ More info: {{url}}",
				"invalidToken": "\nSyntax Error - Found a symbol that JavaScript doesn't recognize or didn't expect at it's place.\n\n+ More info: {{url}}",
				"missingInitializer": "\nSyntax Error - A const variable is declared but not initialized. In JavaScript, an initializer for a const is required. A value must be specified in the same statement in which the variable is declared. Check the line number in the error and assign the const variable a value.\n\n+ More info: {{url}}",
				"redeclaredVariable": "\nSyntax Error - \"{{symbol}}\" is being redeclared. JavaScript doesn't allow declaring a variable more than once. Check the line number in error for redeclaration of the variable.\n\n+ More info: {{url}}",
				"unexpectedToken": "\nSyntax Error - Symbol present at a place that wasn't expected.\nUsually this is due to a typo. Check the line number in the error for anything missing/extra.\n\n+ More info: {{url}}"
			},
			"type": {
				"constAssign": "\n{{location}} A const variable is being re-assigned. In javascript, re-assigning a value to a constant is not allowed. If you want to re-assign new values to a variable, make sure it is declared as var or let.\n\n+ More info: {{url}}",
				"notfunc": "\n{{location}} \"{{symbol}}\" could not be called as a function.\nCheck the spelling, letter-casing (JavaScript is case-sensitive) and its type.\n\n+ More info: {{url}}",
				"notfuncObj": "\n{{location}} \"{{symbol}}\" could not be called as a function.\nVerify whether \"{{obj}}\" has \"{{symbol}}\" in it and check the spelling, letter-casing (JavaScript is case-sensitive) and its type.\n\n+ More info: {{url}}",
				"readFromNull": "\n{{location}} The property of null can't be read. In javascript the value null indicates that an object has no value.\n\n+ More info: {{url}}",
				"readFromUndefined": "\n{{location}} Cannot read property of undefined. Check the line number in error and make sure the variable which is being operated is not undefined.\n\n + More info: {{url}}"
			}
		},
		"libraryError": "{{location}} An error with message \"{{error}}\" occurred inside the p5js library when {{func}} was called. If not stated otherwise, it might be an issue with the arguments passed to {{func}}.",
		"location": "[{{file}}, line {{line}}]",
		"misspelling": "{{location}} It seems that you may have accidentally written \"{{name}}\" instead of \"{{actualName}}\". Please correct it to {{actualName}} if you wish to use the {{type}} from p5.js.",
		"misspelling_plural": "{{location}} It seems that you may have accidentally written \"{{name}}\".\nYou may have meant one of the following: \n{{suggestions}}",
		"misusedTopLevel": "Did you just try to use p5.js's {{symbolName}} {{symbolType}}? If so, you may want to move it into your sketch's setup() function.\n\n+ More info: {{url}}",
		"preloadDisabled": "The preload() function has been removed in p5.js 2.0. Please load assets in setup() using async / await keywords or callbacks instead. See https://dev.to/limzykenneth/asynchronous-p5js-20-458f for more information.",
		"positions": {
			"p_1": "first",
			"p_10": "tenth",
			"p_11": "eleventh",
			"p_12": "twelfth",
			"p_2": "second",
			"p_3": "third",
			"p_4": "fourth",
			"p_5": "fifth",
			"p_6": "sixth",
			"p_7": "seventh",
			"p_8": "eighth",
			"p_9": "ninth"
		},
		"pre": "\n🌸 p5.js says: {{message}}",
		"sketchReaderErrors": {
			"reservedConst": "you have used a p5.js reserved variable \"{{symbol}}\" make sure you change the variable name to something else.\n\n+ More info: {{url}}",
			"reservedFunc": "you have used a p5.js reserved function \"{{symbol}}\" make sure you change the function name to something else.\n\n+ More info: {{url}}"
		},
		"welcome": "Welcome! This is your friendly debugger. To turn me off, switch to using p5.min.js.",
		"wrongPreload": "{{location}} An error with message \"{{error}}\" occurred inside the p5js library when \"{{func}}\" was called. If not stated otherwise, it might be due to \"{{func}}\" being called from preload. Nothing besides load calls (loadImage, loadJSON, loadFont, loadStrings, etc.) should be inside the preload function."
	} };
	var translation_default$1 = { fes: {
		"autoplay": "Su browser impidío un medio tocar (de '{{src}}'), posiblemente porque las reglas de autoplay. Para aprender más, visite {{link}}.",
		"checkUserDefinedFns": "",
		"fileLoadError": {
			"bytes": "",
			"font": "",
			"gif": "",
			"image": "",
			"json": "",
			"large": "",
			"strings": "",
			"suggestion": "",
			"table": "",
			"xml": ""
		},
		"friendlyParamError": {
			"type_EMPTY_VAR": "",
			"type_TOO_FEW_ARGUMENTS": "",
			"type_TOO_MANY_ARGUMENTS": "",
			"type_WRONG_TYPE": ""
		},
		"globalErrors": {
			"reference": {
				"cannotAccess": "",
				"notDefined": ""
			},
			"stackSubseq": "",
			"stackTop": "",
			"syntax": {
				"badReturnOrYield": "",
				"invalidToken": "",
				"missingInitializer": "",
				"redeclaredVariable": "",
				"unexpectedToken": ""
			},
			"type": {
				"constAssign": "",
				"notfunc": "",
				"notfuncObj": "",
				"readFromNull": "",
				"readFromUndefined": ""
			}
		},
		"libraryError": "",
		"location": "",
		"misspelling": "",
		"misspelling_plural": "",
		"misusedTopLevel": "",
		"positions": {
			"p_1": "",
			"p_10": "",
			"p_11": "",
			"p_12": "",
			"p_2": "",
			"p_3": "",
			"p_4": "",
			"p_5": "",
			"p_6": "",
			"p_7": "",
			"p_8": "",
			"p_9": ""
		},
		"pre": "🌸 p5.js dice: {{message}}",
		"sketchReaderErrors": {
			"reservedConst": "",
			"reservedFunc": ""
		},
		"welcome": "",
		"wrongPreload": ""
	} };
	var translation_default$2 = { fes: {
		"autoplay": "미디어('{{src}}')가 이 브라우저에서는 재생되지 않았습니다. 사용하고 계신 브라우저의 자동 재생 정책 때문일 수 있습니다.\n\n+ 추가 정보: {{url}}",
		"checkUserDefinedFns": "혹시 {{actualName}} 대신 {{name}}를 쓴 것이 아닌지 살펴보세요.",
		"fileLoadError": {
			"bytes": "파일을 로드하는 중에 문제가 발생했습니다. {{suggestion}}",
			"font": "글꼴을 로드하는 중에 문제가 발생했습니다. {{suggestion}}",
			"gif": "GIF 파일을 로드하는 중에 문제가 발생했습니다. GIF 파일의 인코딩 방식이 87a이거나 89a인지를 확인해보세요.",
			"image": "이미지를 로드하는 중에 문제가 발생했습니다. {{suggestion}}",
			"json": "JSON 파일을 로드하는 중에 문제가 발생했습니다. {{suggestion}}",
			"large": "용량이 큰 파일을 한꺼번에 로드하는 중에 문제가 발생했습니다. 파일 용량을 줄여 보세요.",
			"strings": "텍스트 파일을 로드하는 중에 문제가 발생했습니다. {{suggestion}}",
			"suggestion": "파일 경로({{filePath}})가 올바른지 확인해보세요. 혹은 해당 파일을 호스팅 서비스를 이용하거나 로컬 서버를 구동하여 웹에 올리는 방법을 고려해 보세요.\n\n+ 추가 정보: {{url}}",
			"table": "테이블 파일을 로드하는 중에 문제가 발생했습니다. {{suggestion}}",
			"xml": "XML 파일을 로드하는 중에 문제가 발생했습니다. {{suggestion}}"
		},
		"friendlyParamError": {
			"type_EMPTY_VAR": "{{location}} {{formatType}} 타입 값을 받는 {{func}}()의 {{position}} 매개변수(parameter)에 아무 값도 전달되지 않았습니다. 범위(scope)와 관련된 문제일 수 있습니다.\n\n+ 추가 정보: {{url}}",
			"type_TOO_FEW_ARGUMENTS": "{{location}} 최소 {{minParams}}개의 인수(argument)를 받는 함수 {{func}}()에 인수가 {{argCount}}개만 입력되었습니다.",
			"type_TOO_MANY_ARGUMENTS": "{{location}} 최대 {{maxParams}}개의 인수(argument)를 받는 함수 {{func}}()에 인수가 {{argCount}}개나 입력되었습니다.",
			"type_WRONG_TYPE": "{{location}} {{formatType}} 타입의 값을 받는 {{func}}()의 {{position}} 매개변수(parameter)에 {{argType}} 타입의 값이 입력되었습니다."
		},
		"globalErrors": {
			"reference": {
				"cannotAccess": "\n{{location}} \"{{symbol}}\"가 선언되지 않은 채 사용되었습니다. 변수를 사용하기 전, 먼저 선언했는지 확인해보세요.\n\n+ 추가 정보: {{url}}",
				"notDefined": "\n{{location}} \"{{symbol}}\"은 현재 범위(scope) 안에 정의되지 않았습니다. 만약 정의를 했다면, 해당 범위와 오탈자, 대소문자 등을 확인해보세요 (자바스크립트에서는 대소문자를 구분합니다).\n\n+ 추가 정보: {{url}}"
			},
			"stackSubseq": "└[{{location}}] \n	 {{func}}()에 있는 줄{{line}}에서 호출\n",
			"stackTop": "┌[{{location}}] \n	 {{func}}()에 있는 줄{{line}}에서 오류 발생\n",
			"syntax": {
				"badReturnOrYield": "\n구문 오류 - 대괄호가 제대로 쓰였는지 확인해 본 후, return을 함수 안에 넣어주세요.\n\n+ 추가 정보: {{url}}",
				"invalidToken": "\n구문 오류 - 자바스크립트가 인식할 수 없거나, 적합하지 않은 기호나 문구가 입력되었습니다.\n\n+ 추가 정보: {{url}}",
				"missingInitializer": "\n구문 오류 - const 변수가 선언되었지만 초기화되지 않았습니다. 변수가 선언된 명령문 안에서 값을 지정해주세요.\n\n+ 추가 정보: {{url}}",
				"redeclaredVariable": "\n구문 오류 - 이미 선언된 \"{{symbol}}\"가 재선언되었습니다. 자바스크립트에서는 같은 변수를 한 번 이상 선언할 수 없습니다.\n\n+ 추가 정보: {{url}}",
				"unexpectedToken": "\n구문 오류 - 입력된 문구가 예상하지 못한 위치에 있습니다.보통 이런 상황은 오탈자 때문에 일어나는 경우가 많습니다. 누락되거나 추가된 내용이 없는지 확인하세요.\n\n+ 추가 정보: {{url}}"
			},
			"type": {
				"constAssign": "\n{{location}} const 변수가 재지정되었습니다. 자바스크립트에서는 const 변수에 다른 값을 여러 번 지정할 수 없으므로 새로운 값을 여러 번 지정하시려면, const 대신 var나 let을 써서 변수를 선언해 주세요.\n\n+ 추가 정보: {{url}}",
				"notfunc": "\n{{location}} \"{{symbol}}\"는 함수로 호출할 수 없습니다. 타입과 오탈자, 대소문자 등을 확인해주세요.\n\n+ 추가 정보: {{url}}",
				"notfuncObj": "\n{{location}} \"{{symbol}}\"는 함수로 호출할 수 없습니다. \"{{obj}}\"가 \"{{symbol}}\"를 가지고 있는지 살펴보고, 타입과 오탈자, 대소문자 등을 확인해주세요.\n\n+ 추가 정보: {{url}}",
				"readFromNull": "\n{{location}} null의 속성(property)을 읽을 수 없습니다. 자바스크립트에서 null이란, 객체(object)에 주어진 값이 비어있다는 뜻입니다.\n\n+ 추가 정보: {{url}}",
				"readFromUndefined": "\n{{location}} undefined의 속성(property)을 읽을 수 없습니다. 혹시 연산 중인 변수가 정의되지 않았는지 확인하세요.\n\n+ 추가 정보: {{url}}"
			}
		},
		"libraryError": "{{location}} 함수 {{func}}가 호출되었을 때,  \"{{error}}\" 오류가 p5js 라이브러리 내에서 발생했습니다. 함수 {{func}}에 전달한 인수(argument)가 문제일 수 있습니다.",
		"location": "[{{file}}, 줄{{line}}]",
		"misspelling": "{{location}} 혹시 p5.js의 {{type}}를 사용하시려면 \"{{name}}\"를 {{actualName}}로 고쳐 보세요.",
		"misspelling_plural": "{{location}} 혹시 p5.js의 {{type}}를 사용하시려면 \"{{name}}\"를 다음 중 하나로 고쳐보세요: \n{{suggestions}}",
		"misusedTopLevel": "{{location}} 혹시 p5.js의 {{symbolType}} 타입 {{symbolName}}을 사용하셨나요? 그렇다면 {{symbolName}}을 작성 중인 setup() 함수의 대괄호 안으로 옮겨보세요.\n\n+ 추가 정보: {{url}}",
		"positions": {
			"p_1": "1번째",
			"p_10": "10번째",
			"p_11": "11번째",
			"p_12": "12번째",
			"p_2": "2번째",
			"p_3": "3번째",
			"p_4": "4번째",
			"p_5": "5번째",
			"p_6": "6번째",
			"p_7": "7번째",
			"p_8": "8번째",
			"p_9": "9번째"
		},
		"pre": "\n🌸 p5.js says: {{message}}",
		"sketchReaderErrors": {
			"reservedConst": "p5.js에서 이미 쓰고 있는 변수 \"{{symbol}}\"를 사용하셨습니다. 해당 변수를 다른 이름으로 바꾸어 주세요.\n\n+ 추가 정보: {{url}}",
			"reservedFunc": "p5.js에서 이미 쓰고 있는 함수 \"{{symbol}}\"를 사용하셨습니다. 해당 함수를 다른 이름으로 바꾸어 주세요.\n\n+ 추가 정보: {{url}}"
		},
		"welcome": "{{logo}} 환영합니다, 이 메세지는 에러를 찾는 디버깅 안내문입니다. 안내가 필요없는 경우 p5.js대신 p5.min.js를 사용하세요.",
		"wrongPreload": "{{location}} \"{{func}}\"가 호출되며 p5js 라이브러리 내부에서 다음 오류가 발생했습니다: \"{{error}}\".\n\n 함수 \"{{func}}\"가 preload()에서 호출되었기 때문일 수 있습니다. preload() 함수 안에서는 지정된 함수(예: loadImage, loadJSON, loadFont, loadStrings 등)만 호출할 수 있습니다."
	} };
	var translation_default$3 = { fes: {
		"autoplay": "尝试播放（使用'{{src}}'）的媒体在此浏览器中被禁止，很可能是由于浏览器的自动播放策略。\n\n+ 更多信息：{{url}}",
		"checkUserDefinedFns": "看起来您可能在{{name}}处意外写错了，应该是{{actualName}}。如果这不是故意的，请进行更正。",
		"fileLoadError": {
			"bytes": "似乎在加载文件时出现了问题。{{suggestion}}",
			"font": "似乎在加载字体时出现了问题。{{suggestion}}",
			"gif": "加载GIF时出现了问题。请确保您的GIF使用87a或89a编码。",
			"image": "似乎在加载图像时出现了问题。{{suggestion}}",
			"json": "似乎在加载JSON文件时出现了问题。{{suggestion}}",
			"large": "如果您无法成功获取大型文件，我们建议将文件分割成较小的段并获取这些段。",
			"strings": "似乎在加载文本文件时出现了问题。{{suggestion}}",
			"suggestion": "尝试检查文件路径（{{filePath}}）是否正确，将文件托管在线上或运行本地服务器。\n\n+ 更多信息：{{url}}",
			"table": "似乎在加载表格文件时出现了问题。{{suggestion}}",
			"xml": "似乎在加载XML文件时出现了问题。{{suggestion}}"
		},
		"friendlyParamError": {
			"type_EMPTY_VAR": "{{location}} {{func}}() 期望的是{{formatType}}类型的{{position}}参数，而接收到了一个空变量。如果这不是故意的，通常是作用域的问题。\n\n+ 更多信息：{{url}}",
			"type_TOO_FEW_ARGUMENTS": "{{location}} {{func}}() 期望至少{{minParams}}个参数，但只收到了{{argCount}}个。",
			"type_TOO_MANY_ARGUMENTS": "{{location}} {{func}}() 期望最多{{maxParams}}个参数，但收到了{{argCount}}个。",
			"type_WRONG_TYPE": "{{location}} {{func}}() 期望的是{{formatType}}类型的{{position}}参数，而接收到了{{argType}}类型。"
		},
		"globalErrors": {
			"reference": {
				"cannotAccess": "\n{{location}} 在声明之前使用了\"{{symbol}}\"。请确保在使用之前已经声明了该变量。\n\n+ 更多信息：{{url}}",
				"notDefined": "\n{{location}} 在当前范围中未定义\"{{symbol}}\"。如果您已经在代码中定义了它，请检查其作用域、拼写和大小写（JavaScript区分大小写）。\n\n+ 更多信息：{{url}}"
			},
			"stackSubseq": "└[{{location}}] \n	 在{{func}}()中的第{{line}}行调用\n",
			"stackTop": "┌[{{location}}] \n	 在{{func}}()的第{{line}}行出现错误\n",
			"syntax": {
				"badReturnOrYield": "\n语法错误 - return位于函数外部。请确保没有漏掉任何括号，以便return位于函数内部。\n\n+ 更多信息：{{url}}",
				"invalidToken": "\n语法错误 - 发现了JavaScript不识别或不期望的符号。\n\n+ 更多信息：{{url}}",
				"missingInitializer": "\n语法错误 - 声明了一个const变量但没有初始化。在JavaScript中，const必须要有初始值。在同一语句中必须指定值来声明变量。请检查错误中的行号并给const变量赋值。\n\n+ 更多信息：{{url}}",
				"redeclaredVariable": "\n语法错误 - \"{{symbol}}\" 正在被重新声明。JavaScript不允许重复声明变量。请检查错误中的行号是否重新声明了该变量。\n\n+ 更多信息：{{url}}",
				"unexpectedToken": "\n语法错误 - 符号出现在不应该出现的位置。\n通常这是由于拼写错误。请检查错误中的行号是否有缺少或多余的内容。\n\n+ 更多信息：{{url}}"
			},
			"type": {
				"constAssign": "\n{{location}} 正在重新赋值const变量。在JavaScript中，不允许对常量进行重新赋值。如果要给变量重新赋值，请确保声明为var或let。\n\n+ 更多信息：{{url}}",
				"notfunc": "\n{{location}} 无法将\"{{symbol}}\" 调用为函数。\n请检查拼写、大小写（JavaScript区分大小写）和其类型。\n\n+ 更多信息：{{url}}",
				"notfuncObj": "\n{{location}} 无法将\"{{symbol}}\" 调用为函数。\n请验证\"{{obj}}\"是否包含\"{{symbol}}\"，并检查拼写、大小写（JavaScript区分大小写）和其类型。\n\n+ 更多信息：{{url}}",
				"readFromNull": "\n{{location}} 无法读取null的属性。在JavaScript中，null表示对象没有值。\n\n+ 更多信息：{{url}}",
				"readFromUndefined": "\n{{location}} 无法读取undefined的属性。请检查错误中的行号并确保正在操作的变量不是undefined。\n\n+ 更多信息：{{url}}"
			}
		},
		"libraryError": "{{location}} 在调用{{func}}时，在p5js库内部出现了一条错误消息\"{{error}}\"。除非另有说明，否则可能是与传递给{{func}}的参数有关的问题。",
		"location": "[{{file}}，第{{line}}行]",
		"misspelling": "{{location}} 看起来您可能在{{name}}处意外写错了，应该是\"{{actualName}}\"。如果希望使用p5.js中的{{type}}，请将其更正为{{actualName}}。",
		"misspelling_plural": "{{location}} 看起来您可能在{{name}}处意外写错了。\n您可能指的是以下之一：\n{{suggestions}}",
		"misusedTopLevel": "您刚刚尝试使用了p5.js的{{symbolType}} {{symbolName}}吗？如果是，请将其移到您的sketch的setup()函数中。\n\n+ 更多信息：{{url}}",
		"positions": {
			"p_1": "第一",
			"p_10": "第十",
			"p_11": "第十一",
			"p_12": "第十二",
			"p_2": "第二",
			"p_3": "第三",
			"p_4": "第四",
			"p_5": "第五",
			"p_6": "第六",
			"p_7": "第七",
			"p_8": "第八",
			"p_9": "第九"
		},
		"pre": "\n🌸 p5.js 说：{{message}}",
		"sketchReaderErrors": {
			"reservedConst": "您使用了p5.js的保留变量\"{{symbol}}\"，请确保将变量名更改为其他名称。\n\n+ 更多信息：{{url}}",
			"reservedFunc": "您使用了p5.js的保留函数\"{{symbol}}\"，请确保将函数名更改为其他名称。\n\n+ 更多信息：{{url}}"
		},
		"welcome": "欢迎！这是您友好的调试程序。要关闭我，请切换到使用p5.min.js。",
		"wrongPreload": "{{location}} 在调用\"{{func}}\"时，在p5js库内部出现了一条错误消息\"{{error}}\"。除非另有说明，否则可能是由于在preload中调用了\"{{func}}\"。preload函数之外不应该包含除load函数（loadImage、loadJSON、loadFont、loadStrings等）以外的内容。"
	} };
	var translation_default$4 = { fes: {
		"autoplay": "जिस मीडिया को चलाने की कोशिश की गई ('{{src}}' के साथ) उसे इस ब्राउज़र द्वारा अनुमति नहीं दी गई, संभवतः ब्राउज़र की स्वत: प्ले नीति के कारण।\n\n+ अधिक जानकारी: {{url}}",
		"checkUserDefinedFns": "ऐसा लगता है कि आपने गलती से {{actualName}} की जगह {{name}} लिख दिया है। यदि यह जानबूझकर नहीं किया गया है तो कृपया इसे सुधारें।",
		"fileLoadError": {
			"bytes": "ऐसा लगता है कि आपकी फ़ाइल लोड करने में कोई समस्या थी। {{suggestion}}",
			"font": "ऐसा लगता है कि आपका मुद्रलिपि लोड करने में कोई समस्या थी। {{suggestion}}",
			"gif": "आपकी GIF लोड करने में कुछ समस्या हुई। सुनिश्चित करें कि आपका GIF 87a या 89a एन्कोडिंग का उपयोग कर रहा है।",
			"image": "ऐसा लगता है कि आपकी छवि लोड करने में कोई समस्या थी। {{suggestion}}",
			"json": "ऐसा लगता है कि आपकी JSON फ़ाइल लोड करने में कोई समस्या थी। {{suggestion}}",
			"large": "यदि आपकी बड़ी फ़ाइल सफलतापूर्वक नहीं लाई गई है, तो हम फ़ाइल को छोटे खंडों में विभाजित करने और उन्हें लाने की सलाह देते हैं।",
			"strings": "ऐसा लगता है कि आपकी पाठ फ़ाइल लोड करने में कोई समस्या थी। {{suggestion}}",
			"suggestion": "यह जाँचने का प्रयास करें कि फ़ाइल पथ ({{filePath}}) सही है या नहीं, फ़ाइल को ऑनलाइन होस्ट करना, या स्थानीय सर्वर चलाना।\n\n+ अधिक जानकारी: {{url}}",
			"table": "ऐसा लगता है कि आपकी तालिका फ़ाइल लोड करने में कोई समस्या थी। {{suggestion}}",
			"xml": "ऐसा लगता है कि आपकी XML फ़ाइल लोड करने में कोई समस्या थी। {{suggestion}}"
		},
		"friendlyParamError": {
			"type_EMPTY_VAR": "{{location}} {{func}}() {{position}} प्राचल के लिए {{formatType}} की अपेक्षा कर रहा था, इसके बजाय एक खाली चर प्राप्त हुआ। यदि जानबूझकर नहीं किया गया है, तो यह अक्सर दायरे के साथ एक समस्या है।\n\n+ अधिक जानकारी:{{url}}",
			"type_TOO_FEW_ARGUMENTS": "{{location}} {{func}}() कम से कम {{minParams}} तर्कों की अपेक्षा थी, लेकिन केवल प्राप्त हुए {{argCount}}.",
			"type_TOO_MANY_ARGUMENTS": "{{location}} {{func}}() {{maxParams}} से अधिक तर्कों की अपेक्षा नहीं कर रहा था, लेकिन प्राप्त हुआ {{argCount}}.",
			"type_WRONG_TYPE": "{{location}} {{func}}() {{position}} प्राचल के लिए {{formatType}} की अपेक्षा कर रहा था, इसके बजाय {{argType}} प्राप्त हुआ।"
		},
		"globalErrors": {
			"reference": {
				"cannotAccess": "\n{{location}} \"{{symbol}}\" घोषणा से पहले प्रयोग किया जाता है। सुनिश्चित करें कि आपने चर का उपयोग करने से पहले उसे घोषित कर दिया है।\n\n+ अधिक जानकारी: {{url}}",
				"notDefined": "\n{{location}} \"{{symbol}}\" वर्तमान दायरे में परिभाषित नहीं है। यदि आपने इसे अपने कोड में परिभाषित किया है, तो आपको इसका दायरा, वर्तनी और अक्षर-आवरण जांचना चाहिए (JavaScript केस-संवेदी है)।\n\n+ अधिक जानकारी: {{url}}"
			},
			"stackSubseq": "└[{{location}}] \n	 {{func}}() में पंक्ति {{line}} से आह्वान किया गया\n",
			"stackTop": "┌[{{location}}] \n	 {{func}}() में पंक्ति {{line}} पर त्रुटि\n",
			"syntax": {
				"badReturnOrYield": "\nवाक्य - विन्यास त्रुटि - रिटर्न किसी फ़ंक्शन के बाहर होता है। सुनिश्चित करें कि आपसे कोई कोष्ठक नहीं छूट रहा है, ताकि रिटर्न किसी फ़ंक्शन के अंदर हो।\n\n+ अधिक जानकारी: {{url}}",
				"invalidToken": "\nवाक्य - विन्यास त्रुटि - एक ऐसा प्रतीक मिला जिसे जावास्क्रिप्ट नहीं पहचानता या अपने स्थान पर अपेक्षित नहीं था।\n\n+ अधिक जानकारी: {{url}}",
				"missingInitializer": "\nवाक्य - विन्यास त्रुटि - एक नियत चर घोषित किया गया है लेकिन प्रारंभ नहीं किया गया है। जावास्क्रिप्ट में, एक नियत के लिए प्रारंभकर्ता की आवश्यकता होती है। एक मान उसी कथन में निर्दिष्ट किया जाना चाहिए जिसमें चर घोषित किया गया है। त्रुटि में पंक्ति संख्या की जाँच करें और स्थिरांक चर को एक मान निर्दिष्ट करें।\n\n+ अधिक जानकारी: {{url}}",
				"redeclaredVariable": "\nवाक्य - विन्यास त्रुटि - \"{{symbol}}\" पुनः घोषित किया जा रहा है। जावास्क्रिप्ट एक चर को एक से अधिक बार घोषित करने की अनुमति नहीं देता है। चर की पुनः घोषणा के लिए त्रुटि वाली पंक्ति संख्या की जाँच करें।\n\n+ अधिक जानकारी: {{url}}",
				"unexpectedToken": "\nवाक्य - विन्यास त्रुटि - प्रतीक ऐसे स्थान पर मौजूद है जिसकी अपेक्षा नहीं थी।\nआम तौर पर यह टंकण त्रुटि के कारण होता है। किसी भी गुम/अतिरिक्त चीज़ के लिए त्रुटि में पंक्ति नंबर की जाँच करें।\n\n+ अधिक जानकारी: {{url}}"
			},
			"type": {
				"constAssign": "\n{{location}} एक नियत चर को फिर से असाइन किया जा रहा है। जावास्क्रिप्ट में, किसी स्थिरांक को दोबारा मान निर्दिष्ट करने की अनुमति नहीं है। यदि आप किसी चर के लिए नए मान पुनः निर्दिष्ट करना चाहते हैं, तो सुनिश्चित करें कि इसे var या Let के रूप में घोषित किया गया है।\n\n+ अधिक जानकारी: {{url}}",
				"notfunc": "\n{{location}} \"{{symbol}}\" फ़ंक्शन के रूप में नहीं बुलाया जा सका।\nवर्तनी, अक्षर-आवरण (जावास्क्रिप्ट केस-संवेदी है) और उसके प्रकार की जाँच करें।\n\n+ अधिक जानकारी: {{url}}",
				"notfuncObj": "\n{{location}} \"{{symbol}}\" फ़ंक्शन के रूप में नहीं बुलाया जा सका।\nसत्यापित करें कि क्या \"{{obj}}\" में \"{{symbol}}\" है और वर्तनी, अक्षर-आवरण (जावास्क्रिप्ट केस-संवेदी है) और उसके प्रकार की जांच करें।\n\n+ अधिक जानकारी: {{url}}",
				"readFromNull": "\n{{location}} null की संपत्ति को पढ़ा नहीं जा सकता. जावास्क्रिप्ट में मान null इंगित करता है कि किसी ऑब्जेक्ट का कोई मूल्य नहीं है।\n\n+ अधिक जानकारी: {{url}}",
				"readFromUndefined": "\n{{location}} undefined की संपत्ति नहीं पढ़ सकता. त्रुटि वाली पंक्ति संख्या की जाँच करें और सुनिश्चित करें कि जो चर संचालित किया जा रहा है वह अपरिभाषित नहीं है।\n\n + अधिक जानकारी: {{url}}"
			}
		},
		"libraryError": "{{location}} जब {{func}} को आह्वान किया गया तो p5js लाइब्रेरी के अंदर \"{{error}}\" संदेश के साथ एक त्रुटि उत्पन्न हुई। यदि अन्यथा नहीं कहा गया है, तो यह {{func}} को दिए गए तर्कों के साथ एक समस्या हो सकती है।",
		"location": "[{{file}}, पंक्ति {{line}}]",
		"misspelling": "{{location}} ऐसा लगता है कि आपने गलती से \"{{actualName}}\" के स्थान पर \"{{name}}\" लिख दिया होगा। यदि आप p5.js से {{type}} का उपयोग करना चाहते हैं तो कृपया इसे सही करके {{actualName}} कर दें।",
		"misspelling_plural": "{{location}} ऐसा लगता है कि आपने गलती से \"{{name}}\" लिख दिया होगा।\nआपका मतलब निम्नलिखित में से कोई एक हो सकता है: \n{{suggestions}}",
		"misusedTopLevel": "क्या आपने अभी p5.js के {{symbolName}} {{symbolType}} का उपयोग करने का प्रयास किया? यदि ऐसा है, तो आप इसे अपने रेखा-चित्र के setup() फ़ंक्शन में ले जाना चाह सकते हैं।\n\n+ अधिक जानकारी: {{url}}",
		"positions": {
			"p_1": "पहला",
			"p_10": "दसवां",
			"p_11": "ग्यारहवें",
			"p_12": "बारहवें",
			"p_2": "दूसरा",
			"p_3": "तीसरा",
			"p_4": "चौथी",
			"p_5": "पांचवां",
			"p_6": "छठा",
			"p_7": "सातवीं",
			"p_8": "आठवाँ",
			"p_9": "नौवां"
		},
		"pre": "\n🌸 p5.js कहता है: {{message}}",
		"sketchReaderErrors": {
			"reservedConst": "आपने एक p5.js आरक्षित चर \"{{symbol}}\" का उपयोग किया है, सुनिश्चित करें कि आपने चर नाम को किसी और चीज़ में बदल दिया है।\n\n+ अधिक जानकारी: {{url}}",
			"reservedFunc": "आपने एक p5.js आरक्षित फ़ंक्शन \"{{symbol}}\" का उपयोग किया है, सुनिश्चित करें कि आपने फ़ंक्शन का नाम किसी और चीज़ में बदल दिया है।\n\n+ अधिक जानकारी: {{url}}"
		},
		"welcome": "स्वागत! यह आपका मित्रवत डिबगर है. मुझे बंद करने के लिए, p5.min.js का उपयोग करें।",
		"wrongPreload": "{{location}} जब \"{{func}}\" को आह्वान किया गया तो p5js लाइब्रेरी के अंदर \"{{error}}\" संदेश के साथ एक त्रुटि उत्पन्न हुई। यदि अन्यथा नहीं कहा गया है, तो यह \"{{func}}\" को प्रीलोड से आह्वान किए जाने के कारण हो सकता है। प्रीलोड फ़ंक्शन के अंदर लोड आह्वान (लोडछवि, लोडजेएसओएन, लोडमुद्रलिपि, लोडस्ट्रिंग्स इत्यादि) के अलावा कुछ भी नहीं होना चाहिए।"
	} };
	var translation_default$5 = { fes: {
		"autoplay": "再生しようとしたメディア({{src}})は、ブラウザから許可されませんでした。おそらくはブラウザの自動再生ポリシーによるものです。\n\n+ 詳細情報: {{url}}",
		"checkUserDefinedFns": "{{actualName}} ではなく、誤って {{name}} と書いてしまったようです。これが意図的でなければ修正してください。",
		"fileLoadError": {
			"bytes": "ファイルをロードする際に問題が発生したようです。 {{suggestion}}",
			"font": "フォントをロードする際に問題が発生したようです。 {{suggestion}}",
			"gif": "GIFをロードする際に問題が発生しました。GIFのエンコーディングが 87a または 89a であることを確認してください。",
			"image": "画像をロードする際に問題が発生したようです。 {{suggestion}}",
			"json": "JSONファイルをロードする際に問題が発生したようです。 {{suggestion}}",
			"large": "大きなファイルを正常に取得できない場合は、ファイルをより小さなセグメントに分割して、それらを取得することをおすすめします。",
			"strings": "テキストファイルをロードする際に問題が発生したようです。 {{suggestion}}",
			"suggestion": "まずはファイルパス({{filePath}})が正しいかを確認し、次にファイルがオンラインでホストされているか、ローカルサーバーを実行しているかを確認してみてください。\n\n+ 詳細情報: {{url}}",
			"table": "テーブルファイルをロードする際に問題が発生したようです。 {{suggestion}}",
			"xml": "XMLファイルをロードする際に問題が発生したようです。 {{suggestion}}"
		},
		"friendlyParamError": {
			"type_EMPTY_VAR": "{{location}} {{func}}()は{{position}}引数に {{formatType}} を期待していましたが、空の変数を受け取りました。これが意図的でなければ、通常はスコープの問題です。\n\n+ 詳細情報: {{url}}",
			"type_TOO_FEW_ARGUMENTS": "{{location}} {{func}}()は少なくとも{{minParams}}個の引数を期待していましたが、{{argCount}}個しか受け取っていません。",
			"type_TOO_MANY_ARGUMENTS": "{{location}} {{func}}()は最大{{maxParams}}個の引数を期待していますが、{{argCount}}個を受け取りました。",
			"type_WRONG_TYPE": "{{location}} {{func}}()は{{position}}引数に {{formatType}}タイプを期待していましたが、{{argType}}タイプを受け取りました。"
		},
		"globalErrors": {
			"reference": {
				"cannotAccess": "\n{{location}} \"{{symbol}}\" が宣言前に使用されています。変数を使用する前に必ず宣言してください。\n\n+ 詳細情報：: {{url}}",
				"notDefined": "\n{{location}} \"{{symbol}}\" が現在のスコープに定義されていません。コード内で定義している場合は、そのスコープ、スペル、大文字と小文字(JavaScriptは大文字と小文字を区別します)を確認してください。\n\n+ 詳細情報： {{url}}"
			},
			"stackSubseq": "└[{{location}}] \n	 {{line}}行目( {{func}}()内 )から呼び出されました\n",
			"stackTop": "┌[{{location}}] \n	 {{line}}行目( {{func}}()内 )でエラーが発生しました\n",
			"syntax": {
				"badReturnOrYield": "\n構文エラー - returnが関数外で使用されています。括弧を忘れずに、returnが関数内で使用されていることを確認してください。\n\n+ 詳細情報: {{url}}",
				"invalidToken": "\n構文エラー - JavaScriptが認識しないか、期待していないシンボルが見つかりました。\n\n+ 詳細情報: {{url}}",
				"missingInitializer": "\n構文エラー - 定数が宣言されていますが初期化されていません。JavaScriptでは const には初期値が必要です。変数を宣言する際に同じ文内で値を指定する必要があります。エラーの行番号を確認して定数に値を割り当ててください。\n\n+ 詳細情報: {{url}}",
				"redeclaredVariable": "\n構文エラー - \"{{symbol}}\" が再宣言されています。JavaScriptでは変数を再宣言することはできません。エラーの行番号でその変数が再宣言されていないか確認してください。\n\n+ 詳細情報: {{url}}",
				"unexpectedToken": "\n構文エラー - 予期しない場所にシンボルがあります。\n通常はタイプミスが原因です。エラー内の行番号を確認し、不足や余分なものがないか確認してください。\n\n+ 詳細情報: {{url}}"
			},
			"type": {
				"constAssign": "\n{{location}} 定数に再代入しています。JavaScriptでは定数に対する再代入は許可されていません。変数に再代入したい場合は、 var または let で宣言してください。\n\n+ 詳細情報: {{url}}",
				"notfunc": "\n{{location}} \"{{symbol}}\" を関数として呼び出すことができません。\nスペル、大文字と小文字(JavaScriptは大文字と小文字を区別します)、そのタイプを確認してください。\n\n+ 詳細情報: {{url}}",
				"notfuncObj": "\n{{location}} \"{{symbol}}\" を関数として呼び出すことができません。\n{{obj}} の中に \"{{symbol}}\" があるかどうか、スペル、大文字と小文字(JavaScriptは大文字と小文字を区別します)、およびそのタイプを確認してください。\n\n+ 詳細情報: {{url}}",
				"readFromNull": "\n{{location}} null のプロパティを読み取ることができません。JavaScriptでは、null はオブジェクトが値を持たないことを意味します。\n\n+ 詳細情報: {{url}}",
				"readFromUndefined": "\n{{location}} undefined のプロパティを読み取ることができません。エラーの行番号を確認し、操作しようとしている変数が undefined でないことを確認してください。\n\n+ 詳細情報: {{url}}"
			}
		},
		"libraryError": "{{location}} {{func}} を呼び出した際に、p5jsライブラリ内でメッセージ \"{{error}}\" のエラーが発生しました。特に記述がなければ、 {{func}} に渡された引数に関する問題があることが多いです。",
		"location": "[{{file}}, {{line}}行目]",
		"misspelling": "{{location}} \"{{actualName}}\" ではなく、誤って \"{{name}}\" と書いてしまったようです。p5.js内の {{type}} を使用したい場合は、 {{actualName}} に修正してください。",
		"misspelling_plural": "{{location}} もしかすると誤って \"{{name}}\" と書いているかもしれません。\n以下のいずれかの候補があります: \n{{suggestions}}",
		"misusedTopLevel": "p5.jsの {{symbolType}} {{symbolName}} を使用しようとしましたか？もしそうなら、それをスケッチの setup()関数内に移動させてください。\n\n+ 詳細情報: {{url}}",
		"positions": {
			"p_1": "第1",
			"p_10": "第10",
			"p_11": "第11",
			"p_12": "第12",
			"p_2": "第2",
			"p_3": "第3",
			"p_4": "第4",
			"p_5": "第5",
			"p_6": "第6",
			"p_7": "第7",
			"p_8": "第8",
			"p_9": "第9"
		},
		"pre": "\n🌸 p5.jsが言っています: {{message}}",
		"sketchReaderErrors": {
			"reservedConst": "p5.jsの予約済み変数 \"{{symbol}}\" を使用しました。変数名を他の名前に変更してください。\n\n+ 詳細情報: {{url}}",
			"reservedFunc": "p5.jsの予約済み関数 \"{{symbol}}\" を使用しました。関数名を他の名前に変更してください。\n\n+ 詳細情報: {{url}}"
		},
		"welcome": "ようこそ！これはあなたのフレンドリーなデバッガーです。オフにするには、p5.min.jsに切り替えてください。",
		"wrongPreload": "{{location}} p5.jsライブラリ内部で \"{{error}}\" というメッセージのエラーが発生しました。特に記載がない場合、preloadから \"{{func}}\" が呼び出されたことが原因かもしれません。load呼び出し(loadImage、loadJSON、loadFont、loadStringsなど)以外のものは、preload関数の中に入れてはなりません。"
	} };
	var dev_exports = /* @__PURE__ */ __export$1({
		en_translation: () => translation_default,
		es_translation: () => translation_default$1,
		hi_translation: () => translation_default$4,
		ja_translation: () => translation_default$5,
		ko_translation: () => translation_default$2,
		zh_translation: () => translation_default$3
	});
	var init_dev = __esmMin((() => {}));
	var fallbackResources = { en: { translation: { fes: {
		autoplay: "The media that tried to play (with '{{src}}') wasn't allowed to by this browser, most likely due to the browser's autoplay policy.\n\n+ More info: {{url}}",
		checkUserDefinedFns: "It seems that you may have accidentally written {{name}} instead of {{actualName}}. Please correct it if it's not intentional.",
		fileLoadError: {
			bytes: "It looks like there was a problem loading your file. {{suggestion}}",
			font: "It looks like there was a problem loading your font. {{suggestion}}",
			gif: "There was some trouble loading your GIF. Make sure that your GIF is using 87a or 89a encoding.",
			image: "It looks like there was a problem loading your image. {{suggestion}}",
			json: "It looks like there was a problem loading your JSON file. {{suggestion}}",
			large: "If your large file isn't fetched successfully, we recommend splitting the file into smaller segments and fetching those.",
			strings: "It looks like there was a problem loading your text file. {{suggestion}}",
			suggestion: "Try checking if the file path ({{filePath}}) is correct, hosting the file online, or running a local server.\n\n+ More info: {{url}}",
			table: "It looks like there was a problem loading your table file. {{suggestion}}",
			xml: "It looks like there was a problem loading your XML file. {{suggestion}}"
		},
		friendlyParamError: {
			type_EMPTY_VAR: "{{location}} {{func}}() was expecting {{formatType}} for the {{position}} parameter, received an empty variable instead. If not intentional, this is often a problem with scope.\n\n+ More info: {{url}}",
			type_TOO_FEW_ARGUMENTS: "{{location}} {{func}}() was expecting at least {{minParams}} arguments, but received only {{argCount}}.",
			type_TOO_MANY_ARGUMENTS: "{{location}} {{func}}() was expecting no more than {{maxParams}} arguments, but received {{argCount}}.",
			type_WRONG_TYPE: "{{location}} {{func}}() was expecting {{formatType}} for the {{position}} parameter, received {{argType}} instead."
		},
		globalErrors: {
			reference: {
				cannotAccess: "\n{{location}} \"{{symbol}}\" is used before declaration. Make sure you have declared the variable before using it.\n\n+ More info: {{url}}",
				notDefined: "\n{{location}} \"{{symbol}}\" is not defined in the current scope. If you have defined it in your code, you should check its scope, spelling, and letter-casing (JavaScript is case-sensitive).\n\n+ More info: {{url}}"
			},
			stackSubseq: "└[{{location}}] \n	 Called from line {{line}} in {{func}}()\n",
			stackTop: "┌[{{location}}] \n	 Error at line {{line}} in {{func}}()\n",
			syntax: {
				badReturnOrYield: "\nSyntax Error - return lies outside of a function. Make sure you’re not missing any brackets, so that return lies inside a function.\n\n+ More info: {{url}}",
				invalidToken: "\nSyntax Error - Found a symbol that JavaScript doesn't recognize or didn't expect at it's place.\n\n+ More info: {{url}}",
				missingInitializer: "\nSyntax Error - A const variable is declared but not initialized. In JavaScript, an initializer for a const is required. A value must be specified in the same statement in which the variable is declared. Check the line number in the error and assign the const variable a value.\n\n+ More info: {{url}}",
				redeclaredVariable: "\nSyntax Error - \"{{symbol}}\" is being redeclared. JavaScript doesn't allow declaring a variable more than once. Check the line number in error for redeclaration of the variable.\n\n+ More info: {{url}}",
				unexpectedToken: "\nSyntax Error - Symbol present at a place that wasn't expected.\nUsually this is due to a typo. Check the line number in the error for anything missing/extra.\n\n+ More info: {{url}}"
			},
			type: {
				constAssign: "\n{{location}} A const variable is being re-assigned. In javascript, re-assigning a value to a constant is not allowed. If you want to re-assign new values to a variable, make sure it is declared as var or let.\n\n+ More info: {{url}}",
				notfunc: "\n{{location}} \"{{symbol}}\" could not be called as a function.\nCheck the spelling, letter-casing (JavaScript is case-sensitive) and its type.\n\n+ More info: {{url}}",
				notfuncObj: "\n{{location}} \"{{symbol}}\" could not be called as a function.\nVerify whether \"{{obj}}\" has \"{{symbol}}\" in it and check the spelling, letter-casing (JavaScript is case-sensitive) and its type.\n\n+ More info: {{url}}",
				readFromNull: "\n{{location}} The property of null can't be read. In javascript the value null indicates that an object has no value.\n\n+ More info: {{url}}",
				readFromUndefined: "\n{{location}} Cannot read property of undefined. Check the line number in error and make sure the variable which is being operated is not undefined.\n\n + More info: {{url}}"
			}
		},
		libraryError: "{{location}} An error with message \"{{error}}\" occurred inside the p5js library when {{func}} was called. If not stated otherwise, it might be an issue with the arguments passed to {{func}}.",
		location: "[{{file}}, line {{line}}]",
		misspelling: "{{location}} It seems that you may have accidentally written \"{{name}}\" instead of \"{{actualName}}\". Please correct it to {{actualName}} if you wish to use the {{type}} from p5.js.",
		misspelling_plural: "{{location}} It seems that you may have accidentally written \"{{name}}\".\nYou may have meant one of the following: \n{{suggestions}}",
		misusedTopLevel: "Did you just try to use p5.js's {{symbolName}} {{symbolType}}? If so, you may want to move it into your sketch's setup() function.\n\n+ More info: {{url}}",
		preloadDisabled: "The preload() function has been removed in p5.js 2.0. Please load assets in setup() using async / await keywords or callbacks instead. See https://dev.to/limzykenneth/asynchronous-p5js-20-458f for more information.",
		positions: {
			p_1: "first",
			p_10: "tenth",
			p_11: "eleventh",
			p_12: "twelfth",
			p_2: "second",
			p_3: "third",
			p_4: "fourth",
			p_5: "fifth",
			p_6: "sixth",
			p_7: "seventh",
			p_8: "eighth",
			p_9: "ninth"
		},
		pre: "\n🌸 p5.js says: {{message}}",
		sketchReaderErrors: {
			reservedConst: "you have used a p5.js reserved variable \"{{symbol}}\" make sure you change the variable name to something else.\n\n+ More info: {{url}}",
			reservedFunc: "you have used a p5.js reserved function \"{{symbol}}\" make sure you change the function name to something else.\n\n+ More info: {{url}}"
		},
		welcome: "Welcome! This is your friendly debugger. To turn me off, switch to using p5.min.js.",
		wrongPreload: "{{location}} An error with message \"{{error}}\" occurred inside the p5js library when \"{{func}}\" was called. If not stated otherwise, it might be due to \"{{func}}\" being called from preload. Nothing besides load calls (loadImage, loadJSON, loadFont, loadStrings, etc.) should be inside the preload function."
	} } } };
	const languages = [
		"en",
		"es",
		"ko",
		"zh",
		"hi",
		"ja"
	];
	if (typeof IS_MINIFIED === "undefined") {
		if (typeof P5_DEV_BUILD !== "undefined") {
			let completeResources = (init_dev(), __toCommonJS(dev_exports));
			for (const language of Object.keys(completeResources)) {
				const parts = language.split("_");
				const lng = parts.slice(0, parts.length - 1).join("-");
				const ns = parts[parts.length - 1];
				fallbackResources[lng] = fallbackResources[lng] || {};
				fallbackResources[lng][ns] = completeResources[language];
			}
		}
	}
	var FetchResources = class {
		constructor(services, options$1) {
			this.init(services, options$1);
		}
		fetchWithTimeout(url, options$1, timeout = 2e3) {
			return Promise.race([fetch(url, options$1), new Promise((_, reject) => setTimeout(() => reject(/* @__PURE__ */ new Error("timeout")), timeout))]);
		}
		init(services, options$1 = {}) {
			this.services = services;
			this.options = options$1;
		}
		read(language, namespace, callback) {
			const loadPath = this.options.loadPath;
			if (language === this.options.fallback) callback(null, fallbackResources[language][namespace]);
			else if (languages.includes(language)) {
				const url = this.services.interpolator.interpolate(loadPath, {
					lng: language,
					ns: namespace
				});
				this.loadUrl(url, callback);
			} else callback("Not found", false);
		}
		loadUrl(url, callback) {
			this.fetchWithTimeout(url).then((response) => {
				if (!response.ok) throw new Error(`failed loading ${url}`);
				return response.json();
			}, () => {
				throw new Error(`failed loading ${url}`);
			}).then((data$2) => {
				return callback(null, data$2);
			}).catch(callback);
		}
	};
	FetchResources.type = "backend";
	let translator = (key, values) => {
		console.debug("p5.js translator called before translations were loaded");
		i18next_default.t(key, values);
	};
	const initialize = () => {
		return i18next_default.use(i18nextBrowserLanguageDetector_default).use(FetchResources).init({
			fallbackLng: "en",
			nestingPrefix: "$tr(",
			nestingSuffix: ")",
			defaultNS: "translation",
			returnEmptyString: false,
			interpolation: { escapeValue: false },
			detection: {
				checkWhitelist: false,
				order: [
					"querystring",
					"navigator",
					"htmlTag",
					"path",
					"subdomain"
				],
				caches: []
			},
			backend: {
				fallback: "en",
				loadPath: "https://cdn.jsdelivr.net/npm/p5/translations/{{lng}}/{{ns}}.json"
			},
			partialBundledLanguages: true,
			resources: fallbackResources
		}).then((translateFn) => {
			translator = translateFn;
		}, (e$1) => console.debug(`Translations failed to load (${e$1})`));
	};
	const strings$1 = {
		ReferenceError: [
			{
				msg: "{{}} is not defined",
				type: "NOTDEFINED",
				browser: "all"
			},
			{
				msg: "Can't find variable: {{}}",
				type: "NOTDEFINED",
				browser: "Safari"
			},
			{
				msg: "Cannot access '{{.}}' before initialization",
				type: "CANNOTACCESS",
				browser: "Chrome"
			},
			{
				msg: "can't access lexical declaration '{{.}}' before initialization",
				type: "CANNOTACCESS",
				browser: "Firefox"
			}
		],
		SyntaxError: [
			{
				msg: "illegal character",
				type: "INVALIDTOKEN",
				browser: "Firefox"
			},
			{
				msg: "Invalid character",
				type: "INVALIDTOKEN",
				browser: "Safari"
			},
			{
				msg: "Invalid or unexpected token",
				type: "INVALIDTOKEN",
				browser: "Chrome"
			},
			{
				msg: "Unexpected token '{{.}}'",
				type: "UNEXPECTEDTOKEN",
				browser: "Chrome"
			},
			{
				msg: "expected {{.}}, got '{{.}}'",
				type: "UNEXPECTEDTOKEN",
				browser: "Chrome"
			},
			{
				msg: "Identifier '{{.}}' has already been declared",
				type: "REDECLAREDVARIABLE",
				browser: "Chrome"
			},
			{
				msg: "redeclaration of {} {{.}}",
				type: "REDECLAREDVARIABLE",
				browser: "Firefox"
			},
			{
				msg: "Missing initializer in const declaration",
				type: "MISSINGINITIALIZER",
				browser: "Chrome"
			},
			{
				msg: "missing = in const declaration",
				type: "MISSINGINITIALIZER",
				browser: "Firefox"
			},
			{
				msg: "Illegal return statement",
				type: "BADRETURNORYIELD",
				browser: "Chrome"
			},
			{
				msg: "return not in function",
				type: "BADRETURNORYIELD",
				browser: "Firefox"
			}
		],
		TypeError: [
			{
				msg: "{{.}} is not a function",
				type: "NOTFUNC",
				browser: "all"
			},
			{
				msg: "Cannot read {{.}} null",
				type: "READNULL",
				browser: "Chrome"
			},
			{
				msg: "{{.}} is null",
				type: "READNULL",
				browser: "Firefox"
			},
			{
				msg: "Cannot read {{.}} undefined",
				type: "READUDEFINED",
				browser: "Chrome"
			},
			{
				msg: "{{.}} is undefined",
				type: "READUDEFINED",
				browser: "Firefox"
			},
			{
				msg: "Assignment to constant variable",
				type: "CONSTASSIGN",
				browser: "Chrome"
			},
			{
				msg: "invalid assignment to const '{{.}}'",
				type: "CONSTASSIGN",
				browser: "Firefox"
			}
		]
	};
	function fesCore(p5$2, fn$1) {
		const typeColors = [
			"#2D7BB6",
			"#EE9900",
			"#4DB200",
			"#C83C00"
		];
		let misusedAtTopLevelCode = null;
		let defineMisusedAtTopLevelCode = null;
		const EDIT_DIST_THRESHOLD = 2;
		class FESError extends Error {}
		if (typeof IS_MINIFIED !== "undefined") p5$2._friendlyError = p5$2._checkForUserDefinedFunctions = p5$2._fesErrorMonitor = () => {};
		else {
			const class2type = {};
			const toString$3 = class2type.toString;
			const names = [
				"Boolean",
				"Number",
				"String",
				"Function",
				"Array",
				"Date",
				"RegExp",
				"Object",
				"Error"
			];
			for (let n$2 = 0; n$2 < names.length; n$2++) class2type[`[object ${names[n$2]}]`] = names[n$2].toLowerCase();
			const getType = (obj) => {
				if (obj == null) return `${obj}`;
				return typeof obj === "object" || typeof obj === "function" ? class2type[toString$3.call(obj)] || "object" : typeof obj;
			};
			const entryPoints = [
				"setup",
				"draw",
				"deviceMoved",
				"deviceTurned",
				"deviceShaken",
				"doubleClicked",
				"mousePressed",
				"mouseReleased",
				"mouseMoved",
				"mouseDragged",
				"mouseClicked",
				"mouseWheel",
				"touchStarted",
				"touchMoved",
				"touchEnded",
				"keyPressed",
				"keyReleased",
				"keyTyped",
				"windowResized"
			];
			const mapToReference = (message, func) => {
				let msgWithReference = "";
				if (func == null || func.substring(0, 4) === "load") msgWithReference = message;
				else {
					const methodParts = func.split(".");
					const referenceSection = methodParts.length > 1 ? `${methodParts[0]}.${methodParts[1]}` : "p5";
					const funcName = methodParts.length === 1 ? func : methodParts.slice(2).join("/");
					funcName.startsWith("p5.") ? msgWithReference = `${message} (https://p5js.org/reference/${referenceSection}.${funcName})` : msgWithReference = `${message} (https://p5js.org/reference/${referenceSection}/${funcName})`;
				}
				return msgWithReference;
			};
			p5$2._report = (message, func, color$2) => {
				const log = p5$2._fesLogger == null ? console.log.bind(console) : p5$2._fesLogger;
				if ("undefined" === getType(color$2)) color$2 = "#B40033";
				else if (getType(color$2) === "number") color$2 = typeColors[color$2];
				message = mapToReference(message, func);
				log(translator("fes.pre", { message }));
			};
			p5$2._error = (context, message, func) => {
				p5$2._report(message, func);
				context.hitCriticalError = true;
				throw new FESError("Stopping sketch to prevent more errors");
			};
			p5$2._friendlyError = function(message, func, color$2) {
				p5$2._report(message, func, color$2);
			};
			p5$2._friendlyAutoplayError = function(src) {
				const message = translator("fes.autoplay", {
					src,
					url: "https://developer.mozilla.org/docs/Web/Media/Autoplay_guide"
				});
				console.log(translator("fes.pre", { message }));
			};
			const computeEditDistance = (w1, w2) => {
				const l1 = w1.length, l2 = w2.length;
				if (l1 === 0) return w2;
				if (l2 === 0) return w1;
				let prev = [];
				let cur = [];
				for (let j = 0; j < l2 + 1; j++) cur[j] = j;
				prev = cur;
				for (let i$1 = 1; i$1 < l1 + 1; i$1++) {
					cur = [];
					for (let j = 0; j < l2 + 1; j++) if (j === 0) cur[j] = i$1;
					else {
						let a1 = w1[i$1 - 1], a2 = w2[j - 1];
						let temp = 999999;
						let cost = a1.toLowerCase() === a2.toLowerCase() ? 0 : 1;
						temp = temp > cost + prev[j - 1] ? cost + prev[j - 1] : temp;
						temp = temp > 1 + cur[j - 1] ? 1 + cur[j - 1] : temp;
						temp = temp > 1 + prev[j] ? 1 + prev[j] : temp;
						cur[j] = temp;
					}
					prev = cur;
				}
				return cur[l2];
			};
			p5$2.isPreloadSupported = function() {
				return false;
			};
			const checkForUserDefinedFunctions = (context) => {
				if (p5$2.disableFriendlyErrors) return;
				context = context instanceof p5$2 ? context : window;
				const fnNames = entryPoints;
				if (context.preload && !p5$2.isPreloadSupported()) p5$2._error(context, translator("fes.preloadDisabled"));
				const fxns = {};
				fnNames.forEach((symbol) => {
					fxns[symbol.toLowerCase()] = symbol;
				});
				for (const prop of Object.keys(context)) {
					const lowercase$1 = prop.toLowerCase();
					if (fxns.hasOwnProperty(lowercase$1) && !context[fxns[lowercase$1]] && typeof context[prop] === "function") {
						const msg = translator("fes.checkUserDefinedFns", {
							name: prop,
							actualName: fxns[lowercase$1]
						});
						p5$2._friendlyError(msg, fxns[lowercase$1]);
					}
				}
			};
			const handleMisspelling = (errSym, error$1) => {
				if (!misusedAtTopLevelCode) defineMisusedAtTopLevelCode();
				const distanceMap = {};
				let min = 999999;
				misusedAtTopLevelCode.forEach((symbol) => {
					let dist = computeEditDistance(errSym, symbol.name);
					if (distanceMap[dist]) distanceMap[dist].push(symbol);
					else distanceMap[dist] = [symbol];
					if (dist < min) min = dist;
				});
				if (min > Math.min(EDIT_DIST_THRESHOLD, errSym.length)) return false;
				const matchedSymbols = distanceMap[min].filter((symbol) => symbol.name !== errSym);
				if (matchedSymbols.length !== 0) {
					const parsed = p5$2._getErrorStackParser().parse(error$1);
					let locationObj;
					if (parsed && parsed[0] && parsed[0].fileName && parsed[0].lineNumber && parsed[0].columnNumber) locationObj = {
						location: `${parsed[0].fileName}:${parsed[0].lineNumber}:${parsed[0].columnNumber}`,
						file: parsed[0].fileName.split("/").slice(-1),
						line: parsed[0].lineNumber
					};
					let msg;
					if (matchedSymbols.length === 1) msg = translator("fes.misspelling", {
						name: errSym,
						actualName: matchedSymbols[0].name,
						type: matchedSymbols[0].type,
						location: locationObj ? translator("fes.location", locationObj) : "",
						count: matchedSymbols.length
					});
					else msg = translator("fes.misspelling", {
						name: errSym,
						suggestions: matchedSymbols.map((symbol) => {
							return mapToReference("▶️ " + symbol.name + (symbol.type === "function" ? "()" : ""), symbol.name);
						}).join("\n"),
						location: locationObj ? translator("fes.location", locationObj) : "",
						count: matchedSymbols.length
					});
					p5$2._friendlyError(msg, matchedSymbols.length === 1 ? matchedSymbols[0].name : void 0);
					return true;
				}
				return false;
			};
			const printFriendlyStack = (friendlyStack) => {
				const log = p5$2._fesLogger && typeof p5$2._fesLogger === "function" ? p5$2._fesLogger : console.log.bind(console);
				if (friendlyStack.length > 1) {
					let stacktraceMsg = "";
					friendlyStack.forEach((frame, idx) => {
						const location$1 = `${frame.fileName}:${frame.lineNumber}:${frame.columnNumber}`;
						let frameMsg, translationObj = {
							func: frame.functionName,
							line: frame.lineNumber,
							location: location$1,
							file: frame.fileName.split("/").slice(-1)
						};
						if (idx === 0) frameMsg = translator("fes.globalErrors.stackTop", translationObj);
						else frameMsg = translator("fes.globalErrors.stackSubseq", translationObj);
						stacktraceMsg += frameMsg;
					});
					log(stacktraceMsg);
				}
			};
			const processStack = (error$1, stacktrace$1) => {
				if (!stacktrace$1) return [false, null];
				stacktrace$1.forEach((frame) => {
					frame.functionName = frame.functionName || "";
				});
				let isInternal = false;
				let p5FileName, friendlyStack, currentEntryPoint;
				try {
					throw new Error();
				} catch (testError) {
					p5FileName = p5$2._getErrorStackParser().parse(testError)[0].fileName;
				}
				for (let i$1 = stacktrace$1.length - 1; i$1 >= 0; i$1--) {
					let splitted = stacktrace$1[i$1].functionName.split(".");
					if (entryPoints.includes(splitted[splitted.length - 1])) {
						friendlyStack = stacktrace$1.slice(0, i$1 + 1);
						currentEntryPoint = splitted[splitted.length - 1];
						if (stacktrace$1[0].fileName === p5FileName) {
							isInternal = true;
							break;
						}
						break;
					}
				}
				if (!friendlyStack) friendlyStack = stacktrace$1;
				if (isInternal) {
					friendlyStack = friendlyStack.map((frame, index) => {
						frame.frameIndex = index;
						return frame;
					}).filter((frame) => frame.fileName !== p5FileName);
					if (friendlyStack.length === 0) return [true, null];
					const func = stacktrace$1[friendlyStack[0].frameIndex - 2].functionName.split(".").slice(-1)[0];
					let locationObj;
					if (friendlyStack[0].fileName && friendlyStack[0].lineNumber && friendlyStack[0].columnNumber) {
						locationObj = {
							location: `${friendlyStack[0].fileName}:${friendlyStack[0].lineNumber}:${friendlyStack[0].columnNumber}`,
							file: friendlyStack[0].fileName.split("/").slice(-1),
							line: friendlyStack[0].lineNumber
						};
						if (p5$2._fesLogCache[locationObj.location]) return [true, null];
					}
					if (currentEntryPoint === "preload" && fn$1._preloadMethods[func] == null) p5$2._friendlyError(translator("fes.wrongPreload", {
						func,
						location: locationObj ? translator("fes.location", locationObj) : "",
						error: error$1.message
					}), "preload");
					else p5$2._friendlyError(translator("fes.libraryError", {
						func,
						location: locationObj ? translator("fes.location", locationObj) : "",
						error: error$1.message
					}), func);
					if (friendlyStack && friendlyStack.length) printFriendlyStack(friendlyStack);
				}
				return [isInternal, friendlyStack];
			};
			const fesErrorMonitor = (e$1) => {
				if (p5$2.disableFriendlyErrors) return;
				if (e$1 && (e$1 instanceof FESError || e$1.reason instanceof FESError)) return;
				let error$1;
				if (e$1 instanceof Error) error$1 = e$1;
				else if (e$1 instanceof ErrorEvent) error$1 = e$1.error;
				else if (e$1 instanceof PromiseRejectionEvent) {
					error$1 = e$1.reason;
					if (!(error$1 instanceof Error)) return;
				}
				if (!error$1) return;
				let stacktrace$1 = p5$2._getErrorStackParser().parse(error$1);
				let [isInternal, friendlyStack] = processStack(error$1, stacktrace$1);
				if (isInternal) return;
				const errList = strings$1[error$1.name];
				if (!errList) return;
				let matchedError;
				for (const obj of errList) {
					let string$2 = obj.msg;
					string$2 = string$2.replace(new RegExp("{{}}", "g"), "([a-zA-Z0-9_]+)");
					string$2 = string$2.replace(new RegExp("{{.}}", "g"), "(.+)");
					string$2 = string$2.replace(new RegExp("{}", "g"), "(?:[a-zA-Z0-9_]+)");
					let matched = error$1.message.match(string$2);
					if (matched) {
						matchedError = Object.assign({}, obj);
						matchedError.match = matched;
						break;
					}
				}
				if (!matchedError) return;
				let locationObj;
				if (stacktrace$1 && stacktrace$1[0].fileName && stacktrace$1[0].lineNumber && stacktrace$1[0].columnNumber) locationObj = {
					location: `${stacktrace$1[0].fileName}:${stacktrace$1[0].lineNumber}:${stacktrace$1[0].columnNumber}`,
					file: stacktrace$1[0].fileName.split("/").slice(-1),
					line: friendlyStack[0].lineNumber
				};
				switch (error$1.name) {
					case "SyntaxError":
						switch (matchedError.type) {
							case "INVALIDTOKEN":
								p5$2._friendlyError(translator("fes.globalErrors.syntax.invalidToken", { url: "https://developer.mozilla.org/docs/Web/JavaScript/Reference/Errors/Illegal_character#What_went_wrong" }));
								break;
							case "UNEXPECTEDTOKEN":
								p5$2._friendlyError(translator("fes.globalErrors.syntax.unexpectedToken", { url: "https://developer.mozilla.org/docs/Web/JavaScript/Reference/Errors/Unexpected_token#What_went_wrong" }));
								break;
							case "REDECLAREDVARIABLE": {
								let errSym = matchedError.match[1];
								p5$2._friendlyError(translator("fes.globalErrors.syntax.redeclaredVariable", {
									symbol: errSym,
									url: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Redeclared_parameter#what_went_wrong"
								}));
								break;
							}
							case "MISSINGINITIALIZER":
								p5$2._friendlyError(translator("fes.globalErrors.syntax.missingInitializer", { url: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Missing_initializer_in_const#what_went_wrong" }));
								break;
							case "BADRETURNORYIELD":
								p5$2._friendlyError(translator("fes.globalErrors.syntax.badReturnOrYield", { url: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Bad_return_or_yield#what_went_wrong" }));
								break;
						}
						break;
					case "ReferenceError":
						switch (matchedError.type) {
							case "NOTDEFINED": {
								let errSym = matchedError.match[1];
								if (errSym && handleMisspelling(errSym, error$1)) break;
								p5$2._friendlyError(translator("fes.globalErrors.reference.notDefined", {
									url: "https://p5js.org/examples/data-variable-scope.html",
									symbol: errSym,
									location: locationObj ? translator("fes.location", locationObj) : ""
								}));
								if (friendlyStack) printFriendlyStack(friendlyStack);
								break;
							}
							case "CANNOTACCESS": {
								let errSym = matchedError.match[1];
								p5$2._friendlyError(translator("fes.globalErrors.reference.cannotAccess", {
									url: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_lexical_declaration_before_init#what_went_wrong",
									symbol: errSym,
									location: locationObj ? translator("fes.location", locationObj) : ""
								}));
								if (friendlyStack) printFriendlyStack(friendlyStack);
								break;
							}
						}
						break;
					case "TypeError": switch (matchedError.type) {
						case "NOTFUNC": {
							let splitSym = matchedError.match[1].split(".");
							let translationObj = {
								url: "https://developer.mozilla.org/docs/Web/JavaScript/Reference/Errors/Not_a_function#What_went_wrong",
								symbol: splitSym[splitSym.length - 1],
								obj: splitSym.slice(0, splitSym.length - 1).join("."),
								location: locationObj ? translator("fes.location", locationObj) : ""
							};
							if (splitSym.length > 1) p5$2._friendlyError(translator("fes.globalErrors.type.notfuncObj", translationObj));
							else p5$2._friendlyError(translator("fes.globalErrors.type.notfunc", translationObj));
							if (friendlyStack) printFriendlyStack(friendlyStack);
							break;
						}
						case "READNULL": {
							let errSym = matchedError.match[1];
							p5$2._friendlyError(translator("fes.globalErrors.type.readFromNull", {
								url: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_property#what_went_wrong",
								symbol: errSym,
								location: locationObj ? translator("fes.location", locationObj) : ""
							}));
							if (friendlyStack) printFriendlyStack(friendlyStack);
							break;
						}
						case "READUDEFINED": {
							let errSym = matchedError.match[1];
							p5$2._friendlyError(translator("fes.globalErrors.type.readFromUndefined", {
								url: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_property#what_went_wrong",
								symbol: errSym,
								location: locationObj ? translator("fes.location", locationObj) : ""
							}));
							if (friendlyStack) printFriendlyStack(friendlyStack);
							break;
						}
						case "CONSTASSIGN":
							p5$2._friendlyError(translator("fes.globalErrors.type.constAssign", {
								url: "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_const_assignment#what_went_wrong",
								location: locationObj ? translator("fes.location", locationObj) : ""
							}));
							if (friendlyStack) printFriendlyStack(friendlyStack);
							break;
					}
				}
			};
			p5$2._fesErrorMonitor = fesErrorMonitor;
			p5$2._checkForUserDefinedFunctions = checkForUserDefinedFunctions;
			p5$2._fesLogger = null;
			p5$2._fesLogCache = {};
			window.addEventListener("load", checkForUserDefinedFunctions, false);
			window.addEventListener("error", p5$2._fesErrorMonitor, false);
			window.addEventListener("unhandledrejection", p5$2._fesErrorMonitor, false);
		}
		misusedAtTopLevelCode = null;
		const FAQ_URL = "https://github.com/processing/p5.js/wiki/p5.js-overview#why-cant-i-assign-variables-using-p5-functions-and-variables-before-setup";
		defineMisusedAtTopLevelCode = () => {
			const uniqueNamesFound = {};
			const getSymbols = (obj) => Object.getOwnPropertyNames(obj).filter((name) => {
				if (name[0] === "_") return false;
				if (name in uniqueNamesFound) return false;
				uniqueNamesFound[name] = true;
				return true;
			}).map((name) => {
				let type$2;
				if (typeof obj[name] === "function") type$2 = "function";
				else if (name === name.toUpperCase()) type$2 = "constant";
				else type$2 = "variable";
				return {
					name,
					type: type$2
				};
			});
			misusedAtTopLevelCode = [].concat(getSymbols(fn$1), getSymbols(constants));
			misusedAtTopLevelCode.sort((a, b$1) => b$1.name.length - a.name.length);
		};
		const helpForMisusedAtTopLevelCode = (e$1, log) => {
			if (!log) log = console.log.bind(console);
			if (!misusedAtTopLevelCode) defineMisusedAtTopLevelCode();
			misusedAtTopLevelCode.some((symbol) => {
				if (e$1.message && e$1.message.match(`\\W?${symbol.name}\\W`) !== null) {
					const symbolName = symbol.type === "function" ? `${symbol.name}()` : symbol.name;
					if (typeof IS_MINIFIED !== "undefined") log(`Did you just try to use p5.js's ${symbolName} ${symbol.type}? If so, you may want to move it into your sketch's setup() function.\n\nFor more details, see: ${FAQ_URL}`);
					else log(translator("fes.misusedTopLevel", {
						symbolName,
						symbolType: symbol.type,
						url: FAQ_URL
					}));
					return true;
				}
			});
		};
		fn$1._helpForMisusedAtTopLevelCode = helpForMisusedAtTopLevelCode;
		if (document.readyState !== "complete") {
			window.addEventListener("error", helpForMisusedAtTopLevelCode, false);
			window.addEventListener("load", () => {
				window.removeEventListener("error", helpForMisusedAtTopLevelCode, false);
			});
		}
	}
	if (typeof p5 !== "undefined") fesCore(p5, p5.prototype);
	function ErrorStackParser() {
		let FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
		let CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
		let SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;
		return {
			parse: function ErrorStackParser$$parse(error$1) {
				if (typeof error$1.stacktrace !== "undefined" || typeof error$1["opera#sourceloc"] !== "undefined") return this.parseOpera(error$1);
				else if (error$1.stack && error$1.stack.match(CHROME_IE_STACK_REGEXP)) return this.parseV8OrIE(error$1);
				else if (error$1.stack) return this.parseFFOrSafari(error$1);
			},
			extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
				if (urlLike.indexOf(":") === -1) return [urlLike];
				let parts = /(.+?)(?::(\d+))?(?::(\d+))?$/.exec(urlLike.replace(/[()]/g, ""));
				return [
					parts[1],
					parts[2] || void 0,
					parts[3] || void 0
				];
			},
			parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error$1) {
				return error$1.stack.split("\n").filter(function(line) {
					return !!line.match(CHROME_IE_STACK_REGEXP);
				}, this).map(function(line) {
					if (line.indexOf("(eval ") > -1) line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(\),.*$)/g, "");
					let sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(");
					let location$1 = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/);
					sanitizedLine = location$1 ? sanitizedLine.replace(location$1[0], "") : sanitizedLine;
					let tokens = sanitizedLine.split(/\s+/).slice(1);
					let locationParts = this.extractLocation(location$1 ? location$1[1] : tokens.pop());
					return {
						functionName: tokens.join(" ") || void 0,
						fileName: ["eval", "<anonymous>"].indexOf(locationParts[0]) > -1 ? void 0 : locationParts[0],
						lineNumber: locationParts[1],
						columnNumber: locationParts[2],
						source: line
					};
				}, this);
			},
			parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error$1) {
				return error$1.stack.split("\n").filter(function(line) {
					return !line.match(SAFARI_NATIVE_CODE_REGEXP);
				}, this).map(function(line) {
					if (line.indexOf(" > eval") > -1) line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1");
					if (line.indexOf("@") === -1 && line.indexOf(":") === -1) return { functionName: line };
					else {
						let functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
						let matches = line.match(functionNameRegex);
						let functionName = matches && matches[1] ? matches[1] : void 0;
						let locationParts = this.extractLocation(line.replace(functionNameRegex, ""));
						return {
							functionName,
							fileName: locationParts[0],
							lineNumber: locationParts[1],
							columnNumber: locationParts[2],
							source: line
						};
					}
				}, this);
			},
			parseOpera: function ErrorStackParser$$parseOpera(e$1) {
				if (!e$1.stacktrace || e$1.message.indexOf("\n") > -1 && e$1.message.split("\n").length > e$1.stacktrace.split("\n").length) return this.parseOpera9(e$1);
				else if (!e$1.stack) return this.parseOpera10(e$1);
				else return this.parseOpera11(e$1);
			},
			parseOpera9: function ErrorStackParser$$parseOpera9(e$1) {
				let lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
				let lines = e$1.message.split("\n");
				let result = [];
				for (let i$1 = 2, len = lines.length; i$1 < len; i$1 += 2) {
					let match = lineRE.exec(lines[i$1]);
					if (match) result.push({
						fileName: match[2],
						lineNumber: match[1],
						source: lines[i$1]
					});
				}
				return result;
			},
			parseOpera10: function ErrorStackParser$$parseOpera10(e$1) {
				let lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
				let lines = e$1.stacktrace.split("\n");
				let result = [];
				for (let i$1 = 0, len = lines.length; i$1 < len; i$1 += 2) {
					let match = lineRE.exec(lines[i$1]);
					if (match) result.push({
						functionName: match[3] || void 0,
						fileName: match[2],
						lineNumber: match[1],
						source: lines[i$1]
					});
				}
				return result;
			},
			parseOpera11: function ErrorStackParser$$parseOpera11(error$1) {
				return error$1.stack.split("\n").filter(function(line) {
					return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
				}, this).map(function(line) {
					let tokens = line.split("@");
					let locationParts = this.extractLocation(tokens.pop());
					let functionCall = tokens.shift() || "";
					let functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || void 0;
					let argsRaw;
					if (functionCall.match(/\(([^)]*)\)/)) argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, "$1");
					return {
						functionName,
						args: argsRaw === void 0 || argsRaw === "[arguments not available]" ? void 0 : argsRaw.split(","),
						fileName: locationParts[0],
						lineNumber: locationParts[1],
						columnNumber: locationParts[2],
						source: line
					};
				}, this);
			}
		};
	}
	function stacktrace(p5$2, fn$1) {
		p5$2._getErrorStackParser = function getErrorStackParser() {
			return new ErrorStackParser();
		};
	}
	if (typeof p5 !== "undefined") stacktrace(p5, p5.prototype);
	Object.freeze({ status: "aborted" });
	function $constructor(name, initializer$2, params) {
		function init(inst, def) {
			var _a;
			Object.defineProperty(inst, "_zod", {
				value: inst._zod ?? {},
				enumerable: false
			});
			(_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());
			inst._zod.traits.add(name);
			initializer$2(inst, def);
			for (const k in _.prototype) if (!(k in inst)) Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
			inst._zod.constr = _;
			inst._zod.def = def;
		}
		const Parent = params?.Parent ?? Object;
		class Definition extends Parent {}
		Object.defineProperty(Definition, "name", { value: name });
		function _(def) {
			var _a;
			const inst = params?.Parent ? new Definition() : this;
			init(inst, def);
			(_a = inst._zod).deferred ?? (_a.deferred = []);
			for (const fn$1 of inst._zod.deferred) fn$1();
			return inst;
		}
		Object.defineProperty(_, "init", { value: init });
		Object.defineProperty(_, Symbol.hasInstance, { value: (inst) => {
			if (params?.Parent && inst instanceof params.Parent) return true;
			return inst?._zod?.traits?.has(name);
		} });
		Object.defineProperty(_, "name", { value: name });
		return _;
	}
	var $ZodAsyncError = class extends Error {
		constructor() {
			super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
		}
	};
	const globalConfig = {};
	function config(newConfig) {
		if (newConfig) Object.assign(globalConfig, newConfig);
		return globalConfig;
	}
	function getEnumValues(entries) {
		const numericValues = Object.values(entries).filter((v$1) => typeof v$1 === "number");
		return Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v$1]) => v$1);
	}
	function jsonStringifyReplacer(_, value) {
		if (typeof value === "bigint") return value.toString();
		return value;
	}
	function cached(getter) {
		return { get value() {
			{
				const value = getter();
				Object.defineProperty(this, "value", { value });
				return value;
			}
			throw new Error("cached value already set");
		} };
	}
	function nullish(input) {
		return input === null || input === void 0;
	}
	function cleanRegex(source) {
		const start = source.startsWith("^") ? 1 : 0;
		const end = source.endsWith("$") ? source.length - 1 : source.length;
		return source.slice(start, end);
	}
	function floatSafeRemainder(val$1, step) {
		const valDecCount = (val$1.toString().split(".")[1] || "").length;
		const stepDecCount = (step.toString().split(".")[1] || "").length;
		const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
		return Number.parseInt(val$1.toFixed(decCount).replace(".", "")) % Number.parseInt(step.toFixed(decCount).replace(".", "")) / 10 ** decCount;
	}
	function defineLazy(object$1, key, getter) {
		Object.defineProperty(object$1, key, {
			get() {
				{
					const value = getter();
					object$1[key] = value;
					return value;
				}
				throw new Error("cached value already set");
			},
			set(v$1) {
				Object.defineProperty(object$1, key, { value: v$1 });
			},
			configurable: true
		});
	}
	function assignProp(target, prop, value) {
		Object.defineProperty(target, prop, {
			value,
			writable: true,
			enumerable: true,
			configurable: true
		});
	}
	function esc(str) {
		return JSON.stringify(str);
	}
	const captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {};
	function isObject(data$2) {
		return typeof data$2 === "object" && data$2 !== null && !Array.isArray(data$2);
	}
	const allowsEval = cached(() => {
		if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) return false;
		try {
			new Function("");
			return true;
		} catch (_) {
			return false;
		}
	});
	function isPlainObject(o) {
		if (isObject(o) === false) return false;
		const ctor = o.constructor;
		if (ctor === void 0) return true;
		const prot = ctor.prototype;
		if (isObject(prot) === false) return false;
		if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) return false;
		return true;
	}
	const propertyKeyTypes = new Set([
		"string",
		"number",
		"symbol"
	]);
	function escapeRegex(str) {
		return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
	}
	function clone(inst, def, params) {
		const cl = new inst._zod.constr(def ?? inst._zod.def);
		if (!def || params?.parent) cl._zod.parent = inst;
		return cl;
	}
	function normalizeParams(_params) {
		const params = _params;
		if (!params) return {};
		if (typeof params === "string") return { error: () => params };
		if (params?.message !== void 0) {
			if (params?.error !== void 0) throw new Error("Cannot specify both `message` and `error` params");
			params.error = params.message;
		}
		delete params.message;
		if (typeof params.error === "string") return {
			...params,
			error: () => params.error
		};
		return params;
	}
	function optionalKeys(shape$1) {
		return Object.keys(shape$1).filter((k) => {
			return shape$1[k]._zod.optin === "optional" && shape$1[k]._zod.optout === "optional";
		});
	}
	const NUMBER_FORMAT_RANGES = {
		safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
		int32: [-2147483648, 2147483647],
		uint32: [0, 4294967295],
		float32: [-34028234663852886e22, 34028234663852886e22],
		float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
	};
	function pick(schema, mask) {
		const newShape = {};
		const currDef = schema._zod.def;
		for (const key in mask) {
			if (!(key in currDef.shape)) throw new Error(`Unrecognized key: "${key}"`);
			if (!mask[key]) continue;
			newShape[key] = currDef.shape[key];
		}
		return clone(schema, {
			...schema._zod.def,
			shape: newShape,
			checks: []
		});
	}
	function omit(schema, mask) {
		const newShape = { ...schema._zod.def.shape };
		const currDef = schema._zod.def;
		for (const key in mask) {
			if (!(key in currDef.shape)) throw new Error(`Unrecognized key: "${key}"`);
			if (!mask[key]) continue;
			delete newShape[key];
		}
		return clone(schema, {
			...schema._zod.def,
			shape: newShape,
			checks: []
		});
	}
	function extend(schema, shape$1) {
		if (!isPlainObject(shape$1)) throw new Error("Invalid input to extend: expected a plain object");
		return clone(schema, {
			...schema._zod.def,
			get shape() {
				const _shape = {
					...schema._zod.def.shape,
					...shape$1
				};
				assignProp(this, "shape", _shape);
				return _shape;
			},
			checks: []
		});
	}
	function merge(a, b$1) {
		return clone(a, {
			...a._zod.def,
			get shape() {
				const _shape = {
					...a._zod.def.shape,
					...b$1._zod.def.shape
				};
				assignProp(this, "shape", _shape);
				return _shape;
			},
			catchall: b$1._zod.def.catchall,
			checks: []
		});
	}
	function partial(Class, schema, mask) {
		const oldShape = schema._zod.def.shape;
		const shape$1 = { ...oldShape };
		if (mask) for (const key in mask) {
			if (!(key in oldShape)) throw new Error(`Unrecognized key: "${key}"`);
			if (!mask[key]) continue;
			shape$1[key] = Class ? new Class({
				type: "optional",
				innerType: oldShape[key]
			}) : oldShape[key];
		}
		else for (const key in oldShape) shape$1[key] = Class ? new Class({
			type: "optional",
			innerType: oldShape[key]
		}) : oldShape[key];
		return clone(schema, {
			...schema._zod.def,
			shape: shape$1,
			checks: []
		});
	}
	function required(Class, schema, mask) {
		const oldShape = schema._zod.def.shape;
		const shape$1 = { ...oldShape };
		if (mask) for (const key in mask) {
			if (!(key in shape$1)) throw new Error(`Unrecognized key: "${key}"`);
			if (!mask[key]) continue;
			shape$1[key] = new Class({
				type: "nonoptional",
				innerType: oldShape[key]
			});
		}
		else for (const key in oldShape) shape$1[key] = new Class({
			type: "nonoptional",
			innerType: oldShape[key]
		});
		return clone(schema, {
			...schema._zod.def,
			shape: shape$1,
			checks: []
		});
	}
	function aborted(x$1, startIndex = 0) {
		for (let i$1 = startIndex; i$1 < x$1.issues.length; i$1++) if (x$1.issues[i$1]?.continue !== true) return true;
		return false;
	}
	function prefixIssues(path$1, issues) {
		return issues.map((iss) => {
			var _a;
			(_a = iss).path ?? (_a.path = []);
			iss.path.unshift(path$1);
			return iss;
		});
	}
	function unwrapMessage(message) {
		return typeof message === "string" ? message : message?.message;
	}
	function finalizeIssue(iss, ctx, config$1) {
		const full = {
			...iss,
			path: iss.path ?? []
		};
		if (!iss.message) full.message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config$1.customError?.(iss)) ?? unwrapMessage(config$1.localeError?.(iss)) ?? "Invalid input";
		delete full.inst;
		delete full.continue;
		if (!ctx?.reportInput) delete full.input;
		return full;
	}
	function getLengthableOrigin(input) {
		if (Array.isArray(input)) return "array";
		if (typeof input === "string") return "string";
		return "unknown";
	}
	function issue(...args) {
		const [iss, input, inst] = args;
		if (typeof iss === "string") return {
			message: iss,
			code: "custom",
			input,
			inst
		};
		return { ...iss };
	}
	const initializer$1 = (inst, def) => {
		inst.name = "$ZodError";
		Object.defineProperty(inst, "_zod", {
			value: inst._zod,
			enumerable: false
		});
		Object.defineProperty(inst, "issues", {
			value: def,
			enumerable: false
		});
		Object.defineProperty(inst, "message", {
			get() {
				return JSON.stringify(def, jsonStringifyReplacer, 2);
			},
			enumerable: true
		});
		Object.defineProperty(inst, "toString", {
			value: () => inst.message,
			enumerable: false
		});
	};
	const $ZodError = $constructor("$ZodError", initializer$1);
	const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
	function flattenError(error$1, mapper = (issue$1) => issue$1.message) {
		const fieldErrors = {};
		const formErrors = [];
		for (const sub of error$1.issues) if (sub.path.length > 0) {
			fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
			fieldErrors[sub.path[0]].push(mapper(sub));
		} else formErrors.push(mapper(sub));
		return {
			formErrors,
			fieldErrors
		};
	}
	function formatError(error$1, _mapper) {
		const mapper = _mapper || function(issue$1) {
			return issue$1.message;
		};
		const fieldErrors = { _errors: [] };
		const processError = (error$2) => {
			for (const issue$1 of error$2.issues) if (issue$1.code === "invalid_union" && issue$1.errors.length) issue$1.errors.map((issues) => processError({ issues }));
			else if (issue$1.code === "invalid_key") processError({ issues: issue$1.issues });
			else if (issue$1.code === "invalid_element") processError({ issues: issue$1.issues });
			else if (issue$1.path.length === 0) fieldErrors._errors.push(mapper(issue$1));
			else {
				let curr = fieldErrors;
				let i$1 = 0;
				while (i$1 < issue$1.path.length) {
					const el = issue$1.path[i$1];
					if (!(i$1 === issue$1.path.length - 1)) curr[el] = curr[el] || { _errors: [] };
					else {
						curr[el] = curr[el] || { _errors: [] };
						curr[el]._errors.push(mapper(issue$1));
					}
					curr = curr[el];
					i$1++;
				}
			}
		};
		processError(error$1);
		return fieldErrors;
	}
	const _parse = (_Err) => (schema, value, _ctx, _params) => {
		const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
		const result = schema._zod.run({
			value,
			issues: []
		}, ctx);
		if (result instanceof Promise) throw new $ZodAsyncError();
		if (result.issues.length) {
			const e$1 = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
			captureStackTrace(e$1, _params?.callee);
			throw e$1;
		}
		return result.value;
	};
	const parse$2 = /* @__PURE__ */ _parse($ZodRealError);
	const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
		const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
		let result = schema._zod.run({
			value,
			issues: []
		}, ctx);
		if (result instanceof Promise) result = await result;
		if (result.issues.length) {
			const e$1 = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
			captureStackTrace(e$1, params?.callee);
			throw e$1;
		}
		return result.value;
	};
	const parseAsync$1 = /* @__PURE__ */ _parseAsync($ZodRealError);
	const _safeParse = (_Err) => (schema, value, _ctx) => {
		const ctx = _ctx ? {
			..._ctx,
			async: false
		} : { async: false };
		const result = schema._zod.run({
			value,
			issues: []
		}, ctx);
		if (result instanceof Promise) throw new $ZodAsyncError();
		return result.issues.length ? {
			success: false,
			error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
		} : {
			success: true,
			data: result.value
		};
	};
	const safeParse$1 = /* @__PURE__ */ _safeParse($ZodRealError);
	const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
		const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
		let result = schema._zod.run({
			value,
			issues: []
		}, ctx);
		if (result instanceof Promise) result = await result;
		return result.issues.length ? {
			success: false,
			error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
		} : {
			success: true,
			data: result.value
		};
	};
	const safeParseAsync$1 = /* @__PURE__ */ _safeParseAsync($ZodRealError);
	const cuid = /^[cC][^\s-]{8,}$/;
	const cuid2 = /^[0-9a-z]+$/;
	const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
	const xid = /^[0-9a-vA-V]{20}$/;
	const ksuid = /^[A-Za-z0-9]{27}$/;
	const nanoid = /^[a-zA-Z0-9_-]{21}$/;
	const duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
	const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
	const uuid = (version$2) => {
		if (!version$2) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
		return /* @__PURE__ */ new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version$2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
	};
	const email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
	const _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
	function emoji() {
		return new RegExp(_emoji$1, "u");
	}
	const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
	const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
	const cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
	const cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
	const base64$1 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
	const base64url = /^[A-Za-z0-9_-]*$/;
	const hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
	const e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
	const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
	const date$1 = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
	function timeSource(args) {
		const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
		return typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
	}
	function time$1(args) {
		return /* @__PURE__ */ new RegExp(`^${timeSource(args)}$`);
	}
	function datetime$1(args) {
		const time$2 = timeSource({ precision: args.precision });
		const opts = ["Z"];
		if (args.local) opts.push("");
		if (args.offset) opts.push(`([+-]\\d{2}:\\d{2})`);
		const timeRegex = `${time$2}(?:${opts.join("|")})`;
		return /* @__PURE__ */ new RegExp(`^${dateSource}T(?:${timeRegex})$`);
	}
	const string$1 = (params) => {
		const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
		return /* @__PURE__ */ new RegExp(`^${regex}$`);
	};
	const integer = /^\d+$/;
	const number$1 = /^-?\d+(?:\.\d+)?/i;
	const boolean$1 = /true|false/i;
	const lowercase = /^[^A-Z]*$/;
	const uppercase = /^[^a-z]*$/;
	const $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
		var _a;
		inst._zod ?? (inst._zod = {});
		inst._zod.def = def;
		(_a = inst._zod).onattach ?? (_a.onattach = []);
	});
	const numericOriginMap = {
		number: "number",
		bigint: "bigint",
		object: "date"
	};
	const $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
		$ZodCheck.init(inst, def);
		const origin = numericOriginMap[typeof def.value];
		inst._zod.onattach.push((inst$1) => {
			const bag = inst$1._zod.bag;
			const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
			if (def.value < curr) if (def.inclusive) bag.maximum = def.value;
			else bag.exclusiveMaximum = def.value;
		});
		inst._zod.check = (payload) => {
			if (def.inclusive ? payload.value <= def.value : payload.value < def.value) return;
			payload.issues.push({
				origin,
				code: "too_big",
				maximum: def.value,
				input: payload.value,
				inclusive: def.inclusive,
				inst,
				continue: !def.abort
			});
		};
	});
	const $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
		$ZodCheck.init(inst, def);
		const origin = numericOriginMap[typeof def.value];
		inst._zod.onattach.push((inst$1) => {
			const bag = inst$1._zod.bag;
			const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
			if (def.value > curr) if (def.inclusive) bag.minimum = def.value;
			else bag.exclusiveMinimum = def.value;
		});
		inst._zod.check = (payload) => {
			if (def.inclusive ? payload.value >= def.value : payload.value > def.value) return;
			payload.issues.push({
				origin,
				code: "too_small",
				minimum: def.value,
				input: payload.value,
				inclusive: def.inclusive,
				inst,
				continue: !def.abort
			});
		};
	});
	const $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
		$ZodCheck.init(inst, def);
		inst._zod.onattach.push((inst$1) => {
			var _a;
			(_a = inst$1._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
		});
		inst._zod.check = (payload) => {
			if (typeof payload.value !== typeof def.value) throw new Error("Cannot mix number and bigint in multiple_of check.");
			if (typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0) return;
			payload.issues.push({
				origin: typeof payload.value,
				code: "not_multiple_of",
				divisor: def.value,
				input: payload.value,
				inst,
				continue: !def.abort
			});
		};
	});
	const $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
		$ZodCheck.init(inst, def);
		def.format = def.format || "float64";
		const isInt = def.format?.includes("int");
		const origin = isInt ? "int" : "number";
		const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
		inst._zod.onattach.push((inst$1) => {
			const bag = inst$1._zod.bag;
			bag.format = def.format;
			bag.minimum = minimum;
			bag.maximum = maximum;
			if (isInt) bag.pattern = integer;
		});
		inst._zod.check = (payload) => {
			const input = payload.value;
			if (isInt) {
				if (!Number.isInteger(input)) {
					payload.issues.push({
						expected: origin,
						format: def.format,
						code: "invalid_type",
						input,
						inst
					});
					return;
				}
				if (!Number.isSafeInteger(input)) {
					if (input > 0) payload.issues.push({
						input,
						code: "too_big",
						maximum: Number.MAX_SAFE_INTEGER,
						note: "Integers must be within the safe integer range.",
						inst,
						origin,
						continue: !def.abort
					});
					else payload.issues.push({
						input,
						code: "too_small",
						minimum: Number.MIN_SAFE_INTEGER,
						note: "Integers must be within the safe integer range.",
						inst,
						origin,
						continue: !def.abort
					});
					return;
				}
			}
			if (input < minimum) payload.issues.push({
				origin: "number",
				input,
				code: "too_small",
				minimum,
				inclusive: true,
				inst,
				continue: !def.abort
			});
			if (input > maximum) payload.issues.push({
				origin: "number",
				input,
				code: "too_big",
				maximum,
				inst
			});
		};
	});
	const $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
		var _a;
		$ZodCheck.init(inst, def);
		(_a = inst._zod.def).when ?? (_a.when = (payload) => {
			const val$1 = payload.value;
			return !nullish(val$1) && val$1.length !== void 0;
		});
		inst._zod.onattach.push((inst$1) => {
			const curr = inst$1._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
			if (def.maximum < curr) inst$1._zod.bag.maximum = def.maximum;
		});
		inst._zod.check = (payload) => {
			const input = payload.value;
			if (input.length <= def.maximum) return;
			const origin = getLengthableOrigin(input);
			payload.issues.push({
				origin,
				code: "too_big",
				maximum: def.maximum,
				inclusive: true,
				input,
				inst,
				continue: !def.abort
			});
		};
	});
	const $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
		var _a;
		$ZodCheck.init(inst, def);
		(_a = inst._zod.def).when ?? (_a.when = (payload) => {
			const val$1 = payload.value;
			return !nullish(val$1) && val$1.length !== void 0;
		});
		inst._zod.onattach.push((inst$1) => {
			const curr = inst$1._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
			if (def.minimum > curr) inst$1._zod.bag.minimum = def.minimum;
		});
		inst._zod.check = (payload) => {
			const input = payload.value;
			if (input.length >= def.minimum) return;
			const origin = getLengthableOrigin(input);
			payload.issues.push({
				origin,
				code: "too_small",
				minimum: def.minimum,
				inclusive: true,
				input,
				inst,
				continue: !def.abort
			});
		};
	});
	const $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
		var _a;
		$ZodCheck.init(inst, def);
		(_a = inst._zod.def).when ?? (_a.when = (payload) => {
			const val$1 = payload.value;
			return !nullish(val$1) && val$1.length !== void 0;
		});
		inst._zod.onattach.push((inst$1) => {
			const bag = inst$1._zod.bag;
			bag.minimum = def.length;
			bag.maximum = def.length;
			bag.length = def.length;
		});
		inst._zod.check = (payload) => {
			const input = payload.value;
			const length = input.length;
			if (length === def.length) return;
			const origin = getLengthableOrigin(input);
			const tooBig = length > def.length;
			payload.issues.push({
				origin,
				...tooBig ? {
					code: "too_big",
					maximum: def.length
				} : {
					code: "too_small",
					minimum: def.length
				},
				inclusive: true,
				exact: true,
				input: payload.value,
				inst,
				continue: !def.abort
			});
		};
	});
	const $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
		var _a, _b;
		$ZodCheck.init(inst, def);
		inst._zod.onattach.push((inst$1) => {
			const bag = inst$1._zod.bag;
			bag.format = def.format;
			if (def.pattern) {
				bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
				bag.patterns.add(def.pattern);
			}
		});
		if (def.pattern) (_a = inst._zod).check ?? (_a.check = (payload) => {
			def.pattern.lastIndex = 0;
			if (def.pattern.test(payload.value)) return;
			payload.issues.push({
				origin: "string",
				code: "invalid_format",
				format: def.format,
				input: payload.value,
				...def.pattern ? { pattern: def.pattern.toString() } : {},
				inst,
				continue: !def.abort
			});
		});
		else (_b = inst._zod).check ?? (_b.check = () => {});
	});
	const $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
		$ZodCheckStringFormat.init(inst, def);
		inst._zod.check = (payload) => {
			def.pattern.lastIndex = 0;
			if (def.pattern.test(payload.value)) return;
			payload.issues.push({
				origin: "string",
				code: "invalid_format",
				format: "regex",
				input: payload.value,
				pattern: def.pattern.toString(),
				inst,
				continue: !def.abort
			});
		};
	});
	const $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
		def.pattern ?? (def.pattern = lowercase);
		$ZodCheckStringFormat.init(inst, def);
	});
	const $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
		def.pattern ?? (def.pattern = uppercase);
		$ZodCheckStringFormat.init(inst, def);
	});
	const $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
		$ZodCheck.init(inst, def);
		const escapedRegex = escapeRegex(def.includes);
		const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
		def.pattern = pattern;
		inst._zod.onattach.push((inst$1) => {
			const bag = inst$1._zod.bag;
			bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
			bag.patterns.add(pattern);
		});
		inst._zod.check = (payload) => {
			if (payload.value.includes(def.includes, def.position)) return;
			payload.issues.push({
				origin: "string",
				code: "invalid_format",
				format: "includes",
				includes: def.includes,
				input: payload.value,
				inst,
				continue: !def.abort
			});
		};
	});
	const $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
		$ZodCheck.init(inst, def);
		const pattern = /* @__PURE__ */ new RegExp(`^${escapeRegex(def.prefix)}.*`);
		def.pattern ?? (def.pattern = pattern);
		inst._zod.onattach.push((inst$1) => {
			const bag = inst$1._zod.bag;
			bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
			bag.patterns.add(pattern);
		});
		inst._zod.check = (payload) => {
			if (payload.value.startsWith(def.prefix)) return;
			payload.issues.push({
				origin: "string",
				code: "invalid_format",
				format: "starts_with",
				prefix: def.prefix,
				input: payload.value,
				inst,
				continue: !def.abort
			});
		};
	});
	const $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
		$ZodCheck.init(inst, def);
		const pattern = /* @__PURE__ */ new RegExp(`.*${escapeRegex(def.suffix)}$`);
		def.pattern ?? (def.pattern = pattern);
		inst._zod.onattach.push((inst$1) => {
			const bag = inst$1._zod.bag;
			bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
			bag.patterns.add(pattern);
		});
		inst._zod.check = (payload) => {
			if (payload.value.endsWith(def.suffix)) return;
			payload.issues.push({
				origin: "string",
				code: "invalid_format",
				format: "ends_with",
				suffix: def.suffix,
				input: payload.value,
				inst,
				continue: !def.abort
			});
		};
	});
	const $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
		$ZodCheck.init(inst, def);
		inst._zod.check = (payload) => {
			payload.value = def.tx(payload.value);
		};
	});
	var Doc = class {
		constructor(args = []) {
			this.content = [];
			this.indent = 0;
			if (this) this.args = args;
		}
		indented(fn$1) {
			this.indent += 1;
			fn$1(this);
			this.indent -= 1;
		}
		write(arg) {
			if (typeof arg === "function") {
				arg(this, { execution: "sync" });
				arg(this, { execution: "async" });
				return;
			}
			const lines = arg.split("\n").filter((x$1) => x$1);
			const minIndent = Math.min(...lines.map((x$1) => x$1.length - x$1.trimStart().length));
			const dedented = lines.map((x$1) => x$1.slice(minIndent)).map((x$1) => " ".repeat(this.indent * 2) + x$1);
			for (const line of dedented) this.content.push(line);
		}
		compile() {
			const F$1 = Function;
			const args = this?.args;
			const lines = [...(this?.content ?? [``]).map((x$1) => `  ${x$1}`)];
			return new F$1(...args, lines.join("\n"));
		}
	};
	const version$1 = {
		major: 4,
		minor: 0,
		patch: 0
	};
	const $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
		var _a;
		inst ?? (inst = {});
		inst._zod.def = def;
		inst._zod.bag = inst._zod.bag || {};
		inst._zod.version = version$1;
		const checks = [...inst._zod.def.checks ?? []];
		if (inst._zod.traits.has("$ZodCheck")) checks.unshift(inst);
		for (const ch of checks) for (const fn$1 of ch._zod.onattach) fn$1(inst);
		if (checks.length === 0) {
			(_a = inst._zod).deferred ?? (_a.deferred = []);
			inst._zod.deferred?.push(() => {
				inst._zod.run = inst._zod.parse;
			});
		} else {
			const runChecks = (payload, checks$1, ctx) => {
				let isAborted = aborted(payload);
				let asyncResult;
				for (const ch of checks$1) {
					if (ch._zod.def.when) {
						if (!ch._zod.def.when(payload)) continue;
					} else if (isAborted) continue;
					const currLen = payload.issues.length;
					const _ = ch._zod.check(payload);
					if (_ instanceof Promise && ctx?.async === false) throw new $ZodAsyncError();
					if (asyncResult || _ instanceof Promise) asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
						await _;
						if (payload.issues.length === currLen) return;
						if (!isAborted) isAborted = aborted(payload, currLen);
					});
					else {
						if (payload.issues.length === currLen) continue;
						if (!isAborted) isAborted = aborted(payload, currLen);
					}
				}
				if (asyncResult) return asyncResult.then(() => {
					return payload;
				});
				return payload;
			};
			inst._zod.run = (payload, ctx) => {
				const result = inst._zod.parse(payload, ctx);
				if (result instanceof Promise) {
					if (ctx.async === false) throw new $ZodAsyncError();
					return result.then((result$1) => runChecks(result$1, checks, ctx));
				}
				return runChecks(result, checks, ctx);
			};
		}
		inst["~standard"] = {
			validate: (value) => {
				try {
					const r = safeParse$1(inst, value);
					return r.success ? { value: r.data } : { issues: r.error?.issues };
				} catch (_) {
					return safeParseAsync$1(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
				}
			},
			vendor: "zod",
			version: 1
		};
	});
	const $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
		$ZodType.init(inst, def);
		inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string$1(inst._zod.bag);
		inst._zod.parse = (payload, _) => {
			if (def.coerce) try {
				payload.value = String(payload.value);
			} catch (_$1) {}
			if (typeof payload.value === "string") return payload;
			payload.issues.push({
				expected: "string",
				code: "invalid_type",
				input: payload.value,
				inst
			});
			return payload;
		};
	});
	const $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
		$ZodCheckStringFormat.init(inst, def);
		$ZodString.init(inst, def);
	});
	const $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
		def.pattern ?? (def.pattern = guid);
		$ZodStringFormat.init(inst, def);
	});
	const $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
		if (def.version) {
			const v$1 = {
				v1: 1,
				v2: 2,
				v3: 3,
				v4: 4,
				v5: 5,
				v6: 6,
				v7: 7,
				v8: 8
			}[def.version];
			if (v$1 === void 0) throw new Error(`Invalid UUID version: "${def.version}"`);
			def.pattern ?? (def.pattern = uuid(v$1));
		} else def.pattern ?? (def.pattern = uuid());
		$ZodStringFormat.init(inst, def);
	});
	const $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
		def.pattern ?? (def.pattern = email);
		$ZodStringFormat.init(inst, def);
	});
	const $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
		$ZodStringFormat.init(inst, def);
		inst._zod.check = (payload) => {
			try {
				const orig = payload.value;
				const url = new URL(orig);
				const href = url.href;
				if (def.hostname) {
					def.hostname.lastIndex = 0;
					if (!def.hostname.test(url.hostname)) payload.issues.push({
						code: "invalid_format",
						format: "url",
						note: "Invalid hostname",
						pattern: hostname.source,
						input: payload.value,
						inst,
						continue: !def.abort
					});
				}
				if (def.protocol) {
					def.protocol.lastIndex = 0;
					if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) payload.issues.push({
						code: "invalid_format",
						format: "url",
						note: "Invalid protocol",
						pattern: def.protocol.source,
						input: payload.value,
						inst,
						continue: !def.abort
					});
				}
				if (!orig.endsWith("/") && href.endsWith("/")) payload.value = href.slice(0, -1);
				else payload.value = href;
				return;
			} catch (_) {
				payload.issues.push({
					code: "invalid_format",
					format: "url",
					input: payload.value,
					inst,
					continue: !def.abort
				});
			}
		};
	});
	const $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
		def.pattern ?? (def.pattern = emoji());
		$ZodStringFormat.init(inst, def);
	});
	const $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
		def.pattern ?? (def.pattern = nanoid);
		$ZodStringFormat.init(inst, def);
	});
	const $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
		def.pattern ?? (def.pattern = cuid);
		$ZodStringFormat.init(inst, def);
	});
	const $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
		def.pattern ?? (def.pattern = cuid2);
		$ZodStringFormat.init(inst, def);
	});
	const $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
		def.pattern ?? (def.pattern = ulid);
		$ZodStringFormat.init(inst, def);
	});
	const $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
		def.pattern ?? (def.pattern = xid);
		$ZodStringFormat.init(inst, def);
	});
	const $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
		def.pattern ?? (def.pattern = ksuid);
		$ZodStringFormat.init(inst, def);
	});
	const $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
		def.pattern ?? (def.pattern = datetime$1(def));
		$ZodStringFormat.init(inst, def);
	});
	const $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
		def.pattern ?? (def.pattern = date$1);
		$ZodStringFormat.init(inst, def);
	});
	const $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
		def.pattern ?? (def.pattern = time$1(def));
		$ZodStringFormat.init(inst, def);
	});
	const $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
		def.pattern ?? (def.pattern = duration$1);
		$ZodStringFormat.init(inst, def);
	});
	const $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
		def.pattern ?? (def.pattern = ipv4);
		$ZodStringFormat.init(inst, def);
		inst._zod.onattach.push((inst$1) => {
			const bag = inst$1._zod.bag;
			bag.format = `ipv4`;
		});
	});
	const $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
		def.pattern ?? (def.pattern = ipv6);
		$ZodStringFormat.init(inst, def);
		inst._zod.onattach.push((inst$1) => {
			const bag = inst$1._zod.bag;
			bag.format = `ipv6`;
		});
		inst._zod.check = (payload) => {
			try {
				new URL(`http://[${payload.value}]`);
			} catch {
				payload.issues.push({
					code: "invalid_format",
					format: "ipv6",
					input: payload.value,
					inst,
					continue: !def.abort
				});
			}
		};
	});
	const $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
		def.pattern ?? (def.pattern = cidrv4);
		$ZodStringFormat.init(inst, def);
	});
	const $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
		def.pattern ?? (def.pattern = cidrv6);
		$ZodStringFormat.init(inst, def);
		inst._zod.check = (payload) => {
			const [address, prefix] = payload.value.split("/");
			try {
				if (!prefix) throw new Error();
				const prefixNum = Number(prefix);
				if (`${prefixNum}` !== prefix) throw new Error();
				if (prefixNum < 0 || prefixNum > 128) throw new Error();
				new URL(`http://[${address}]`);
			} catch {
				payload.issues.push({
					code: "invalid_format",
					format: "cidrv6",
					input: payload.value,
					inst,
					continue: !def.abort
				});
			}
		};
	});
	function isValidBase64(data$2) {
		if (data$2 === "") return true;
		if (data$2.length % 4 !== 0) return false;
		try {
			atob(data$2);
			return true;
		} catch {
			return false;
		}
	}
	const $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
		def.pattern ?? (def.pattern = base64$1);
		$ZodStringFormat.init(inst, def);
		inst._zod.onattach.push((inst$1) => {
			inst$1._zod.bag.contentEncoding = "base64";
		});
		inst._zod.check = (payload) => {
			if (isValidBase64(payload.value)) return;
			payload.issues.push({
				code: "invalid_format",
				format: "base64",
				input: payload.value,
				inst,
				continue: !def.abort
			});
		};
	});
	function isValidBase64URL(data$2) {
		if (!base64url.test(data$2)) return false;
		const base64$2 = data$2.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
		return isValidBase64(base64$2.padEnd(Math.ceil(base64$2.length / 4) * 4, "="));
	}
	const $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
		def.pattern ?? (def.pattern = base64url);
		$ZodStringFormat.init(inst, def);
		inst._zod.onattach.push((inst$1) => {
			inst$1._zod.bag.contentEncoding = "base64url";
		});
		inst._zod.check = (payload) => {
			if (isValidBase64URL(payload.value)) return;
			payload.issues.push({
				code: "invalid_format",
				format: "base64url",
				input: payload.value,
				inst,
				continue: !def.abort
			});
		};
	});
	const $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
		def.pattern ?? (def.pattern = e164);
		$ZodStringFormat.init(inst, def);
	});
	function isValidJWT(token, algorithm = null) {
		try {
			const tokensParts = token.split(".");
			if (tokensParts.length !== 3) return false;
			const [header] = tokensParts;
			if (!header) return false;
			const parsedHeader = JSON.parse(atob(header));
			if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT") return false;
			if (!parsedHeader.alg) return false;
			if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm)) return false;
			return true;
		} catch {
			return false;
		}
	}
	const $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
		$ZodStringFormat.init(inst, def);
		inst._zod.check = (payload) => {
			if (isValidJWT(payload.value, def.alg)) return;
			payload.issues.push({
				code: "invalid_format",
				format: "jwt",
				input: payload.value,
				inst,
				continue: !def.abort
			});
		};
	});
	const $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
		$ZodType.init(inst, def);
		inst._zod.pattern = inst._zod.bag.pattern ?? number$1;
		inst._zod.parse = (payload, _ctx) => {
			if (def.coerce) try {
				payload.value = Number(payload.value);
			} catch (_) {}
			const input = payload.value;
			if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) return payload;
			const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
			payload.issues.push({
				expected: "number",
				code: "invalid_type",
				input,
				inst,
				...received ? { received } : {}
			});
			return payload;
		};
	});
	const $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
		$ZodCheckNumberFormat.init(inst, def);
		$ZodNumber.init(inst, def);
	});
	const $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
		$ZodType.init(inst, def);
		inst._zod.pattern = boolean$1;
		inst._zod.parse = (payload, _ctx) => {
			if (def.coerce) try {
				payload.value = Boolean(payload.value);
			} catch (_) {}
			const input = payload.value;
			if (typeof input === "boolean") return payload;
			payload.issues.push({
				expected: "boolean",
				code: "invalid_type",
				input,
				inst
			});
			return payload;
		};
	});
	const $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
		$ZodType.init(inst, def);
		inst._zod.parse = (payload) => payload;
	});
	const $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
		$ZodType.init(inst, def);
		inst._zod.parse = (payload) => payload;
	});
	const $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
		$ZodType.init(inst, def);
		inst._zod.parse = (payload, _ctx) => {
			payload.issues.push({
				expected: "never",
				code: "invalid_type",
				input: payload.value,
				inst
			});
			return payload;
		};
	});
	function handleArrayResult(result, final, index) {
		if (result.issues.length) final.issues.push(...prefixIssues(index, result.issues));
		final.value[index] = result.value;
	}
	const $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
		$ZodType.init(inst, def);
		inst._zod.parse = (payload, ctx) => {
			const input = payload.value;
			if (!Array.isArray(input)) {
				payload.issues.push({
					expected: "array",
					code: "invalid_type",
					input,
					inst
				});
				return payload;
			}
			payload.value = Array(input.length);
			const proms = [];
			for (let i$1 = 0; i$1 < input.length; i$1++) {
				const item = input[i$1];
				const result = def.element._zod.run({
					value: item,
					issues: []
				}, ctx);
				if (result instanceof Promise) proms.push(result.then((result$1) => handleArrayResult(result$1, payload, i$1)));
				else handleArrayResult(result, payload, i$1);
			}
			if (proms.length) return Promise.all(proms).then(() => payload);
			return payload;
		};
	});
	function handleObjectResult(result, final, key) {
		if (result.issues.length) final.issues.push(...prefixIssues(key, result.issues));
		final.value[key] = result.value;
	}
	function handleOptionalObjectResult(result, final, key, input) {
		if (result.issues.length) if (input[key] === void 0) if (key in input) final.value[key] = void 0;
		else final.value[key] = result.value;
		else final.issues.push(...prefixIssues(key, result.issues));
		else if (result.value === void 0) {
			if (key in input) final.value[key] = void 0;
		} else final.value[key] = result.value;
	}
	const $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
		$ZodType.init(inst, def);
		const _normalized = cached(() => {
			const keys = Object.keys(def.shape);
			for (const k of keys) if (!(def.shape[k] instanceof $ZodType)) throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
			const okeys = optionalKeys(def.shape);
			return {
				shape: def.shape,
				keys,
				keySet: new Set(keys),
				numKeys: keys.length,
				optionalKeys: new Set(okeys)
			};
		});
		defineLazy(inst._zod, "propValues", () => {
			const shape$1 = def.shape;
			const propValues = {};
			for (const key in shape$1) {
				const field = shape$1[key]._zod;
				if (field.values) {
					propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
					for (const v$1 of field.values) propValues[key].add(v$1);
				}
			}
			return propValues;
		});
		const generateFastpass = (shape$1) => {
			const doc = new Doc([
				"shape",
				"payload",
				"ctx"
			]);
			const normalized = _normalized.value;
			const parseStr = (key) => {
				const k = esc(key);
				return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
			};
			doc.write(`const input = payload.value;`);
			const ids = Object.create(null);
			let counter = 0;
			for (const key of normalized.keys) ids[key] = `key_${counter++}`;
			doc.write(`const newResult = {}`);
			for (const key of normalized.keys) if (normalized.optionalKeys.has(key)) {
				const id = ids[key];
				doc.write(`const ${id} = ${parseStr(key)};`);
				const k = esc(key);
				doc.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
			} else {
				const id = ids[key];
				doc.write(`const ${id} = ${parseStr(key)};`);
				doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
				doc.write(`newResult[${esc(key)}] = ${id}.value`);
			}
			doc.write(`payload.value = newResult;`);
			doc.write(`return payload;`);
			const fn$1 = doc.compile();
			return (payload, ctx) => fn$1(shape$1, payload, ctx);
		};
		let fastpass;
		const isObject$1 = isObject;
		const jit = !globalConfig.jitless;
		const fastEnabled = jit && allowsEval.value;
		const catchall = def.catchall;
		let value;
		inst._zod.parse = (payload, ctx) => {
			value ?? (value = _normalized.value);
			const input = payload.value;
			if (!isObject$1(input)) {
				payload.issues.push({
					expected: "object",
					code: "invalid_type",
					input,
					inst
				});
				return payload;
			}
			const proms = [];
			if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
				if (!fastpass) fastpass = generateFastpass(def.shape);
				payload = fastpass(payload, ctx);
			} else {
				payload.value = {};
				const shape$1 = value.shape;
				for (const key of value.keys) {
					const el = shape$1[key];
					const r = el._zod.run({
						value: input[key],
						issues: []
					}, ctx);
					const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
					if (r instanceof Promise) proms.push(r.then((r$1) => isOptional ? handleOptionalObjectResult(r$1, payload, key, input) : handleObjectResult(r$1, payload, key)));
					else if (isOptional) handleOptionalObjectResult(r, payload, key, input);
					else handleObjectResult(r, payload, key);
				}
			}
			if (!catchall) return proms.length ? Promise.all(proms).then(() => payload) : payload;
			const unrecognized = [];
			const keySet = value.keySet;
			const _catchall = catchall._zod;
			const t$1 = _catchall.def.type;
			for (const key of Object.keys(input)) {
				if (keySet.has(key)) continue;
				if (t$1 === "never") {
					unrecognized.push(key);
					continue;
				}
				const r = _catchall.run({
					value: input[key],
					issues: []
				}, ctx);
				if (r instanceof Promise) proms.push(r.then((r$1) => handleObjectResult(r$1, payload, key)));
				else handleObjectResult(r, payload, key);
			}
			if (unrecognized.length) payload.issues.push({
				code: "unrecognized_keys",
				keys: unrecognized,
				input,
				inst
			});
			if (!proms.length) return payload;
			return Promise.all(proms).then(() => {
				return payload;
			});
		};
	});
	function handleUnionResults(results, final, inst, ctx) {
		for (const result of results) if (result.issues.length === 0) {
			final.value = result.value;
			return final;
		}
		final.issues.push({
			code: "invalid_union",
			input: final.value,
			inst,
			errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
		});
		return final;
	}
	const $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
		$ZodType.init(inst, def);
		defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
		defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
		defineLazy(inst._zod, "values", () => {
			if (def.options.every((o) => o._zod.values)) return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
		});
		defineLazy(inst._zod, "pattern", () => {
			if (def.options.every((o) => o._zod.pattern)) {
				const patterns = def.options.map((o) => o._zod.pattern);
				return /* @__PURE__ */ new RegExp(`^(${patterns.map((p$1) => cleanRegex(p$1.source)).join("|")})$`);
			}
		});
		inst._zod.parse = (payload, ctx) => {
			let async = false;
			const results = [];
			for (const option of def.options) {
				const result = option._zod.run({
					value: payload.value,
					issues: []
				}, ctx);
				if (result instanceof Promise) {
					results.push(result);
					async = true;
				} else {
					if (result.issues.length === 0) return result;
					results.push(result);
				}
			}
			if (!async) return handleUnionResults(results, payload, inst, ctx);
			return Promise.all(results).then((results$1) => {
				return handleUnionResults(results$1, payload, inst, ctx);
			});
		};
	});
	const $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
		$ZodType.init(inst, def);
		inst._zod.parse = (payload, ctx) => {
			const input = payload.value;
			const left = def.left._zod.run({
				value: input,
				issues: []
			}, ctx);
			const right = def.right._zod.run({
				value: input,
				issues: []
			}, ctx);
			if (left instanceof Promise || right instanceof Promise) return Promise.all([left, right]).then(([left$1, right$1]) => {
				return handleIntersectionResults(payload, left$1, right$1);
			});
			return handleIntersectionResults(payload, left, right);
		};
	});
	function mergeValues(a, b$1) {
		if (a === b$1) return {
			valid: true,
			data: a
		};
		if (a instanceof Date && b$1 instanceof Date && +a === +b$1) return {
			valid: true,
			data: a
		};
		if (isPlainObject(a) && isPlainObject(b$1)) {
			const bKeys = Object.keys(b$1);
			const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
			const newObj = {
				...a,
				...b$1
			};
			for (const key of sharedKeys) {
				const sharedValue = mergeValues(a[key], b$1[key]);
				if (!sharedValue.valid) return {
					valid: false,
					mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
				};
				newObj[key] = sharedValue.data;
			}
			return {
				valid: true,
				data: newObj
			};
		}
		if (Array.isArray(a) && Array.isArray(b$1)) {
			if (a.length !== b$1.length) return {
				valid: false,
				mergeErrorPath: []
			};
			const newArray = [];
			for (let index = 0; index < a.length; index++) {
				const itemA = a[index];
				const itemB = b$1[index];
				const sharedValue = mergeValues(itemA, itemB);
				if (!sharedValue.valid) return {
					valid: false,
					mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
				};
				newArray.push(sharedValue.data);
			}
			return {
				valid: true,
				data: newArray
			};
		}
		return {
			valid: false,
			mergeErrorPath: []
		};
	}
	function handleIntersectionResults(result, left, right) {
		if (left.issues.length) result.issues.push(...left.issues);
		if (right.issues.length) result.issues.push(...right.issues);
		if (aborted(result)) return result;
		const merged = mergeValues(left.value, right.value);
		if (!merged.valid) throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
		result.value = merged.data;
		return result;
	}
	const $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
		$ZodType.init(inst, def);
		const items = def.items;
		const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
		inst._zod.parse = (payload, ctx) => {
			const input = payload.value;
			if (!Array.isArray(input)) {
				payload.issues.push({
					input,
					inst,
					expected: "tuple",
					code: "invalid_type"
				});
				return payload;
			}
			payload.value = [];
			const proms = [];
			if (!def.rest) {
				const tooBig = input.length > items.length;
				const tooSmall = input.length < optStart - 1;
				if (tooBig || tooSmall) {
					payload.issues.push({
						input,
						inst,
						origin: "array",
						...tooBig ? {
							code: "too_big",
							maximum: items.length
						} : {
							code: "too_small",
							minimum: items.length
						}
					});
					return payload;
				}
			}
			let i$1 = -1;
			for (const item of items) {
				i$1++;
				if (i$1 >= input.length) {
					if (i$1 >= optStart) continue;
				}
				const result = item._zod.run({
					value: input[i$1],
					issues: []
				}, ctx);
				if (result instanceof Promise) proms.push(result.then((result$1) => handleTupleResult(result$1, payload, i$1)));
				else handleTupleResult(result, payload, i$1);
			}
			if (def.rest) {
				const rest = input.slice(items.length);
				for (const el of rest) {
					i$1++;
					const result = def.rest._zod.run({
						value: el,
						issues: []
					}, ctx);
					if (result instanceof Promise) proms.push(result.then((result$1) => handleTupleResult(result$1, payload, i$1)));
					else handleTupleResult(result, payload, i$1);
				}
			}
			if (proms.length) return Promise.all(proms).then(() => payload);
			return payload;
		};
	});
	function handleTupleResult(result, final, index) {
		if (result.issues.length) final.issues.push(...prefixIssues(index, result.issues));
		final.value[index] = result.value;
	}
	const $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
		$ZodType.init(inst, def);
		const values = getEnumValues(def.entries);
		inst._zod.values = new Set(values);
		inst._zod.pattern = /* @__PURE__ */ new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
		inst._zod.parse = (payload, _ctx) => {
			const input = payload.value;
			if (inst._zod.values.has(input)) return payload;
			payload.issues.push({
				code: "invalid_value",
				values,
				input,
				inst
			});
			return payload;
		};
	});
	const $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
		$ZodType.init(inst, def);
		inst._zod.values = new Set(def.values);
		inst._zod.pattern = /* @__PURE__ */ new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? o.toString() : String(o)).join("|")})$`);
		inst._zod.parse = (payload, _ctx) => {
			const input = payload.value;
			if (inst._zod.values.has(input)) return payload;
			payload.issues.push({
				code: "invalid_value",
				values: def.values,
				input,
				inst
			});
			return payload;
		};
	});
	const $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
		$ZodType.init(inst, def);
		inst._zod.parse = (payload, _ctx) => {
			const _out = def.transform(payload.value, payload);
			if (_ctx.async) return (_out instanceof Promise ? _out : Promise.resolve(_out)).then((output) => {
				payload.value = output;
				return payload;
			});
			if (_out instanceof Promise) throw new $ZodAsyncError();
			payload.value = _out;
			return payload;
		};
	});
	const $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
		$ZodType.init(inst, def);
		inst._zod.optin = "optional";
		inst._zod.optout = "optional";
		defineLazy(inst._zod, "values", () => {
			return def.innerType._zod.values ? new Set([...def.innerType._zod.values, void 0]) : void 0;
		});
		defineLazy(inst._zod, "pattern", () => {
			const pattern = def.innerType._zod.pattern;
			return pattern ? /* @__PURE__ */ new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
		});
		inst._zod.parse = (payload, ctx) => {
			if (def.innerType._zod.optin === "optional") return def.innerType._zod.run(payload, ctx);
			if (payload.value === void 0) return payload;
			return def.innerType._zod.run(payload, ctx);
		};
	});
	const $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
		$ZodType.init(inst, def);
		defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
		defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
		defineLazy(inst._zod, "pattern", () => {
			const pattern = def.innerType._zod.pattern;
			return pattern ? /* @__PURE__ */ new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
		});
		defineLazy(inst._zod, "values", () => {
			return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : void 0;
		});
		inst._zod.parse = (payload, ctx) => {
			if (payload.value === null) return payload;
			return def.innerType._zod.run(payload, ctx);
		};
	});
	const $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
		$ZodType.init(inst, def);
		inst._zod.optin = "optional";
		defineLazy(inst._zod, "values", () => def.innerType._zod.values);
		inst._zod.parse = (payload, ctx) => {
			if (payload.value === void 0) {
				payload.value = def.defaultValue;
				return payload;
			}
			const result = def.innerType._zod.run(payload, ctx);
			if (result instanceof Promise) return result.then((result$1) => handleDefaultResult(result$1, def));
			return handleDefaultResult(result, def);
		};
	});
	function handleDefaultResult(payload, def) {
		if (payload.value === void 0) payload.value = def.defaultValue;
		return payload;
	}
	const $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
		$ZodType.init(inst, def);
		inst._zod.optin = "optional";
		defineLazy(inst._zod, "values", () => def.innerType._zod.values);
		inst._zod.parse = (payload, ctx) => {
			if (payload.value === void 0) payload.value = def.defaultValue;
			return def.innerType._zod.run(payload, ctx);
		};
	});
	const $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
		$ZodType.init(inst, def);
		defineLazy(inst._zod, "values", () => {
			const v$1 = def.innerType._zod.values;
			return v$1 ? new Set([...v$1].filter((x$1) => x$1 !== void 0)) : void 0;
		});
		inst._zod.parse = (payload, ctx) => {
			const result = def.innerType._zod.run(payload, ctx);
			if (result instanceof Promise) return result.then((result$1) => handleNonOptionalResult(result$1, inst));
			return handleNonOptionalResult(result, inst);
		};
	});
	function handleNonOptionalResult(payload, inst) {
		if (!payload.issues.length && payload.value === void 0) payload.issues.push({
			code: "invalid_type",
			expected: "nonoptional",
			input: payload.value,
			inst
		});
		return payload;
	}
	const $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
		$ZodType.init(inst, def);
		inst._zod.optin = "optional";
		defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
		defineLazy(inst._zod, "values", () => def.innerType._zod.values);
		inst._zod.parse = (payload, ctx) => {
			const result = def.innerType._zod.run(payload, ctx);
			if (result instanceof Promise) return result.then((result$1) => {
				payload.value = result$1.value;
				if (result$1.issues.length) {
					payload.value = def.catchValue({
						...payload,
						error: { issues: result$1.issues.map((iss) => finalizeIssue(iss, ctx, config())) },
						input: payload.value
					});
					payload.issues = [];
				}
				return payload;
			});
			payload.value = result.value;
			if (result.issues.length) {
				payload.value = def.catchValue({
					...payload,
					error: { issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config())) },
					input: payload.value
				});
				payload.issues = [];
			}
			return payload;
		};
	});
	const $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
		$ZodType.init(inst, def);
		defineLazy(inst._zod, "values", () => def.in._zod.values);
		defineLazy(inst._zod, "optin", () => def.in._zod.optin);
		defineLazy(inst._zod, "optout", () => def.out._zod.optout);
		inst._zod.parse = (payload, ctx) => {
			const left = def.in._zod.run(payload, ctx);
			if (left instanceof Promise) return left.then((left$1) => handlePipeResult(left$1, def, ctx));
			return handlePipeResult(left, def, ctx);
		};
	});
	function handlePipeResult(left, def, ctx) {
		if (aborted(left)) return left;
		return def.out._zod.run({
			value: left.value,
			issues: left.issues
		}, ctx);
	}
	const $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
		$ZodType.init(inst, def);
		defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
		defineLazy(inst._zod, "values", () => def.innerType._zod.values);
		defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
		defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
		inst._zod.parse = (payload, ctx) => {
			const result = def.innerType._zod.run(payload, ctx);
			if (result instanceof Promise) return result.then(handleReadonlyResult);
			return handleReadonlyResult(result);
		};
	});
	function handleReadonlyResult(payload) {
		payload.value = Object.freeze(payload.value);
		return payload;
	}
	const $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
		$ZodCheck.init(inst, def);
		$ZodType.init(inst, def);
		inst._zod.parse = (payload, _) => {
			return payload;
		};
		inst._zod.check = (payload) => {
			const input = payload.value;
			const r = def.fn(input);
			if (r instanceof Promise) return r.then((r$1) => handleRefineResult(r$1, payload, input, inst));
			handleRefineResult(r, payload, input, inst);
		};
	});
	function handleRefineResult(result, payload, input, inst) {
		if (!result) {
			const _iss = {
				code: "custom",
				input,
				inst,
				path: [...inst._zod.def.path ?? []],
				continue: !inst._zod.def.abort
			};
			if (inst._zod.def.params) _iss.params = inst._zod.def.params;
			payload.issues.push(issue(_iss));
		}
	}
	var $ZodRegistry = class {
		constructor() {
			this._map = /* @__PURE__ */ new Map();
			this._idmap = /* @__PURE__ */ new Map();
		}
		add(schema, ..._meta) {
			const meta = _meta[0];
			this._map.set(schema, meta);
			if (meta && typeof meta === "object" && "id" in meta) {
				if (this._idmap.has(meta.id)) throw new Error(`ID ${meta.id} already exists in the registry`);
				this._idmap.set(meta.id, schema);
			}
			return this;
		}
		clear() {
			this._map = /* @__PURE__ */ new Map();
			this._idmap = /* @__PURE__ */ new Map();
			return this;
		}
		remove(schema) {
			const meta = this._map.get(schema);
			if (meta && typeof meta === "object" && "id" in meta) this._idmap.delete(meta.id);
			this._map.delete(schema);
			return this;
		}
		get(schema) {
			const p$1 = schema._zod.parent;
			if (p$1) {
				const pm = { ...this.get(p$1) ?? {} };
				delete pm.id;
				return {
					...pm,
					...this._map.get(schema)
				};
			}
			return this._map.get(schema);
		}
		has(schema) {
			return this._map.has(schema);
		}
	};
	function registry() {
		return new $ZodRegistry();
	}
	const globalRegistry = /* @__PURE__ */ registry();
	function _string(Class, params) {
		return new Class({
			type: "string",
			...normalizeParams(params)
		});
	}
	function _email(Class, params) {
		return new Class({
			type: "string",
			format: "email",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _guid(Class, params) {
		return new Class({
			type: "string",
			format: "guid",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _uuid(Class, params) {
		return new Class({
			type: "string",
			format: "uuid",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _uuidv4(Class, params) {
		return new Class({
			type: "string",
			format: "uuid",
			check: "string_format",
			abort: false,
			version: "v4",
			...normalizeParams(params)
		});
	}
	function _uuidv6(Class, params) {
		return new Class({
			type: "string",
			format: "uuid",
			check: "string_format",
			abort: false,
			version: "v6",
			...normalizeParams(params)
		});
	}
	function _uuidv7(Class, params) {
		return new Class({
			type: "string",
			format: "uuid",
			check: "string_format",
			abort: false,
			version: "v7",
			...normalizeParams(params)
		});
	}
	function _url(Class, params) {
		return new Class({
			type: "string",
			format: "url",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _emoji(Class, params) {
		return new Class({
			type: "string",
			format: "emoji",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _nanoid(Class, params) {
		return new Class({
			type: "string",
			format: "nanoid",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _cuid(Class, params) {
		return new Class({
			type: "string",
			format: "cuid",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _cuid2(Class, params) {
		return new Class({
			type: "string",
			format: "cuid2",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _ulid(Class, params) {
		return new Class({
			type: "string",
			format: "ulid",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _xid(Class, params) {
		return new Class({
			type: "string",
			format: "xid",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _ksuid(Class, params) {
		return new Class({
			type: "string",
			format: "ksuid",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _ipv4(Class, params) {
		return new Class({
			type: "string",
			format: "ipv4",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _ipv6(Class, params) {
		return new Class({
			type: "string",
			format: "ipv6",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _cidrv4(Class, params) {
		return new Class({
			type: "string",
			format: "cidrv4",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _cidrv6(Class, params) {
		return new Class({
			type: "string",
			format: "cidrv6",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _base64(Class, params) {
		return new Class({
			type: "string",
			format: "base64",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _base64url(Class, params) {
		return new Class({
			type: "string",
			format: "base64url",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _e164(Class, params) {
		return new Class({
			type: "string",
			format: "e164",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _jwt(Class, params) {
		return new Class({
			type: "string",
			format: "jwt",
			check: "string_format",
			abort: false,
			...normalizeParams(params)
		});
	}
	function _isoDateTime(Class, params) {
		return new Class({
			type: "string",
			format: "datetime",
			check: "string_format",
			offset: false,
			local: false,
			precision: null,
			...normalizeParams(params)
		});
	}
	function _isoDate(Class, params) {
		return new Class({
			type: "string",
			format: "date",
			check: "string_format",
			...normalizeParams(params)
		});
	}
	function _isoTime(Class, params) {
		return new Class({
			type: "string",
			format: "time",
			check: "string_format",
			precision: null,
			...normalizeParams(params)
		});
	}
	function _isoDuration(Class, params) {
		return new Class({
			type: "string",
			format: "duration",
			check: "string_format",
			...normalizeParams(params)
		});
	}
	function _number(Class, params) {
		return new Class({
			type: "number",
			checks: [],
			...normalizeParams(params)
		});
	}
	function _int(Class, params) {
		return new Class({
			type: "number",
			check: "number_format",
			abort: false,
			format: "safeint",
			...normalizeParams(params)
		});
	}
	function _boolean(Class, params) {
		return new Class({
			type: "boolean",
			...normalizeParams(params)
		});
	}
	function _any(Class) {
		return new Class({ type: "any" });
	}
	function _unknown(Class) {
		return new Class({ type: "unknown" });
	}
	function _never(Class, params) {
		return new Class({
			type: "never",
			...normalizeParams(params)
		});
	}
	function _lt(value, params) {
		return new $ZodCheckLessThan({
			check: "less_than",
			...normalizeParams(params),
			value,
			inclusive: false
		});
	}
	function _lte(value, params) {
		return new $ZodCheckLessThan({
			check: "less_than",
			...normalizeParams(params),
			value,
			inclusive: true
		});
	}
	function _gt(value, params) {
		return new $ZodCheckGreaterThan({
			check: "greater_than",
			...normalizeParams(params),
			value,
			inclusive: false
		});
	}
	function _gte(value, params) {
		return new $ZodCheckGreaterThan({
			check: "greater_than",
			...normalizeParams(params),
			value,
			inclusive: true
		});
	}
	function _multipleOf(value, params) {
		return new $ZodCheckMultipleOf({
			check: "multiple_of",
			...normalizeParams(params),
			value
		});
	}
	function _maxLength(maximum, params) {
		return new $ZodCheckMaxLength({
			check: "max_length",
			...normalizeParams(params),
			maximum
		});
	}
	function _minLength(minimum, params) {
		return new $ZodCheckMinLength({
			check: "min_length",
			...normalizeParams(params),
			minimum
		});
	}
	function _length(length, params) {
		return new $ZodCheckLengthEquals({
			check: "length_equals",
			...normalizeParams(params),
			length
		});
	}
	function _regex(pattern, params) {
		return new $ZodCheckRegex({
			check: "string_format",
			format: "regex",
			...normalizeParams(params),
			pattern
		});
	}
	function _lowercase(params) {
		return new $ZodCheckLowerCase({
			check: "string_format",
			format: "lowercase",
			...normalizeParams(params)
		});
	}
	function _uppercase(params) {
		return new $ZodCheckUpperCase({
			check: "string_format",
			format: "uppercase",
			...normalizeParams(params)
		});
	}
	function _includes(includes, params) {
		return new $ZodCheckIncludes({
			check: "string_format",
			format: "includes",
			...normalizeParams(params),
			includes
		});
	}
	function _startsWith(prefix, params) {
		return new $ZodCheckStartsWith({
			check: "string_format",
			format: "starts_with",
			...normalizeParams(params),
			prefix
		});
	}
	function _endsWith(suffix, params) {
		return new $ZodCheckEndsWith({
			check: "string_format",
			format: "ends_with",
			...normalizeParams(params),
			suffix
		});
	}
	function _overwrite(tx) {
		return new $ZodCheckOverwrite({
			check: "overwrite",
			tx
		});
	}
	function _normalize(form) {
		return _overwrite((input) => input.normalize(form));
	}
	function _trim() {
		return _overwrite((input) => input.trim());
	}
	function _toLowerCase() {
		return _overwrite((input) => input.toLowerCase());
	}
	function _toUpperCase() {
		return _overwrite((input) => input.toUpperCase());
	}
	function _array(Class, element$1, params) {
		return new Class({
			type: "array",
			element: element$1,
			...normalizeParams(params)
		});
	}
	function _tuple(Class, items, _paramsOrRest, _params) {
		const hasRest = _paramsOrRest instanceof $ZodType;
		return new Class({
			type: "tuple",
			items,
			rest: hasRest ? _paramsOrRest : null,
			...normalizeParams(hasRest ? _params : _paramsOrRest)
		});
	}
	function _custom(Class, fn$1, _params) {
		const norm = normalizeParams(_params);
		norm.abort ?? (norm.abort = true);
		return new Class({
			type: "custom",
			check: "custom",
			fn: fn$1,
			...norm
		});
	}
	function _refine(Class, fn$1, _params) {
		return new Class({
			type: "custom",
			check: "custom",
			fn: fn$1,
			...normalizeParams(_params)
		});
	}
	var $ZodFunction = class {
		constructor(def) {
			this._def = def;
			this.def = def;
		}
		implement(func) {
			if (typeof func !== "function") throw new Error("implement() must be called with a function");
			const impl = ((...args) => {
				const parsedArgs = this._def.input ? parse$2(this._def.input, args, void 0, { callee: impl }) : args;
				if (!Array.isArray(parsedArgs)) throw new Error("Invalid arguments schema: not an array or tuple schema.");
				const output = func(...parsedArgs);
				return this._def.output ? parse$2(this._def.output, output, void 0, { callee: impl }) : output;
			});
			return impl;
		}
		implementAsync(func) {
			if (typeof func !== "function") throw new Error("implement() must be called with a function");
			const impl = (async (...args) => {
				const parsedArgs = this._def.input ? await parseAsync$1(this._def.input, args, void 0, { callee: impl }) : args;
				if (!Array.isArray(parsedArgs)) throw new Error("Invalid arguments schema: not an array or tuple schema.");
				const output = await func(...parsedArgs);
				return this._def.output ? parseAsync$1(this._def.output, output, void 0, { callee: impl }) : output;
			});
			return impl;
		}
		input(...args) {
			const F$1 = this.constructor;
			if (Array.isArray(args[0])) return new F$1({
				type: "function",
				input: new $ZodTuple({
					type: "tuple",
					items: args[0],
					rest: args[1]
				}),
				output: this._def.output
			});
			return new F$1({
				type: "function",
				input: args[0],
				output: this._def.output
			});
		}
		output(output) {
			const F$1 = this.constructor;
			return new F$1({
				type: "function",
				input: this._def.input,
				output
			});
		}
	};
	function _function(params) {
		return new $ZodFunction({
			type: "function",
			input: Array.isArray(params?.input) ? _tuple($ZodTuple, params?.input) : params?.input ?? _array($ZodArray, _unknown($ZodUnknown)),
			output: params?.output ?? _unknown($ZodUnknown)
		});
	}
	const ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
		$ZodISODateTime.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	function datetime(params) {
		return _isoDateTime(ZodISODateTime, params);
	}
	const ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
		$ZodISODate.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	function date(params) {
		return _isoDate(ZodISODate, params);
	}
	const ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
		$ZodISOTime.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	function time(params) {
		return _isoTime(ZodISOTime, params);
	}
	const ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
		$ZodISODuration.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	function duration(params) {
		return _isoDuration(ZodISODuration, params);
	}
	const initializer = (inst, issues) => {
		$ZodError.init(inst, issues);
		inst.name = "ZodError";
		Object.defineProperties(inst, {
			format: { value: (mapper) => formatError(inst, mapper) },
			flatten: { value: (mapper) => flattenError(inst, mapper) },
			addIssue: { value: (issue$1) => inst.issues.push(issue$1) },
			addIssues: { value: (issues$1) => inst.issues.push(...issues$1) },
			isEmpty: { get() {
				return inst.issues.length === 0;
			} }
		});
	};
	$constructor("ZodError", initializer);
	const ZodRealError = $constructor("ZodError", initializer, { Parent: Error });
	const parse$1 = /* @__PURE__ */ _parse(ZodRealError);
	const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
	const safeParse = /* @__PURE__ */ _safeParse(ZodRealError);
	const safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
	const ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
		$ZodType.init(inst, def);
		inst.def = def;
		Object.defineProperty(inst, "_def", { value: def });
		inst.check = (...checks) => {
			return inst.clone({
				...def,
				checks: [...def.checks ?? [], ...checks.map((ch) => typeof ch === "function" ? { _zod: {
					check: ch,
					def: { check: "custom" },
					onattach: []
				} } : ch)]
			});
		};
		inst.clone = (def$1, params) => clone(inst, def$1, params);
		inst.brand = () => inst;
		inst.register = ((reg, meta) => {
			reg.add(inst, meta);
			return inst;
		});
		inst.parse = (data$2, params) => parse$1(inst, data$2, params, { callee: inst.parse });
		inst.safeParse = (data$2, params) => safeParse(inst, data$2, params);
		inst.parseAsync = async (data$2, params) => parseAsync(inst, data$2, params, { callee: inst.parseAsync });
		inst.safeParseAsync = async (data$2, params) => safeParseAsync(inst, data$2, params);
		inst.spa = inst.safeParseAsync;
		inst.refine = (check$1, params) => inst.check(refine(check$1, params));
		inst.superRefine = (refinement) => inst.check(superRefine(refinement));
		inst.overwrite = (fn$1) => inst.check(_overwrite(fn$1));
		inst.optional = () => optional(inst);
		inst.nullable = () => nullable(inst);
		inst.nullish = () => optional(nullable(inst));
		inst.nonoptional = (params) => nonoptional(inst, params);
		inst.array = () => array(inst);
		inst.or = (arg) => union([inst, arg]);
		inst.and = (arg) => intersection(inst, arg);
		inst.transform = (tx) => pipe(inst, transform(tx));
		inst.default = (def$1) => _default(inst, def$1);
		inst.prefault = (def$1) => prefault(inst, def$1);
		inst.catch = (params) => _catch(inst, params);
		inst.pipe = (target) => pipe(inst, target);
		inst.readonly = () => readonly(inst);
		inst.describe = (description) => {
			const cl = inst.clone();
			globalRegistry.add(cl, { description });
			return cl;
		};
		Object.defineProperty(inst, "description", {
			get() {
				return globalRegistry.get(inst)?.description;
			},
			configurable: true
		});
		inst.meta = (...args) => {
			if (args.length === 0) return globalRegistry.get(inst);
			const cl = inst.clone();
			globalRegistry.add(cl, args[0]);
			return cl;
		};
		inst.isOptional = () => inst.safeParse(void 0).success;
		inst.isNullable = () => inst.safeParse(null).success;
		return inst;
	});
	const _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
		$ZodString.init(inst, def);
		ZodType.init(inst, def);
		const bag = inst._zod.bag;
		inst.format = bag.format ?? null;
		inst.minLength = bag.minimum ?? null;
		inst.maxLength = bag.maximum ?? null;
		inst.regex = (...args) => inst.check(_regex(...args));
		inst.includes = (...args) => inst.check(_includes(...args));
		inst.startsWith = (...args) => inst.check(_startsWith(...args));
		inst.endsWith = (...args) => inst.check(_endsWith(...args));
		inst.min = (...args) => inst.check(_minLength(...args));
		inst.max = (...args) => inst.check(_maxLength(...args));
		inst.length = (...args) => inst.check(_length(...args));
		inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
		inst.lowercase = (params) => inst.check(_lowercase(params));
		inst.uppercase = (params) => inst.check(_uppercase(params));
		inst.trim = () => inst.check(_trim());
		inst.normalize = (...args) => inst.check(_normalize(...args));
		inst.toLowerCase = () => inst.check(_toLowerCase());
		inst.toUpperCase = () => inst.check(_toUpperCase());
	});
	const ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
		$ZodString.init(inst, def);
		_ZodString.init(inst, def);
		inst.email = (params) => inst.check(_email(ZodEmail, params));
		inst.url = (params) => inst.check(_url(ZodURL, params));
		inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
		inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params));
		inst.guid = (params) => inst.check(_guid(ZodGUID, params));
		inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
		inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
		inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
		inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
		inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
		inst.guid = (params) => inst.check(_guid(ZodGUID, params));
		inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
		inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
		inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
		inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
		inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
		inst.xid = (params) => inst.check(_xid(ZodXID, params));
		inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
		inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
		inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
		inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
		inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
		inst.e164 = (params) => inst.check(_e164(ZodE164, params));
		inst.datetime = (params) => inst.check(datetime(params));
		inst.date = (params) => inst.check(date(params));
		inst.time = (params) => inst.check(time(params));
		inst.duration = (params) => inst.check(duration(params));
	});
	function string(params) {
		return _string(ZodString, params);
	}
	const ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
		$ZodStringFormat.init(inst, def);
		_ZodString.init(inst, def);
	});
	const ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
		$ZodEmail.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
		$ZodGUID.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
		$ZodUUID.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
		$ZodURL.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
		$ZodEmoji.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
		$ZodNanoID.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
		$ZodCUID.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
		$ZodCUID2.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
		$ZodULID.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
		$ZodXID.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
		$ZodKSUID.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
		$ZodIPv4.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
		$ZodIPv6.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
		$ZodCIDRv4.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
		$ZodCIDRv6.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
		$ZodBase64.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
		$ZodBase64URL.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
		$ZodE164.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
		$ZodJWT.init(inst, def);
		ZodStringFormat.init(inst, def);
	});
	const ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
		$ZodNumber.init(inst, def);
		ZodType.init(inst, def);
		inst.gt = (value, params) => inst.check(_gt(value, params));
		inst.gte = (value, params) => inst.check(_gte(value, params));
		inst.min = (value, params) => inst.check(_gte(value, params));
		inst.lt = (value, params) => inst.check(_lt(value, params));
		inst.lte = (value, params) => inst.check(_lte(value, params));
		inst.max = (value, params) => inst.check(_lte(value, params));
		inst.int = (params) => inst.check(int(params));
		inst.safe = (params) => inst.check(int(params));
		inst.positive = (params) => inst.check(_gt(0, params));
		inst.nonnegative = (params) => inst.check(_gte(0, params));
		inst.negative = (params) => inst.check(_lt(0, params));
		inst.nonpositive = (params) => inst.check(_lte(0, params));
		inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
		inst.step = (value, params) => inst.check(_multipleOf(value, params));
		inst.finite = () => inst;
		const bag = inst._zod.bag;
		inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
		inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
		inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? .5);
		inst.isFinite = true;
		inst.format = bag.format ?? null;
	});
	function number(params) {
		return _number(ZodNumber, params);
	}
	const ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
		$ZodNumberFormat.init(inst, def);
		ZodNumber.init(inst, def);
	});
	function int(params) {
		return _int(ZodNumberFormat, params);
	}
	const ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
		$ZodBoolean.init(inst, def);
		ZodType.init(inst, def);
	});
	function boolean(params) {
		return _boolean(ZodBoolean, params);
	}
	const ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
		$ZodAny.init(inst, def);
		ZodType.init(inst, def);
	});
	function any() {
		return _any(ZodAny);
	}
	const ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
		$ZodUnknown.init(inst, def);
		ZodType.init(inst, def);
	});
	function unknown() {
		return _unknown(ZodUnknown);
	}
	const ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
		$ZodNever.init(inst, def);
		ZodType.init(inst, def);
	});
	function never(params) {
		return _never(ZodNever, params);
	}
	const ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
		$ZodArray.init(inst, def);
		ZodType.init(inst, def);
		inst.element = def.element;
		inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
		inst.nonempty = (params) => inst.check(_minLength(1, params));
		inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
		inst.length = (len, params) => inst.check(_length(len, params));
		inst.unwrap = () => inst.element;
	});
	function array(element$1, params) {
		return _array(ZodArray, element$1, params);
	}
	const ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
		$ZodObject.init(inst, def);
		ZodType.init(inst, def);
		defineLazy(inst, "shape", () => def.shape);
		inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
		inst.catchall = (catchall) => inst.clone({
			...inst._zod.def,
			catchall
		});
		inst.passthrough = () => inst.clone({
			...inst._zod.def,
			catchall: unknown()
		});
		inst.loose = () => inst.clone({
			...inst._zod.def,
			catchall: unknown()
		});
		inst.strict = () => inst.clone({
			...inst._zod.def,
			catchall: never()
		});
		inst.strip = () => inst.clone({
			...inst._zod.def,
			catchall: void 0
		});
		inst.extend = (incoming) => {
			return extend(inst, incoming);
		};
		inst.merge = (other) => merge(inst, other);
		inst.pick = (mask) => pick(inst, mask);
		inst.omit = (mask) => omit(inst, mask);
		inst.partial = (...args) => partial(ZodOptional, inst, args[0]);
		inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
	});
	function object(shape$1, params) {
		return new ZodObject({
			type: "object",
			get shape() {
				assignProp(this, "shape", { ...shape$1 });
				return this.shape;
			},
			...normalizeParams(params)
		});
	}
	const ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
		$ZodUnion.init(inst, def);
		ZodType.init(inst, def);
		inst.options = def.options;
	});
	function union(options$1, params) {
		return new ZodUnion({
			type: "union",
			options: options$1,
			...normalizeParams(params)
		});
	}
	const ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
		$ZodIntersection.init(inst, def);
		ZodType.init(inst, def);
	});
	function intersection(left, right) {
		return new ZodIntersection({
			type: "intersection",
			left,
			right
		});
	}
	const ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
		$ZodTuple.init(inst, def);
		ZodType.init(inst, def);
		inst.rest = (rest) => inst.clone({
			...inst._zod.def,
			rest
		});
	});
	function tuple(items, _paramsOrRest, _params) {
		const hasRest = _paramsOrRest instanceof $ZodType;
		return new ZodTuple({
			type: "tuple",
			items,
			rest: hasRest ? _paramsOrRest : null,
			...normalizeParams(hasRest ? _params : _paramsOrRest)
		});
	}
	const ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
		$ZodEnum.init(inst, def);
		ZodType.init(inst, def);
		inst.enum = def.entries;
		inst.options = Object.values(def.entries);
		const keys = new Set(Object.keys(def.entries));
		inst.extract = (values, params) => {
			const newEntries = {};
			for (const value of values) if (keys.has(value)) newEntries[value] = def.entries[value];
			else throw new Error(`Key ${value} not found in enum`);
			return new ZodEnum({
				...def,
				checks: [],
				...normalizeParams(params),
				entries: newEntries
			});
		};
		inst.exclude = (values, params) => {
			const newEntries = { ...def.entries };
			for (const value of values) if (keys.has(value)) delete newEntries[value];
			else throw new Error(`Key ${value} not found in enum`);
			return new ZodEnum({
				...def,
				checks: [],
				...normalizeParams(params),
				entries: newEntries
			});
		};
	});
	function _enum(values, params) {
		return new ZodEnum({
			type: "enum",
			entries: Array.isArray(values) ? Object.fromEntries(values.map((v$1) => [v$1, v$1])) : values,
			...normalizeParams(params)
		});
	}
	const ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
		$ZodLiteral.init(inst, def);
		ZodType.init(inst, def);
		inst.values = new Set(def.values);
		Object.defineProperty(inst, "value", { get() {
			if (def.values.length > 1) throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
			return def.values[0];
		} });
	});
	function literal$1(value, params) {
		return new ZodLiteral({
			type: "literal",
			values: Array.isArray(value) ? value : [value],
			...normalizeParams(params)
		});
	}
	const ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
		$ZodTransform.init(inst, def);
		ZodType.init(inst, def);
		inst._zod.parse = (payload, _ctx) => {
			payload.addIssue = (issue$1) => {
				if (typeof issue$1 === "string") payload.issues.push(issue(issue$1, payload.value, def));
				else {
					const _issue = issue$1;
					if (_issue.fatal) _issue.continue = false;
					_issue.code ?? (_issue.code = "custom");
					_issue.input ?? (_issue.input = payload.value);
					_issue.inst ?? (_issue.inst = inst);
					_issue.continue ?? (_issue.continue = true);
					payload.issues.push(issue(_issue));
				}
			};
			const output = def.transform(payload.value, payload);
			if (output instanceof Promise) return output.then((output$1) => {
				payload.value = output$1;
				return payload;
			});
			payload.value = output;
			return payload;
		};
	});
	function transform(fn$1) {
		return new ZodTransform({
			type: "transform",
			transform: fn$1
		});
	}
	const ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
		$ZodOptional.init(inst, def);
		ZodType.init(inst, def);
		inst.unwrap = () => inst._zod.def.innerType;
	});
	function optional(innerType) {
		return new ZodOptional({
			type: "optional",
			innerType
		});
	}
	const ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
		$ZodNullable.init(inst, def);
		ZodType.init(inst, def);
		inst.unwrap = () => inst._zod.def.innerType;
	});
	function nullable(innerType) {
		return new ZodNullable({
			type: "nullable",
			innerType
		});
	}
	const ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
		$ZodDefault.init(inst, def);
		ZodType.init(inst, def);
		inst.unwrap = () => inst._zod.def.innerType;
		inst.removeDefault = inst.unwrap;
	});
	function _default(innerType, defaultValue) {
		return new ZodDefault({
			type: "default",
			innerType,
			get defaultValue() {
				return typeof defaultValue === "function" ? defaultValue() : defaultValue;
			}
		});
	}
	const ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
		$ZodPrefault.init(inst, def);
		ZodType.init(inst, def);
		inst.unwrap = () => inst._zod.def.innerType;
	});
	function prefault(innerType, defaultValue) {
		return new ZodPrefault({
			type: "prefault",
			innerType,
			get defaultValue() {
				return typeof defaultValue === "function" ? defaultValue() : defaultValue;
			}
		});
	}
	const ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
		$ZodNonOptional.init(inst, def);
		ZodType.init(inst, def);
		inst.unwrap = () => inst._zod.def.innerType;
	});
	function nonoptional(innerType, params) {
		return new ZodNonOptional({
			type: "nonoptional",
			innerType,
			...normalizeParams(params)
		});
	}
	const ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
		$ZodCatch.init(inst, def);
		ZodType.init(inst, def);
		inst.unwrap = () => inst._zod.def.innerType;
		inst.removeCatch = inst.unwrap;
	});
	function _catch(innerType, catchValue) {
		return new ZodCatch({
			type: "catch",
			innerType,
			catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
		});
	}
	const ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
		$ZodPipe.init(inst, def);
		ZodType.init(inst, def);
		inst.in = def.in;
		inst.out = def.out;
	});
	function pipe(in_, out) {
		return new ZodPipe({
			type: "pipe",
			in: in_,
			out
		});
	}
	const ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
		$ZodReadonly.init(inst, def);
		ZodType.init(inst, def);
	});
	function readonly(innerType) {
		return new ZodReadonly({
			type: "readonly",
			innerType
		});
	}
	const ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
		$ZodCustom.init(inst, def);
		ZodType.init(inst, def);
	});
	function check(fn$1) {
		const ch = new $ZodCheck({ check: "custom" });
		ch._zod.check = fn$1;
		return ch;
	}
	function custom(fn$1, _params) {
		return _custom(ZodCustom, fn$1 ?? (() => true), _params);
	}
	function refine(fn$1, _params = {}) {
		return _refine(ZodCustom, fn$1, _params);
	}
	function superRefine(fn$1) {
		const ch = check((payload) => {
			payload.addIssue = (issue$1) => {
				if (typeof issue$1 === "string") payload.issues.push(issue(issue$1, payload.value, ch._zod.def));
				else {
					const _issue = issue$1;
					if (_issue.fatal) _issue.continue = false;
					_issue.code ?? (_issue.code = "custom");
					_issue.input ?? (_issue.input = payload.value);
					_issue.inst ?? (_issue.inst = ch);
					_issue.continue ?? (_issue.continue = !ch._zod.def.abort);
					payload.issues.push(issue(_issue));
				}
			};
			return fn$1(payload.value, payload);
		});
		return ch;
	}
	function _instanceof(cls, params = { error: `Input not instance of ${cls.name}` }) {
		const inst = new ZodCustom({
			type: "custom",
			check: "custom",
			fn: (data$2) => data$2 instanceof cls,
			abort: true,
			...normalizeParams(params)
		});
		inst._zod.bag.Class = cls;
		return inst;
	}
	var dataDoc = {
		p5: {
			describe: { overloads: [["String", "FALLBACK|LABEL?"]] },
			describeElement: { overloads: [[
				"String",
				"String",
				"FALLBACK|LABEL?"
			]] },
			textOutput: { overloads: [["FALLBACK|LABEL?"]] },
			gridOutput: { overloads: [["FALLBACK|LABEL?"]] },
			p5: { overloads: [["Object", "String|HTMLElement"]] },
			color: { overloads: [
				["Number", "Number?"],
				[
					"Number",
					"Number",
					"Number",
					"Number?"
				],
				["String"],
				["Number[]"],
				["p5.Color"]
			] },
			red: { overloads: [["p5.Color|Number[]|String"]] },
			green: { overloads: [["p5.Color|Number[]|String"]] },
			blue: { overloads: [["p5.Color|Number[]|String"]] },
			alpha: { overloads: [["p5.Color|Number[]|String"]] },
			hue: { overloads: [["p5.Color|Number[]|String"]] },
			saturation: { overloads: [["p5.Color|Number[]|String"]] },
			brightness: { overloads: [["p5.Color|Number[]|String"]] },
			lightness: { overloads: [["p5.Color|Number[]|String"]] },
			lerpColor: { overloads: [[
				"p5.Color",
				"p5.Color",
				"Number"
			]] },
			paletteLerp: { overloads: [["[p5.Color|String|Number|Number[], Number][]", "Number"]] },
			beginClip: { overloads: [["Object?"]] },
			endClip: { overloads: [[]] },
			clip: { overloads: [["Function", "Object?"]] },
			background: { overloads: [
				["p5.Color"],
				["String", "Number?"],
				["Number", "Number?"],
				[
					"Number",
					"Number",
					"Number",
					"Number?"
				],
				["Number[]"],
				["p5.Image", "Number?"]
			] },
			clear: { overloads: [[
				"Number?",
				"Number?",
				"Number?",
				"Number?"
			], []] },
			colorMode: { overloads: [["RGB|HSB|HSL|RGBHDR|HWB|LAB|LCH|OKLAB|OKLCH", "Number?"], [
				"RGB|HSB|HSL|RGBHDR|HWB|LAB|LCH|OKLAB|OKLCH",
				"Number",
				"Number",
				"Number",
				"Number?"
			]] },
			fill: { overloads: [
				[
					"Number",
					"Number",
					"Number",
					"Number?"
				],
				["String"],
				["Number", "Number?"],
				["Number[]"],
				["p5.Color"]
			] },
			noFill: { overloads: [[]] },
			noStroke: { overloads: [[]] },
			stroke: { overloads: [
				[
					"Number",
					"Number",
					"Number",
					"Number?"
				],
				["String"],
				["Number", "Number?"],
				["Number[]"],
				["p5.Color"]
			] },
			erase: { overloads: [["Number?", "Number?"]] },
			noErase: { overloads: [[]] },
			blendMode: { overloads: [["BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|REMOVE|SUBTRACT"]] },
			print: { overloads: [["Any"], ["String|Number|Array"]] },
			cursor: { overloads: [[
				"ARROW|CROSS|HAND|MOVE|TEXT|WAIT|String",
				"Number?",
				"Number?"
			]] },
			frameRate: { overloads: [["Number"], []] },
			getTargetFrameRate: { overloads: [[]] },
			noCursor: { overloads: [[]] },
			windowResized: { overloads: [["UIEvent?"]] },
			fullscreen: { overloads: [["Boolean?"]] },
			pixelDensity: { overloads: [["Number?"], []] },
			displayDensity: { overloads: [[]] },
			getURL: { overloads: [[]] },
			getURLPath: { overloads: [[]] },
			getURLParams: { overloads: [[]] },
			worldToScreen: { overloads: [[
				"Number|p5.Vector",
				"Number",
				"Number?"
			]] },
			screenToWorld: { overloads: [[
				"Number|p5.Vector",
				"Number",
				"Number?"
			]] },
			setup: { overloads: [[]] },
			draw: { overloads: [[]] },
			createCanvas: { overloads: [[
				"Number?",
				"Number?",
				"P2D|WEBGL|P2DHDR?",
				"HTMLCanvasElement?"
			], [
				"Number?",
				"Number?",
				"HTMLCanvasElement?"
			]] },
			resizeCanvas: { overloads: [[
				"Number",
				"Number",
				"Boolean?"
			]] },
			noCanvas: { overloads: [[]] },
			createGraphics: { overloads: [[
				"Number",
				"Number",
				"P2D|WEBGL?",
				"HTMLCanvasElement?"
			], [
				"Number",
				"Number",
				"HTMLCanvasElement?"
			]] },
			createFramebuffer: { overloads: [["Object?"]] },
			clearDepth: { overloads: [["Number?"]] },
			noLoop: { overloads: [[]] },
			loop: { overloads: [[]] },
			isLooping: { overloads: [[]] },
			redraw: { overloads: [["Integer?"]] },
			applyMatrix: { overloads: [
				["Array"],
				[
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number"
				],
				[
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number"
				]
			] },
			resetMatrix: { overloads: [[]] },
			rotate: { overloads: [["Number", "p5.Vector|Number[]?"]] },
			rotateX: { overloads: [["Number"]] },
			rotateY: { overloads: [["Number"]] },
			rotateZ: { overloads: [["Number"]] },
			scale: { overloads: [[
				"Number|p5.Vector|Number[]",
				"Number?",
				"Number?"
			], ["p5.Vector|Number[]"]] },
			shearX: { overloads: [["Number"]] },
			shearY: { overloads: [["Number"]] },
			translate: { overloads: [[
				"Number",
				"Number",
				"Number?"
			], ["p5.Vector"]] },
			push: { overloads: [[]] },
			pop: { overloads: [[]] },
			storeItem: { overloads: [["String", "String|Number|Boolean|Object|Array"]] },
			getItem: { overloads: [["String"]] },
			clearStorage: { overloads: [[]] },
			removeItem: { overloads: [["String"]] },
			select: { overloads: [["String", "String|p5.Element|HTMLElement?"]] },
			selectAll: { overloads: [["String", "String|p5.Element|HTMLElement?"]] },
			createElement: { overloads: [["String", "String?"]] },
			removeElements: { overloads: [[]] },
			addElement: { overloads: [[]] },
			createDiv: { overloads: [["String?"]] },
			createP: { overloads: [["String?"]] },
			createSpan: { overloads: [["String?"]] },
			createImg: { overloads: [["String", "String"], [
				"String",
				"String",
				"String?",
				"Function?"
			]] },
			createA: { overloads: [[
				"String",
				"String",
				"String?"
			]] },
			createSlider: { overloads: [[
				"Number",
				"Number",
				"Number?",
				"Number?"
			]] },
			createButton: { overloads: [["String", "String?"]] },
			createCheckbox: { overloads: [["String?", "Boolean?"]] },
			createSelect: { overloads: [["Boolean?"], ["Object"]] },
			createRadio: { overloads: [
				["Object?"],
				["String?"],
				[]
			] },
			createColorPicker: { overloads: [["String|p5.Color?"]] },
			createInput: { overloads: [["String?", "String?"], ["String?"]] },
			createFileInput: { overloads: [["Function", "Boolean?"]] },
			setMoveThreshold: { overloads: [["Number"]] },
			setShakeThreshold: { overloads: [["Number"]] },
			deviceMoved: { overloads: [[]] },
			deviceTurned: { overloads: [[]] },
			deviceShaken: { overloads: [[]] },
			keyPressed: { overloads: [["KeyboardEvent?"]] },
			keyReleased: { overloads: [["KeyboardEvent?"]] },
			keyTyped: { overloads: [["KeyboardEvent?"]] },
			keyIsDown: { overloads: [["Number|String"]] },
			mouseMoved: { overloads: [["MouseEvent?"]] },
			mouseDragged: { overloads: [["MouseEvent?"]] },
			mousePressed: { overloads: [["MouseEvent?"]] },
			mouseReleased: { overloads: [["MouseEvent?"]] },
			mouseClicked: { overloads: [["MouseEvent?"]] },
			doubleClicked: { overloads: [["MouseEvent?"]] },
			mouseWheel: { overloads: [["WheelEvent?"]] },
			requestPointerLock: { overloads: [[]] },
			exitPointerLock: { overloads: [[]] },
			createImage: { overloads: [["Integer", "Integer"]] },
			saveCanvas: { overloads: [[
				"p5.Framebuffer|p5.Element|HTMLCanvasElement",
				"String?",
				"String?"
			], ["String?", "String?"]] },
			saveFrames: { overloads: [[
				"String",
				"String",
				"Number",
				"Number",
				"function(Array)?"
			]] },
			loadImage: { overloads: [[
				"String|Request",
				"function(p5.Image)?",
				"function(Event)?"
			]] },
			saveGif: { overloads: [[
				"String",
				"Number",
				"Object?"
			]] },
			image: { overloads: [[
				"p5.Image|p5.Element|p5.Texture|p5.Framebuffer|p5.FramebufferTexture|p5.Renderer|p5.Graphics",
				"Number",
				"Number",
				"Number?",
				"Number?"
			], [
				"p5.Image|p5.Element|p5.Texture|p5.Framebuffer|p5.FramebufferTexture",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number?",
				"Number?",
				"CONTAIN|COVER?",
				"LEFT|RIGHT|CENTER?",
				"TOP|BOTTOM|CENTER?"
			]] },
			tint: { overloads: [
				[
					"Number",
					"Number",
					"Number",
					"Number?"
				],
				["String"],
				["Number", "Number?"],
				["Number[]"],
				["p5.Color"]
			] },
			noTint: { overloads: [[]] },
			imageMode: { overloads: [["CORNER|CORNERS|CENTER"]] },
			blend: { overloads: [[
				"p5.Image",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"
			], [
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"
			]] },
			copy: { overloads: [[
				"p5.Image|p5.Element",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer"
			], [
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer"
			]] },
			filter: { overloads: [[
				"THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|BLUR|ERODE|DILATE|BLUR",
				"Number?",
				"Boolean?"
			], ["p5.Shader"]] },
			get: { overloads: [
				[
					"Number",
					"Number",
					"Number",
					"Number"
				],
				[],
				["Number", "Number"]
			] },
			loadPixels: { overloads: [[]] },
			set: { overloads: [[
				"Number",
				"Number",
				"Number|Number[]|Object"
			]] },
			updatePixels: { overloads: [[
				"Number?",
				"Number?",
				"Number?",
				"Number?"
			], []] },
			loadJSON: { overloads: [[
				"String|Request",
				"Function?",
				"Function?"
			]] },
			loadStrings: { overloads: [[
				"String|Request",
				"Function?",
				"Function?"
			]] },
			loadTable: { overloads: [[
				"String|Request",
				"String?",
				"String?",
				"Function?",
				"Function?"
			]] },
			loadXML: { overloads: [[
				"String|Request",
				"Function?",
				"Function?"
			]] },
			loadBytes: { overloads: [[
				"String|Request",
				"Function?",
				"Function?"
			]] },
			loadBlob: { overloads: [[
				"String|Request",
				"Function?",
				"Function?"
			]] },
			httpGet: { overloads: [[
				"String|Request",
				"String?",
				"Function?",
				"Function?"
			], [
				"String|Request",
				"Function",
				"Function?"
			]] },
			httpPost: { overloads: [
				[
					"String|Request",
					"Object|Boolean?",
					"String?",
					"Function?",
					"Function?"
				],
				[
					"String|Request",
					"Object|Boolean",
					"Function?",
					"Function?"
				],
				[
					"String|Request",
					"Function?",
					"Function?"
				]
			] },
			httpDo: { overloads: [[
				"String|Request",
				"String?",
				"String?",
				"Object?",
				"Function?",
				"Function?"
			], [
				"String|Request",
				"Function?",
				"Function?"
			]] },
			createWriter: { overloads: [["String", "String?"]] },
			write: { overloads: [["String|Number|Array"]] },
			close: { overloads: [[]] },
			save: { overloads: [[
				"Object|String?",
				"String?",
				"Boolean|String?"
			]] },
			saveJSON: { overloads: [[
				"Array|Object",
				"String",
				"Boolean?"
			]] },
			saveStrings: { overloads: [[
				"String[]",
				"String",
				"String?",
				"Boolean?"
			]] },
			saveTable: { overloads: [[
				"p5.Table",
				"String",
				"String?"
			]] },
			abs: { overloads: [["Number"]] },
			ceil: { overloads: [["Number"]] },
			constrain: { overloads: [[
				"Number",
				"Number",
				"Number"
			]] },
			dist: { overloads: [
				[
					"Number",
					"Number",
					"Number",
					"Number"
				],
				[
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number"
				],
				["p5.Vector"]
			] },
			exp: { overloads: [["Number"]] },
			floor: { overloads: [["Number"]] },
			lerp: { overloads: [[
				"Number",
				"Number",
				"Number"
			]] },
			log: { overloads: [["Number"]] },
			mag: { overloads: [["Number", "Number"]] },
			map: { overloads: [[
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Boolean?"
			]] },
			max: { overloads: [["Number", "Number"], ["Number[]"]] },
			min: { overloads: [["Number", "Number"], ["Number[]"]] },
			norm: { overloads: [[
				"Number",
				"Number",
				"Number"
			]] },
			pow: { overloads: [["Number", "Number"]] },
			round: { overloads: [["Number", "Number?"]] },
			sq: { overloads: [["Number"]] },
			sqrt: { overloads: [["Number"]] },
			fract: { overloads: [["Number"]] },
			createVector: { overloads: [["...Number[]"]] },
			noise: { overloads: [[
				"Number",
				"Number?",
				"Number?"
			]] },
			noiseDetail: { overloads: [["Number", "Number"]] },
			noiseSeed: { overloads: [["Number"]] },
			randomSeed: { overloads: [["Number"]] },
			random: { overloads: [["Number?", "Number?"], ["Array"]] },
			randomGaussian: { overloads: [["Number?", "Number?"]] },
			acos: { overloads: [["Number"]] },
			asin: { overloads: [["Number"]] },
			atan: { overloads: [["Number"]] },
			atan2: { overloads: [["Number", "Number"]] },
			cos: { overloads: [["Number"]] },
			sin: { overloads: [["Number"]] },
			tan: { overloads: [["Number"]] },
			degrees: { overloads: [["Number"]] },
			radians: { overloads: [["Number"]] },
			angleMode: { overloads: [["RADIANS|DEGREES"], []] },
			arc: { overloads: [[
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"CHORD|PIE|OPEN?",
				"Integer?"
			]] },
			ellipse: { overloads: [[
				"Number",
				"Number",
				"Number",
				"Number?"
			], [
				"Number",
				"Number",
				"Number",
				"Number",
				"Integer?"
			]] },
			circle: { overloads: [[
				"Number",
				"Number",
				"Number"
			]] },
			line: { overloads: [[
				"Number",
				"Number",
				"Number",
				"Number"
			], [
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number"
			]] },
			point: { overloads: [[
				"Number",
				"Number",
				"Number?"
			], ["p5.Vector"]] },
			quad: { overloads: [[
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Integer?",
				"Integer?"
			], [
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Integer?",
				"Integer?"
			]] },
			rect: { overloads: [[
				"Number",
				"Number",
				"Number",
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?"
			], [
				"Number",
				"Number",
				"Number",
				"Number",
				"Integer?",
				"Integer?"
			]] },
			square: { overloads: [[
				"Number",
				"Number",
				"Number",
				"Number?",
				"Number?",
				"Number?",
				"Number?"
			]] },
			triangle: { overloads: [[
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number"
			]] },
			ellipseMode: { overloads: [["CENTER|RADIUS|CORNER|CORNERS"]] },
			noSmooth: { overloads: [[]] },
			rectMode: { overloads: [["CENTER|RADIUS|CORNER|CORNERS"]] },
			smooth: { overloads: [[]] },
			strokeCap: { overloads: [["ROUND|SQUARE|PROJECT"]] },
			strokeJoin: { overloads: [["MITER|BEVEL|ROUND"]] },
			strokeWeight: { overloads: [["Number"]] },
			bezier: { overloads: [[
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number"
			], [
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number"
			]] },
			bezierPoint: { overloads: [[
				"Number",
				"Number",
				"Number",
				"Number",
				"Number"
			]] },
			bezierTangent: { overloads: [[
				"Number",
				"Number",
				"Number",
				"Number",
				"Number"
			]] },
			spline: { overloads: [[
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number"
			], [
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number",
				"Number"
			]] },
			splinePoint: { overloads: [[
				"Number",
				"Number",
				"Number",
				"Number",
				"Number"
			]] },
			splineTangent: { overloads: [[
				"Number",
				"Number",
				"Number",
				"Number",
				"Number"
			]] },
			bezierOrder: { overloads: [["Number"], []] },
			splineVertex: { overloads: [
				["Number", "Number"],
				[
					"Number",
					"Number",
					"Number?"
				],
				[
					"Number",
					"Number",
					"Number?",
					"Number?"
				],
				[
					"Number",
					"Number",
					"Number",
					"Number?",
					"Number?"
				]
			] },
			splineProperty: { overloads: [["String", null], ["String"]] },
			splineProperties: { overloads: [["Object"], []] },
			vertex: { overloads: [
				["Number", "Number"],
				[
					"Number",
					"Number",
					"Number?",
					"Number?"
				],
				[
					"Number",
					"Number",
					"Number",
					"Number?",
					"Number?"
				]
			] },
			beginContour: { overloads: [[]] },
			endContour: { overloads: [["OPEN|CLOSE?"]] },
			beginShape: { overloads: [["POINTS|LINES|TRIANGLES|TRIANGLE_FAN|TRIANGLE_STRIP|QUADS|QUAD_STRIP|PATH?"]] },
			bezierVertex: { overloads: [[
				"Number",
				"Number",
				"Number?",
				"Number?"
			], [
				"Number",
				"Number",
				"Number",
				"Number?",
				"Number?"
			]] },
			endShape: { overloads: [["CLOSE?", "Integer?"]] },
			normal: { overloads: [["p5.Vector"], [
				"Number",
				"Number",
				"Number"
			]] },
			vertexProperty: { overloads: [["String", "Number|Number[]"]] },
			loadFont: { overloads: [[
				"String",
				"String?",
				"Object?",
				"Function?",
				"Function?"
			], [
				"String",
				"Function?",
				"Function?"
			]] },
			text: { overloads: [[
				"String|Object|Array|Number|Boolean",
				"Number",
				"Number",
				"Number?",
				"Number?"
			]] },
			textAlign: { overloads: [["LEFT|CENTER|RIGHT", "TOP|BOTTOM|CENTER|BASELINE?"]] },
			textAscent: { overloads: [["String?"]] },
			textDescent: { overloads: [["String?"]] },
			textLeading: { overloads: [["Number"]] },
			textFont: { overloads: [["p5.Font|String|Object", "Number?"]] },
			textSize: { overloads: [["Number"], []] },
			textStyle: { overloads: [["NORMAL|ITALIC|BOLD|BOLDITALIC"], []] },
			textWidth: { overloads: [["String"]] },
			textWrap: { overloads: [["WORD|CHAR"], []] },
			textBounds: { overloads: [[
				"String",
				"Number",
				"Number",
				"Number?",
				"Number?"
			]] },
			textDirection: { overloads: [["String"], []] },
			textProperty: { overloads: [["String", null], ["String"]] },
			textProperties: { overloads: [["Object"], []] },
			fontBounds: { overloads: [[
				"String",
				"Number",
				"Number",
				"Number?",
				"Number?"
			]] },
			fontWidth: { overloads: [["String"]] },
			fontAscent: { overloads: [[]] },
			fontDescent: { overloads: [[]] },
			textWeight: { overloads: [["Number"], []] },
			float: { overloads: [["String"], ["String[]"]] },
			int: { overloads: [["String|Boolean|Number"], ["Array"]] },
			str: { overloads: [["String|Boolean|Number"]] },
			boolean: { overloads: [["String|Boolean|Number"], ["Array"]] },
			byte: { overloads: [["String|Boolean|Number"], ["Array"]] },
			char: { overloads: [["String|Number"], ["Array"]] },
			unchar: { overloads: [["String"], ["String[]"]] },
			hex: { overloads: [["Number", "Number?"], ["Number[]", "Number?"]] },
			unhex: { overloads: [["String"], ["String[]"]] },
			day: { overloads: [[]] },
			hour: { overloads: [[]] },
			minute: { overloads: [[]] },
			millis: { overloads: [[]] },
			month: { overloads: [[]] },
			second: { overloads: [[]] },
			year: { overloads: [[]] },
			nf: { overloads: [[
				"Number|String",
				"Integer|String?",
				"Integer|String?"
			], [
				"Number[]",
				"Integer|String?",
				"Integer|String?"
			]] },
			nfc: { overloads: [["Number|String", "Integer|String?"], ["Number[]", "Integer|String?"]] },
			nfp: { overloads: [[
				"Number",
				"Integer?",
				"Integer?"
			], [
				"Number[]",
				"Integer?",
				"Integer?"
			]] },
			nfs: { overloads: [[
				"Number",
				"Integer?",
				"Integer?"
			], [
				"Array",
				"Integer?",
				"Integer?"
			]] },
			splitTokens: { overloads: [["String", "String?"]] },
			shuffle: { overloads: [["Array", "Boolean?"]] },
			strokeMode: { overloads: [["String"]] },
			buildGeometry: { overloads: [["Function"]] },
			freeGeometry: { overloads: [["p5.Geometry"]] },
			plane: { overloads: [[
				"Number?",
				"Number?",
				"Integer?",
				"Integer?"
			]] },
			box: { overloads: [[
				"Number?",
				"Number?",
				"Number?",
				"Integer?",
				"Integer?"
			]] },
			sphere: { overloads: [[
				"Number?",
				"Integer?",
				"Integer?"
			]] },
			cylinder: { overloads: [[
				"Number?",
				"Number?",
				"Integer?",
				"Integer?",
				"Boolean?",
				"Boolean?"
			]] },
			cone: { overloads: [[
				"Number?",
				"Number?",
				"Integer?",
				"Integer?",
				"Boolean?"
			]] },
			ellipsoid: { overloads: [[
				"Number?",
				"Number?",
				"Number?",
				"Integer?",
				"Integer?"
			]] },
			torus: { overloads: [[
				"Number?",
				"Number?",
				"Integer?",
				"Integer?"
			]] },
			curveDetail: { overloads: [["Number"]] },
			orbitControl: { overloads: [[
				"Number?",
				"Number?",
				"Number?",
				"Object?"
			]] },
			debugMode: { overloads: [
				[],
				["GRID|AXES"],
				[
					"GRID|AXES",
					"Number?",
					"Number?",
					"Number?",
					"Number?",
					"Number?"
				],
				[
					"GRID|AXES",
					"Number?",
					"Number?",
					"Number?",
					"Number?"
				],
				[
					"Number?",
					"Number?",
					"Number?",
					"Number?",
					"Number?",
					"Number?",
					"Number?",
					"Number?",
					"Number?"
				]
			] },
			noDebugMode: { overloads: [[]] },
			ambientLight: { overloads: [
				[
					"Number",
					"Number",
					"Number",
					"Number?"
				],
				["Number", "Number?"],
				["String"],
				["Number[]"],
				["p5.Color"]
			] },
			specularColor: { overloads: [
				[
					"Number",
					"Number",
					"Number"
				],
				["Number"],
				["String"],
				["Number[]"],
				["p5.Color"]
			] },
			directionalLight: { overloads: [
				[
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number"
				],
				[
					"Number",
					"Number",
					"Number",
					"p5.Vector"
				],
				[
					"p5.Color|Number[]|String",
					"Number",
					"Number",
					"Number"
				],
				["p5.Color|Number[]|String", "p5.Vector"]
			] },
			pointLight: { overloads: [
				[
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number"
				],
				[
					"Number",
					"Number",
					"Number",
					"p5.Vector"
				],
				[
					"p5.Color|Number[]|String",
					"Number",
					"Number",
					"Number"
				],
				["p5.Color|Number[]|String", "p5.Vector"]
			] },
			imageLight: { overloads: [["p5.image"]] },
			panorama: { overloads: [["p5.Image"]] },
			lights: { overloads: [[]] },
			lightFalloff: { overloads: [[
				"Number",
				"Number",
				"Number"
			]] },
			spotLight: { overloads: [
				[
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number?",
					"Number?"
				],
				[
					"p5.Color|Number[]|String",
					"p5.Vector",
					"p5.Vector",
					"Number?",
					"Number?"
				],
				[
					"Number",
					"Number",
					"Number",
					"p5.Vector",
					"p5.Vector",
					"Number?",
					"Number?"
				],
				[
					"p5.Color|Number[]|String",
					"Number",
					"Number",
					"Number",
					"p5.Vector",
					"Number?",
					"Number?"
				],
				[
					"p5.Color|Number[]|String",
					"p5.Vector",
					"Number",
					"Number",
					"Number",
					"Number?",
					"Number?"
				],
				[
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"p5.Vector",
					"Number?",
					"Number?"
				],
				[
					"Number",
					"Number",
					"Number",
					"p5.Vector",
					"Number",
					"Number",
					"Number",
					"Number?",
					"Number?"
				],
				[
					"p5.Color|Number[]|String",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number",
					"Number?",
					"Number?"
				]
			] },
			noLights: { overloads: [[]] },
			loadModel: { overloads: [
				[
					"String|Request",
					"String?",
					"Boolean",
					"function(p5.Geometry)?",
					"function(Event)?"
				],
				[
					"String|Request",
					"String?",
					"function(p5.Geometry)?",
					"function(Event)?"
				],
				["String|Request", "Object?"]
			] },
			model: { overloads: [["p5.Geometry", "Number?"]] },
			createModel: { overloads: [
				[
					"String",
					"String?",
					"Boolean",
					"function(p5.Geometry)?",
					"function(Event)?"
				],
				[
					"String",
					"String?",
					"function(p5.Geometry)?",
					"function(Event)?"
				],
				[
					"String",
					"String?",
					"Object?"
				]
			] },
			loadShader: { overloads: [[
				"String|Request",
				"String|Request",
				"Function?",
				"Function?"
			]] },
			createShader: { overloads: [[
				"String",
				"String",
				"Object?"
			]] },
			loadFilterShader: { overloads: [[
				"String",
				"Function?",
				"Function?"
			]] },
			createFilterShader: { overloads: [["String"]] },
			shader: { overloads: [["p5.Shader"]] },
			strokeShader: { overloads: [["p5.Shader"]] },
			imageShader: { overloads: [["p5.Shader"]] },
			baseMaterialShader: { overloads: [[]] },
			baseFilterShader: { overloads: [[]] },
			baseNormalShader: { overloads: [[]] },
			baseColorShader: { overloads: [[]] },
			baseStrokeShader: { overloads: [[]] },
			resetShader: { overloads: [[]] },
			texture: { overloads: [["p5.Image|p5.MediaElement|p5.Graphics|p5.Texture|p5.Framebuffer|p5.FramebufferTexture"]] },
			textureMode: { overloads: [["IMAGE|NORMAL"]] },
			textureWrap: { overloads: [["CLAMP|REPEAT|MIRROR", "CLAMP|REPEAT|MIRROR?"]] },
			normalMaterial: { overloads: [[]] },
			ambientMaterial: { overloads: [
				[
					"Number",
					"Number",
					"Number"
				],
				["Number"],
				["p5.Color|Number[]|String"]
			] },
			emissiveMaterial: { overloads: [
				[
					"Number",
					"Number",
					"Number",
					"Number?"
				],
				["Number"],
				["p5.Color|Number[]|String"]
			] },
			specularMaterial: { overloads: [
				["Number", "Number?"],
				[
					"Number",
					"Number",
					"Number",
					"Number?"
				],
				["p5.Color|Number[]|String"]
			] },
			shininess: { overloads: [["Number"]] },
			metalness: { overloads: [["Number"]] },
			camera: { overloads: [[
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?"
			]] },
			perspective: { overloads: [[
				"Number?",
				"Number?",
				"Number?",
				"Number?"
			]] },
			linePerspective: { overloads: [["Boolean"], []] },
			ortho: { overloads: [[
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?"
			]] },
			frustum: { overloads: [[
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?"
			]] },
			createCamera: { overloads: [[]] },
			setCamera: { overloads: [["p5.Camera"]] },
			saveObj: { overloads: [["String?"]] },
			saveStl: { overloads: [["String?", "Object?"]] },
			setAttributes: { overloads: [["String", "Boolean"], ["Object"]] },
			remove: { overloads: [[]] },
			createVideo: { overloads: [["String|String[]", "Function?"]] },
			createAudio: { overloads: [[], ["String|String[]?", "Function?"]] },
			createCapture: { overloads: [[
				"AUDIO|VIDEO|Object?",
				"Object?",
				"Function?"
			]] }
		},
		"p5.Geometry": {
			flipV: { overloads: [[]] },
			calculateBoundingBox: { overloads: [[]] },
			clearColors: { overloads: [[]] },
			flipU: { overloads: [[]] },
			computeFaces: { overloads: [[]] },
			computeNormals: { overloads: [["FLAT|SMOOTH?", "Object?"]] },
			makeEdgesFromFaces: { overloads: [[]] },
			normalize: { overloads: [[]] },
			vertexProperty: { overloads: [[
				"String",
				"Number|Number[]",
				"Number?"
			]] }
		},
		"p5.Color": {
			toString: { overloads: [["String?"]] },
			setRed: { overloads: [["Number"]] },
			setGreen: { overloads: [["Number"]] },
			setBlue: { overloads: [["Number"]] },
			setAlpha: { overloads: [["Number"]] }
		},
		"p5.Graphics": {
			reset: { overloads: [[]] },
			remove: { overloads: [[]] },
			createFramebuffer: { overloads: [["Object?"]] }
		},
		"p5.Element": {
			remove: { overloads: [[]] },
			parent: { overloads: [["String|p5.Element|Object"], []] },
			child: { overloads: [[], ["String|p5.Element?"]] },
			html: { overloads: [[], ["String?", "Boolean?"]] },
			id: { overloads: [["String"], []] },
			"class": { overloads: [["String"], []] },
			addClass: { overloads: [["String"]] },
			removeClass: { overloads: [["String"]] },
			hasClass: { overloads: [[null]] },
			toggleClass: { overloads: [[null]] },
			center: { overloads: [["String?"]] },
			position: { overloads: [[], [
				"Number?",
				"Number?",
				"String?"
			]] },
			show: { overloads: [[]] },
			hide: { overloads: [[]] },
			size: { overloads: [[], ["Number|AUTO?", "Number|AUTO?"]] },
			style: { overloads: [["String"], ["String", "String|p5.Color"]] },
			attribute: { overloads: [[], ["String", "String"]] },
			removeAttribute: { overloads: [["String"]] },
			value: { overloads: [[], ["String|Number"]] },
			mousePressed: { overloads: [["Function|Boolean"]] },
			doubleClicked: { overloads: [["Function|Boolean"]] },
			mouseWheel: { overloads: [["Function|Boolean"]] },
			mouseReleased: { overloads: [["Function|Boolean"]] },
			mouseClicked: { overloads: [["Function|Boolean"]] },
			mouseMoved: { overloads: [["Function|Boolean"]] },
			mouseOver: { overloads: [["Function|Boolean"]] },
			mouseOut: { overloads: [["Function|Boolean"]] },
			dragOver: { overloads: [["Function|Boolean"]] },
			dragLeave: { overloads: [["Function|Boolean"]] },
			changed: { overloads: [["Function|Boolean"]] },
			input: { overloads: [["Function|Boolean"]] },
			drop: { overloads: [["Function", "Function?"]] },
			draggable: { overloads: [["p5.Element?"]] }
		},
		"p5.MediaElement": {
			play: { overloads: [[]] },
			stop: { overloads: [[]] },
			pause: { overloads: [[]] },
			loop: { overloads: [[]] },
			noLoop: { overloads: [[]] },
			autoplay: { overloads: [["Boolean?"]] },
			volume: { overloads: [[], ["Number"]] },
			speed: { overloads: [[], ["Number"]] },
			time: { overloads: [[], ["Number"]] },
			duration: { overloads: [[]] },
			onended: { overloads: [["Function"]] },
			connect: { overloads: [["AudioNode|Object"]] },
			disconnect: { overloads: [[]] },
			showControls: { overloads: [[]] },
			hideControls: { overloads: [[]] },
			addCue: { overloads: [[
				"Number",
				"Function",
				"Object?"
			]] },
			removeCue: { overloads: [["Number"]] },
			clearCues: { overloads: [[]] }
		},
		"p5.Image": {
			pixelDensity: { overloads: [["Number?"]] },
			loadPixels: { overloads: [[]] },
			updatePixels: { overloads: [[
				"Integer",
				"Integer",
				"Integer",
				"Integer"
			]] },
			get: { overloads: [
				[
					"Number",
					"Number",
					"Number",
					"Number"
				],
				[],
				["Number", "Number"]
			] },
			set: { overloads: [[
				"Number",
				"Number",
				"Number|Number[]|Object"
			]] },
			resize: { overloads: [["Number", "Number"]] },
			copy: { overloads: [[
				"p5.Image|p5.Element",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer"
			], [
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer"
			]] },
			mask: { overloads: [["p5.Image"]] },
			filter: { overloads: [["THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|ERODE|DILATE|BLUR", "Number?"]] },
			blend: { overloads: [[
				"p5.Image",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"
			], [
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"Integer",
				"BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"
			]] },
			save: { overloads: [["String", "String?"]] },
			reset: { overloads: [[]] },
			getCurrentFrame: { overloads: [[]] },
			setFrame: { overloads: [["Number"]] },
			numFrames: { overloads: [[]] },
			play: { overloads: [[]] },
			pause: { overloads: [[]] },
			delay: { overloads: [["Number", "Number?"]] }
		},
		"p5.Table": {
			addRow: { overloads: [["p5.TableRow?"]] },
			removeRow: { overloads: [["Integer"]] },
			getRow: { overloads: [["Integer"]] },
			getRows: { overloads: [[]] },
			findRow: { overloads: [["String", "Integer|String"]] },
			findRows: { overloads: [["String", "Integer|String"]] },
			matchRow: { overloads: [["String|RegExp", "String|Integer"]] },
			matchRows: { overloads: [["String", "String|Integer?"]] },
			getColumn: { overloads: [["String|Number"]] },
			clearRows: { overloads: [[]] },
			addColumn: { overloads: [["String?"]] },
			getColumnCount: { overloads: [[]] },
			getRowCount: { overloads: [[]] },
			removeTokens: { overloads: [["String", "String|Integer?"]] },
			trim: { overloads: [["String|Integer?"]] },
			removeColumn: { overloads: [["String|Integer"]] },
			set: { overloads: [[
				"Integer",
				"String|Integer",
				"String|Number"
			]] },
			setNum: { overloads: [[
				"Integer",
				"String|Integer",
				"Number"
			]] },
			setString: { overloads: [[
				"Integer",
				"String|Integer",
				"String"
			]] },
			get: { overloads: [["Integer", "String|Integer"]] },
			getNum: { overloads: [["Integer", "String|Integer"]] },
			getString: { overloads: [["Integer", "String|Integer"]] },
			getObject: { overloads: [["String?"]] },
			getArray: { overloads: [[]] }
		},
		"p5.TableRow": {
			set: { overloads: [["String|Integer", "String|Number"]] },
			setNum: { overloads: [["String|Integer", "Number|String"]] },
			setString: { overloads: [["String|Integer", "String|Number|Boolean|Object"]] },
			get: { overloads: [["String|Integer"]] },
			getNum: { overloads: [["String|Integer"]] },
			getString: { overloads: [["String|Integer"]] }
		},
		"p5.XML": {
			getParent: { overloads: [[]] },
			getName: { overloads: [[]] },
			setName: { overloads: [["String"]] },
			hasChildren: { overloads: [[]] },
			listChildren: { overloads: [[]] },
			getChildren: { overloads: [["String?"]] },
			getChild: { overloads: [["String|Integer"]] },
			addChild: { overloads: [["p5.XML"]] },
			removeChild: { overloads: [["String|Integer"]] },
			getAttributeCount: { overloads: [[]] },
			listAttributes: { overloads: [[]] },
			hasAttribute: { overloads: [["String"]] },
			getNum: { overloads: [["String", "Number?"]] },
			getString: { overloads: [["String", "Number?"]] },
			setAttribute: { overloads: [["String", "Number|String|Boolean"]] },
			getContent: { overloads: [["String?"]] },
			serialize: { overloads: [[]] }
		},
		"p5.Vector": {
			getValue: { overloads: [["Number"]] },
			setValue: { overloads: [["Number", "Number"]] },
			set: { overloads: [[
				"Number?",
				"Number?",
				"Number?"
			], ["p5.Vector|Number[]"]] },
			copy: { overloads: [[], ["p5.Vector"]] },
			add: { overloads: [
				[
					"Number|Array",
					"Number?",
					"Number?"
				],
				["p5.Vector|Number[]"],
				[
					"p5.Vector",
					"p5.Vector",
					"p5.Vector?"
				]
			] },
			rem: { overloads: [
				[
					"Number",
					"Number",
					"Number"
				],
				["p5.Vector|Number[]"],
				["p5.Vector", "p5.Vector"]
			] },
			sub: { overloads: [
				[
					"Number",
					"Number?",
					"Number?"
				],
				["p5.Vector|Number[]"],
				[
					"p5.Vector",
					"p5.Vector",
					"p5.Vector?"
				]
			] },
			mult: { overloads: [
				[
					"Number",
					"Number",
					"Number?"
				],
				["Number[]"],
				["p5.Vector"],
				[],
				[
					"p5.Vector",
					"Number",
					"p5.Vector?"
				],
				[
					"p5.Vector",
					"p5.Vector",
					"p5.Vector?"
				],
				[
					"p5.Vector",
					"Number[]",
					"p5.Vector?"
				]
			] },
			div: { overloads: [
				["Number"],
				[
					"Number",
					"Number",
					"Number?"
				],
				["Number[]"],
				["p5.Vector"],
				[],
				[
					"p5.Vector",
					"Number",
					"p5.Vector?"
				],
				[
					"p5.Vector",
					"p5.Vector",
					"p5.Vector?"
				],
				[
					"p5.Vector",
					"Number[]",
					"p5.Vector?"
				]
			] },
			mag: { overloads: [[], ["p5.Vector"]] },
			magSq: { overloads: [[], ["p5.Vector"]] },
			dot: { overloads: [
				[
					"Number",
					"Number?",
					"Number?"
				],
				["p5.Vector"],
				[],
				["p5.Vector", "p5.Vector"]
			] },
			cross: { overloads: [
				["p5.Vector"],
				[],
				["p5.Vector", "p5.Vector"]
			] },
			normalize: { overloads: [[], ["p5.Vector", "p5.Vector?"]] },
			limit: { overloads: [
				["Number"],
				[],
				[
					"p5.Vector",
					"Number",
					"p5.Vector?"
				]
			] },
			setMag: { overloads: [
				["Number"],
				[],
				[
					"p5.Vector",
					"Number",
					"p5.Vector?"
				]
			] },
			heading: { overloads: [[], ["p5.Vector"]] },
			setHeading: { overloads: [["Number"]] },
			rotate: { overloads: [
				["Number"],
				[],
				[
					"p5.Vector",
					"Number",
					"p5.Vector?"
				]
			] },
			angleBetween: { overloads: [
				["p5.Vector"],
				[],
				["p5.Vector", "p5.Vector"]
			] },
			lerp: { overloads: [
				[
					"Number",
					"Number",
					"Number",
					"Number"
				],
				["p5.Vector", "Number"],
				[],
				[
					"p5.Vector",
					"p5.Vector",
					"Number",
					"p5.Vector?"
				]
			] },
			slerp: { overloads: [
				["p5.Vector", "Number"],
				[],
				[
					"p5.Vector",
					"p5.Vector",
					"Number",
					"p5.Vector?"
				]
			] },
			reflect: { overloads: [
				["p5.Vector"],
				[],
				[
					"p5.Vector",
					"p5.Vector",
					"p5.Vector?"
				]
			] },
			array: { overloads: [[], ["p5.Vector"]] },
			equals: { overloads: [
				[
					"Number?",
					"Number?",
					"Number?"
				],
				["p5.Vector|Array"],
				[],
				["p5.Vector|Array", "p5.Vector|Array"]
			] },
			fromAngle: { overloads: [["Number", "Number?"]] },
			fromAngles: { overloads: [[
				"Number",
				"Number",
				"Number?"
			]] },
			random2D: { overloads: [[]] },
			random3D: { overloads: [[]] },
			dist: { overloads: [[], ["p5.Vector", "p5.Vector"]] }
		},
		"p5.Font": {
			textToPaths: { overloads: [[
				"String",
				"Number",
				"Number",
				"Number?",
				"Number?",
				"Object?"
			]] },
			textToPoints: { overloads: [[
				"String",
				"Number",
				"Number",
				"Object?"
			]] },
			textToContours: { overloads: [[
				"String",
				"Number",
				"Number",
				"Object?"
			]] },
			textToModel: { overloads: [[
				"String",
				"Number",
				"Number",
				"Number",
				"Number",
				"Object?"
			]] }
		},
		"p5.Camera": {
			perspective: { overloads: [[
				"Number?",
				"Number?",
				"Number?",
				"Number?"
			]] },
			ortho: { overloads: [[
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?"
			]] },
			frustum: { overloads: [[
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?"
			]] },
			pan: { overloads: [["Number"]] },
			tilt: { overloads: [["Number"]] },
			lookAt: { overloads: [[
				"Number",
				"Number",
				"Number"
			]] },
			camera: { overloads: [[
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?",
				"Number?"
			]] },
			move: { overloads: [[
				"Number",
				"Number",
				"Number"
			]] },
			setPosition: { overloads: [[
				"Number",
				"Number",
				"Number"
			]] },
			set: { overloads: [["p5.Camera"]] },
			slerp: { overloads: [[
				"p5.Camera",
				"p5.Camera",
				"Number"
			]] }
		},
		"p5.Framebuffer": {
			resize: { overloads: [["Number", "Number"]] },
			pixelDensity: { overloads: [["Number?"]] },
			autoSized: { overloads: [["Boolean?"]] },
			createCamera: { overloads: [[]] },
			remove: { overloads: [[]] },
			begin: { overloads: [[]] },
			end: { overloads: [[]] },
			draw: { overloads: [["Function"]] },
			get: { overloads: [
				[
					"Number",
					"Number",
					"Number",
					"Number"
				],
				[],
				["Number", "Number"]
			] }
		},
		"p5.Shader": {
			version: { overloads: [[]] },
			inspectHooks: { overloads: [[]] },
			modify: { overloads: [["Object?"]] },
			copyToContext: { overloads: [["p5|p5.Graphics"]] },
			setUniform: { overloads: [["String", "Boolean|Number|Number[]|p5.Image|p5.Graphics|p5.MediaElement|p5.Texture"]] }
		}
	};
	function validateParams(p5$2, fn$1, lifecycles) {
		let schemaRegistry = /* @__PURE__ */ new Map();
		const p5Constructors = Object.keys(p5$2).reduce((acc, val$1) => {
			if (val$1.match(/^[A-Z]/) && !val$1.match(/^[A-Z][A-Z0-9]*$/) && p5$2[val$1] instanceof Function) acc[val$1] = p5$2[val$1];
			return acc;
		}, {});
		function loadP5Constructors() {
			for (let key of Object.keys(p5$2)) if (typeof p5$2[key] === "function" && key[0] !== key[0].toLowerCase()) p5Constructors[key] = p5$2[key];
		}
		const constantsMap = {};
		for (const [key, value] of Object.entries(constants)) constantsMap[key] = value;
		const schemaMap = {
			"Any": any(),
			"Array": array(any()),
			"Boolean": boolean(),
			"Function": _function(),
			"Integer": number().int(),
			"Number": number(),
			"Object": object({}),
			"String": string()
		};
		const webAPIObjects = [
			"AudioNode",
			"HTMLCanvasElement",
			"HTMLElement",
			"KeyboardEvent",
			"MouseEvent",
			"RegExp",
			"TouchEvent",
			"UIEvent",
			"WheelEvent"
		];
		function generateWebAPISchemas(apiObjects) {
			return apiObjects.reduce((acc, obj) => {
				acc[obj] = custom((data$2) => data$2 instanceof globalThis[obj], { message: `Expected a ${obj}` });
				return acc;
			}, {});
		}
		const webAPISchemas = generateWebAPISchemas(webAPIObjects);
		Object.assign(schemaMap, webAPISchemas);
		const ordinals = [
			"first",
			"second",
			"third",
			"fourth",
			"fifth",
			"sixth",
			"seventh",
			"eighth",
			"ninth",
			"tenth"
		];
		function extractFuncNameAndClass(func) {
			const ichDot = func.lastIndexOf(".");
			return {
				funcName: func.slice(ichDot + 1),
				funcClass: func.slice(0, ichDot !== -1 ? ichDot : 0) || "p5"
			};
		}
		function validBracketNesting(type$2) {
			let level = 0;
			for (let i$1 = 0; i$1 < type$2.length; i$1++) if (type$2[i$1] === "[") level++;
			else if (type$2[i$1] === "]") {
				level--;
				if (level < 0) return false;
			}
			return level === 0;
		}
		fn$1.generateZodSchemasForFunc = function(func) {
			const { funcName, funcClass } = extractFuncNameAndClass(func);
			let funcInfo = dataDoc[funcClass][funcName];
			if (!funcInfo) return;
			let overloads = [];
			if (funcInfo.hasOwnProperty("overloads")) overloads = funcInfo.overloads;
			const generateTypeSchema = (baseType) => {
				if (!baseType) return any();
				let typeSchema;
				if (baseType in constantsMap) typeSchema = literal$1(constantsMap[baseType]);
				else if (baseType.match(/^[A-Z][A-Z0-9]*$/) && baseType in fn$1) typeSchema = literal$1(fn$1[baseType]);
				else if (baseType.startsWith("function")) typeSchema = _function();
				else if (/^p5\.[a-zA-Z0-9]+$/.exec(baseType) || baseType === "p5") typeSchema = _instanceof(p5Constructors[baseType.substring(baseType.indexOf(".") + 1)]);
				else if (schemaMap[baseType]) typeSchema = schemaMap[baseType];
				else if (baseType.startsWith("[") && baseType.endsWith("]") && validBracketNesting(baseType.slice(1, -1))) typeSchema = tuple(baseType.slice(1, -1).split(/, */g).map((entry) => generateTypeSchema(entry)));
				else if (baseType.match(/^[A-Z]/) && baseType in window) typeSchema = _instanceof(window[baseType]);
				else if (baseType.includes("|") && baseType.split("|").every((t$1) => validBracketNesting(t$1))) typeSchema = union(baseType.split("|").map((t$1) => generateTypeSchema(t$1)).filter((s) => s !== void 0));
				else if (baseType.endsWith("[]")) typeSchema = array(generateTypeSchema(baseType.slice(0, -2)));
				else throw new Error(`Unsupported type '${baseType}' in parameter validation. Please report this issue.`);
				return typeSchema;
			};
			const generateParamSchema = (param) => {
				const isOptional = param?.endsWith("?");
				param = param?.replace(/\?$/, "");
				const isRest = param?.startsWith("...") && param?.endsWith("[]");
				param = param?.replace(/^\.\.\.(.+)\[\]$/, "$1");
				let schema = generateTypeSchema(param);
				if (schema.def.type === "function") schema = custom((val$1) => val$1 instanceof Function);
				if (isOptional) schema = schema.optional();
				return {
					schema,
					rest: isRest
				};
			};
			const generateOverloadCombinations = (params) => {
				if (!params.some((p$1) => p$1?.endsWith("?"))) return [params];
				const requiredParamsCount = params.filter((p$1) => p$1 === null || !p$1.endsWith("?")).length;
				const result = [];
				for (let i$1 = requiredParamsCount; i$1 <= params.length; i$1++) result.push(params.slice(0, i$1));
				return result;
			};
			const overloadSchemas = overloads.flatMap((overload) => {
				return generateOverloadCombinations(overload).map((combo) => {
					const params = combo.map((p$1) => generateParamSchema(p$1)).filter((s) => s.schema !== void 0);
					let rest;
					if (params.at(-1)?.rest) rest = params.pop();
					let combined = tuple(params.map((s) => s.schema));
					if (rest) combined = combined.rest(rest.schema);
					return combined;
				});
			});
			return overloadSchemas.length === 1 ? overloadSchemas[0] : union(overloadSchemas);
		};
		fn$1.findClosestSchema = function(schema, args) {
			if (!(schema instanceof ZodUnion)) return schema;
			const scoreSchema = (schema$1) => {
				let score = Infinity;
				if (!(schema$1 instanceof ZodTuple)) {
					console.warn("Schema below is not a tuple: ");
					printZodSchema(schema$1);
					return score;
				}
				const numArgs = args.length;
				const schemaItems = schema$1.def.items;
				const numSchemaItems = schemaItems.length;
				const numRequiredSchemaItems = schemaItems.filter((item) => !item.isOptional()).length;
				if (numArgs >= numRequiredSchemaItems && numArgs <= numSchemaItems) score = 0;
				else score = Math.abs(numArgs < numRequiredSchemaItems ? numRequiredSchemaItems - numArgs : numArgs - numSchemaItems) * 4;
				for (let i$1 = 0; i$1 < Math.min(schemaItems.length, args.length); i$1++) {
					const paramSchema = schemaItems[i$1];
					const arg = args[i$1];
					if (!paramSchema.safeParse(arg).success) score++;
				}
				return score;
			};
			let closestSchema = schema.def.options[0];
			let bestScore = Infinity;
			schema.def.options.forEach((schema$1) => {
				const score = scoreSchema(schema$1);
				if (score < bestScore) {
					closestSchema = schema$1;
					bestScore = score;
				}
			});
			return closestSchema;
		};
		fn$1.friendlyParamError = function(zodErrorObj, func, args) {
			let message = "🌸 p5.js says: ";
			let isVersionError = false;
			let currentError = zodErrorObj.issues[0];
			const buildTypeMismatchMessage = (actualType, expectedTypeStr, position) => {
				return `Expected ${expectedTypeStr} ${position ? `at the ${ordinals[position]} parameter` : ""}${actualType ? `, but received ${actualType}` : ""}`;
			};
			const processUnionError = (error$1) => {
				const expectedTypes = /* @__PURE__ */ new Set();
				let actualType;
				error$1.errors.forEach((err$1) => {
					const issue$1 = err$1[0];
					if (issue$1) {
						if (!actualType) actualType = issue$1.message;
						if (issue$1.code === "invalid_type") {
							actualType = issue$1.message.split(", received ")[1];
							expectedTypes.add(issue$1.expected);
						} else if (issue$1.code === "invalid_value") {
							expectedTypes.add("constant (please refer to documentation for allowed values)");
							actualType = args[error$1.path[0]];
						} else if (issue$1.code === "custom") {
							const match = issue$1.message.match(/Input not instance of (\w+)/);
							if (match) expectedTypes.add(match[1]);
							actualType = void 0;
						}
					}
				});
				if (expectedTypes.size > 0) {
					if (error$1.path?.length > 0 && args[error$1.path[0]] instanceof Promise) {
						message += "Did you mean to put `await` before a loading function? An unexpected Promise was found. ";
						isVersionError = true;
					}
					const expectedTypesStr = Array.from(expectedTypes).join(" or ");
					const position = error$1.path.join(".");
					message += buildTypeMismatchMessage(actualType, expectedTypesStr, position);
				}
				return message;
			};
			switch (currentError.code) {
				case "invalid_union":
					processUnionError(currentError);
					break;
				case "too_small": {
					const minArgs = currentError.minimum;
					message += `Expected at least ${minArgs} argument${minArgs > 1 ? "s" : ""}, but received fewer`;
					break;
				}
				case "invalid_type":
					message += buildTypeMismatchMessage(currentError.message.split(", received ")[1], currentError.expected, currentError.path.join("."));
					break;
				case "too_big": {
					const maxArgs = currentError.maximum;
					message += `Expected at most ${maxArgs} argument${maxArgs > 1 ? "s" : ""}, but received more`;
					break;
				}
				default: console.log("Zod error object", currentError);
			}
			message += ` in ${func}().`;
			const generateDocumentationLink = (func$1) => {
				const { funcName, funcClass } = extractFuncNameAndClass(func$1);
				return `https://p5js.org/reference/${funcClass}/${funcName}`;
			};
			if (currentError.code === "too_big" || currentError.code === "too_small") {
				const documentationLink = generateDocumentationLink(func);
				message += ` For more information, see ${documentationLink}.`;
			}
			if (isVersionError) p5$2._error(this, message);
			else console.log(message);
			return message;
		};
		fn$1.validate = function(func, args) {
			if (p5$2.disableFriendlyErrors) return;
			if (!Array.isArray(args)) args = Array.from(args);
			if (Array.isArray(args) && args.length > 0 && args.every((arg) => arg === void 0)) return {
				success: false,
				error: `🌸 p5.js says: All arguments for ${func}() are undefined. There is likely an error in the code.`
			};
			let funcSchemas = schemaRegistry.get(func);
			if (!funcSchemas) {
				funcSchemas = fn$1.generateZodSchemasForFunc(func);
				if (!funcSchemas) return;
				schemaRegistry.set(func, funcSchemas);
			}
			try {
				return {
					success: true,
					data: funcSchemas.parse(args)
				};
			} catch (error$1) {
				const zodError = fn$1.findClosestSchema(funcSchemas, args).safeParse(args).error;
				return {
					success: false,
					error: fn$1.friendlyParamError(zodError, func, args)
				};
			}
		};
		lifecycles.presetup = function() {
			loadP5Constructors();
			if (p5$2.disableParameterValidator !== true) {
				const excludes = ["validate"];
				for (const f in this) if (!excludes.includes(f) && !f.startsWith("_") && typeof this[f] === "function") {
					const copy$1 = this[f];
					this[f] = function(...args) {
						this.validate(f, args);
						return copy$1.call(this, ...args);
					};
				}
			}
		};
	}
	if (typeof p5 !== "undefined") validateParams(p5, p5.prototype);
	var astralIdentifierCodes = [
		509,
		0,
		227,
		0,
		150,
		4,
		294,
		9,
		1368,
		2,
		2,
		1,
		6,
		3,
		41,
		2,
		5,
		0,
		166,
		1,
		574,
		3,
		9,
		9,
		7,
		9,
		32,
		4,
		318,
		1,
		80,
		3,
		71,
		10,
		50,
		3,
		123,
		2,
		54,
		14,
		32,
		10,
		3,
		1,
		11,
		3,
		46,
		10,
		8,
		0,
		46,
		9,
		7,
		2,
		37,
		13,
		2,
		9,
		6,
		1,
		45,
		0,
		13,
		2,
		49,
		13,
		9,
		3,
		2,
		11,
		83,
		11,
		7,
		0,
		3,
		0,
		158,
		11,
		6,
		9,
		7,
		3,
		56,
		1,
		2,
		6,
		3,
		1,
		3,
		2,
		10,
		0,
		11,
		1,
		3,
		6,
		4,
		4,
		68,
		8,
		2,
		0,
		3,
		0,
		2,
		3,
		2,
		4,
		2,
		0,
		15,
		1,
		83,
		17,
		10,
		9,
		5,
		0,
		82,
		19,
		13,
		9,
		214,
		6,
		3,
		8,
		28,
		1,
		83,
		16,
		16,
		9,
		82,
		12,
		9,
		9,
		7,
		19,
		58,
		14,
		5,
		9,
		243,
		14,
		166,
		9,
		71,
		5,
		2,
		1,
		3,
		3,
		2,
		0,
		2,
		1,
		13,
		9,
		120,
		6,
		3,
		6,
		4,
		0,
		29,
		9,
		41,
		6,
		2,
		3,
		9,
		0,
		10,
		10,
		47,
		15,
		343,
		9,
		54,
		7,
		2,
		7,
		17,
		9,
		57,
		21,
		2,
		13,
		123,
		5,
		4,
		0,
		2,
		1,
		2,
		6,
		2,
		0,
		9,
		9,
		49,
		4,
		2,
		1,
		2,
		4,
		9,
		9,
		330,
		3,
		10,
		1,
		2,
		0,
		49,
		6,
		4,
		4,
		14,
		10,
		5350,
		0,
		7,
		14,
		11465,
		27,
		2343,
		9,
		87,
		9,
		39,
		4,
		60,
		6,
		26,
		9,
		535,
		9,
		470,
		0,
		2,
		54,
		8,
		3,
		82,
		0,
		12,
		1,
		19628,
		1,
		4178,
		9,
		519,
		45,
		3,
		22,
		543,
		4,
		4,
		5,
		9,
		7,
		3,
		6,
		31,
		3,
		149,
		2,
		1418,
		49,
		513,
		54,
		5,
		49,
		9,
		0,
		15,
		0,
		23,
		4,
		2,
		14,
		1361,
		6,
		2,
		16,
		3,
		6,
		2,
		1,
		2,
		4,
		101,
		0,
		161,
		6,
		10,
		9,
		357,
		0,
		62,
		13,
		499,
		13,
		245,
		1,
		2,
		9,
		726,
		6,
		110,
		6,
		6,
		9,
		4759,
		9,
		787719,
		239
	];
	var astralIdentifierStartCodes = [
		0,
		11,
		2,
		25,
		2,
		18,
		2,
		1,
		2,
		14,
		3,
		13,
		35,
		122,
		70,
		52,
		268,
		28,
		4,
		48,
		48,
		31,
		14,
		29,
		6,
		37,
		11,
		29,
		3,
		35,
		5,
		7,
		2,
		4,
		43,
		157,
		19,
		35,
		5,
		35,
		5,
		39,
		9,
		51,
		13,
		10,
		2,
		14,
		2,
		6,
		2,
		1,
		2,
		10,
		2,
		14,
		2,
		6,
		2,
		1,
		4,
		51,
		13,
		310,
		10,
		21,
		11,
		7,
		25,
		5,
		2,
		41,
		2,
		8,
		70,
		5,
		3,
		0,
		2,
		43,
		2,
		1,
		4,
		0,
		3,
		22,
		11,
		22,
		10,
		30,
		66,
		18,
		2,
		1,
		11,
		21,
		11,
		25,
		71,
		55,
		7,
		1,
		65,
		0,
		16,
		3,
		2,
		2,
		2,
		28,
		43,
		28,
		4,
		28,
		36,
		7,
		2,
		27,
		28,
		53,
		11,
		21,
		11,
		18,
		14,
		17,
		111,
		72,
		56,
		50,
		14,
		50,
		14,
		35,
		39,
		27,
		10,
		22,
		251,
		41,
		7,
		1,
		17,
		2,
		60,
		28,
		11,
		0,
		9,
		21,
		43,
		17,
		47,
		20,
		28,
		22,
		13,
		52,
		58,
		1,
		3,
		0,
		14,
		44,
		33,
		24,
		27,
		35,
		30,
		0,
		3,
		0,
		9,
		34,
		4,
		0,
		13,
		47,
		15,
		3,
		22,
		0,
		2,
		0,
		36,
		17,
		2,
		24,
		20,
		1,
		64,
		6,
		2,
		0,
		2,
		3,
		2,
		14,
		2,
		9,
		8,
		46,
		39,
		7,
		3,
		1,
		3,
		21,
		2,
		6,
		2,
		1,
		2,
		4,
		4,
		0,
		19,
		0,
		13,
		4,
		31,
		9,
		2,
		0,
		3,
		0,
		2,
		37,
		2,
		0,
		26,
		0,
		2,
		0,
		45,
		52,
		19,
		3,
		21,
		2,
		31,
		47,
		21,
		1,
		2,
		0,
		185,
		46,
		42,
		3,
		37,
		47,
		21,
		0,
		60,
		42,
		14,
		0,
		72,
		26,
		38,
		6,
		186,
		43,
		117,
		63,
		32,
		7,
		3,
		0,
		3,
		7,
		2,
		1,
		2,
		23,
		16,
		0,
		2,
		0,
		95,
		7,
		3,
		38,
		17,
		0,
		2,
		0,
		29,
		0,
		11,
		39,
		8,
		0,
		22,
		0,
		12,
		45,
		20,
		0,
		19,
		72,
		200,
		32,
		32,
		8,
		2,
		36,
		18,
		0,
		50,
		29,
		113,
		6,
		2,
		1,
		2,
		37,
		22,
		0,
		26,
		5,
		2,
		1,
		2,
		31,
		15,
		0,
		328,
		18,
		16,
		0,
		2,
		12,
		2,
		33,
		125,
		0,
		80,
		921,
		103,
		110,
		18,
		195,
		2637,
		96,
		16,
		1071,
		18,
		5,
		26,
		3994,
		6,
		582,
		6842,
		29,
		1763,
		568,
		8,
		30,
		18,
		78,
		18,
		29,
		19,
		47,
		17,
		3,
		32,
		20,
		6,
		18,
		433,
		44,
		212,
		63,
		129,
		74,
		6,
		0,
		67,
		12,
		65,
		1,
		2,
		0,
		29,
		6135,
		9,
		1237,
		42,
		9,
		8936,
		3,
		2,
		6,
		2,
		1,
		2,
		290,
		16,
		0,
		30,
		2,
		3,
		0,
		15,
		3,
		9,
		395,
		2309,
		106,
		6,
		12,
		4,
		8,
		8,
		9,
		5991,
		84,
		2,
		70,
		2,
		1,
		3,
		0,
		3,
		1,
		3,
		3,
		2,
		11,
		2,
		0,
		2,
		6,
		2,
		64,
		2,
		3,
		3,
		7,
		2,
		6,
		2,
		27,
		2,
		3,
		2,
		4,
		2,
		0,
		4,
		6,
		2,
		339,
		3,
		24,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		30,
		2,
		24,
		2,
		7,
		1845,
		30,
		7,
		5,
		262,
		61,
		147,
		44,
		11,
		6,
		17,
		0,
		322,
		29,
		19,
		43,
		485,
		27,
		229,
		29,
		3,
		0,
		496,
		6,
		2,
		3,
		2,
		1,
		2,
		14,
		2,
		196,
		60,
		67,
		8,
		0,
		1205,
		3,
		2,
		26,
		2,
		1,
		2,
		0,
		3,
		0,
		2,
		9,
		2,
		3,
		2,
		0,
		2,
		0,
		7,
		0,
		5,
		0,
		2,
		0,
		2,
		0,
		2,
		2,
		2,
		1,
		2,
		0,
		3,
		0,
		2,
		0,
		2,
		0,
		2,
		0,
		2,
		0,
		2,
		1,
		2,
		0,
		3,
		3,
		2,
		6,
		2,
		3,
		2,
		3,
		2,
		0,
		2,
		9,
		2,
		16,
		6,
		2,
		2,
		4,
		2,
		16,
		4421,
		42719,
		33,
		4153,
		7,
		221,
		3,
		5761,
		15,
		7472,
		16,
		621,
		2467,
		541,
		1507,
		4938,
		6,
		4191
	];
	var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
	var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
	var reservedWords = {
		3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
		5: "class enum extends super const export import",
		6: "enum",
		strict: "implements interface let package private protected public static yield",
		strictBind: "eval arguments"
	};
	var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
	var keywords$1 = {
		5: ecma5AndLessKeywords,
		"5module": ecma5AndLessKeywords + " export import",
		6: ecma5AndLessKeywords + " const class extends export import super"
	};
	var keywordRelationalOperator = /^in(stanceof)?$/;
	var nonASCIIidentifierStart = /* @__PURE__ */ new RegExp("[" + nonASCIIidentifierStartChars + "]");
	var nonASCIIidentifier = /* @__PURE__ */ new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
	function isInAstralSet(code, set$1) {
		var pos = 65536;
		for (var i$1 = 0; i$1 < set$1.length; i$1 += 2) {
			pos += set$1[i$1];
			if (pos > code) return false;
			pos += set$1[i$1 + 1];
			if (pos >= code) return true;
		}
		return false;
	}
	function isIdentifierStart(code, astral) {
		if (code < 65) return code === 36;
		if (code < 91) return true;
		if (code < 97) return code === 95;
		if (code < 123) return true;
		if (code <= 65535) return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
		if (astral === false) return false;
		return isInAstralSet(code, astralIdentifierStartCodes);
	}
	function isIdentifierChar(code, astral) {
		if (code < 48) return code === 36;
		if (code < 58) return true;
		if (code < 65) return false;
		if (code < 91) return true;
		if (code < 97) return code === 95;
		if (code < 123) return true;
		if (code <= 65535) return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
		if (astral === false) return false;
		return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
	}
	var TokenType = function TokenType$1(label, conf) {
		if (conf === void 0) conf = {};
		this.label = label;
		this.keyword = conf.keyword;
		this.beforeExpr = !!conf.beforeExpr;
		this.startsExpr = !!conf.startsExpr;
		this.isLoop = !!conf.isLoop;
		this.isAssign = !!conf.isAssign;
		this.prefix = !!conf.prefix;
		this.postfix = !!conf.postfix;
		this.binop = conf.binop || null;
		this.updateContext = null;
	};
	function binop(name, prec) {
		return new TokenType(name, {
			beforeExpr: true,
			binop: prec
		});
	}
	var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
	var keywords = {};
	function kw(name, options$1) {
		if (options$1 === void 0) options$1 = {};
		options$1.keyword = name;
		return keywords[name] = new TokenType(name, options$1);
	}
	var types$1 = {
		num: new TokenType("num", startsExpr),
		regexp: new TokenType("regexp", startsExpr),
		string: new TokenType("string", startsExpr),
		name: new TokenType("name", startsExpr),
		privateId: new TokenType("privateId", startsExpr),
		eof: new TokenType("eof"),
		bracketL: new TokenType("[", {
			beforeExpr: true,
			startsExpr: true
		}),
		bracketR: new TokenType("]"),
		braceL: new TokenType("{", {
			beforeExpr: true,
			startsExpr: true
		}),
		braceR: new TokenType("}"),
		parenL: new TokenType("(", {
			beforeExpr: true,
			startsExpr: true
		}),
		parenR: new TokenType(")"),
		comma: new TokenType(",", beforeExpr),
		semi: new TokenType(";", beforeExpr),
		colon: new TokenType(":", beforeExpr),
		dot: new TokenType("."),
		question: new TokenType("?", beforeExpr),
		questionDot: new TokenType("?."),
		arrow: new TokenType("=>", beforeExpr),
		template: new TokenType("template"),
		invalidTemplate: new TokenType("invalidTemplate"),
		ellipsis: new TokenType("...", beforeExpr),
		backQuote: new TokenType("`", startsExpr),
		dollarBraceL: new TokenType("${", {
			beforeExpr: true,
			startsExpr: true
		}),
		eq: new TokenType("=", {
			beforeExpr: true,
			isAssign: true
		}),
		assign: new TokenType("_=", {
			beforeExpr: true,
			isAssign: true
		}),
		incDec: new TokenType("++/--", {
			prefix: true,
			postfix: true,
			startsExpr: true
		}),
		prefix: new TokenType("!/~", {
			beforeExpr: true,
			prefix: true,
			startsExpr: true
		}),
		logicalOR: binop("||", 1),
		logicalAND: binop("&&", 2),
		bitwiseOR: binop("|", 3),
		bitwiseXOR: binop("^", 4),
		bitwiseAND: binop("&", 5),
		equality: binop("==/!=/===/!==", 6),
		relational: binop("</>/<=/>=", 7),
		bitShift: binop("<</>>/>>>", 8),
		plusMin: new TokenType("+/-", {
			beforeExpr: true,
			binop: 9,
			prefix: true,
			startsExpr: true
		}),
		modulo: binop("%", 10),
		star: binop("*", 10),
		slash: binop("/", 10),
		starstar: new TokenType("**", { beforeExpr: true }),
		coalesce: binop("??", 1),
		_break: kw("break"),
		_case: kw("case", beforeExpr),
		_catch: kw("catch"),
		_continue: kw("continue"),
		_debugger: kw("debugger"),
		_default: kw("default", beforeExpr),
		_do: kw("do", {
			isLoop: true,
			beforeExpr: true
		}),
		_else: kw("else", beforeExpr),
		_finally: kw("finally"),
		_for: kw("for", { isLoop: true }),
		_function: kw("function", startsExpr),
		_if: kw("if"),
		_return: kw("return", beforeExpr),
		_switch: kw("switch"),
		_throw: kw("throw", beforeExpr),
		_try: kw("try"),
		_var: kw("var"),
		_const: kw("const"),
		_while: kw("while", { isLoop: true }),
		_with: kw("with"),
		_new: kw("new", {
			beforeExpr: true,
			startsExpr: true
		}),
		_this: kw("this", startsExpr),
		_super: kw("super", startsExpr),
		_class: kw("class", startsExpr),
		_extends: kw("extends", beforeExpr),
		_export: kw("export"),
		_import: kw("import", startsExpr),
		_null: kw("null", startsExpr),
		_true: kw("true", startsExpr),
		_false: kw("false", startsExpr),
		_in: kw("in", {
			beforeExpr: true,
			binop: 7
		}),
		_instanceof: kw("instanceof", {
			beforeExpr: true,
			binop: 7
		}),
		_typeof: kw("typeof", {
			beforeExpr: true,
			prefix: true,
			startsExpr: true
		}),
		_void: kw("void", {
			beforeExpr: true,
			prefix: true,
			startsExpr: true
		}),
		_delete: kw("delete", {
			beforeExpr: true,
			prefix: true,
			startsExpr: true
		})
	};
	var lineBreak = /\r\n?|\n|\u2028|\u2029/;
	var lineBreakG = new RegExp(lineBreak.source, "g");
	function isNewLine(code) {
		return code === 10 || code === 13 || code === 8232 || code === 8233;
	}
	function nextLineBreak(code, from, end) {
		if (end === void 0) end = code.length;
		for (var i$1 = from; i$1 < end; i$1++) {
			var next = code.charCodeAt(i$1);
			if (isNewLine(next)) return i$1 < end - 1 && next === 13 && code.charCodeAt(i$1 + 1) === 10 ? i$1 + 2 : i$1 + 1;
		}
		return -1;
	}
	var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
	var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
	var ref = Object.prototype;
	var hasOwnProperty = ref.hasOwnProperty;
	var toString$2 = ref.toString;
	var hasOwn = Object.hasOwn || (function(obj, propName) {
		return hasOwnProperty.call(obj, propName);
	});
	var isArray = Array.isArray || (function(obj) {
		return toString$2.call(obj) === "[object Array]";
	});
	var regexpCache = Object.create(null);
	function wordsRegexp(words) {
		return regexpCache[words] || (regexpCache[words] = /* @__PURE__ */ new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
	}
	function codePointToString(code) {
		if (code <= 65535) return String.fromCharCode(code);
		code -= 65536;
		return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
	}
	var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
	var Position = function Position$1(line, col) {
		this.line = line;
		this.column = col;
	};
	Position.prototype.offset = function offset(n$2) {
		return new Position(this.line, this.column + n$2);
	};
	var SourceLocation = function SourceLocation$1(p$1, start, end) {
		this.start = start;
		this.end = end;
		if (p$1.sourceFile !== null) this.source = p$1.sourceFile;
	};
	function getLineInfo(input, offset) {
		for (var line = 1, cur = 0;;) {
			var nextBreak = nextLineBreak(input, cur, offset);
			if (nextBreak < 0) return new Position(line, offset - cur);
			++line;
			cur = nextBreak;
		}
	}
	var defaultOptions = {
		ecmaVersion: null,
		sourceType: "script",
		onInsertedSemicolon: null,
		onTrailingComma: null,
		allowReserved: null,
		allowReturnOutsideFunction: false,
		allowImportExportEverywhere: false,
		allowAwaitOutsideFunction: null,
		allowSuperOutsideMethod: null,
		allowHashBang: false,
		checkPrivateFields: true,
		locations: false,
		onToken: null,
		onComment: null,
		ranges: false,
		program: null,
		sourceFile: null,
		directSourceFile: null,
		preserveParens: false
	};
	var warnedAboutEcmaVersion = false;
	function getOptions(opts) {
		var options$1 = {};
		for (var opt in defaultOptions) options$1[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
		if (options$1.ecmaVersion === "latest") options$1.ecmaVersion = 1e8;
		else if (options$1.ecmaVersion == null) {
			if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
				warnedAboutEcmaVersion = true;
				console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
			}
			options$1.ecmaVersion = 11;
		} else if (options$1.ecmaVersion >= 2015) options$1.ecmaVersion -= 2009;
		if (options$1.allowReserved == null) options$1.allowReserved = options$1.ecmaVersion < 5;
		if (!opts || opts.allowHashBang == null) options$1.allowHashBang = options$1.ecmaVersion >= 14;
		if (isArray(options$1.onToken)) {
			var tokens = options$1.onToken;
			options$1.onToken = function(token) {
				return tokens.push(token);
			};
		}
		if (isArray(options$1.onComment)) options$1.onComment = pushComment(options$1, options$1.onComment);
		return options$1;
	}
	function pushComment(options$1, array$1) {
		return function(block, text$1, start, end, startLoc, endLoc) {
			var comment = {
				type: block ? "Block" : "Line",
				value: text$1,
				start,
				end
			};
			if (options$1.locations) comment.loc = new SourceLocation(this, startLoc, endLoc);
			if (options$1.ranges) comment.range = [start, end];
			array$1.push(comment);
		};
	}
	var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_CLASS_FIELD_INIT = 512, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
	function functionFlags(async, generator) {
		return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
	}
	var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
	var Parser = function Parser$1(options$1, input, startPos) {
		this.options = options$1 = getOptions(options$1);
		this.sourceFile = options$1.sourceFile;
		this.keywords = wordsRegexp(keywords$1[options$1.ecmaVersion >= 6 ? 6 : options$1.sourceType === "module" ? "5module" : 5]);
		var reserved = "";
		if (options$1.allowReserved !== true) {
			reserved = reservedWords[options$1.ecmaVersion >= 6 ? 6 : options$1.ecmaVersion === 5 ? 5 : 3];
			if (options$1.sourceType === "module") reserved += " await";
		}
		this.reservedWords = wordsRegexp(reserved);
		var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
		this.reservedWordsStrict = wordsRegexp(reservedStrict);
		this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
		this.input = String(input);
		this.containsEsc = false;
		if (startPos) {
			this.pos = startPos;
			this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
			this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
		} else {
			this.pos = this.lineStart = 0;
			this.curLine = 1;
		}
		this.type = types$1.eof;
		this.value = null;
		this.start = this.end = this.pos;
		this.startLoc = this.endLoc = this.curPosition();
		this.lastTokEndLoc = this.lastTokStartLoc = null;
		this.lastTokStart = this.lastTokEnd = this.pos;
		this.context = this.initialContext();
		this.exprAllowed = true;
		this.inModule = options$1.sourceType === "module";
		this.strict = this.inModule || this.strictDirective(this.pos);
		this.potentialArrowAt = -1;
		this.potentialArrowInForAwait = false;
		this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
		this.labels = [];
		this.undefinedExports = Object.create(null);
		if (this.pos === 0 && options$1.allowHashBang && this.input.slice(0, 2) === "#!") this.skipLineComment(2);
		this.scopeStack = [];
		this.enterScope(SCOPE_TOP);
		this.regexpState = null;
		this.privateNameStack = [];
	};
	var prototypeAccessors = {
		inFunction: { configurable: true },
		inGenerator: { configurable: true },
		inAsync: { configurable: true },
		canAwait: { configurable: true },
		allowSuper: { configurable: true },
		allowDirectSuper: { configurable: true },
		treatFunctionsAsVar: { configurable: true },
		allowNewDotTarget: { configurable: true },
		inClassStaticBlock: { configurable: true }
	};
	Parser.prototype.parse = function parse$5() {
		var node = this.options.program || this.startNode();
		this.nextToken();
		return this.parseTopLevel(node);
	};
	prototypeAccessors.inFunction.get = function() {
		return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
	};
	prototypeAccessors.inGenerator.get = function() {
		return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
	};
	prototypeAccessors.inAsync.get = function() {
		return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
	};
	prototypeAccessors.canAwait.get = function() {
		for (var i$1 = this.scopeStack.length - 1; i$1 >= 0; i$1--) {
			var flags = this.scopeStack[i$1].flags;
			if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) return false;
			if (flags & SCOPE_FUNCTION) return (flags & SCOPE_ASYNC) > 0;
		}
		return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
	};
	prototypeAccessors.allowSuper.get = function() {
		return (this.currentThisScope().flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
	};
	prototypeAccessors.allowDirectSuper.get = function() {
		return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
	};
	prototypeAccessors.treatFunctionsAsVar.get = function() {
		return this.treatFunctionsAsVarInScope(this.currentScope());
	};
	prototypeAccessors.allowNewDotTarget.get = function() {
		for (var i$1 = this.scopeStack.length - 1; i$1 >= 0; i$1--) {
			var flags = this.scopeStack[i$1].flags;
			if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) return true;
		}
		return false;
	};
	prototypeAccessors.inClassStaticBlock.get = function() {
		return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
	};
	Parser.extend = function extend$1() {
		var plugins = [], len = arguments.length;
		while (len--) plugins[len] = arguments[len];
		var cls = this;
		for (var i$1 = 0; i$1 < plugins.length; i$1++) cls = plugins[i$1](cls);
		return cls;
	};
	Parser.parse = function parse$5(input, options$1) {
		return new this(options$1, input).parse();
	};
	Parser.parseExpressionAt = function parseExpressionAt(input, pos, options$1) {
		var parser = new this(options$1, input, pos);
		parser.nextToken();
		return parser.parseExpression();
	};
	Parser.tokenizer = function tokenizer(input, options$1) {
		return new this(options$1, input);
	};
	Object.defineProperties(Parser.prototype, prototypeAccessors);
	var pp$9 = Parser.prototype;
	var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
	pp$9.strictDirective = function(start) {
		if (this.options.ecmaVersion < 5) return false;
		for (;;) {
			skipWhiteSpace.lastIndex = start;
			start += skipWhiteSpace.exec(this.input)[0].length;
			var match = literal.exec(this.input.slice(start));
			if (!match) return false;
			if ((match[1] || match[2]) === "use strict") {
				skipWhiteSpace.lastIndex = start + match[0].length;
				var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
				var next = this.input.charAt(end);
				return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
			}
			start += match[0].length;
			skipWhiteSpace.lastIndex = start;
			start += skipWhiteSpace.exec(this.input)[0].length;
			if (this.input[start] === ";") start++;
		}
	};
	pp$9.eat = function(type$2) {
		if (this.type === type$2) {
			this.next();
			return true;
		} else return false;
	};
	pp$9.isContextual = function(name) {
		return this.type === types$1.name && this.value === name && !this.containsEsc;
	};
	pp$9.eatContextual = function(name) {
		if (!this.isContextual(name)) return false;
		this.next();
		return true;
	};
	pp$9.expectContextual = function(name) {
		if (!this.eatContextual(name)) this.unexpected();
	};
	pp$9.canInsertSemicolon = function() {
		return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
	};
	pp$9.insertSemicolon = function() {
		if (this.canInsertSemicolon()) {
			if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
			return true;
		}
	};
	pp$9.semicolon = function() {
		if (!this.eat(types$1.semi) && !this.insertSemicolon()) this.unexpected();
	};
	pp$9.afterTrailingComma = function(tokType, notNext) {
		if (this.type === tokType) {
			if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
			if (!notNext) this.next();
			return true;
		}
	};
	pp$9.expect = function(type$2) {
		this.eat(type$2) || this.unexpected();
	};
	pp$9.unexpected = function(pos) {
		this.raise(pos != null ? pos : this.start, "Unexpected token");
	};
	var DestructuringErrors = function DestructuringErrors$1() {
		this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
	};
	pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
		if (!refDestructuringErrors) return;
		if (refDestructuringErrors.trailingComma > -1) this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
		var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
		if (parens > -1) this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
	};
	pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
		if (!refDestructuringErrors) return false;
		var shorthandAssign = refDestructuringErrors.shorthandAssign;
		var doubleProto = refDestructuringErrors.doubleProto;
		if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;
		if (shorthandAssign >= 0) this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
		if (doubleProto >= 0) this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
	};
	pp$9.checkYieldAwaitInDefaultParams = function() {
		if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) this.raise(this.yieldPos, "Yield expression cannot be a default value");
		if (this.awaitPos) this.raise(this.awaitPos, "Await expression cannot be a default value");
	};
	pp$9.isSimpleAssignTarget = function(expr) {
		if (expr.type === "ParenthesizedExpression") return this.isSimpleAssignTarget(expr.expression);
		return expr.type === "Identifier" || expr.type === "MemberExpression";
	};
	var pp$8 = Parser.prototype;
	pp$8.parseTopLevel = function(node) {
		var exports$1 = Object.create(null);
		if (!node.body) node.body = [];
		while (this.type !== types$1.eof) {
			var stmt = this.parseStatement(null, true, exports$1);
			node.body.push(stmt);
		}
		if (this.inModule) for (var i$1 = 0, list$1 = Object.keys(this.undefinedExports); i$1 < list$1.length; i$1 += 1) {
			var name = list$1[i$1];
			this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
		}
		this.adaptDirectivePrologue(node.body);
		this.next();
		node.sourceType = this.options.sourceType;
		return this.finishNode(node, "Program");
	};
	var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
	pp$8.isLet = function(context) {
		if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return false;
		skipWhiteSpace.lastIndex = this.pos;
		var skip = skipWhiteSpace.exec(this.input);
		var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
		if (nextCh === 91 || nextCh === 92) return true;
		if (context) return false;
		if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) return true;
		if (isIdentifierStart(nextCh, true)) {
			var pos = next + 1;
			while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) ++pos;
			if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) return true;
			var ident = this.input.slice(next, pos);
			if (!keywordRelationalOperator.test(ident)) return true;
		}
		return false;
	};
	pp$8.isAsyncFunction = function() {
		if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return false;
		skipWhiteSpace.lastIndex = this.pos;
		var skip = skipWhiteSpace.exec(this.input);
		var next = this.pos + skip[0].length, after;
		return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
	};
	pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
		if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) return false;
		skipWhiteSpace.lastIndex = this.pos;
		var skip = skipWhiteSpace.exec(this.input);
		var next = this.pos + skip[0].length;
		if (lineBreak.test(this.input.slice(this.pos, next))) return false;
		if (isAwaitUsing) {
			var awaitEndPos = next + 5, after;
			if (this.input.slice(next, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) || after > 55295 && after < 56320) return false;
			skipWhiteSpace.lastIndex = awaitEndPos;
			var skipAfterUsing = skipWhiteSpace.exec(this.input);
			if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) return false;
		}
		if (isFor) {
			var ofEndPos = next + 2, after$1;
			if (this.input.slice(next, ofEndPos) === "of") {
				if (ofEndPos === this.input.length || !isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 55295 && after$1 < 56320)) return false;
			}
		}
		var ch = this.input.charCodeAt(next);
		return isIdentifierStart(ch, true) || ch === 92;
	};
	pp$8.isAwaitUsing = function(isFor) {
		return this.isUsingKeyword(true, isFor);
	};
	pp$8.isUsing = function(isFor) {
		return this.isUsingKeyword(false, isFor);
	};
	pp$8.parseStatement = function(context, topLevel, exports$1) {
		var starttype = this.type, node = this.startNode(), kind;
		if (this.isLet(context)) {
			starttype = types$1._var;
			kind = "let";
		}
		switch (starttype) {
			case types$1._break:
			case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword);
			case types$1._debugger: return this.parseDebuggerStatement(node);
			case types$1._do: return this.parseDoStatement(node);
			case types$1._for: return this.parseForStatement(node);
			case types$1._function:
				if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) this.unexpected();
				return this.parseFunctionStatement(node, false, !context);
			case types$1._class:
				if (context) this.unexpected();
				return this.parseClass(node, true);
			case types$1._if: return this.parseIfStatement(node);
			case types$1._return: return this.parseReturnStatement(node);
			case types$1._switch: return this.parseSwitchStatement(node);
			case types$1._throw: return this.parseThrowStatement(node);
			case types$1._try: return this.parseTryStatement(node);
			case types$1._const:
			case types$1._var:
				kind = kind || this.value;
				if (context && kind !== "var") this.unexpected();
				return this.parseVarStatement(node, kind);
			case types$1._while: return this.parseWhileStatement(node);
			case types$1._with: return this.parseWithStatement(node);
			case types$1.braceL: return this.parseBlock(true, node);
			case types$1.semi: return this.parseEmptyStatement(node);
			case types$1._export:
			case types$1._import:
				if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
					skipWhiteSpace.lastIndex = this.pos;
					var skip = skipWhiteSpace.exec(this.input);
					var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
					if (nextCh === 40 || nextCh === 46) return this.parseExpressionStatement(node, this.parseExpression());
				}
				if (!this.options.allowImportExportEverywhere) {
					if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
					if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
				}
				return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports$1);
			default:
				if (this.isAsyncFunction()) {
					if (context) this.unexpected();
					this.next();
					return this.parseFunctionStatement(node, true, !context);
				}
				var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
				if (usingKind) {
					if (topLevel && this.options.sourceType === "script") this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
					if (usingKind === "await using") {
						if (!this.canAwait) this.raise(this.start, "Await using cannot appear outside of async function");
						this.next();
					}
					this.next();
					this.parseVar(node, false, usingKind);
					this.semicolon();
					return this.finishNode(node, "VariableDeclaration");
				}
				var maybeName = this.value, expr = this.parseExpression();
				if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) return this.parseLabeledStatement(node, maybeName, expr, context);
				else return this.parseExpressionStatement(node, expr);
		}
	};
	pp$8.parseBreakContinueStatement = function(node, keyword) {
		var isBreak = keyword === "break";
		this.next();
		if (this.eat(types$1.semi) || this.insertSemicolon()) node.label = null;
		else if (this.type !== types$1.name) this.unexpected();
		else {
			node.label = this.parseIdent();
			this.semicolon();
		}
		var i$1 = 0;
		for (; i$1 < this.labels.length; ++i$1) {
			var lab = this.labels[i$1];
			if (node.label == null || lab.name === node.label.name) {
				if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
				if (node.label && isBreak) break;
			}
		}
		if (i$1 === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
		return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
	};
	pp$8.parseDebuggerStatement = function(node) {
		this.next();
		this.semicolon();
		return this.finishNode(node, "DebuggerStatement");
	};
	pp$8.parseDoStatement = function(node) {
		this.next();
		this.labels.push(loopLabel);
		node.body = this.parseStatement("do");
		this.labels.pop();
		this.expect(types$1._while);
		node.test = this.parseParenExpression();
		if (this.options.ecmaVersion >= 6) this.eat(types$1.semi);
		else this.semicolon();
		return this.finishNode(node, "DoWhileStatement");
	};
	pp$8.parseForStatement = function(node) {
		this.next();
		var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
		this.labels.push(loopLabel);
		this.enterScope(0);
		this.expect(types$1.parenL);
		if (this.type === types$1.semi) {
			if (awaitAt > -1) this.unexpected(awaitAt);
			return this.parseFor(node, null);
		}
		var isLet = this.isLet();
		if (this.type === types$1._var || this.type === types$1._const || isLet) {
			var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
			this.next();
			this.parseVar(init$1, true, kind);
			this.finishNode(init$1, "VariableDeclaration");
			return this.parseForAfterInit(node, init$1, awaitAt);
		}
		var startsWithLet = this.isContextual("let"), isForOf = false;
		var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
		if (usingKind) {
			var init$2 = this.startNode();
			this.next();
			if (usingKind === "await using") this.next();
			this.parseVar(init$2, true, usingKind);
			this.finishNode(init$2, "VariableDeclaration");
			return this.parseForAfterInit(node, init$2, awaitAt);
		}
		var containsEsc = this.containsEsc;
		var refDestructuringErrors = new DestructuringErrors();
		var initPos = this.start;
		var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
		if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
			if (awaitAt > -1) {
				if (this.type === types$1._in) this.unexpected(awaitAt);
				node.await = true;
			} else if (isForOf && this.options.ecmaVersion >= 8) {
				if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") this.unexpected();
				else if (this.options.ecmaVersion >= 9) node.await = false;
			}
			if (startsWithLet && isForOf) this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
			this.toAssignable(init, false, refDestructuringErrors);
			this.checkLValPattern(init);
			return this.parseForIn(node, init);
		} else this.checkExpressionErrors(refDestructuringErrors, true);
		if (awaitAt > -1) this.unexpected(awaitAt);
		return this.parseFor(node, init);
	};
	pp$8.parseForAfterInit = function(node, init, awaitAt) {
		if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init.declarations.length === 1) {
			if (this.options.ecmaVersion >= 9) if (this.type === types$1._in) {
				if (awaitAt > -1) this.unexpected(awaitAt);
			} else node.await = awaitAt > -1;
			return this.parseForIn(node, init);
		}
		if (awaitAt > -1) this.unexpected(awaitAt);
		return this.parseFor(node, init);
	};
	pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
		this.next();
		return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
	};
	pp$8.parseIfStatement = function(node) {
		this.next();
		node.test = this.parseParenExpression();
		node.consequent = this.parseStatement("if");
		node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
		return this.finishNode(node, "IfStatement");
	};
	pp$8.parseReturnStatement = function(node) {
		if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
		this.next();
		if (this.eat(types$1.semi) || this.insertSemicolon()) node.argument = null;
		else {
			node.argument = this.parseExpression();
			this.semicolon();
		}
		return this.finishNode(node, "ReturnStatement");
	};
	pp$8.parseSwitchStatement = function(node) {
		this.next();
		node.discriminant = this.parseParenExpression();
		node.cases = [];
		this.expect(types$1.braceL);
		this.labels.push(switchLabel);
		this.enterScope(0);
		var cur;
		for (var sawDefault = false; this.type !== types$1.braceR;) if (this.type === types$1._case || this.type === types$1._default) {
			var isCase = this.type === types$1._case;
			if (cur) this.finishNode(cur, "SwitchCase");
			node.cases.push(cur = this.startNode());
			cur.consequent = [];
			this.next();
			if (isCase) cur.test = this.parseExpression();
			else {
				if (sawDefault) this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
				sawDefault = true;
				cur.test = null;
			}
			this.expect(types$1.colon);
		} else {
			if (!cur) this.unexpected();
			cur.consequent.push(this.parseStatement(null));
		}
		this.exitScope();
		if (cur) this.finishNode(cur, "SwitchCase");
		this.next();
		this.labels.pop();
		return this.finishNode(node, "SwitchStatement");
	};
	pp$8.parseThrowStatement = function(node) {
		this.next();
		if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
		node.argument = this.parseExpression();
		this.semicolon();
		return this.finishNode(node, "ThrowStatement");
	};
	var empty$1 = [];
	pp$8.parseCatchClauseParam = function() {
		var param = this.parseBindingAtom();
		var simple$1 = param.type === "Identifier";
		this.enterScope(simple$1 ? SCOPE_SIMPLE_CATCH : 0);
		this.checkLValPattern(param, simple$1 ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
		this.expect(types$1.parenR);
		return param;
	};
	pp$8.parseTryStatement = function(node) {
		this.next();
		node.block = this.parseBlock();
		node.handler = null;
		if (this.type === types$1._catch) {
			var clause = this.startNode();
			this.next();
			if (this.eat(types$1.parenL)) clause.param = this.parseCatchClauseParam();
			else {
				if (this.options.ecmaVersion < 10) this.unexpected();
				clause.param = null;
				this.enterScope(0);
			}
			clause.body = this.parseBlock(false);
			this.exitScope();
			node.handler = this.finishNode(clause, "CatchClause");
		}
		node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
		if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
		return this.finishNode(node, "TryStatement");
	};
	pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
		this.next();
		this.parseVar(node, false, kind, allowMissingInitializer);
		this.semicolon();
		return this.finishNode(node, "VariableDeclaration");
	};
	pp$8.parseWhileStatement = function(node) {
		this.next();
		node.test = this.parseParenExpression();
		this.labels.push(loopLabel);
		node.body = this.parseStatement("while");
		this.labels.pop();
		return this.finishNode(node, "WhileStatement");
	};
	pp$8.parseWithStatement = function(node) {
		if (this.strict) this.raise(this.start, "'with' in strict mode");
		this.next();
		node.object = this.parseParenExpression();
		node.body = this.parseStatement("with");
		return this.finishNode(node, "WithStatement");
	};
	pp$8.parseEmptyStatement = function(node) {
		this.next();
		return this.finishNode(node, "EmptyStatement");
	};
	pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
		for (var i$1 = 0, list$1 = this.labels; i$1 < list$1.length; i$1 += 1) if (list$1[i$1].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
		var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
		for (var i$2 = this.labels.length - 1; i$2 >= 0; i$2--) {
			var label$1 = this.labels[i$2];
			if (label$1.statementStart === node.start) {
				label$1.statementStart = this.start;
				label$1.kind = kind;
			} else break;
		}
		this.labels.push({
			name: maybeName,
			kind,
			statementStart: this.start
		});
		node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
		this.labels.pop();
		node.label = expr;
		return this.finishNode(node, "LabeledStatement");
	};
	pp$8.parseExpressionStatement = function(node, expr) {
		node.expression = expr;
		this.semicolon();
		return this.finishNode(node, "ExpressionStatement");
	};
	pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
		if (createNewLexicalScope === void 0) createNewLexicalScope = true;
		if (node === void 0) node = this.startNode();
		node.body = [];
		this.expect(types$1.braceL);
		if (createNewLexicalScope) this.enterScope(0);
		while (this.type !== types$1.braceR) {
			var stmt = this.parseStatement(null);
			node.body.push(stmt);
		}
		if (exitStrict) this.strict = false;
		this.next();
		if (createNewLexicalScope) this.exitScope();
		return this.finishNode(node, "BlockStatement");
	};
	pp$8.parseFor = function(node, init) {
		node.init = init;
		this.expect(types$1.semi);
		node.test = this.type === types$1.semi ? null : this.parseExpression();
		this.expect(types$1.semi);
		node.update = this.type === types$1.parenR ? null : this.parseExpression();
		this.expect(types$1.parenR);
		node.body = this.parseStatement("for");
		this.exitScope();
		this.labels.pop();
		return this.finishNode(node, "ForStatement");
	};
	pp$8.parseForIn = function(node, init) {
		var isForIn = this.type === types$1._in;
		this.next();
		if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
		node.left = init;
		node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
		this.expect(types$1.parenR);
		node.body = this.parseStatement("for");
		this.exitScope();
		this.labels.pop();
		return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
	};
	pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
		node.declarations = [];
		node.kind = kind;
		for (;;) {
			var decl = this.startNode();
			this.parseVarId(decl, kind);
			if (this.eat(types$1.eq)) decl.init = this.parseMaybeAssign(isFor);
			else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) this.unexpected();
			else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
			else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
			else decl.init = null;
			node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
			if (!this.eat(types$1.comma)) break;
		}
		return node;
	};
	pp$8.parseVarId = function(decl, kind) {
		decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
		this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
	};
	var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
	pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
		this.initFunction(node);
		if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
			if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) this.unexpected();
			node.generator = this.eat(types$1.star);
		}
		if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
		if (statement & FUNC_STATEMENT) {
			node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
			if (node.id && !(statement & FUNC_HANGING_STATEMENT)) this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
		}
		var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
		this.yieldPos = 0;
		this.awaitPos = 0;
		this.awaitIdentPos = 0;
		this.enterScope(functionFlags(node.async, node.generator));
		if (!(statement & FUNC_STATEMENT)) node.id = this.type === types$1.name ? this.parseIdent() : null;
		this.parseFunctionParams(node);
		this.parseFunctionBody(node, allowExpressionBody, false, forInit);
		this.yieldPos = oldYieldPos;
		this.awaitPos = oldAwaitPos;
		this.awaitIdentPos = oldAwaitIdentPos;
		return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
	};
	pp$8.parseFunctionParams = function(node) {
		this.expect(types$1.parenL);
		node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
		this.checkYieldAwaitInDefaultParams();
	};
	pp$8.parseClass = function(node, isStatement) {
		this.next();
		var oldStrict = this.strict;
		this.strict = true;
		this.parseClassId(node, isStatement);
		this.parseClassSuper(node);
		var privateNameMap = this.enterClassBody();
		var classBody = this.startNode();
		var hadConstructor = false;
		classBody.body = [];
		this.expect(types$1.braceL);
		while (this.type !== types$1.braceR) {
			var element$1 = this.parseClassElement(node.superClass !== null);
			if (element$1) {
				classBody.body.push(element$1);
				if (element$1.type === "MethodDefinition" && element$1.kind === "constructor") {
					if (hadConstructor) this.raiseRecoverable(element$1.start, "Duplicate constructor in the same class");
					hadConstructor = true;
				} else if (element$1.key && element$1.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element$1)) this.raiseRecoverable(element$1.key.start, "Identifier '#" + element$1.key.name + "' has already been declared");
			}
		}
		this.strict = oldStrict;
		this.next();
		node.body = this.finishNode(classBody, "ClassBody");
		this.exitClassBody();
		return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
	};
	pp$8.parseClassElement = function(constructorAllowsSuper) {
		if (this.eat(types$1.semi)) return null;
		var ecmaVersion$1 = this.options.ecmaVersion;
		var node = this.startNode();
		var keyName = "";
		var isGenerator = false;
		var isAsync = false;
		var kind = "method";
		var isStatic = false;
		if (this.eatContextual("static")) {
			if (ecmaVersion$1 >= 13 && this.eat(types$1.braceL)) {
				this.parseClassStaticBlock(node);
				return node;
			}
			if (this.isClassElementNameStart() || this.type === types$1.star) isStatic = true;
			else keyName = "static";
		}
		node.static = isStatic;
		if (!keyName && ecmaVersion$1 >= 8 && this.eatContextual("async")) if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) isAsync = true;
		else keyName = "async";
		if (!keyName && (ecmaVersion$1 >= 9 || !isAsync) && this.eat(types$1.star)) isGenerator = true;
		if (!keyName && !isAsync && !isGenerator) {
			var lastValue = this.value;
			if (this.eatContextual("get") || this.eatContextual("set")) if (this.isClassElementNameStart()) kind = lastValue;
			else keyName = lastValue;
		}
		if (keyName) {
			node.computed = false;
			node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
			node.key.name = keyName;
			this.finishNode(node.key, "Identifier");
		} else this.parseClassElementName(node);
		if (ecmaVersion$1 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
			var isConstructor = !node.static && checkKeyName(node, "constructor");
			var allowsDirectSuper = isConstructor && constructorAllowsSuper;
			if (isConstructor && kind !== "method") this.raise(node.key.start, "Constructor can't have get/set modifier");
			node.kind = isConstructor ? "constructor" : kind;
			this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
		} else this.parseClassField(node);
		return node;
	};
	pp$8.isClassElementNameStart = function() {
		return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
	};
	pp$8.parseClassElementName = function(element$1) {
		if (this.type === types$1.privateId) {
			if (this.value === "constructor") this.raise(this.start, "Classes can't have an element named '#constructor'");
			element$1.computed = false;
			element$1.key = this.parsePrivateIdent();
		} else this.parsePropertyName(element$1);
	};
	pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
		var key = method.key;
		if (method.kind === "constructor") {
			if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
			if (isAsync) this.raise(key.start, "Constructor can't be an async method");
		} else if (method.static && checkKeyName(method, "prototype")) this.raise(key.start, "Classes may not have a static property named prototype");
		var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
		if (method.kind === "get" && value.params.length !== 0) this.raiseRecoverable(value.start, "getter should have no params");
		if (method.kind === "set" && value.params.length !== 1) this.raiseRecoverable(value.start, "setter should have exactly one param");
		if (method.kind === "set" && value.params[0].type === "RestElement") this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
		return this.finishNode(method, "MethodDefinition");
	};
	pp$8.parseClassField = function(field) {
		if (checkKeyName(field, "constructor")) this.raise(field.key.start, "Classes can't have a field named 'constructor'");
		else if (field.static && checkKeyName(field, "prototype")) this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
		if (this.eat(types$1.eq)) {
			this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
			field.value = this.parseMaybeAssign();
			this.exitScope();
		} else field.value = null;
		this.semicolon();
		return this.finishNode(field, "PropertyDefinition");
	};
	pp$8.parseClassStaticBlock = function(node) {
		node.body = [];
		var oldLabels = this.labels;
		this.labels = [];
		this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
		while (this.type !== types$1.braceR) {
			var stmt = this.parseStatement(null);
			node.body.push(stmt);
		}
		this.next();
		this.exitScope();
		this.labels = oldLabels;
		return this.finishNode(node, "StaticBlock");
	};
	pp$8.parseClassId = function(node, isStatement) {
		if (this.type === types$1.name) {
			node.id = this.parseIdent();
			if (isStatement) this.checkLValSimple(node.id, BIND_LEXICAL, false);
		} else {
			if (isStatement === true) this.unexpected();
			node.id = null;
		}
	};
	pp$8.parseClassSuper = function(node) {
		node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
	};
	pp$8.enterClassBody = function() {
		var element$1 = {
			declared: Object.create(null),
			used: []
		};
		this.privateNameStack.push(element$1);
		return element$1.declared;
	};
	pp$8.exitClassBody = function() {
		var ref$1 = this.privateNameStack.pop();
		var declared = ref$1.declared;
		var used = ref$1.used;
		if (!this.options.checkPrivateFields) return;
		var len = this.privateNameStack.length;
		var parent = len === 0 ? null : this.privateNameStack[len - 1];
		for (var i$1 = 0; i$1 < used.length; ++i$1) {
			var id = used[i$1];
			if (!hasOwn(declared, id.name)) if (parent) parent.used.push(id);
			else this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
		}
	};
	function isPrivateNameConflicted(privateNameMap, element$1) {
		var name = element$1.key.name;
		var curr = privateNameMap[name];
		var next = "true";
		if (element$1.type === "MethodDefinition" && (element$1.kind === "get" || element$1.kind === "set")) next = (element$1.static ? "s" : "i") + element$1.kind;
		if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
			privateNameMap[name] = "true";
			return false;
		} else if (!curr) {
			privateNameMap[name] = next;
			return false;
		} else return true;
	}
	function checkKeyName(node, name) {
		var computed = node.computed;
		var key = node.key;
		return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
	}
	pp$8.parseExportAllDeclaration = function(node, exports$1) {
		if (this.options.ecmaVersion >= 11) if (this.eatContextual("as")) {
			node.exported = this.parseModuleExportName();
			this.checkExport(exports$1, node.exported, this.lastTokStart);
		} else node.exported = null;
		this.expectContextual("from");
		if (this.type !== types$1.string) this.unexpected();
		node.source = this.parseExprAtom();
		if (this.options.ecmaVersion >= 16) node.attributes = this.parseWithClause();
		this.semicolon();
		return this.finishNode(node, "ExportAllDeclaration");
	};
	pp$8.parseExport = function(node, exports$1) {
		this.next();
		if (this.eat(types$1.star)) return this.parseExportAllDeclaration(node, exports$1);
		if (this.eat(types$1._default)) {
			this.checkExport(exports$1, "default", this.lastTokStart);
			node.declaration = this.parseExportDefaultDeclaration();
			return this.finishNode(node, "ExportDefaultDeclaration");
		}
		if (this.shouldParseExportStatement()) {
			node.declaration = this.parseExportDeclaration(node);
			if (node.declaration.type === "VariableDeclaration") this.checkVariableExport(exports$1, node.declaration.declarations);
			else this.checkExport(exports$1, node.declaration.id, node.declaration.id.start);
			node.specifiers = [];
			node.source = null;
			if (this.options.ecmaVersion >= 16) node.attributes = [];
		} else {
			node.declaration = null;
			node.specifiers = this.parseExportSpecifiers(exports$1);
			if (this.eatContextual("from")) {
				if (this.type !== types$1.string) this.unexpected();
				node.source = this.parseExprAtom();
				if (this.options.ecmaVersion >= 16) node.attributes = this.parseWithClause();
			} else {
				for (var i$1 = 0, list$1 = node.specifiers; i$1 < list$1.length; i$1 += 1) {
					var spec = list$1[i$1];
					this.checkUnreserved(spec.local);
					this.checkLocalExport(spec.local);
					if (spec.local.type === "Literal") this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
				}
				node.source = null;
				if (this.options.ecmaVersion >= 16) node.attributes = [];
			}
			this.semicolon();
		}
		return this.finishNode(node, "ExportNamedDeclaration");
	};
	pp$8.parseExportDeclaration = function(node) {
		return this.parseStatement(null);
	};
	pp$8.parseExportDefaultDeclaration = function() {
		var isAsync;
		if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
			var fNode = this.startNode();
			this.next();
			if (isAsync) this.next();
			return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
		} else if (this.type === types$1._class) {
			var cNode = this.startNode();
			return this.parseClass(cNode, "nullableID");
		} else {
			var declaration = this.parseMaybeAssign();
			this.semicolon();
			return declaration;
		}
	};
	pp$8.checkExport = function(exports$1, name, pos) {
		if (!exports$1) return;
		if (typeof name !== "string") name = name.type === "Identifier" ? name.name : name.value;
		if (hasOwn(exports$1, name)) this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
		exports$1[name] = true;
	};
	pp$8.checkPatternExport = function(exports$1, pat) {
		var type$2 = pat.type;
		if (type$2 === "Identifier") this.checkExport(exports$1, pat, pat.start);
		else if (type$2 === "ObjectPattern") for (var i$1 = 0, list$1 = pat.properties; i$1 < list$1.length; i$1 += 1) {
			var prop = list$1[i$1];
			this.checkPatternExport(exports$1, prop);
		}
		else if (type$2 === "ArrayPattern") for (var i$1$1 = 0, list$1$1 = pat.elements; i$1$1 < list$1$1.length; i$1$1 += 1) {
			var elt = list$1$1[i$1$1];
			if (elt) this.checkPatternExport(exports$1, elt);
		}
		else if (type$2 === "Property") this.checkPatternExport(exports$1, pat.value);
		else if (type$2 === "AssignmentPattern") this.checkPatternExport(exports$1, pat.left);
		else if (type$2 === "RestElement") this.checkPatternExport(exports$1, pat.argument);
	};
	pp$8.checkVariableExport = function(exports$1, decls) {
		if (!exports$1) return;
		for (var i$1 = 0, list$1 = decls; i$1 < list$1.length; i$1 += 1) {
			var decl = list$1[i$1];
			this.checkPatternExport(exports$1, decl.id);
		}
	};
	pp$8.shouldParseExportStatement = function() {
		return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
	};
	pp$8.parseExportSpecifier = function(exports$1) {
		var node = this.startNode();
		node.local = this.parseModuleExportName();
		node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
		this.checkExport(exports$1, node.exported, node.exported.start);
		return this.finishNode(node, "ExportSpecifier");
	};
	pp$8.parseExportSpecifiers = function(exports$1) {
		var nodes = [], first = true;
		this.expect(types$1.braceL);
		while (!this.eat(types$1.braceR)) {
			if (!first) {
				this.expect(types$1.comma);
				if (this.afterTrailingComma(types$1.braceR)) break;
			} else first = false;
			nodes.push(this.parseExportSpecifier(exports$1));
		}
		return nodes;
	};
	pp$8.parseImport = function(node) {
		this.next();
		if (this.type === types$1.string) {
			node.specifiers = empty$1;
			node.source = this.parseExprAtom();
		} else {
			node.specifiers = this.parseImportSpecifiers();
			this.expectContextual("from");
			node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
		}
		if (this.options.ecmaVersion >= 16) node.attributes = this.parseWithClause();
		this.semicolon();
		return this.finishNode(node, "ImportDeclaration");
	};
	pp$8.parseImportSpecifier = function() {
		var node = this.startNode();
		node.imported = this.parseModuleExportName();
		if (this.eatContextual("as")) node.local = this.parseIdent();
		else {
			this.checkUnreserved(node.imported);
			node.local = node.imported;
		}
		this.checkLValSimple(node.local, BIND_LEXICAL);
		return this.finishNode(node, "ImportSpecifier");
	};
	pp$8.parseImportDefaultSpecifier = function() {
		var node = this.startNode();
		node.local = this.parseIdent();
		this.checkLValSimple(node.local, BIND_LEXICAL);
		return this.finishNode(node, "ImportDefaultSpecifier");
	};
	pp$8.parseImportNamespaceSpecifier = function() {
		var node = this.startNode();
		this.next();
		this.expectContextual("as");
		node.local = this.parseIdent();
		this.checkLValSimple(node.local, BIND_LEXICAL);
		return this.finishNode(node, "ImportNamespaceSpecifier");
	};
	pp$8.parseImportSpecifiers = function() {
		var nodes = [], first = true;
		if (this.type === types$1.name) {
			nodes.push(this.parseImportDefaultSpecifier());
			if (!this.eat(types$1.comma)) return nodes;
		}
		if (this.type === types$1.star) {
			nodes.push(this.parseImportNamespaceSpecifier());
			return nodes;
		}
		this.expect(types$1.braceL);
		while (!this.eat(types$1.braceR)) {
			if (!first) {
				this.expect(types$1.comma);
				if (this.afterTrailingComma(types$1.braceR)) break;
			} else first = false;
			nodes.push(this.parseImportSpecifier());
		}
		return nodes;
	};
	pp$8.parseWithClause = function() {
		var nodes = [];
		if (!this.eat(types$1._with)) return nodes;
		this.expect(types$1.braceL);
		var attributeKeys = {};
		var first = true;
		while (!this.eat(types$1.braceR)) {
			if (!first) {
				this.expect(types$1.comma);
				if (this.afterTrailingComma(types$1.braceR)) break;
			} else first = false;
			var attr = this.parseImportAttribute();
			var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
			if (hasOwn(attributeKeys, keyName)) this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
			attributeKeys[keyName] = true;
			nodes.push(attr);
		}
		return nodes;
	};
	pp$8.parseImportAttribute = function() {
		var node = this.startNode();
		node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
		this.expect(types$1.colon);
		if (this.type !== types$1.string) this.unexpected();
		node.value = this.parseExprAtom();
		return this.finishNode(node, "ImportAttribute");
	};
	pp$8.parseModuleExportName = function() {
		if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
			var stringLiteral = this.parseLiteral(this.value);
			if (loneSurrogate.test(stringLiteral.value)) this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
			return stringLiteral;
		}
		return this.parseIdent(true);
	};
	pp$8.adaptDirectivePrologue = function(statements) {
		for (var i$1 = 0; i$1 < statements.length && this.isDirectiveCandidate(statements[i$1]); ++i$1) statements[i$1].directive = statements[i$1].expression.raw.slice(1, -1);
	};
	pp$8.isDirectiveCandidate = function(statement) {
		return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === "\"" || this.input[statement.start] === "'");
	};
	var pp$7 = Parser.prototype;
	pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
		if (this.options.ecmaVersion >= 6 && node) switch (node.type) {
			case "Identifier":
				if (this.inAsync && node.name === "await") this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
				break;
			case "ObjectPattern":
			case "ArrayPattern":
			case "AssignmentPattern":
			case "RestElement": break;
			case "ObjectExpression":
				node.type = "ObjectPattern";
				if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
				for (var i$1 = 0, list$1 = node.properties; i$1 < list$1.length; i$1 += 1) {
					var prop = list$1[i$1];
					this.toAssignable(prop, isBinding);
					if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) this.raise(prop.argument.start, "Unexpected token");
				}
				break;
			case "Property":
				if (node.kind !== "init") this.raise(node.key.start, "Object pattern can't contain getter or setter");
				this.toAssignable(node.value, isBinding);
				break;
			case "ArrayExpression":
				node.type = "ArrayPattern";
				if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
				this.toAssignableList(node.elements, isBinding);
				break;
			case "SpreadElement":
				node.type = "RestElement";
				this.toAssignable(node.argument, isBinding);
				if (node.argument.type === "AssignmentPattern") this.raise(node.argument.start, "Rest elements cannot have a default value");
				break;
			case "AssignmentExpression":
				if (node.operator !== "=") this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
				node.type = "AssignmentPattern";
				delete node.operator;
				this.toAssignable(node.left, isBinding);
				break;
			case "ParenthesizedExpression":
				this.toAssignable(node.expression, isBinding, refDestructuringErrors);
				break;
			case "ChainExpression":
				this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
				break;
			case "MemberExpression": if (!isBinding) break;
			default: this.raise(node.start, "Assigning to rvalue");
		}
		else if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);
		return node;
	};
	pp$7.toAssignableList = function(exprList, isBinding) {
		var end = exprList.length;
		for (var i$1 = 0; i$1 < end; i$1++) {
			var elt = exprList[i$1];
			if (elt) this.toAssignable(elt, isBinding);
		}
		if (end) {
			var last$1 = exprList[end - 1];
			if (this.options.ecmaVersion === 6 && isBinding && last$1 && last$1.type === "RestElement" && last$1.argument.type !== "Identifier") this.unexpected(last$1.argument.start);
		}
		return exprList;
	};
	pp$7.parseSpread = function(refDestructuringErrors) {
		var node = this.startNode();
		this.next();
		node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
		return this.finishNode(node, "SpreadElement");
	};
	pp$7.parseRestBinding = function() {
		var node = this.startNode();
		this.next();
		if (this.options.ecmaVersion === 6 && this.type !== types$1.name) this.unexpected();
		node.argument = this.parseBindingAtom();
		return this.finishNode(node, "RestElement");
	};
	pp$7.parseBindingAtom = function() {
		if (this.options.ecmaVersion >= 6) switch (this.type) {
			case types$1.bracketL:
				var node = this.startNode();
				this.next();
				node.elements = this.parseBindingList(types$1.bracketR, true, true);
				return this.finishNode(node, "ArrayPattern");
			case types$1.braceL: return this.parseObj(true);
		}
		return this.parseIdent();
	};
	pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
		var elts = [], first = true;
		while (!this.eat(close)) {
			if (first) first = false;
			else this.expect(types$1.comma);
			if (allowEmpty && this.type === types$1.comma) elts.push(null);
			else if (allowTrailingComma && this.afterTrailingComma(close)) break;
			else if (this.type === types$1.ellipsis) {
				var rest = this.parseRestBinding();
				this.parseBindingListItem(rest);
				elts.push(rest);
				if (this.type === types$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
				this.expect(close);
				break;
			} else elts.push(this.parseAssignableListItem(allowModifiers));
		}
		return elts;
	};
	pp$7.parseAssignableListItem = function(allowModifiers) {
		var elem = this.parseMaybeDefault(this.start, this.startLoc);
		this.parseBindingListItem(elem);
		return elem;
	};
	pp$7.parseBindingListItem = function(param) {
		return param;
	};
	pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
		left = left || this.parseBindingAtom();
		if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) return left;
		var node = this.startNodeAt(startPos, startLoc);
		node.left = left;
		node.right = this.parseMaybeAssign();
		return this.finishNode(node, "AssignmentPattern");
	};
	pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
		if (bindingType === void 0) bindingType = BIND_NONE;
		var isBind = bindingType !== BIND_NONE;
		switch (expr.type) {
			case "Identifier":
				if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
				if (isBind) {
					if (bindingType === BIND_LEXICAL && expr.name === "let") this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
					if (checkClashes) {
						if (hasOwn(checkClashes, expr.name)) this.raiseRecoverable(expr.start, "Argument name clash");
						checkClashes[expr.name] = true;
					}
					if (bindingType !== BIND_OUTSIDE) this.declareName(expr.name, bindingType, expr.start);
				}
				break;
			case "ChainExpression":
				this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
				break;
			case "MemberExpression":
				if (isBind) this.raiseRecoverable(expr.start, "Binding member expression");
				break;
			case "ParenthesizedExpression":
				if (isBind) this.raiseRecoverable(expr.start, "Binding parenthesized expression");
				return this.checkLValSimple(expr.expression, bindingType, checkClashes);
			default: this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
		}
	};
	pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
		if (bindingType === void 0) bindingType = BIND_NONE;
		switch (expr.type) {
			case "ObjectPattern":
				for (var i$1 = 0, list$1 = expr.properties; i$1 < list$1.length; i$1 += 1) {
					var prop = list$1[i$1];
					this.checkLValInnerPattern(prop, bindingType, checkClashes);
				}
				break;
			case "ArrayPattern":
				for (var i$1$1 = 0, list$1$1 = expr.elements; i$1$1 < list$1$1.length; i$1$1 += 1) {
					var elem = list$1$1[i$1$1];
					if (elem) this.checkLValInnerPattern(elem, bindingType, checkClashes);
				}
				break;
			default: this.checkLValSimple(expr, bindingType, checkClashes);
		}
	};
	pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
		if (bindingType === void 0) bindingType = BIND_NONE;
		switch (expr.type) {
			case "Property":
				this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
				break;
			case "AssignmentPattern":
				this.checkLValPattern(expr.left, bindingType, checkClashes);
				break;
			case "RestElement":
				this.checkLValPattern(expr.argument, bindingType, checkClashes);
				break;
			default: this.checkLValPattern(expr, bindingType, checkClashes);
		}
	};
	var TokContext = function TokContext$1(token, isExpr, preserveSpace, override, generator) {
		this.token = token;
		this.isExpr = !!isExpr;
		this.preserveSpace = !!preserveSpace;
		this.override = override;
		this.generator = !!generator;
	};
	var types = {
		b_stat: new TokContext("{", false),
		b_expr: new TokContext("{", true),
		b_tmpl: new TokContext("${", false),
		p_stat: new TokContext("(", false),
		p_expr: new TokContext("(", true),
		q_tmpl: new TokContext("`", true, true, function(p$1) {
			return p$1.tryReadTemplateToken();
		}),
		f_stat: new TokContext("function", false),
		f_expr: new TokContext("function", true),
		f_expr_gen: new TokContext("function", true, false, null, true),
		f_gen: new TokContext("function", false, false, null, true)
	};
	var pp$6 = Parser.prototype;
	pp$6.initialContext = function() {
		return [types.b_stat];
	};
	pp$6.curContext = function() {
		return this.context[this.context.length - 1];
	};
	pp$6.braceIsBlock = function(prevType) {
		var parent = this.curContext();
		if (parent === types.f_expr || parent === types.f_stat) return true;
		if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) return !parent.isExpr;
		if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
		if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) return true;
		if (prevType === types$1.braceL) return parent === types.b_stat;
		if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) return false;
		return !this.exprAllowed;
	};
	pp$6.inGeneratorContext = function() {
		for (var i$1 = this.context.length - 1; i$1 >= 1; i$1--) {
			var context = this.context[i$1];
			if (context.token === "function") return context.generator;
		}
		return false;
	};
	pp$6.updateContext = function(prevType) {
		var update, type$2 = this.type;
		if (type$2.keyword && prevType === types$1.dot) this.exprAllowed = false;
		else if (update = type$2.updateContext) update.call(this, prevType);
		else this.exprAllowed = type$2.beforeExpr;
	};
	pp$6.overrideContext = function(tokenCtx) {
		if (this.curContext() !== tokenCtx) this.context[this.context.length - 1] = tokenCtx;
	};
	types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
		if (this.context.length === 1) {
			this.exprAllowed = true;
			return;
		}
		var out = this.context.pop();
		if (out === types.b_stat && this.curContext().token === "function") out = this.context.pop();
		this.exprAllowed = !out.isExpr;
	};
	types$1.braceL.updateContext = function(prevType) {
		this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
		this.exprAllowed = true;
	};
	types$1.dollarBraceL.updateContext = function() {
		this.context.push(types.b_tmpl);
		this.exprAllowed = true;
	};
	types$1.parenL.updateContext = function(prevType) {
		var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
		this.context.push(statementParens ? types.p_stat : types.p_expr);
		this.exprAllowed = true;
	};
	types$1.incDec.updateContext = function() {};
	types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
		if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) this.context.push(types.f_expr);
		else this.context.push(types.f_stat);
		this.exprAllowed = false;
	};
	types$1.colon.updateContext = function() {
		if (this.curContext().token === "function") this.context.pop();
		this.exprAllowed = true;
	};
	types$1.backQuote.updateContext = function() {
		if (this.curContext() === types.q_tmpl) this.context.pop();
		else this.context.push(types.q_tmpl);
		this.exprAllowed = false;
	};
	types$1.star.updateContext = function(prevType) {
		if (prevType === types$1._function) {
			var index = this.context.length - 1;
			if (this.context[index] === types.f_expr) this.context[index] = types.f_expr_gen;
			else this.context[index] = types.f_gen;
		}
		this.exprAllowed = true;
	};
	types$1.name.updateContext = function(prevType) {
		var allowed = false;
		if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
			if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) allowed = true;
		}
		this.exprAllowed = allowed;
	};
	var pp$5 = Parser.prototype;
	pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
		if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") return;
		if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
		var key = prop.key;
		var name;
		switch (key.type) {
			case "Identifier":
				name = key.name;
				break;
			case "Literal":
				name = String(key.value);
				break;
			default: return;
		}
		var kind = prop.kind;
		if (this.options.ecmaVersion >= 6) {
			if (name === "__proto__" && kind === "init") {
				if (propHash.proto) if (refDestructuringErrors) {
					if (refDestructuringErrors.doubleProto < 0) refDestructuringErrors.doubleProto = key.start;
				} else this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
				propHash.proto = true;
			}
			return;
		}
		name = "$" + name;
		var other = propHash[name];
		if (other) {
			var redefinition;
			if (kind === "init") redefinition = this.strict && other.init || other.get || other.set;
			else redefinition = other.init || other[kind];
			if (redefinition) this.raiseRecoverable(key.start, "Redefinition of property");
		} else other = propHash[name] = {
			init: false,
			get: false,
			set: false
		};
		other[kind] = true;
	};
	pp$5.parseExpression = function(forInit, refDestructuringErrors) {
		var startPos = this.start, startLoc = this.startLoc;
		var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
		if (this.type === types$1.comma) {
			var node = this.startNodeAt(startPos, startLoc);
			node.expressions = [expr];
			while (this.eat(types$1.comma)) node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
			return this.finishNode(node, "SequenceExpression");
		}
		return expr;
	};
	pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
		if (this.isContextual("yield")) if (this.inGenerator) return this.parseYield(forInit);
		else this.exprAllowed = false;
		var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
		if (refDestructuringErrors) {
			oldParenAssign = refDestructuringErrors.parenthesizedAssign;
			oldTrailingComma = refDestructuringErrors.trailingComma;
			oldDoubleProto = refDestructuringErrors.doubleProto;
			refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
		} else {
			refDestructuringErrors = new DestructuringErrors();
			ownDestructuringErrors = true;
		}
		var startPos = this.start, startLoc = this.startLoc;
		if (this.type === types$1.parenL || this.type === types$1.name) {
			this.potentialArrowAt = this.start;
			this.potentialArrowInForAwait = forInit === "await";
		}
		var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
		if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
		if (this.type.isAssign) {
			var node = this.startNodeAt(startPos, startLoc);
			node.operator = this.value;
			if (this.type === types$1.eq) left = this.toAssignable(left, false, refDestructuringErrors);
			if (!ownDestructuringErrors) refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
			if (refDestructuringErrors.shorthandAssign >= left.start) refDestructuringErrors.shorthandAssign = -1;
			if (this.type === types$1.eq) this.checkLValPattern(left);
			else this.checkLValSimple(left);
			node.left = left;
			this.next();
			node.right = this.parseMaybeAssign(forInit);
			if (oldDoubleProto > -1) refDestructuringErrors.doubleProto = oldDoubleProto;
			return this.finishNode(node, "AssignmentExpression");
		} else if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);
		if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;
		if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma;
		return left;
	};
	pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
		var startPos = this.start, startLoc = this.startLoc;
		var expr = this.parseExprOps(forInit, refDestructuringErrors);
		if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
		if (this.eat(types$1.question)) {
			var node = this.startNodeAt(startPos, startLoc);
			node.test = expr;
			node.consequent = this.parseMaybeAssign();
			this.expect(types$1.colon);
			node.alternate = this.parseMaybeAssign(forInit);
			return this.finishNode(node, "ConditionalExpression");
		}
		return expr;
	};
	pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
		var startPos = this.start, startLoc = this.startLoc;
		var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
		if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
		return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
	};
	pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
		var prec = this.type.binop;
		if (prec != null && (!forInit || this.type !== types$1._in)) {
			if (prec > minPrec) {
				var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
				var coalesce = this.type === types$1.coalesce;
				if (coalesce) prec = types$1.logicalAND.binop;
				var op = this.value;
				this.next();
				var startPos = this.start, startLoc = this.startLoc;
				var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
				var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
				if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
				return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
			}
		}
		return left;
	};
	pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
		if (right.type === "PrivateIdentifier") this.raise(right.start, "Private identifier can only be left side of binary expression");
		var node = this.startNodeAt(startPos, startLoc);
		node.left = left;
		node.operator = op;
		node.right = right;
		return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
	};
	pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
		var startPos = this.start, startLoc = this.startLoc, expr;
		if (this.isContextual("await") && this.canAwait) {
			expr = this.parseAwait(forInit);
			sawUnary = true;
		} else if (this.type.prefix) {
			var node = this.startNode(), update = this.type === types$1.incDec;
			node.operator = this.value;
			node.prefix = true;
			this.next();
			node.argument = this.parseMaybeUnary(null, true, update, forInit);
			this.checkExpressionErrors(refDestructuringErrors, true);
			if (update) this.checkLValSimple(node.argument);
			else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
			else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) this.raiseRecoverable(node.start, "Private fields can not be deleted");
			else sawUnary = true;
			expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
		} else if (!sawUnary && this.type === types$1.privateId) {
			if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) this.unexpected();
			expr = this.parsePrivateIdent();
			if (this.type !== types$1._in) this.unexpected();
		} else {
			expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
			if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
			while (this.type.postfix && !this.canInsertSemicolon()) {
				var node$1 = this.startNodeAt(startPos, startLoc);
				node$1.operator = this.value;
				node$1.prefix = false;
				node$1.argument = expr;
				this.checkLValSimple(expr);
				this.next();
				expr = this.finishNode(node$1, "UpdateExpression");
			}
		}
		if (!incDec && this.eat(types$1.starstar)) if (sawUnary) this.unexpected(this.lastTokStart);
		else return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
		else return expr;
	};
	function isLocalVariableAccess(node) {
		return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
	}
	function isPrivateFieldAccess(node) {
		return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
	}
	pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
		var startPos = this.start, startLoc = this.startLoc;
		var expr = this.parseExprAtom(refDestructuringErrors, forInit);
		if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return expr;
		var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
		if (refDestructuringErrors && result.type === "MemberExpression") {
			if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1;
			if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1;
			if (refDestructuringErrors.trailingComma >= result.start) refDestructuringErrors.trailingComma = -1;
		}
		return result;
	};
	pp$5.parseSubscripts = function(base$1, startPos, startLoc, noCalls, forInit) {
		var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base$1.type === "Identifier" && base$1.name === "async" && this.lastTokEnd === base$1.end && !this.canInsertSemicolon() && base$1.end - base$1.start === 5 && this.potentialArrowAt === base$1.start;
		var optionalChained = false;
		while (true) {
			var element$1 = this.parseSubscript(base$1, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
			if (element$1.optional) optionalChained = true;
			if (element$1 === base$1 || element$1.type === "ArrowFunctionExpression") {
				if (optionalChained) {
					var chainNode = this.startNodeAt(startPos, startLoc);
					chainNode.expression = element$1;
					element$1 = this.finishNode(chainNode, "ChainExpression");
				}
				return element$1;
			}
			base$1 = element$1;
		}
	};
	pp$5.shouldParseAsyncArrow = function() {
		return !this.canInsertSemicolon() && this.eat(types$1.arrow);
	};
	pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
		return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
	};
	pp$5.parseSubscript = function(base$1, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
		var optionalSupported = this.options.ecmaVersion >= 11;
		var optional$1 = optionalSupported && this.eat(types$1.questionDot);
		if (noCalls && optional$1) this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
		var computed = this.eat(types$1.bracketL);
		if (computed || optional$1 && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
			var node = this.startNodeAt(startPos, startLoc);
			node.object = base$1;
			if (computed) {
				node.property = this.parseExpression();
				this.expect(types$1.bracketR);
			} else if (this.type === types$1.privateId && base$1.type !== "Super") node.property = this.parsePrivateIdent();
			else node.property = this.parseIdent(this.options.allowReserved !== "never");
			node.computed = !!computed;
			if (optionalSupported) node.optional = optional$1;
			base$1 = this.finishNode(node, "MemberExpression");
		} else if (!noCalls && this.eat(types$1.parenL)) {
			var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
			this.yieldPos = 0;
			this.awaitPos = 0;
			this.awaitIdentPos = 0;
			var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
			if (maybeAsyncArrow && !optional$1 && this.shouldParseAsyncArrow()) {
				this.checkPatternErrors(refDestructuringErrors, false);
				this.checkYieldAwaitInDefaultParams();
				if (this.awaitIdentPos > 0) this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
				this.yieldPos = oldYieldPos;
				this.awaitPos = oldAwaitPos;
				this.awaitIdentPos = oldAwaitIdentPos;
				return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
			}
			this.checkExpressionErrors(refDestructuringErrors, true);
			this.yieldPos = oldYieldPos || this.yieldPos;
			this.awaitPos = oldAwaitPos || this.awaitPos;
			this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
			var node$1 = this.startNodeAt(startPos, startLoc);
			node$1.callee = base$1;
			node$1.arguments = exprList;
			if (optionalSupported) node$1.optional = optional$1;
			base$1 = this.finishNode(node$1, "CallExpression");
		} else if (this.type === types$1.backQuote) {
			if (optional$1 || optionalChained) this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
			var node$2 = this.startNodeAt(startPos, startLoc);
			node$2.tag = base$1;
			node$2.quasi = this.parseTemplate({ isTagged: true });
			base$1 = this.finishNode(node$2, "TaggedTemplateExpression");
		}
		return base$1;
	};
	pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
		if (this.type === types$1.slash) this.readRegexp();
		var node, canBeArrow = this.potentialArrowAt === this.start;
		switch (this.type) {
			case types$1._super:
				if (!this.allowSuper) this.raise(this.start, "'super' keyword outside a method");
				node = this.startNode();
				this.next();
				if (this.type === types$1.parenL && !this.allowDirectSuper) this.raise(node.start, "super() call outside constructor of a subclass");
				if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) this.unexpected();
				return this.finishNode(node, "Super");
			case types$1._this:
				node = this.startNode();
				this.next();
				return this.finishNode(node, "ThisExpression");
			case types$1.name:
				var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
				var id = this.parseIdent(false);
				if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
					this.overrideContext(types.f_expr);
					return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
				}
				if (canBeArrow && !this.canInsertSemicolon()) {
					if (this.eat(types$1.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
					if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
						id = this.parseIdent(false);
						if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) this.unexpected();
						return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
					}
				}
				return id;
			case types$1.regexp:
				var value = this.value;
				node = this.parseLiteral(value.value);
				node.regex = {
					pattern: value.pattern,
					flags: value.flags
				};
				return node;
			case types$1.num:
			case types$1.string: return this.parseLiteral(this.value);
			case types$1._null:
			case types$1._true:
			case types$1._false:
				node = this.startNode();
				node.value = this.type === types$1._null ? null : this.type === types$1._true;
				node.raw = this.type.keyword;
				this.next();
				return this.finishNode(node, "Literal");
			case types$1.parenL:
				var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
				if (refDestructuringErrors) {
					if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) refDestructuringErrors.parenthesizedAssign = start;
					if (refDestructuringErrors.parenthesizedBind < 0) refDestructuringErrors.parenthesizedBind = start;
				}
				return expr;
			case types$1.bracketL:
				node = this.startNode();
				this.next();
				node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
				return this.finishNode(node, "ArrayExpression");
			case types$1.braceL:
				this.overrideContext(types.b_expr);
				return this.parseObj(false, refDestructuringErrors);
			case types$1._function:
				node = this.startNode();
				this.next();
				return this.parseFunction(node, 0);
			case types$1._class: return this.parseClass(this.startNode(), false);
			case types$1._new: return this.parseNew();
			case types$1.backQuote: return this.parseTemplate();
			case types$1._import: if (this.options.ecmaVersion >= 11) return this.parseExprImport(forNew);
			else return this.unexpected();
			default: return this.parseExprAtomDefault();
		}
	};
	pp$5.parseExprAtomDefault = function() {
		this.unexpected();
	};
	pp$5.parseExprImport = function(forNew) {
		var node = this.startNode();
		if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword import");
		this.next();
		if (this.type === types$1.parenL && !forNew) return this.parseDynamicImport(node);
		else if (this.type === types$1.dot) {
			var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
			meta.name = "import";
			node.meta = this.finishNode(meta, "Identifier");
			return this.parseImportMeta(node);
		} else this.unexpected();
	};
	pp$5.parseDynamicImport = function(node) {
		this.next();
		node.source = this.parseMaybeAssign();
		if (this.options.ecmaVersion >= 16) if (!this.eat(types$1.parenR)) {
			this.expect(types$1.comma);
			if (!this.afterTrailingComma(types$1.parenR)) {
				node.options = this.parseMaybeAssign();
				if (!this.eat(types$1.parenR)) {
					this.expect(types$1.comma);
					if (!this.afterTrailingComma(types$1.parenR)) this.unexpected();
				}
			} else node.options = null;
		} else node.options = null;
		else if (!this.eat(types$1.parenR)) {
			var errorPos = this.start;
			if (this.eat(types$1.comma) && this.eat(types$1.parenR)) this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
			else this.unexpected(errorPos);
		}
		return this.finishNode(node, "ImportExpression");
	};
	pp$5.parseImportMeta = function(node) {
		this.next();
		var containsEsc = this.containsEsc;
		node.property = this.parseIdent(true);
		if (node.property.name !== "meta") this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
		if (containsEsc) this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
		if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
		return this.finishNode(node, "MetaProperty");
	};
	pp$5.parseLiteral = function(value) {
		var node = this.startNode();
		node.value = value;
		node.raw = this.input.slice(this.start, this.end);
		if (node.raw.charCodeAt(node.raw.length - 1) === 110) node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, "");
		this.next();
		return this.finishNode(node, "Literal");
	};
	pp$5.parseParenExpression = function() {
		this.expect(types$1.parenL);
		var val$1 = this.parseExpression();
		this.expect(types$1.parenR);
		return val$1;
	};
	pp$5.shouldParseArrow = function(exprList) {
		return !this.canInsertSemicolon();
	};
	pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
		var startPos = this.start, startLoc = this.startLoc, val$1, allowTrailingComma = this.options.ecmaVersion >= 8;
		if (this.options.ecmaVersion >= 6) {
			this.next();
			var innerStartPos = this.start, innerStartLoc = this.startLoc;
			var exprList = [], first = true, lastIsComma = false;
			var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
			this.yieldPos = 0;
			this.awaitPos = 0;
			while (this.type !== types$1.parenR) {
				first ? first = false : this.expect(types$1.comma);
				if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
					lastIsComma = true;
					break;
				} else if (this.type === types$1.ellipsis) {
					spreadStart = this.start;
					exprList.push(this.parseParenItem(this.parseRestBinding()));
					if (this.type === types$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
					break;
				} else exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
			}
			var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
			this.expect(types$1.parenR);
			if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
				this.checkPatternErrors(refDestructuringErrors, false);
				this.checkYieldAwaitInDefaultParams();
				this.yieldPos = oldYieldPos;
				this.awaitPos = oldAwaitPos;
				return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
			}
			if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);
			if (spreadStart) this.unexpected(spreadStart);
			this.checkExpressionErrors(refDestructuringErrors, true);
			this.yieldPos = oldYieldPos || this.yieldPos;
			this.awaitPos = oldAwaitPos || this.awaitPos;
			if (exprList.length > 1) {
				val$1 = this.startNodeAt(innerStartPos, innerStartLoc);
				val$1.expressions = exprList;
				this.finishNodeAt(val$1, "SequenceExpression", innerEndPos, innerEndLoc);
			} else val$1 = exprList[0];
		} else val$1 = this.parseParenExpression();
		if (this.options.preserveParens) {
			var par = this.startNodeAt(startPos, startLoc);
			par.expression = val$1;
			return this.finishNode(par, "ParenthesizedExpression");
		} else return val$1;
	};
	pp$5.parseParenItem = function(item) {
		return item;
	};
	pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
		return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
	};
	var empty = [];
	pp$5.parseNew = function() {
		if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword new");
		var node = this.startNode();
		this.next();
		if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
			var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
			meta.name = "new";
			node.meta = this.finishNode(meta, "Identifier");
			this.next();
			var containsEsc = this.containsEsc;
			node.property = this.parseIdent(true);
			if (node.property.name !== "target") this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
			if (containsEsc) this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
			if (!this.allowNewDotTarget) this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
			return this.finishNode(node, "MetaProperty");
		}
		var startPos = this.start, startLoc = this.startLoc;
		node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
		if (this.eat(types$1.parenL)) node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
		else node.arguments = empty;
		return this.finishNode(node, "NewExpression");
	};
	pp$5.parseTemplateElement = function(ref$1) {
		var isTagged = ref$1.isTagged;
		var elem = this.startNode();
		if (this.type === types$1.invalidTemplate) {
			if (!isTagged) this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
			elem.value = {
				raw: this.value.replace(/\r\n?/g, "\n"),
				cooked: null
			};
		} else elem.value = {
			raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
			cooked: this.value
		};
		this.next();
		elem.tail = this.type === types$1.backQuote;
		return this.finishNode(elem, "TemplateElement");
	};
	pp$5.parseTemplate = function(ref$1) {
		if (ref$1 === void 0) ref$1 = {};
		var isTagged = ref$1.isTagged;
		if (isTagged === void 0) isTagged = false;
		var node = this.startNode();
		this.next();
		node.expressions = [];
		var curElt = this.parseTemplateElement({ isTagged });
		node.quasis = [curElt];
		while (!curElt.tail) {
			if (this.type === types$1.eof) this.raise(this.pos, "Unterminated template literal");
			this.expect(types$1.dollarBraceL);
			node.expressions.push(this.parseExpression());
			this.expect(types$1.braceR);
			node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
		}
		this.next();
		return this.finishNode(node, "TemplateLiteral");
	};
	pp$5.isAsyncProp = function(prop) {
		return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
	};
	pp$5.parseObj = function(isPattern, refDestructuringErrors) {
		var node = this.startNode(), first = true, propHash = {};
		node.properties = [];
		this.next();
		while (!this.eat(types$1.braceR)) {
			if (!first) {
				this.expect(types$1.comma);
				if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) break;
			} else first = false;
			var prop = this.parseProperty(isPattern, refDestructuringErrors);
			if (!isPattern) this.checkPropClash(prop, propHash, refDestructuringErrors);
			node.properties.push(prop);
		}
		return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
	};
	pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
		var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
		if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
			if (isPattern) {
				prop.argument = this.parseIdent(false);
				if (this.type === types$1.comma) this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
				return this.finishNode(prop, "RestElement");
			}
			prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
			if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
			return this.finishNode(prop, "SpreadElement");
		}
		if (this.options.ecmaVersion >= 6) {
			prop.method = false;
			prop.shorthand = false;
			if (isPattern || refDestructuringErrors) {
				startPos = this.start;
				startLoc = this.startLoc;
			}
			if (!isPattern) isGenerator = this.eat(types$1.star);
		}
		var containsEsc = this.containsEsc;
		this.parsePropertyName(prop);
		if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
			isAsync = true;
			isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
			this.parsePropertyName(prop);
		} else isAsync = false;
		this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
		return this.finishNode(prop, "Property");
	};
	pp$5.parseGetterSetter = function(prop) {
		var kind = prop.key.name;
		this.parsePropertyName(prop);
		prop.value = this.parseMethod(false);
		prop.kind = kind;
		var paramCount = prop.kind === "get" ? 0 : 1;
		if (prop.value.params.length !== paramCount) {
			var start = prop.value.start;
			if (prop.kind === "get") this.raiseRecoverable(start, "getter should have no params");
			else this.raiseRecoverable(start, "setter should have exactly one param");
		} else if (prop.kind === "set" && prop.value.params[0].type === "RestElement") this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
	};
	pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
		if ((isGenerator || isAsync) && this.type === types$1.colon) this.unexpected();
		if (this.eat(types$1.colon)) {
			prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
			prop.kind = "init";
		} else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
			if (isPattern) this.unexpected();
			prop.method = true;
			prop.value = this.parseMethod(isGenerator, isAsync);
			prop.kind = "init";
		} else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq) {
			if (isGenerator || isAsync) this.unexpected();
			this.parseGetterSetter(prop);
		} else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
			if (isGenerator || isAsync) this.unexpected();
			this.checkUnreserved(prop.key);
			if (prop.key.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = startPos;
			if (isPattern) prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
			else if (this.type === types$1.eq && refDestructuringErrors) {
				if (refDestructuringErrors.shorthandAssign < 0) refDestructuringErrors.shorthandAssign = this.start;
				prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
			} else prop.value = this.copyNode(prop.key);
			prop.kind = "init";
			prop.shorthand = true;
		} else this.unexpected();
	};
	pp$5.parsePropertyName = function(prop) {
		if (this.options.ecmaVersion >= 6) if (this.eat(types$1.bracketL)) {
			prop.computed = true;
			prop.key = this.parseMaybeAssign();
			this.expect(types$1.bracketR);
			return prop.key;
		} else prop.computed = false;
		return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
	};
	pp$5.initFunction = function(node) {
		node.id = null;
		if (this.options.ecmaVersion >= 6) node.generator = node.expression = false;
		if (this.options.ecmaVersion >= 8) node.async = false;
	};
	pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
		var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
		this.initFunction(node);
		if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
		if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
		this.yieldPos = 0;
		this.awaitPos = 0;
		this.awaitIdentPos = 0;
		this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
		this.expect(types$1.parenL);
		node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
		this.checkYieldAwaitInDefaultParams();
		this.parseFunctionBody(node, false, true, false);
		this.yieldPos = oldYieldPos;
		this.awaitPos = oldAwaitPos;
		this.awaitIdentPos = oldAwaitIdentPos;
		return this.finishNode(node, "FunctionExpression");
	};
	pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
		var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
		this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
		this.initFunction(node);
		if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
		this.yieldPos = 0;
		this.awaitPos = 0;
		this.awaitIdentPos = 0;
		node.params = this.toAssignableList(params, true);
		this.parseFunctionBody(node, true, false, forInit);
		this.yieldPos = oldYieldPos;
		this.awaitPos = oldAwaitPos;
		this.awaitIdentPos = oldAwaitIdentPos;
		return this.finishNode(node, "ArrowFunctionExpression");
	};
	pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
		var isExpression = isArrowFunction && this.type !== types$1.braceL;
		var oldStrict = this.strict, useStrict = false;
		if (isExpression) {
			node.body = this.parseMaybeAssign(forInit);
			node.expression = true;
			this.checkParams(node, false);
		} else {
			var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
			if (!oldStrict || nonSimple) {
				useStrict = this.strictDirective(this.end);
				if (useStrict && nonSimple) this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
			}
			var oldLabels = this.labels;
			this.labels = [];
			if (useStrict) this.strict = true;
			this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
			if (this.strict && node.id) this.checkLValSimple(node.id, BIND_OUTSIDE);
			node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
			node.expression = false;
			this.adaptDirectivePrologue(node.body.body);
			this.labels = oldLabels;
		}
		this.exitScope();
	};
	pp$5.isSimpleParamList = function(params) {
		for (var i$1 = 0, list$1 = params; i$1 < list$1.length; i$1 += 1) if (list$1[i$1].type !== "Identifier") return false;
		return true;
	};
	pp$5.checkParams = function(node, allowDuplicates) {
		var nameHash = Object.create(null);
		for (var i$1 = 0, list$1 = node.params; i$1 < list$1.length; i$1 += 1) {
			var param = list$1[i$1];
			this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
		}
	};
	pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
		var elts = [], first = true;
		while (!this.eat(close)) {
			if (!first) {
				this.expect(types$1.comma);
				if (allowTrailingComma && this.afterTrailingComma(close)) break;
			} else first = false;
			var elt = void 0;
			if (allowEmpty && this.type === types$1.comma) elt = null;
			else if (this.type === types$1.ellipsis) {
				elt = this.parseSpread(refDestructuringErrors);
				if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;
			} else elt = this.parseMaybeAssign(false, refDestructuringErrors);
			elts.push(elt);
		}
		return elts;
	};
	pp$5.checkUnreserved = function(ref$1) {
		var start = ref$1.start;
		var end = ref$1.end;
		var name = ref$1.name;
		if (this.inGenerator && name === "yield") this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
		if (this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
		if (!(this.currentThisScope().flags & SCOPE_VAR) && name === "arguments") this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
		if (this.inClassStaticBlock && (name === "arguments" || name === "await")) this.raise(start, "Cannot use " + name + " in class static initialization block");
		if (this.keywords.test(name)) this.raise(start, "Unexpected keyword '" + name + "'");
		if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) return;
		if ((this.strict ? this.reservedWordsStrict : this.reservedWords).test(name)) {
			if (!this.inAsync && name === "await") this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
			this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
		}
	};
	pp$5.parseIdent = function(liberal) {
		var node = this.parseIdentNode();
		this.next(!!liberal);
		this.finishNode(node, "Identifier");
		if (!liberal) {
			this.checkUnreserved(node);
			if (node.name === "await" && !this.awaitIdentPos) this.awaitIdentPos = node.start;
		}
		return node;
	};
	pp$5.parseIdentNode = function() {
		var node = this.startNode();
		if (this.type === types$1.name) node.name = this.value;
		else if (this.type.keyword) {
			node.name = this.type.keyword;
			if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) this.context.pop();
			this.type = types$1.name;
		} else this.unexpected();
		return node;
	};
	pp$5.parsePrivateIdent = function() {
		var node = this.startNode();
		if (this.type === types$1.privateId) node.name = this.value;
		else this.unexpected();
		this.next();
		this.finishNode(node, "PrivateIdentifier");
		if (this.options.checkPrivateFields) if (this.privateNameStack.length === 0) this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
		else this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
		return node;
	};
	pp$5.parseYield = function(forInit) {
		if (!this.yieldPos) this.yieldPos = this.start;
		var node = this.startNode();
		this.next();
		if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
			node.delegate = false;
			node.argument = null;
		} else {
			node.delegate = this.eat(types$1.star);
			node.argument = this.parseMaybeAssign(forInit);
		}
		return this.finishNode(node, "YieldExpression");
	};
	pp$5.parseAwait = function(forInit) {
		if (!this.awaitPos) this.awaitPos = this.start;
		var node = this.startNode();
		this.next();
		node.argument = this.parseMaybeUnary(null, true, false, forInit);
		return this.finishNode(node, "AwaitExpression");
	};
	var pp$4 = Parser.prototype;
	pp$4.raise = function(pos, message) {
		var loc = getLineInfo(this.input, pos);
		message += " (" + loc.line + ":" + loc.column + ")";
		if (this.sourceFile) message += " in " + this.sourceFile;
		var err$1 = new SyntaxError(message);
		err$1.pos = pos;
		err$1.loc = loc;
		err$1.raisedAt = this.pos;
		throw err$1;
	};
	pp$4.raiseRecoverable = pp$4.raise;
	pp$4.curPosition = function() {
		if (this.options.locations) return new Position(this.curLine, this.pos - this.lineStart);
	};
	var pp$3 = Parser.prototype;
	var Scope = function Scope$1(flags) {
		this.flags = flags;
		this.var = [];
		this.lexical = [];
		this.functions = [];
	};
	pp$3.enterScope = function(flags) {
		this.scopeStack.push(new Scope(flags));
	};
	pp$3.exitScope = function() {
		this.scopeStack.pop();
	};
	pp$3.treatFunctionsAsVarInScope = function(scope) {
		return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
	};
	pp$3.declareName = function(name, bindingType, pos) {
		var redeclared = false;
		if (bindingType === BIND_LEXICAL) {
			var scope = this.currentScope();
			redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
			scope.lexical.push(name);
			if (this.inModule && scope.flags & SCOPE_TOP) delete this.undefinedExports[name];
		} else if (bindingType === BIND_SIMPLE_CATCH) this.currentScope().lexical.push(name);
		else if (bindingType === BIND_FUNCTION) {
			var scope$2 = this.currentScope();
			if (this.treatFunctionsAsVar) redeclared = scope$2.lexical.indexOf(name) > -1;
			else redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
			scope$2.functions.push(name);
		} else for (var i$1 = this.scopeStack.length - 1; i$1 >= 0; --i$1) {
			var scope$3 = this.scopeStack[i$1];
			if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
				redeclared = true;
				break;
			}
			scope$3.var.push(name);
			if (this.inModule && scope$3.flags & SCOPE_TOP) delete this.undefinedExports[name];
			if (scope$3.flags & SCOPE_VAR) break;
		}
		if (redeclared) this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
	};
	pp$3.checkLocalExport = function(id) {
		if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) this.undefinedExports[id.name] = id;
	};
	pp$3.currentScope = function() {
		return this.scopeStack[this.scopeStack.length - 1];
	};
	pp$3.currentVarScope = function() {
		for (var i$1 = this.scopeStack.length - 1;; i$1--) {
			var scope = this.scopeStack[i$1];
			if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) return scope;
		}
	};
	pp$3.currentThisScope = function() {
		for (var i$1 = this.scopeStack.length - 1;; i$1--) {
			var scope = this.scopeStack[i$1];
			if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) return scope;
		}
	};
	var Node = function Node$1(parser, pos, loc) {
		this.type = "";
		this.start = pos;
		this.end = 0;
		if (parser.options.locations) this.loc = new SourceLocation(parser, loc);
		if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
		if (parser.options.ranges) this.range = [pos, 0];
	};
	var pp$2 = Parser.prototype;
	pp$2.startNode = function() {
		return new Node(this, this.start, this.startLoc);
	};
	pp$2.startNodeAt = function(pos, loc) {
		return new Node(this, pos, loc);
	};
	function finishNodeAt(node, type$2, pos, loc) {
		node.type = type$2;
		node.end = pos;
		if (this.options.locations) node.loc.end = loc;
		if (this.options.ranges) node.range[1] = pos;
		return node;
	}
	pp$2.finishNode = function(node, type$2) {
		return finishNodeAt.call(this, node, type$2, this.lastTokEnd, this.lastTokEndLoc);
	};
	pp$2.finishNodeAt = function(node, type$2, pos, loc) {
		return finishNodeAt.call(this, node, type$2, pos, loc);
	};
	pp$2.copyNode = function(node) {
		var newNode = new Node(this, node.start, this.startLoc);
		for (var prop in node) newNode[prop] = node[prop];
		return newNode;
	};
	var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
	var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
	var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
	var ecma11BinaryProperties = ecma10BinaryProperties;
	var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
	var ecma13BinaryProperties = ecma12BinaryProperties;
	var ecma14BinaryProperties = ecma13BinaryProperties;
	var unicodeBinaryProperties = {
		9: ecma9BinaryProperties,
		10: ecma10BinaryProperties,
		11: ecma11BinaryProperties,
		12: ecma12BinaryProperties,
		13: ecma13BinaryProperties,
		14: ecma14BinaryProperties
	};
	var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
	var unicodeBinaryPropertiesOfStrings = {
		9: "",
		10: "",
		11: "",
		12: "",
		13: "",
		14: ecma14BinaryPropertiesOfStrings
	};
	var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
	var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
	var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
	var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
	var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
	var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
	var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
	var unicodeScriptValues = {
		9: ecma9ScriptValues,
		10: ecma10ScriptValues,
		11: ecma11ScriptValues,
		12: ecma12ScriptValues,
		13: ecma13ScriptValues,
		14: ecma14ScriptValues
	};
	var data$1 = {};
	function buildUnicodeData(ecmaVersion$1) {
		var d$1 = data$1[ecmaVersion$1] = {
			binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion$1] + " " + unicodeGeneralCategoryValues),
			binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion$1]),
			nonBinary: {
				General_Category: wordsRegexp(unicodeGeneralCategoryValues),
				Script: wordsRegexp(unicodeScriptValues[ecmaVersion$1])
			}
		};
		d$1.nonBinary.Script_Extensions = d$1.nonBinary.Script;
		d$1.nonBinary.gc = d$1.nonBinary.General_Category;
		d$1.nonBinary.sc = d$1.nonBinary.Script;
		d$1.nonBinary.scx = d$1.nonBinary.Script_Extensions;
	}
	for (var i = 0, list = [
		9,
		10,
		11,
		12,
		13,
		14
	]; i < list.length; i += 1) {
		var ecmaVersion = list[i];
		buildUnicodeData(ecmaVersion);
	}
	var pp$1 = Parser.prototype;
	var BranchID = function BranchID$1(parent, base$1) {
		this.parent = parent;
		this.base = base$1 || this;
	};
	BranchID.prototype.separatedFrom = function separatedFrom(alt) {
		for (var self$1 = this; self$1; self$1 = self$1.parent) for (var other = alt; other; other = other.parent) if (self$1.base === other.base && self$1 !== other) return true;
		return false;
	};
	BranchID.prototype.sibling = function sibling() {
		return new BranchID(this.parent, this.base);
	};
	var RegExpValidationState = function RegExpValidationState$1(parser) {
		this.parser = parser;
		this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
		this.unicodeProperties = data$1[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
		this.source = "";
		this.flags = "";
		this.start = 0;
		this.switchU = false;
		this.switchV = false;
		this.switchN = false;
		this.pos = 0;
		this.lastIntValue = 0;
		this.lastStringValue = "";
		this.lastAssertionIsQuantifiable = false;
		this.numCapturingParens = 0;
		this.maxBackReference = 0;
		this.groupNames = Object.create(null);
		this.backReferenceNames = [];
		this.branchID = null;
	};
	RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
		var unicodeSets = flags.indexOf("v") !== -1;
		var unicode = flags.indexOf("u") !== -1;
		this.start = start | 0;
		this.source = pattern + "";
		this.flags = flags;
		if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
			this.switchU = true;
			this.switchV = true;
			this.switchN = true;
		} else {
			this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
			this.switchV = false;
			this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
		}
	};
	RegExpValidationState.prototype.raise = function raise(message) {
		this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
	};
	RegExpValidationState.prototype.at = function at(i$1, forceU) {
		if (forceU === void 0) forceU = false;
		var s = this.source;
		var l = s.length;
		if (i$1 >= l) return -1;
		var c = s.charCodeAt(i$1);
		if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i$1 + 1 >= l) return c;
		var next = s.charCodeAt(i$1 + 1);
		return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
	};
	RegExpValidationState.prototype.nextIndex = function nextIndex(i$1, forceU) {
		if (forceU === void 0) forceU = false;
		var s = this.source;
		var l = s.length;
		if (i$1 >= l) return l;
		var c = s.charCodeAt(i$1), next;
		if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i$1 + 1 >= l || (next = s.charCodeAt(i$1 + 1)) < 56320 || next > 57343) return i$1 + 1;
		return i$1 + 2;
	};
	RegExpValidationState.prototype.current = function current(forceU) {
		if (forceU === void 0) forceU = false;
		return this.at(this.pos, forceU);
	};
	RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
		if (forceU === void 0) forceU = false;
		return this.at(this.nextIndex(this.pos, forceU), forceU);
	};
	RegExpValidationState.prototype.advance = function advance(forceU) {
		if (forceU === void 0) forceU = false;
		this.pos = this.nextIndex(this.pos, forceU);
	};
	RegExpValidationState.prototype.eat = function eat(ch, forceU) {
		if (forceU === void 0) forceU = false;
		if (this.current(forceU) === ch) {
			this.advance(forceU);
			return true;
		}
		return false;
	};
	RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
		if (forceU === void 0) forceU = false;
		var pos = this.pos;
		for (var i$1 = 0, list$1 = chs; i$1 < list$1.length; i$1 += 1) {
			var ch = list$1[i$1];
			var current = this.at(pos, forceU);
			if (current === -1 || current !== ch) return false;
			pos = this.nextIndex(pos, forceU);
		}
		this.pos = pos;
		return true;
	};
	pp$1.validateRegExpFlags = function(state) {
		var validFlags = state.validFlags;
		var flags = state.flags;
		var u$1 = false;
		var v$1 = false;
		for (var i$1 = 0; i$1 < flags.length; i$1++) {
			var flag = flags.charAt(i$1);
			if (validFlags.indexOf(flag) === -1) this.raise(state.start, "Invalid regular expression flag");
			if (flags.indexOf(flag, i$1 + 1) > -1) this.raise(state.start, "Duplicate regular expression flag");
			if (flag === "u") u$1 = true;
			if (flag === "v") v$1 = true;
		}
		if (this.options.ecmaVersion >= 15 && u$1 && v$1) this.raise(state.start, "Invalid regular expression flag");
	};
	function hasProp(obj) {
		for (var _ in obj) return true;
		return false;
	}
	pp$1.validateRegExpPattern = function(state) {
		this.regexp_pattern(state);
		if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
			state.switchN = true;
			this.regexp_pattern(state);
		}
	};
	pp$1.regexp_pattern = function(state) {
		state.pos = 0;
		state.lastIntValue = 0;
		state.lastStringValue = "";
		state.lastAssertionIsQuantifiable = false;
		state.numCapturingParens = 0;
		state.maxBackReference = 0;
		state.groupNames = Object.create(null);
		state.backReferenceNames.length = 0;
		state.branchID = null;
		this.regexp_disjunction(state);
		if (state.pos !== state.source.length) {
			if (state.eat(41)) state.raise("Unmatched ')'");
			if (state.eat(93) || state.eat(125)) state.raise("Lone quantifier brackets");
		}
		if (state.maxBackReference > state.numCapturingParens) state.raise("Invalid escape");
		for (var i$1 = 0, list$1 = state.backReferenceNames; i$1 < list$1.length; i$1 += 1) {
			var name = list$1[i$1];
			if (!state.groupNames[name]) state.raise("Invalid named capture referenced");
		}
	};
	pp$1.regexp_disjunction = function(state) {
		var trackDisjunction = this.options.ecmaVersion >= 16;
		if (trackDisjunction) state.branchID = new BranchID(state.branchID, null);
		this.regexp_alternative(state);
		while (state.eat(124)) {
			if (trackDisjunction) state.branchID = state.branchID.sibling();
			this.regexp_alternative(state);
		}
		if (trackDisjunction) state.branchID = state.branchID.parent;
		if (this.regexp_eatQuantifier(state, true)) state.raise("Nothing to repeat");
		if (state.eat(123)) state.raise("Lone quantifier brackets");
	};
	pp$1.regexp_alternative = function(state) {
		while (state.pos < state.source.length && this.regexp_eatTerm(state));
	};
	pp$1.regexp_eatTerm = function(state) {
		if (this.regexp_eatAssertion(state)) {
			if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
				if (state.switchU) state.raise("Invalid quantifier");
			}
			return true;
		}
		if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
			this.regexp_eatQuantifier(state);
			return true;
		}
		return false;
	};
	pp$1.regexp_eatAssertion = function(state) {
		var start = state.pos;
		state.lastAssertionIsQuantifiable = false;
		if (state.eat(94) || state.eat(36)) return true;
		if (state.eat(92)) {
			if (state.eat(66) || state.eat(98)) return true;
			state.pos = start;
		}
		if (state.eat(40) && state.eat(63)) {
			var lookbehind = false;
			if (this.options.ecmaVersion >= 9) lookbehind = state.eat(60);
			if (state.eat(61) || state.eat(33)) {
				this.regexp_disjunction(state);
				if (!state.eat(41)) state.raise("Unterminated group");
				state.lastAssertionIsQuantifiable = !lookbehind;
				return true;
			}
		}
		state.pos = start;
		return false;
	};
	pp$1.regexp_eatQuantifier = function(state, noError) {
		if (noError === void 0) noError = false;
		if (this.regexp_eatQuantifierPrefix(state, noError)) {
			state.eat(63);
			return true;
		}
		return false;
	};
	pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
		return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
	};
	pp$1.regexp_eatBracedQuantifier = function(state, noError) {
		var start = state.pos;
		if (state.eat(123)) {
			var min = 0, max = -1;
			if (this.regexp_eatDecimalDigits(state)) {
				min = state.lastIntValue;
				if (state.eat(44) && this.regexp_eatDecimalDigits(state)) max = state.lastIntValue;
				if (state.eat(125)) {
					if (max !== -1 && max < min && !noError) state.raise("numbers out of order in {} quantifier");
					return true;
				}
			}
			if (state.switchU && !noError) state.raise("Incomplete quantifier");
			state.pos = start;
		}
		return false;
	};
	pp$1.regexp_eatAtom = function(state) {
		return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
	};
	pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
		var start = state.pos;
		if (state.eat(92)) {
			if (this.regexp_eatAtomEscape(state)) return true;
			state.pos = start;
		}
		return false;
	};
	pp$1.regexp_eatUncapturingGroup = function(state) {
		var start = state.pos;
		if (state.eat(40)) {
			if (state.eat(63)) {
				if (this.options.ecmaVersion >= 16) {
					var addModifiers = this.regexp_eatModifiers(state);
					var hasHyphen = state.eat(45);
					if (addModifiers || hasHyphen) {
						for (var i$1 = 0; i$1 < addModifiers.length; i$1++) {
							var modifier = addModifiers.charAt(i$1);
							if (addModifiers.indexOf(modifier, i$1 + 1) > -1) state.raise("Duplicate regular expression modifiers");
						}
						if (hasHyphen) {
							var removeModifiers = this.regexp_eatModifiers(state);
							if (!addModifiers && !removeModifiers && state.current() === 58) state.raise("Invalid regular expression modifiers");
							for (var i$1$1 = 0; i$1$1 < removeModifiers.length; i$1$1++) {
								var modifier$1 = removeModifiers.charAt(i$1$1);
								if (removeModifiers.indexOf(modifier$1, i$1$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) state.raise("Duplicate regular expression modifiers");
							}
						}
					}
				}
				if (state.eat(58)) {
					this.regexp_disjunction(state);
					if (state.eat(41)) return true;
					state.raise("Unterminated group");
				}
			}
			state.pos = start;
		}
		return false;
	};
	pp$1.regexp_eatCapturingGroup = function(state) {
		if (state.eat(40)) {
			if (this.options.ecmaVersion >= 9) this.regexp_groupSpecifier(state);
			else if (state.current() === 63) state.raise("Invalid group");
			this.regexp_disjunction(state);
			if (state.eat(41)) {
				state.numCapturingParens += 1;
				return true;
			}
			state.raise("Unterminated group");
		}
		return false;
	};
	pp$1.regexp_eatModifiers = function(state) {
		var modifiers = "";
		var ch = 0;
		while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
			modifiers += codePointToString(ch);
			state.advance();
		}
		return modifiers;
	};
	function isRegularExpressionModifier(ch) {
		return ch === 105 || ch === 109 || ch === 115;
	}
	pp$1.regexp_eatExtendedAtom = function(state) {
		return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
	};
	pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
		if (this.regexp_eatBracedQuantifier(state, true)) state.raise("Nothing to repeat");
		return false;
	};
	pp$1.regexp_eatSyntaxCharacter = function(state) {
		var ch = state.current();
		if (isSyntaxCharacter(ch)) {
			state.lastIntValue = ch;
			state.advance();
			return true;
		}
		return false;
	};
	function isSyntaxCharacter(ch) {
		return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
	}
	pp$1.regexp_eatPatternCharacters = function(state) {
		var start = state.pos;
		var ch = 0;
		while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) state.advance();
		return state.pos !== start;
	};
	pp$1.regexp_eatExtendedPatternCharacter = function(state) {
		var ch = state.current();
		if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
			state.advance();
			return true;
		}
		return false;
	};
	pp$1.regexp_groupSpecifier = function(state) {
		if (state.eat(63)) {
			if (!this.regexp_eatGroupName(state)) state.raise("Invalid group");
			var trackDisjunction = this.options.ecmaVersion >= 16;
			var known = state.groupNames[state.lastStringValue];
			if (known) if (trackDisjunction) {
				for (var i$1 = 0, list$1 = known; i$1 < list$1.length; i$1 += 1) if (!list$1[i$1].separatedFrom(state.branchID)) state.raise("Duplicate capture group name");
			} else state.raise("Duplicate capture group name");
			if (trackDisjunction) (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
			else state.groupNames[state.lastStringValue] = true;
		}
	};
	pp$1.regexp_eatGroupName = function(state) {
		state.lastStringValue = "";
		if (state.eat(60)) {
			if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) return true;
			state.raise("Invalid capture group name");
		}
		return false;
	};
	pp$1.regexp_eatRegExpIdentifierName = function(state) {
		state.lastStringValue = "";
		if (this.regexp_eatRegExpIdentifierStart(state)) {
			state.lastStringValue += codePointToString(state.lastIntValue);
			while (this.regexp_eatRegExpIdentifierPart(state)) state.lastStringValue += codePointToString(state.lastIntValue);
			return true;
		}
		return false;
	};
	pp$1.regexp_eatRegExpIdentifierStart = function(state) {
		var start = state.pos;
		var forceU = this.options.ecmaVersion >= 11;
		var ch = state.current(forceU);
		state.advance(forceU);
		if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
		if (isRegExpIdentifierStart(ch)) {
			state.lastIntValue = ch;
			return true;
		}
		state.pos = start;
		return false;
	};
	function isRegExpIdentifierStart(ch) {
		return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
	}
	pp$1.regexp_eatRegExpIdentifierPart = function(state) {
		var start = state.pos;
		var forceU = this.options.ecmaVersion >= 11;
		var ch = state.current(forceU);
		state.advance(forceU);
		if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;
		if (isRegExpIdentifierPart(ch)) {
			state.lastIntValue = ch;
			return true;
		}
		state.pos = start;
		return false;
	};
	function isRegExpIdentifierPart(ch) {
		return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
	}
	pp$1.regexp_eatAtomEscape = function(state) {
		if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) return true;
		if (state.switchU) {
			if (state.current() === 99) state.raise("Invalid unicode escape");
			state.raise("Invalid escape");
		}
		return false;
	};
	pp$1.regexp_eatBackReference = function(state) {
		var start = state.pos;
		if (this.regexp_eatDecimalEscape(state)) {
			var n$2 = state.lastIntValue;
			if (state.switchU) {
				if (n$2 > state.maxBackReference) state.maxBackReference = n$2;
				return true;
			}
			if (n$2 <= state.numCapturingParens) return true;
			state.pos = start;
		}
		return false;
	};
	pp$1.regexp_eatKGroupName = function(state) {
		if (state.eat(107)) {
			if (this.regexp_eatGroupName(state)) {
				state.backReferenceNames.push(state.lastStringValue);
				return true;
			}
			state.raise("Invalid named reference");
		}
		return false;
	};
	pp$1.regexp_eatCharacterEscape = function(state) {
		return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
	};
	pp$1.regexp_eatCControlLetter = function(state) {
		var start = state.pos;
		if (state.eat(99)) {
			if (this.regexp_eatControlLetter(state)) return true;
			state.pos = start;
		}
		return false;
	};
	pp$1.regexp_eatZero = function(state) {
		if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
			state.lastIntValue = 0;
			state.advance();
			return true;
		}
		return false;
	};
	pp$1.regexp_eatControlEscape = function(state) {
		var ch = state.current();
		if (ch === 116) {
			state.lastIntValue = 9;
			state.advance();
			return true;
		}
		if (ch === 110) {
			state.lastIntValue = 10;
			state.advance();
			return true;
		}
		if (ch === 118) {
			state.lastIntValue = 11;
			state.advance();
			return true;
		}
		if (ch === 102) {
			state.lastIntValue = 12;
			state.advance();
			return true;
		}
		if (ch === 114) {
			state.lastIntValue = 13;
			state.advance();
			return true;
		}
		return false;
	};
	pp$1.regexp_eatControlLetter = function(state) {
		var ch = state.current();
		if (isControlLetter(ch)) {
			state.lastIntValue = ch % 32;
			state.advance();
			return true;
		}
		return false;
	};
	function isControlLetter(ch) {
		return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
	}
	pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
		if (forceU === void 0) forceU = false;
		var start = state.pos;
		var switchU = forceU || state.switchU;
		if (state.eat(117)) {
			if (this.regexp_eatFixedHexDigits(state, 4)) {
				var lead = state.lastIntValue;
				if (switchU && lead >= 55296 && lead <= 56319) {
					var leadSurrogateEnd = state.pos;
					if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
						var trail = state.lastIntValue;
						if (trail >= 56320 && trail <= 57343) {
							state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
							return true;
						}
					}
					state.pos = leadSurrogateEnd;
					state.lastIntValue = lead;
				}
				return true;
			}
			if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) return true;
			if (switchU) state.raise("Invalid unicode escape");
			state.pos = start;
		}
		return false;
	};
	function isValidUnicode(ch) {
		return ch >= 0 && ch <= 1114111;
	}
	pp$1.regexp_eatIdentityEscape = function(state) {
		if (state.switchU) {
			if (this.regexp_eatSyntaxCharacter(state)) return true;
			if (state.eat(47)) {
				state.lastIntValue = 47;
				return true;
			}
			return false;
		}
		var ch = state.current();
		if (ch !== 99 && (!state.switchN || ch !== 107)) {
			state.lastIntValue = ch;
			state.advance();
			return true;
		}
		return false;
	};
	pp$1.regexp_eatDecimalEscape = function(state) {
		state.lastIntValue = 0;
		var ch = state.current();
		if (ch >= 49 && ch <= 57) {
			do {
				state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
				state.advance();
			} while ((ch = state.current()) >= 48 && ch <= 57);
			return true;
		}
		return false;
	};
	var CharSetNone = 0;
	var CharSetOk = 1;
	var CharSetString = 2;
	pp$1.regexp_eatCharacterClassEscape = function(state) {
		var ch = state.current();
		if (isCharacterClassEscape(ch)) {
			state.lastIntValue = -1;
			state.advance();
			return CharSetOk;
		}
		var negate = false;
		if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
			state.lastIntValue = -1;
			state.advance();
			var result;
			if (state.eat(123) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(125)) {
				if (negate && result === CharSetString) state.raise("Invalid property name");
				return result;
			}
			state.raise("Invalid property name");
		}
		return CharSetNone;
	};
	function isCharacterClassEscape(ch) {
		return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
	}
	pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
		var start = state.pos;
		if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
			var name = state.lastStringValue;
			if (this.regexp_eatUnicodePropertyValue(state)) {
				var value = state.lastStringValue;
				this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
				return CharSetOk;
			}
		}
		state.pos = start;
		if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
			var nameOrValue = state.lastStringValue;
			return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
		}
		return CharSetNone;
	};
	pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
		if (!hasOwn(state.unicodeProperties.nonBinary, name)) state.raise("Invalid property name");
		if (!state.unicodeProperties.nonBinary[name].test(value)) state.raise("Invalid property value");
	};
	pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
		if (state.unicodeProperties.binary.test(nameOrValue)) return CharSetOk;
		if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) return CharSetString;
		state.raise("Invalid property name");
	};
	pp$1.regexp_eatUnicodePropertyName = function(state) {
		var ch = 0;
		state.lastStringValue = "";
		while (isUnicodePropertyNameCharacter(ch = state.current())) {
			state.lastStringValue += codePointToString(ch);
			state.advance();
		}
		return state.lastStringValue !== "";
	};
	function isUnicodePropertyNameCharacter(ch) {
		return isControlLetter(ch) || ch === 95;
	}
	pp$1.regexp_eatUnicodePropertyValue = function(state) {
		var ch = 0;
		state.lastStringValue = "";
		while (isUnicodePropertyValueCharacter(ch = state.current())) {
			state.lastStringValue += codePointToString(ch);
			state.advance();
		}
		return state.lastStringValue !== "";
	};
	function isUnicodePropertyValueCharacter(ch) {
		return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
	}
	pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
		return this.regexp_eatUnicodePropertyValue(state);
	};
	pp$1.regexp_eatCharacterClass = function(state) {
		if (state.eat(91)) {
			var negate = state.eat(94);
			var result = this.regexp_classContents(state);
			if (!state.eat(93)) state.raise("Unterminated character class");
			if (negate && result === CharSetString) state.raise("Negated character class may contain strings");
			return true;
		}
		return false;
	};
	pp$1.regexp_classContents = function(state) {
		if (state.current() === 93) return CharSetOk;
		if (state.switchV) return this.regexp_classSetExpression(state);
		this.regexp_nonEmptyClassRanges(state);
		return CharSetOk;
	};
	pp$1.regexp_nonEmptyClassRanges = function(state) {
		while (this.regexp_eatClassAtom(state)) {
			var left = state.lastIntValue;
			if (state.eat(45) && this.regexp_eatClassAtom(state)) {
				var right = state.lastIntValue;
				if (state.switchU && (left === -1 || right === -1)) state.raise("Invalid character class");
				if (left !== -1 && right !== -1 && left > right) state.raise("Range out of order in character class");
			}
		}
	};
	pp$1.regexp_eatClassAtom = function(state) {
		var start = state.pos;
		if (state.eat(92)) {
			if (this.regexp_eatClassEscape(state)) return true;
			if (state.switchU) {
				var ch$1 = state.current();
				if (ch$1 === 99 || isOctalDigit(ch$1)) state.raise("Invalid class escape");
				state.raise("Invalid escape");
			}
			state.pos = start;
		}
		var ch = state.current();
		if (ch !== 93) {
			state.lastIntValue = ch;
			state.advance();
			return true;
		}
		return false;
	};
	pp$1.regexp_eatClassEscape = function(state) {
		var start = state.pos;
		if (state.eat(98)) {
			state.lastIntValue = 8;
			return true;
		}
		if (state.switchU && state.eat(45)) {
			state.lastIntValue = 45;
			return true;
		}
		if (!state.switchU && state.eat(99)) {
			if (this.regexp_eatClassControlLetter(state)) return true;
			state.pos = start;
		}
		return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
	};
	pp$1.regexp_classSetExpression = function(state) {
		var result = CharSetOk, subResult;
		if (this.regexp_eatClassSetRange(state));
		else if (subResult = this.regexp_eatClassSetOperand(state)) {
			if (subResult === CharSetString) result = CharSetString;
			var start = state.pos;
			while (state.eatChars([38, 38])) {
				if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
					if (subResult !== CharSetString) result = CharSetOk;
					continue;
				}
				state.raise("Invalid character in character class");
			}
			if (start !== state.pos) return result;
			while (state.eatChars([45, 45])) {
				if (this.regexp_eatClassSetOperand(state)) continue;
				state.raise("Invalid character in character class");
			}
			if (start !== state.pos) return result;
		} else state.raise("Invalid character in character class");
		for (;;) {
			if (this.regexp_eatClassSetRange(state)) continue;
			subResult = this.regexp_eatClassSetOperand(state);
			if (!subResult) return result;
			if (subResult === CharSetString) result = CharSetString;
		}
	};
	pp$1.regexp_eatClassSetRange = function(state) {
		var start = state.pos;
		if (this.regexp_eatClassSetCharacter(state)) {
			var left = state.lastIntValue;
			if (state.eat(45) && this.regexp_eatClassSetCharacter(state)) {
				var right = state.lastIntValue;
				if (left !== -1 && right !== -1 && left > right) state.raise("Range out of order in character class");
				return true;
			}
			state.pos = start;
		}
		return false;
	};
	pp$1.regexp_eatClassSetOperand = function(state) {
		if (this.regexp_eatClassSetCharacter(state)) return CharSetOk;
		return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
	};
	pp$1.regexp_eatNestedClass = function(state) {
		var start = state.pos;
		if (state.eat(91)) {
			var negate = state.eat(94);
			var result = this.regexp_classContents(state);
			if (state.eat(93)) {
				if (negate && result === CharSetString) state.raise("Negated character class may contain strings");
				return result;
			}
			state.pos = start;
		}
		if (state.eat(92)) {
			var result$1 = this.regexp_eatCharacterClassEscape(state);
			if (result$1) return result$1;
			state.pos = start;
		}
		return null;
	};
	pp$1.regexp_eatClassStringDisjunction = function(state) {
		var start = state.pos;
		if (state.eatChars([92, 113])) {
			if (state.eat(123)) {
				var result = this.regexp_classStringDisjunctionContents(state);
				if (state.eat(125)) return result;
			} else state.raise("Invalid escape");
			state.pos = start;
		}
		return null;
	};
	pp$1.regexp_classStringDisjunctionContents = function(state) {
		var result = this.regexp_classString(state);
		while (state.eat(124)) if (this.regexp_classString(state) === CharSetString) result = CharSetString;
		return result;
	};
	pp$1.regexp_classString = function(state) {
		var count = 0;
		while (this.regexp_eatClassSetCharacter(state)) count++;
		return count === 1 ? CharSetOk : CharSetString;
	};
	pp$1.regexp_eatClassSetCharacter = function(state) {
		var start = state.pos;
		if (state.eat(92)) {
			if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) return true;
			if (state.eat(98)) {
				state.lastIntValue = 8;
				return true;
			}
			state.pos = start;
			return false;
		}
		var ch = state.current();
		if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) return false;
		if (isClassSetSyntaxCharacter(ch)) return false;
		state.advance();
		state.lastIntValue = ch;
		return true;
	};
	function isClassSetReservedDoublePunctuatorCharacter(ch) {
		return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
	}
	function isClassSetSyntaxCharacter(ch) {
		return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
	}
	pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
		var ch = state.current();
		if (isClassSetReservedPunctuator(ch)) {
			state.lastIntValue = ch;
			state.advance();
			return true;
		}
		return false;
	};
	function isClassSetReservedPunctuator(ch) {
		return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
	}
	pp$1.regexp_eatClassControlLetter = function(state) {
		var ch = state.current();
		if (isDecimalDigit(ch) || ch === 95) {
			state.lastIntValue = ch % 32;
			state.advance();
			return true;
		}
		return false;
	};
	pp$1.regexp_eatHexEscapeSequence = function(state) {
		var start = state.pos;
		if (state.eat(120)) {
			if (this.regexp_eatFixedHexDigits(state, 2)) return true;
			if (state.switchU) state.raise("Invalid escape");
			state.pos = start;
		}
		return false;
	};
	pp$1.regexp_eatDecimalDigits = function(state) {
		var start = state.pos;
		var ch = 0;
		state.lastIntValue = 0;
		while (isDecimalDigit(ch = state.current())) {
			state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
			state.advance();
		}
		return state.pos !== start;
	};
	function isDecimalDigit(ch) {
		return ch >= 48 && ch <= 57;
	}
	pp$1.regexp_eatHexDigits = function(state) {
		var start = state.pos;
		var ch = 0;
		state.lastIntValue = 0;
		while (isHexDigit(ch = state.current())) {
			state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
			state.advance();
		}
		return state.pos !== start;
	};
	function isHexDigit(ch) {
		return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
	}
	function hexToInt(ch) {
		if (ch >= 65 && ch <= 70) return 10 + (ch - 65);
		if (ch >= 97 && ch <= 102) return 10 + (ch - 97);
		return ch - 48;
	}
	pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
		if (this.regexp_eatOctalDigit(state)) {
			var n1 = state.lastIntValue;
			if (this.regexp_eatOctalDigit(state)) {
				var n2 = state.lastIntValue;
				if (n1 <= 3 && this.regexp_eatOctalDigit(state)) state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
				else state.lastIntValue = n1 * 8 + n2;
			} else state.lastIntValue = n1;
			return true;
		}
		return false;
	};
	pp$1.regexp_eatOctalDigit = function(state) {
		var ch = state.current();
		if (isOctalDigit(ch)) {
			state.lastIntValue = ch - 48;
			state.advance();
			return true;
		}
		state.lastIntValue = 0;
		return false;
	};
	function isOctalDigit(ch) {
		return ch >= 48 && ch <= 55;
	}
	pp$1.regexp_eatFixedHexDigits = function(state, length) {
		var start = state.pos;
		state.lastIntValue = 0;
		for (var i$1 = 0; i$1 < length; ++i$1) {
			var ch = state.current();
			if (!isHexDigit(ch)) {
				state.pos = start;
				return false;
			}
			state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
			state.advance();
		}
		return true;
	};
	var Token = function Token$1(p$1) {
		this.type = p$1.type;
		this.value = p$1.value;
		this.start = p$1.start;
		this.end = p$1.end;
		if (p$1.options.locations) this.loc = new SourceLocation(p$1, p$1.startLoc, p$1.endLoc);
		if (p$1.options.ranges) this.range = [p$1.start, p$1.end];
	};
	var pp = Parser.prototype;
	pp.next = function(ignoreEscapeSequenceInKeyword) {
		if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
		if (this.options.onToken) this.options.onToken(new Token(this));
		this.lastTokEnd = this.end;
		this.lastTokStart = this.start;
		this.lastTokEndLoc = this.endLoc;
		this.lastTokStartLoc = this.startLoc;
		this.nextToken();
	};
	pp.getToken = function() {
		this.next();
		return new Token(this);
	};
	if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function() {
		var this$1$1 = this;
		return { next: function() {
			var token = this$1$1.getToken();
			return {
				done: token.type === types$1.eof,
				value: token
			};
		} };
	};
	pp.nextToken = function() {
		var curContext = this.curContext();
		if (!curContext || !curContext.preserveSpace) this.skipSpace();
		this.start = this.pos;
		if (this.options.locations) this.startLoc = this.curPosition();
		if (this.pos >= this.input.length) return this.finishToken(types$1.eof);
		if (curContext.override) return curContext.override(this);
		else this.readToken(this.fullCharCodeAtPos());
	};
	pp.readToken = function(code) {
		if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) return this.readWord();
		return this.getTokenFromCode(code);
	};
	pp.fullCharCodeAtPos = function() {
		var code = this.input.charCodeAt(this.pos);
		if (code <= 55295 || code >= 56320) return code;
		var next = this.input.charCodeAt(this.pos + 1);
		return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
	};
	pp.skipBlockComment = function() {
		var startLoc = this.options.onComment && this.curPosition();
		var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
		if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
		this.pos = end + 2;
		if (this.options.locations) for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
			++this.curLine;
			pos = this.lineStart = nextBreak;
		}
		if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
	};
	pp.skipLineComment = function(startSkip) {
		var start = this.pos;
		var startLoc = this.options.onComment && this.curPosition();
		var ch = this.input.charCodeAt(this.pos += startSkip);
		while (this.pos < this.input.length && !isNewLine(ch)) ch = this.input.charCodeAt(++this.pos);
		if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
	};
	pp.skipSpace = function() {
		loop: while (this.pos < this.input.length) {
			var ch = this.input.charCodeAt(this.pos);
			switch (ch) {
				case 32:
				case 160:
					++this.pos;
					break;
				case 13: if (this.input.charCodeAt(this.pos + 1) === 10) ++this.pos;
				case 10:
				case 8232:
				case 8233:
					++this.pos;
					if (this.options.locations) {
						++this.curLine;
						this.lineStart = this.pos;
					}
					break;
				case 47:
					switch (this.input.charCodeAt(this.pos + 1)) {
						case 42:
							this.skipBlockComment();
							break;
						case 47:
							this.skipLineComment(2);
							break;
						default: break loop;
					}
					break;
				default: if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) ++this.pos;
				else break loop;
			}
		}
	};
	pp.finishToken = function(type$2, val$1) {
		this.end = this.pos;
		if (this.options.locations) this.endLoc = this.curPosition();
		var prevType = this.type;
		this.type = type$2;
		this.value = val$1;
		this.updateContext(prevType);
	};
	pp.readToken_dot = function() {
		var next = this.input.charCodeAt(this.pos + 1);
		if (next >= 48 && next <= 57) return this.readNumber(true);
		var next2 = this.input.charCodeAt(this.pos + 2);
		if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
			this.pos += 3;
			return this.finishToken(types$1.ellipsis);
		} else {
			++this.pos;
			return this.finishToken(types$1.dot);
		}
	};
	pp.readToken_slash = function() {
		var next = this.input.charCodeAt(this.pos + 1);
		if (this.exprAllowed) {
			++this.pos;
			return this.readRegexp();
		}
		if (next === 61) return this.finishOp(types$1.assign, 2);
		return this.finishOp(types$1.slash, 1);
	};
	pp.readToken_mult_modulo_exp = function(code) {
		var next = this.input.charCodeAt(this.pos + 1);
		var size = 1;
		var tokentype = code === 42 ? types$1.star : types$1.modulo;
		if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
			++size;
			tokentype = types$1.starstar;
			next = this.input.charCodeAt(this.pos + 2);
		}
		if (next === 61) return this.finishOp(types$1.assign, size + 1);
		return this.finishOp(tokentype, size);
	};
	pp.readToken_pipe_amp = function(code) {
		var next = this.input.charCodeAt(this.pos + 1);
		if (next === code) {
			if (this.options.ecmaVersion >= 12) {
				if (this.input.charCodeAt(this.pos + 2) === 61) return this.finishOp(types$1.assign, 3);
			}
			return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
		}
		if (next === 61) return this.finishOp(types$1.assign, 2);
		return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
	};
	pp.readToken_caret = function() {
		if (this.input.charCodeAt(this.pos + 1) === 61) return this.finishOp(types$1.assign, 2);
		return this.finishOp(types$1.bitwiseXOR, 1);
	};
	pp.readToken_plus_min = function(code) {
		var next = this.input.charCodeAt(this.pos + 1);
		if (next === code) {
			if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
				this.skipLineComment(3);
				this.skipSpace();
				return this.nextToken();
			}
			return this.finishOp(types$1.incDec, 2);
		}
		if (next === 61) return this.finishOp(types$1.assign, 2);
		return this.finishOp(types$1.plusMin, 1);
	};
	pp.readToken_lt_gt = function(code) {
		var next = this.input.charCodeAt(this.pos + 1);
		var size = 1;
		if (next === code) {
			size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
			if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(types$1.assign, size + 1);
			return this.finishOp(types$1.bitShift, size);
		}
		if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
			this.skipLineComment(4);
			this.skipSpace();
			return this.nextToken();
		}
		if (next === 61) size = 2;
		return this.finishOp(types$1.relational, size);
	};
	pp.readToken_eq_excl = function(code) {
		var next = this.input.charCodeAt(this.pos + 1);
		if (next === 61) return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
		if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
			this.pos += 2;
			return this.finishToken(types$1.arrow);
		}
		return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
	};
	pp.readToken_question = function() {
		var ecmaVersion$1 = this.options.ecmaVersion;
		if (ecmaVersion$1 >= 11) {
			var next = this.input.charCodeAt(this.pos + 1);
			if (next === 46) {
				var next2 = this.input.charCodeAt(this.pos + 2);
				if (next2 < 48 || next2 > 57) return this.finishOp(types$1.questionDot, 2);
			}
			if (next === 63) {
				if (ecmaVersion$1 >= 12) {
					if (this.input.charCodeAt(this.pos + 2) === 61) return this.finishOp(types$1.assign, 3);
				}
				return this.finishOp(types$1.coalesce, 2);
			}
		}
		return this.finishOp(types$1.question, 1);
	};
	pp.readToken_numberSign = function() {
		var ecmaVersion$1 = this.options.ecmaVersion;
		var code = 35;
		if (ecmaVersion$1 >= 13) {
			++this.pos;
			code = this.fullCharCodeAtPos();
			if (isIdentifierStart(code, true) || code === 92) return this.finishToken(types$1.privateId, this.readWord1());
		}
		this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
	};
	pp.getTokenFromCode = function(code) {
		switch (code) {
			case 46: return this.readToken_dot();
			case 40:
				++this.pos;
				return this.finishToken(types$1.parenL);
			case 41:
				++this.pos;
				return this.finishToken(types$1.parenR);
			case 59:
				++this.pos;
				return this.finishToken(types$1.semi);
			case 44:
				++this.pos;
				return this.finishToken(types$1.comma);
			case 91:
				++this.pos;
				return this.finishToken(types$1.bracketL);
			case 93:
				++this.pos;
				return this.finishToken(types$1.bracketR);
			case 123:
				++this.pos;
				return this.finishToken(types$1.braceL);
			case 125:
				++this.pos;
				return this.finishToken(types$1.braceR);
			case 58:
				++this.pos;
				return this.finishToken(types$1.colon);
			case 96:
				if (this.options.ecmaVersion < 6) break;
				++this.pos;
				return this.finishToken(types$1.backQuote);
			case 48:
				var next = this.input.charCodeAt(this.pos + 1);
				if (next === 120 || next === 88) return this.readRadixNumber(16);
				if (this.options.ecmaVersion >= 6) {
					if (next === 111 || next === 79) return this.readRadixNumber(8);
					if (next === 98 || next === 66) return this.readRadixNumber(2);
				}
			case 49:
			case 50:
			case 51:
			case 52:
			case 53:
			case 54:
			case 55:
			case 56:
			case 57: return this.readNumber(false);
			case 34:
			case 39: return this.readString(code);
			case 47: return this.readToken_slash();
			case 37:
			case 42: return this.readToken_mult_modulo_exp(code);
			case 124:
			case 38: return this.readToken_pipe_amp(code);
			case 94: return this.readToken_caret();
			case 43:
			case 45: return this.readToken_plus_min(code);
			case 60:
			case 62: return this.readToken_lt_gt(code);
			case 61:
			case 33: return this.readToken_eq_excl(code);
			case 63: return this.readToken_question();
			case 126: return this.finishOp(types$1.prefix, 1);
			case 35: return this.readToken_numberSign();
		}
		this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
	};
	pp.finishOp = function(type$2, size) {
		var str = this.input.slice(this.pos, this.pos + size);
		this.pos += size;
		return this.finishToken(type$2, str);
	};
	pp.readRegexp = function() {
		var escaped, inClass, start = this.pos;
		for (;;) {
			if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
			var ch = this.input.charAt(this.pos);
			if (lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
			if (!escaped) {
				if (ch === "[") inClass = true;
				else if (ch === "]" && inClass) inClass = false;
				else if (ch === "/" && !inClass) break;
				escaped = ch === "\\";
			} else escaped = false;
			++this.pos;
		}
		var pattern = this.input.slice(start, this.pos);
		++this.pos;
		var flagsStart = this.pos;
		var flags = this.readWord1();
		if (this.containsEsc) this.unexpected(flagsStart);
		var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
		state.reset(start, pattern, flags);
		this.validateRegExpFlags(state);
		this.validateRegExpPattern(state);
		var value = null;
		try {
			value = new RegExp(pattern, flags);
		} catch (e$1) {}
		return this.finishToken(types$1.regexp, {
			pattern,
			flags,
			value
		});
	};
	pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
		var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
		var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
		var start = this.pos, total = 0, lastCode = 0;
		for (var i$1 = 0, e$1 = len == null ? Infinity : len; i$1 < e$1; ++i$1, ++this.pos) {
			var code = this.input.charCodeAt(this.pos), val$1 = void 0;
			if (allowSeparators && code === 95) {
				if (isLegacyOctalNumericLiteral) this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
				if (lastCode === 95) this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
				if (i$1 === 0) this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
				lastCode = code;
				continue;
			}
			if (code >= 97) val$1 = code - 97 + 10;
			else if (code >= 65) val$1 = code - 65 + 10;
			else if (code >= 48 && code <= 57) val$1 = code - 48;
			else val$1 = Infinity;
			if (val$1 >= radix) break;
			lastCode = code;
			total = total * radix + val$1;
		}
		if (allowSeparators && lastCode === 95) this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
		if (this.pos === start || len != null && this.pos - start !== len) return null;
		return total;
	};
	function stringToNumber(str, isLegacyOctalNumericLiteral) {
		if (isLegacyOctalNumericLiteral) return parseInt(str, 8);
		return parseFloat(str.replace(/_/g, ""));
	}
	function stringToBigInt(str) {
		if (typeof BigInt !== "function") return null;
		return BigInt(str.replace(/_/g, ""));
	}
	pp.readRadixNumber = function(radix) {
		var start = this.pos;
		this.pos += 2;
		var val$1 = this.readInt(radix);
		if (val$1 == null) this.raise(this.start + 2, "Expected number in radix " + radix);
		if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
			val$1 = stringToBigInt(this.input.slice(start, this.pos));
			++this.pos;
		} else if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
		return this.finishToken(types$1.num, val$1);
	};
	pp.readNumber = function(startsWithDot) {
		var start = this.pos;
		if (!startsWithDot && this.readInt(10, void 0, true) === null) this.raise(start, "Invalid number");
		var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
		if (octal && this.strict) this.raise(start, "Invalid number");
		var next = this.input.charCodeAt(this.pos);
		if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
			var val$1 = stringToBigInt(this.input.slice(start, this.pos));
			++this.pos;
			if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
			return this.finishToken(types$1.num, val$1);
		}
		if (octal && /[89]/.test(this.input.slice(start, this.pos))) octal = false;
		if (next === 46 && !octal) {
			++this.pos;
			this.readInt(10);
			next = this.input.charCodeAt(this.pos);
		}
		if ((next === 69 || next === 101) && !octal) {
			next = this.input.charCodeAt(++this.pos);
			if (next === 43 || next === 45) ++this.pos;
			if (this.readInt(10) === null) this.raise(start, "Invalid number");
		}
		if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
		var val$2 = stringToNumber(this.input.slice(start, this.pos), octal);
		return this.finishToken(types$1.num, val$2);
	};
	pp.readCodePoint = function() {
		var ch = this.input.charCodeAt(this.pos), code;
		if (ch === 123) {
			if (this.options.ecmaVersion < 6) this.unexpected();
			var codePos = ++this.pos;
			code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
			++this.pos;
			if (code > 1114111) this.invalidStringToken(codePos, "Code point out of bounds");
		} else code = this.readHexChar(4);
		return code;
	};
	pp.readString = function(quote) {
		var out = "", chunkStart = ++this.pos;
		for (;;) {
			if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
			var ch = this.input.charCodeAt(this.pos);
			if (ch === quote) break;
			if (ch === 92) {
				out += this.input.slice(chunkStart, this.pos);
				out += this.readEscapedChar(false);
				chunkStart = this.pos;
			} else if (ch === 8232 || ch === 8233) {
				if (this.options.ecmaVersion < 10) this.raise(this.start, "Unterminated string constant");
				++this.pos;
				if (this.options.locations) {
					this.curLine++;
					this.lineStart = this.pos;
				}
			} else {
				if (isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
				++this.pos;
			}
		}
		out += this.input.slice(chunkStart, this.pos++);
		return this.finishToken(types$1.string, out);
	};
	var INVALID_TEMPLATE_ESCAPE_ERROR = {};
	pp.tryReadTemplateToken = function() {
		this.inTemplateElement = true;
		try {
			this.readTmplToken();
		} catch (err$1) {
			if (err$1 === INVALID_TEMPLATE_ESCAPE_ERROR) this.readInvalidTemplateToken();
			else throw err$1;
		}
		this.inTemplateElement = false;
	};
	pp.invalidStringToken = function(position, message) {
		if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw INVALID_TEMPLATE_ESCAPE_ERROR;
		else this.raise(position, message);
	};
	pp.readTmplToken = function() {
		var out = "", chunkStart = this.pos;
		for (;;) {
			if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
			var ch = this.input.charCodeAt(this.pos);
			if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
				if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) if (ch === 36) {
					this.pos += 2;
					return this.finishToken(types$1.dollarBraceL);
				} else {
					++this.pos;
					return this.finishToken(types$1.backQuote);
				}
				out += this.input.slice(chunkStart, this.pos);
				return this.finishToken(types$1.template, out);
			}
			if (ch === 92) {
				out += this.input.slice(chunkStart, this.pos);
				out += this.readEscapedChar(true);
				chunkStart = this.pos;
			} else if (isNewLine(ch)) {
				out += this.input.slice(chunkStart, this.pos);
				++this.pos;
				switch (ch) {
					case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
					case 10:
						out += "\n";
						break;
					default:
						out += String.fromCharCode(ch);
						break;
				}
				if (this.options.locations) {
					++this.curLine;
					this.lineStart = this.pos;
				}
				chunkStart = this.pos;
			} else ++this.pos;
		}
	};
	pp.readInvalidTemplateToken = function() {
		for (; this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
			case "\\":
				++this.pos;
				break;
			case "$": if (this.input[this.pos + 1] !== "{") break;
			case "`": return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
			case "\r": if (this.input[this.pos + 1] === "\n") ++this.pos;
			case "\n":
			case "\u2028":
			case "\u2029":
				++this.curLine;
				this.lineStart = this.pos + 1;
				break;
		}
		this.raise(this.start, "Unterminated template");
	};
	pp.readEscapedChar = function(inTemplate) {
		var ch = this.input.charCodeAt(++this.pos);
		++this.pos;
		switch (ch) {
			case 110: return "\n";
			case 114: return "\r";
			case 120: return String.fromCharCode(this.readHexChar(2));
			case 117: return codePointToString(this.readCodePoint());
			case 116: return "	";
			case 98: return "\b";
			case 118: return "\v";
			case 102: return "\f";
			case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
			case 10:
				if (this.options.locations) {
					this.lineStart = this.pos;
					++this.curLine;
				}
				return "";
			case 56:
			case 57:
				if (this.strict) this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
				if (inTemplate) {
					var codePos = this.pos - 1;
					this.invalidStringToken(codePos, "Invalid escape sequence in template string");
				}
			default:
				if (ch >= 48 && ch <= 55) {
					var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
					var octal = parseInt(octalStr, 8);
					if (octal > 255) {
						octalStr = octalStr.slice(0, -1);
						octal = parseInt(octalStr, 8);
					}
					this.pos += octalStr.length - 1;
					ch = this.input.charCodeAt(this.pos);
					if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
					return String.fromCharCode(octal);
				}
				if (isNewLine(ch)) {
					if (this.options.locations) {
						this.lineStart = this.pos;
						++this.curLine;
					}
					return "";
				}
				return String.fromCharCode(ch);
		}
	};
	pp.readHexChar = function(len) {
		var codePos = this.pos;
		var n$2 = this.readInt(16, len);
		if (n$2 === null) this.invalidStringToken(codePos, "Bad character escape sequence");
		return n$2;
	};
	pp.readWord1 = function() {
		this.containsEsc = false;
		var word = "", first = true, chunkStart = this.pos;
		var astral = this.options.ecmaVersion >= 6;
		while (this.pos < this.input.length) {
			var ch = this.fullCharCodeAtPos();
			if (isIdentifierChar(ch, astral)) this.pos += ch <= 65535 ? 1 : 2;
			else if (ch === 92) {
				this.containsEsc = true;
				word += this.input.slice(chunkStart, this.pos);
				var escStart = this.pos;
				if (this.input.charCodeAt(++this.pos) !== 117) this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
				++this.pos;
				var esc$1 = this.readCodePoint();
				if (!(first ? isIdentifierStart : isIdentifierChar)(esc$1, astral)) this.invalidStringToken(escStart, "Invalid Unicode escape");
				word += codePointToString(esc$1);
				chunkStart = this.pos;
			} else break;
			first = false;
		}
		return word + this.input.slice(chunkStart, this.pos);
	};
	pp.readWord = function() {
		var word = this.readWord1();
		var type$2 = types$1.name;
		if (this.keywords.test(word)) type$2 = keywords[word];
		return this.finishToken(type$2, word);
	};
	Parser.acorn = {
		Parser,
		version: "8.15.0",
		defaultOptions,
		Position,
		SourceLocation,
		getLineInfo,
		Node,
		TokenType,
		tokTypes: types$1,
		keywordTypes: keywords,
		TokContext,
		tokContexts: types,
		isIdentifierChar,
		isIdentifierStart,
		Token,
		isNewLine,
		lineBreak,
		lineBreakG,
		nonASCIIwhitespace
	};
	function parse(input, options$1) {
		return Parser.parse(input, options$1);
	}
	function simple(node, visitors, baseVisitor, state, override) {
		if (!baseVisitor) baseVisitor = base;
		(function c(node$1, st, override$1) {
			var type$2 = override$1 || node$1.type;
			baseVisitor[type$2](node$1, st, c);
			if (visitors[type$2]) visitors[type$2](node$1, st);
		})(node, state, override);
	}
	function ancestor(node, visitors, baseVisitor, state, override) {
		var ancestors = [];
		if (!baseVisitor) baseVisitor = base;
		(function c(node$1, st, override$1) {
			var type$2 = override$1 || node$1.type;
			var isNew = node$1 !== ancestors[ancestors.length - 1];
			if (isNew) ancestors.push(node$1);
			baseVisitor[type$2](node$1, st, c);
			if (visitors[type$2]) visitors[type$2](node$1, st || ancestors, ancestors);
			if (isNew) ancestors.pop();
		})(node, state, override);
	}
	function skipThrough(node, st, c) {
		c(node, st);
	}
	function ignore(_node, _st, _c) {}
	var base = {};
	base.Program = base.BlockStatement = base.StaticBlock = function(node, st, c) {
		for (var i$1 = 0, list$1 = node.body; i$1 < list$1.length; i$1 += 1) {
			var stmt = list$1[i$1];
			c(stmt, st, "Statement");
		}
	};
	base.Statement = skipThrough;
	base.EmptyStatement = ignore;
	base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression = function(node, st, c) {
		return c(node.expression, st, "Expression");
	};
	base.IfStatement = function(node, st, c) {
		c(node.test, st, "Expression");
		c(node.consequent, st, "Statement");
		if (node.alternate) c(node.alternate, st, "Statement");
	};
	base.LabeledStatement = function(node, st, c) {
		return c(node.body, st, "Statement");
	};
	base.BreakStatement = base.ContinueStatement = ignore;
	base.WithStatement = function(node, st, c) {
		c(node.object, st, "Expression");
		c(node.body, st, "Statement");
	};
	base.SwitchStatement = function(node, st, c) {
		c(node.discriminant, st, "Expression");
		for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {
			var cs = list$1[i$1];
			c(cs, st);
		}
	};
	base.SwitchCase = function(node, st, c) {
		if (node.test) c(node.test, st, "Expression");
		for (var i$1 = 0, list$1 = node.consequent; i$1 < list$1.length; i$1 += 1) {
			var cons = list$1[i$1];
			c(cons, st, "Statement");
		}
	};
	base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function(node, st, c) {
		if (node.argument) c(node.argument, st, "Expression");
	};
	base.ThrowStatement = base.SpreadElement = function(node, st, c) {
		return c(node.argument, st, "Expression");
	};
	base.TryStatement = function(node, st, c) {
		c(node.block, st, "Statement");
		if (node.handler) c(node.handler, st);
		if (node.finalizer) c(node.finalizer, st, "Statement");
	};
	base.CatchClause = function(node, st, c) {
		if (node.param) c(node.param, st, "Pattern");
		c(node.body, st, "Statement");
	};
	base.WhileStatement = base.DoWhileStatement = function(node, st, c) {
		c(node.test, st, "Expression");
		c(node.body, st, "Statement");
	};
	base.ForStatement = function(node, st, c) {
		if (node.init) c(node.init, st, "ForInit");
		if (node.test) c(node.test, st, "Expression");
		if (node.update) c(node.update, st, "Expression");
		c(node.body, st, "Statement");
	};
	base.ForInStatement = base.ForOfStatement = function(node, st, c) {
		c(node.left, st, "ForInit");
		c(node.right, st, "Expression");
		c(node.body, st, "Statement");
	};
	base.ForInit = function(node, st, c) {
		if (node.type === "VariableDeclaration") c(node, st);
		else c(node, st, "Expression");
	};
	base.DebuggerStatement = ignore;
	base.FunctionDeclaration = function(node, st, c) {
		return c(node, st, "Function");
	};
	base.VariableDeclaration = function(node, st, c) {
		for (var i$1 = 0, list$1 = node.declarations; i$1 < list$1.length; i$1 += 1) {
			var decl = list$1[i$1];
			c(decl, st);
		}
	};
	base.VariableDeclarator = function(node, st, c) {
		c(node.id, st, "Pattern");
		if (node.init) c(node.init, st, "Expression");
	};
	base.Function = function(node, st, c) {
		if (node.id) c(node.id, st, "Pattern");
		for (var i$1 = 0, list$1 = node.params; i$1 < list$1.length; i$1 += 1) {
			var param = list$1[i$1];
			c(param, st, "Pattern");
		}
		c(node.body, st, node.expression ? "Expression" : "Statement");
	};
	base.Pattern = function(node, st, c) {
		if (node.type === "Identifier") c(node, st, "VariablePattern");
		else if (node.type === "MemberExpression") c(node, st, "MemberPattern");
		else c(node, st);
	};
	base.VariablePattern = ignore;
	base.MemberPattern = skipThrough;
	base.RestElement = function(node, st, c) {
		return c(node.argument, st, "Pattern");
	};
	base.ArrayPattern = function(node, st, c) {
		for (var i$1 = 0, list$1 = node.elements; i$1 < list$1.length; i$1 += 1) {
			var elt = list$1[i$1];
			if (elt) c(elt, st, "Pattern");
		}
	};
	base.ObjectPattern = function(node, st, c) {
		for (var i$1 = 0, list$1 = node.properties; i$1 < list$1.length; i$1 += 1) {
			var prop = list$1[i$1];
			if (prop.type === "Property") {
				if (prop.computed) c(prop.key, st, "Expression");
				c(prop.value, st, "Pattern");
			} else if (prop.type === "RestElement") c(prop.argument, st, "Pattern");
		}
	};
	base.Expression = skipThrough;
	base.ThisExpression = base.Super = base.MetaProperty = ignore;
	base.ArrayExpression = function(node, st, c) {
		for (var i$1 = 0, list$1 = node.elements; i$1 < list$1.length; i$1 += 1) {
			var elt = list$1[i$1];
			if (elt) c(elt, st, "Expression");
		}
	};
	base.ObjectExpression = function(node, st, c) {
		for (var i$1 = 0, list$1 = node.properties; i$1 < list$1.length; i$1 += 1) {
			var prop = list$1[i$1];
			c(prop, st);
		}
	};
	base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
	base.SequenceExpression = function(node, st, c) {
		for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {
			var expr = list$1[i$1];
			c(expr, st, "Expression");
		}
	};
	base.TemplateLiteral = function(node, st, c) {
		for (var i$1 = 0, list$1 = node.quasis; i$1 < list$1.length; i$1 += 1) {
			var quasi = list$1[i$1];
			c(quasi, st);
		}
		for (var i$1$1 = 0, list$1$1 = node.expressions; i$1$1 < list$1$1.length; i$1$1 += 1) {
			var expr = list$1$1[i$1$1];
			c(expr, st, "Expression");
		}
	};
	base.TemplateElement = ignore;
	base.UnaryExpression = base.UpdateExpression = function(node, st, c) {
		c(node.argument, st, "Expression");
	};
	base.BinaryExpression = base.LogicalExpression = function(node, st, c) {
		c(node.left, st, "Expression");
		c(node.right, st, "Expression");
	};
	base.AssignmentExpression = base.AssignmentPattern = function(node, st, c) {
		c(node.left, st, "Pattern");
		c(node.right, st, "Expression");
	};
	base.ConditionalExpression = function(node, st, c) {
		c(node.test, st, "Expression");
		c(node.consequent, st, "Expression");
		c(node.alternate, st, "Expression");
	};
	base.NewExpression = base.CallExpression = function(node, st, c) {
		c(node.callee, st, "Expression");
		if (node.arguments) for (var i$1 = 0, list$1 = node.arguments; i$1 < list$1.length; i$1 += 1) {
			var arg = list$1[i$1];
			c(arg, st, "Expression");
		}
	};
	base.MemberExpression = function(node, st, c) {
		c(node.object, st, "Expression");
		if (node.computed) c(node.property, st, "Expression");
	};
	base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function(node, st, c) {
		if (node.declaration) c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
		if (node.source) c(node.source, st, "Expression");
	};
	base.ExportAllDeclaration = function(node, st, c) {
		if (node.exported) c(node.exported, st);
		c(node.source, st, "Expression");
	};
	base.ImportDeclaration = function(node, st, c) {
		for (var i$1 = 0, list$1 = node.specifiers; i$1 < list$1.length; i$1 += 1) {
			var spec = list$1[i$1];
			c(spec, st);
		}
		c(node.source, st, "Expression");
	};
	base.ImportExpression = function(node, st, c) {
		c(node.source, st, "Expression");
	};
	base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;
	base.TaggedTemplateExpression = function(node, st, c) {
		c(node.tag, st, "Expression");
		c(node.quasi, st, "Expression");
	};
	base.ClassDeclaration = base.ClassExpression = function(node, st, c) {
		return c(node, st, "Class");
	};
	base.Class = function(node, st, c) {
		if (node.id) c(node.id, st, "Pattern");
		if (node.superClass) c(node.superClass, st, "Expression");
		c(node.body, st);
	};
	base.ClassBody = function(node, st, c) {
		for (var i$1 = 0, list$1 = node.body; i$1 < list$1.length; i$1 += 1) {
			var elt = list$1[i$1];
			c(elt, st);
		}
	};
	base.MethodDefinition = base.PropertyDefinition = base.Property = function(node, st, c) {
		if (node.computed) c(node.key, st, "Expression");
		if (node.value) c(node.value, st, "Expression");
	};
	const ignoreFunction = [
		"setup",
		"draw",
		"preload",
		"deviceMoved",
		"deviceTurned",
		"deviceShaken",
		"doubleClicked",
		"mousePressed",
		"mouseReleased",
		"mouseMoved",
		"mouseDragged",
		"mouseClicked",
		"mouseWheel",
		"touchStarted",
		"touchMoved",
		"touchEnded",
		"keyPressed",
		"keyReleased",
		"keyTyped",
		"windowResized"
	];
	const verifierUtils = {
		fetchScript: async function(script) {
			if (script.src) try {
				return await fetch(script.src).then((res) => res.text());
			} catch (error$1) {
				console.error("Error fetching script:", error$1);
				return "";
			}
			else return script.textContent;
		},
		extractUserDefinedVariablesAndFuncs: function(code) {
			const userDefinitions = {
				variables: [],
				functions: []
			};
			const lineOffset = -1;
			try {
				simple(parse(code, {
					ecmaVersion: 2021,
					sourceType: "module",
					locations: true
				}), {
					VariableDeclarator(node) {
						if (node.id.type === "Identifier") userDefinitions[node.init && ["ArrowFunctionExpression", "FunctionExpression"].includes(node.init.type) ? "functions" : "variables"].push({
							name: node.id.name,
							line: node.loc.start.line + lineOffset
						});
					},
					FunctionDeclaration(node) {
						if (node.id && node.id.type === "Identifier") userDefinitions.functions.push({
							name: node.id.name,
							line: node.loc.start.line + lineOffset
						});
					},
					ClassDeclaration(node) {
						if (node.id && node.id.type === "Identifier") userDefinitions.variables.push({
							name: node.id.name,
							line: node.loc.start.line + lineOffset
						});
					}
				});
			} catch (error$1) {
				console.error("Error parsing code:", error$1);
			}
			return userDefinitions;
		},
		checkForConstsAndFuncs: function(userDefinitions, p5$2) {
			const allDefinitions = [...userDefinitions.variables, ...userDefinitions.functions];
			function generateFriendlyError(errorType, name, line) {
				const url = `https://p5js.org/reference/p5/${name}`;
				return `${errorType} "${name}" on line ${line} is being redeclared and conflicts with a p5.js ${errorType.toLowerCase()}. p5.js reference: ${url}`;
			}
			for (let { name, line } of allDefinitions) if (constants[name] !== void 0) {
				const message = generateFriendlyError("Constant", name, line);
				console.log(message);
				return true;
			}
			const globalFunctions = new Set(Object.getOwnPropertyNames(p5$2.prototype).filter((key) => !key.startsWith("_") && key !== "constructor"));
			for (let { name, line } of allDefinitions) if (!ignoreFunction.includes(name) && globalFunctions.has(name)) {
				const message = generateFriendlyError("Function", name, line);
				console.log(message);
				return true;
			}
			return false;
		},
		getUserCode: async function() {
			const scripts = document.querySelectorAll("script");
			const userCodeScript = scripts[scripts.length - 1];
			return await verifierUtils.fetchScript(userCodeScript);
		},
		runFES: async function(p5$2) {
			const userCode = await verifierUtils.getUserCode();
			const userDefinedVariablesAndFuncs = verifierUtils.extractUserDefinedVariablesAndFuncs(userCode);
			verifierUtils.checkForConstsAndFuncs(userDefinedVariablesAndFuncs, p5$2);
		}
	};
	function sketchVerifier(p5$2, _fn, lifecycles) {
		lifecycles.presetup = async function() {
			if (!p5$2.disableFriendlyErrors && !p5$2.disableSketchChecker) verifierUtils.runFES(p5$2);
		};
	}
	if (typeof p5 !== "undefined") sketchVerifier(p5, p5.prototype);
	function fileErrors(p5$2, fn$1) {
		const fileLoadErrorCases = (num, filePath) => {
			const suggestion = translator("fes.fileLoadError.suggestion", {
				filePath,
				url: "https://github.com/processing/p5.js/wiki/Local-server"
			});
			switch (num) {
				case 0: return {
					message: translator("fes.fileLoadError.image", { suggestion }),
					method: "loadImage"
				};
				case 1: return {
					message: translator("fes.fileLoadError.xml", { suggestion }),
					method: "loadXML"
				};
				case 2: return {
					message: translator("fes.fileLoadError.table", { suggestion }),
					method: "loadTable"
				};
				case 3: return {
					message: translator("fes.fileLoadError.strings", { suggestion }),
					method: "loadStrings"
				};
				case 4: return {
					message: translator("fes.fileLoadError.font", { suggestion }),
					method: "loadFont"
				};
				case 5: return {
					message: translator("fes.fileLoadError.json", { suggestion }),
					method: "loadJSON"
				};
				case 6: return {
					message: translator("fes.fileLoadError.bytes", { suggestion }),
					method: "loadBytes"
				};
				case 7: return {
					message: translator("fes.fileLoadError.large"),
					method: "loadX"
				};
				case 8: return {
					message: translator("fes.fileLoadError.gif"),
					method: "loadImage"
				};
			}
		};
		p5$2._friendlyFileLoadError = function(errorType, filePath) {
			const { message, method } = fileLoadErrorCases(errorType, filePath);
			p5$2._friendlyError(message, method, 3);
		};
	}
	if (typeof p5 !== "undefined") fileErrors(p5, p5.prototype);
	function friendlyErrors(p5$2) {
		p5$2.registerAddon(fesCore);
		p5$2.registerAddon(stacktrace);
		p5$2.registerAddon(validateParams);
		p5$2.registerAddon(sketchVerifier);
		p5$2.registerAddon(fileErrors);
	}
	function storage(p5$2, fn$1) {
		fn$1.storeItem = function(key, value) {
			if (typeof key !== "string") console.log(`The argument that you passed to storeItem() - ${key} is not a string.`);
			if (key.endsWith("p5TypeID")) console.log(`The argument that you passed to storeItem() - ${key} must not end with 'p5TypeID'.`);
			if (typeof value === "undefined") console.log("You cannot store undefined variables using storeItem().");
			let type$2 = typeof value;
			switch (type$2) {
				case "number":
				case "boolean":
					value = value.toString();
					break;
				case "object":
					if (value instanceof p5$2.Color) {
						type$2 = "p5.Color";
						value = value.toString();
					} else if (value instanceof p5$2.Vector) {
						type$2 = "p5.Vector";
						value = [
							value.x,
							value.y,
							value.z
						];
					}
					value = JSON.stringify(value);
					break;
			}
			localStorage.setItem(key, value);
			const typeKey = `${key}p5TypeID`;
			localStorage.setItem(typeKey, type$2);
		};
		fn$1.getItem = function(key) {
			let value = localStorage.getItem(key);
			const type$2 = localStorage.getItem(`${key}p5TypeID`);
			if (typeof type$2 === "undefined") console.log(`Unable to determine type of item stored under ${key}in local storage. Did you save the item with something other than setItem()?`);
			else if (value !== null) switch (type$2) {
				case "number":
					value = parseFloat(value);
					break;
				case "boolean":
					value = value === "true";
					break;
				case "object":
					value = JSON.parse(value);
					break;
				case "p5.Color":
					value = this.color(JSON.parse(value));
					break;
				case "p5.Vector":
					value = JSON.parse(value);
					value = this.createVector(...value);
					break;
			}
			return value;
		};
		fn$1.clearStorage = function() {
			Object.keys(localStorage).forEach((key) => {
				if (key.endsWith("p5TypeID")) this.removeItem(key.replace("p5TypeID", ""));
			});
		};
		fn$1.removeItem = function(key) {
			if (typeof key !== "string") console.log(`The argument that you passed to removeItem() - ${key} is not a string.`);
			localStorage.removeItem(key);
			localStorage.removeItem(`${key}p5TypeID`);
		};
	}
	if (typeof p5 !== "undefined") storage(p5, p5.prototype);
	function data(p5$2) {
		p5$2.registerAddon(storage);
	}
	function dom$1(p5$2, fn$1) {
		fn$1.select = function(e$1, p$1) {
			const res = this._getContainer(p$1).querySelector(e$1);
			if (res) return this._wrapElement(res);
			else return null;
		};
		fn$1.selectAll = function(e$1, p$1) {
			const arr$1 = [];
			const res = this._getContainer(p$1).querySelectorAll(e$1);
			if (res) for (let j = 0; j < res.length; j++) {
				const obj = this._wrapElement(res[j]);
				arr$1.push(obj);
			}
			return arr$1;
		};
		fn$1._getContainer = function(p$1) {
			let container = document;
			if (typeof p$1 === "string") container = document.querySelector(p$1) || document;
			else if (p$1 instanceof Element) container = p$1.elt;
			else if (p$1 instanceof HTMLElement) container = p$1;
			return container;
		};
		fn$1._wrapElement = function(elt) {
			const children = Array.prototype.slice.call(elt.children);
			if (elt.tagName === "INPUT" && elt.type === "checkbox") {
				let converted = new Element(elt, this);
				converted.checked = function(...args) {
					if (args.length === 0) return this.elt.checked;
					else if (args[0]) this.elt.checked = true;
					else this.elt.checked = false;
					return this;
				};
				return converted;
			} else if (elt.tagName === "VIDEO" || elt.tagName === "AUDIO") return new MediaElement(elt, this);
			else if (elt.tagName === "SELECT") return this.createSelect(new Element(elt, this));
			else if (children.length > 0 && children.every(function(c) {
				return c.tagName === "INPUT" || c.tagName === "LABEL";
			}) && (elt.tagName === "DIV" || elt.tagName === "SPAN")) return this.createRadio(new Element(elt, this));
			else return new Element(elt, this);
		};
		fn$1.createElement = function(tag, content) {
			const elt = document.createElement(tag);
			if (typeof content !== "undefined") elt.innerHTML = content;
			return addElement(elt, this);
		};
		fn$1.removeElements = function(e$1) {
			const isNotCanvasElement = (el) => !(el.elt instanceof HTMLCanvasElement);
			this._elements.filter(isNotCanvasElement).map((el) => el.remove());
		};
		function addElement(elt, pInst, media$1) {
			(pInst._userNode ? pInst._userNode : document.body).appendChild(elt);
			const c = media$1 ? new MediaElement(elt, pInst) : new Element(elt, pInst);
			pInst._elements.push(c);
			return c;
		}
		fn$1.createDiv = function(html = "") {
			let elt = document.createElement("div");
			elt.innerHTML = html;
			return addElement(elt, this);
		};
		fn$1.createP = function(html = "") {
			let elt = document.createElement("p");
			elt.innerHTML = html;
			return addElement(elt, this);
		};
		fn$1.createSpan = function(html = "") {
			let elt = document.createElement("span");
			elt.innerHTML = html;
			return addElement(elt, this);
		};
		fn$1.createImg = function() {
			const elt = document.createElement("img");
			const args = arguments;
			let self$1;
			if (args.length > 1 && typeof args[1] === "string") elt.alt = args[1];
			if (args.length > 2 && typeof args[2] === "string") elt.crossOrigin = args[2];
			elt.src = args[0];
			self$1 = addElement(elt, this);
			elt.addEventListener("load", function() {
				self$1.width = elt.offsetWidth || elt.width;
				self$1.height = elt.offsetHeight || elt.height;
				const last$1 = args[args.length - 1];
				if (typeof last$1 === "function") last$1(self$1);
			});
			return self$1;
		};
		fn$1.createA = function(href, html, target) {
			const elt = document.createElement("a");
			elt.href = href;
			elt.innerHTML = html;
			if (target) elt.target = target;
			return addElement(elt, this);
		};
		fn$1.createSlider = function(min, max, value, step) {
			const elt = document.createElement("input");
			elt.type = "range";
			elt.min = min;
			elt.max = max;
			if (step === 0) elt.step = 1e-18;
			else if (step) elt.step = step;
			if (typeof value === "number") elt.value = value;
			return addElement(elt, this);
		};
		fn$1.createButton = function(label, value) {
			const elt = document.createElement("button");
			elt.innerHTML = label;
			if (value) elt.value = value;
			return addElement(elt, this);
		};
		fn$1.createCheckbox = function(...args) {
			const elt = document.createElement("div");
			const checkbox = document.createElement("input");
			checkbox.type = "checkbox";
			const label = document.createElement("label");
			label.appendChild(checkbox);
			elt.appendChild(label);
			const self$1 = addElement(elt, this);
			self$1.checked = function(...args$1) {
				const cb = self$1.elt.firstElementChild.getElementsByTagName("input")[0];
				if (cb) if (args$1.length === 0) return cb.checked;
				else if (args$1[0]) cb.checked = true;
				else cb.checked = false;
				return self$1;
			};
			this.value = function(val$1) {
				self$1.value = val$1;
				return this;
			};
			if (args[0]) {
				self$1.value(args[0]);
				const span = document.createElement("span");
				span.innerHTML = args[0];
				label.appendChild(span);
			}
			if (args[1]) checkbox.checked = true;
			return self$1;
		};
		fn$1.createSelect = function(...args) {
			let self$1;
			let arg = args[0];
			if (arg instanceof Element && arg.elt instanceof HTMLSelectElement) {
				self$1 = arg;
				this.elt = arg.elt;
			} else if (arg instanceof HTMLSelectElement) {
				self$1 = addElement(arg, this);
				this.elt = arg;
			} else {
				const elt = document.createElement("select");
				if (arg && typeof arg === "boolean") elt.setAttribute("multiple", "true");
				self$1 = addElement(elt, this);
				this.elt = elt;
			}
			self$1.option = function(name, value) {
				let index;
				if (name === void 0) return;
				for (let i$1 = 0; i$1 < this.elt.length; i$1 += 1) if (this.elt[i$1].textContent === name) {
					index = i$1;
					break;
				}
				if (index !== void 0) if (value === false) this.elt.remove(index);
				else this.elt[index].value = value;
				else {
					const opt = document.createElement("option");
					opt.textContent = name;
					opt.value = value === void 0 ? name : value;
					this.elt.appendChild(opt);
					this._pInst._elements.push(opt);
				}
			};
			self$1.selected = function(value) {
				if (value !== void 0) {
					for (let i$1 = 0; i$1 < this.elt.length; i$1 += 1) if (this.elt[i$1].value.toString() === value.toString()) this.elt.selectedIndex = i$1;
					return this;
				} else if (this.elt.getAttribute("multiple")) {
					let arr$1 = [];
					for (const selectedOption of this.elt.selectedOptions) arr$1.push(selectedOption.value);
					return arr$1;
				} else return this.elt.value;
			};
			self$1.disable = function(value) {
				if (typeof value === "string") {
					for (let i$1 = 0; i$1 < this.elt.length; i$1++) if (this.elt[i$1].value.toString() === value) {
						this.elt[i$1].disabled = true;
						this.elt[i$1].selected = false;
					}
				} else this.elt.disabled = true;
				return this;
			};
			self$1.enable = function(value) {
				if (typeof value === "string") {
					for (let i$1 = 0; i$1 < this.elt.length; i$1++) if (this.elt[i$1].value.toString() === value) {
						this.elt[i$1].disabled = false;
						this.elt[i$1].selected = false;
					}
				} else {
					this.elt.disabled = false;
					for (let i$1 = 0; i$1 < this.elt.length; i$1++) {
						this.elt[i$1].disabled = false;
						this.elt[i$1].selected = false;
					}
				}
				return this;
			};
			return self$1;
		};
		let counter = 0;
		fn$1.createRadio = function(...args) {
			let self$1;
			let radioElement;
			let name;
			const arg0 = args[0];
			if (arg0 instanceof Element && (arg0.elt instanceof HTMLDivElement || arg0.elt instanceof HTMLSpanElement)) {
				self$1 = arg0;
				this.elt = arg0.elt;
			} else if (arg0 instanceof HTMLDivElement || arg0 instanceof HTMLSpanElement) {
				self$1 = addElement(arg0, this);
				this.elt = arg0;
				radioElement = arg0;
				if (typeof args[1] === "string") name = args[1];
			} else {
				if (typeof arg0 === "string") name = arg0;
				radioElement = document.createElement("div");
				self$1 = addElement(radioElement, this);
				this.elt = radioElement;
			}
			self$1._name = name || `radioOption_${counter++}`;
			const isRadioInput = (el) => el instanceof HTMLInputElement && el.type === "radio";
			const isLabelElement = (el) => el instanceof HTMLLabelElement;
			const isSpanElement = (el) => el instanceof HTMLSpanElement;
			self$1._getOptionsArray = function() {
				return Array.from(this.elt.children).filter((el) => isRadioInput(el) || isLabelElement(el) && isRadioInput(el.firstElementChild)).map((el) => isRadioInput(el) ? el : el.firstElementChild);
			};
			self$1.option = function(value, label) {
				let optionEl;
				for (const option of self$1._getOptionsArray()) if (option.value === value) {
					optionEl = option;
					break;
				}
				if (optionEl === void 0) {
					optionEl = document.createElement("input");
					optionEl.setAttribute("type", "radio");
					optionEl.setAttribute("value", value);
				}
				optionEl.setAttribute("name", self$1._name);
				let labelElement;
				if (!isLabelElement(optionEl.parentElement)) {
					labelElement = document.createElement("label");
					labelElement.insertAdjacentElement("afterbegin", optionEl);
				} else labelElement = optionEl.parentElement;
				let spanElement;
				if (!isSpanElement(labelElement.lastElementChild)) {
					spanElement = document.createElement("span");
					optionEl.insertAdjacentElement("afterend", spanElement);
				} else spanElement = labelElement.lastElementChild;
				spanElement.innerHTML = label === void 0 ? value : label;
				this.elt.appendChild(labelElement);
				return optionEl;
			};
			self$1.remove = function(value) {
				for (const optionEl of self$1._getOptionsArray()) if (optionEl.value === value) {
					if (isLabelElement(optionEl.parentElement)) optionEl.parentElement.remove();
					else optionEl.remove();
					return;
				}
			};
			self$1.value = function() {
				let result = "";
				for (const option of self$1._getOptionsArray()) if (option.checked) {
					result = option.value;
					break;
				}
				return result;
			};
			self$1.selected = function(value) {
				let result = null;
				if (value === void 0) {
					for (const option of self$1._getOptionsArray()) if (option.checked) {
						result = option;
						break;
					}
				} else {
					self$1._getOptionsArray().forEach((option) => {
						option.checked = false;
						option.removeAttribute("checked");
					});
					for (const option of self$1._getOptionsArray()) if (option.value === value) {
						option.setAttribute("checked", true);
						option.checked = true;
						result = option;
					}
				}
				return result;
			};
			self$1.disable = function(shouldDisable = true) {
				for (const radioInput of self$1._getOptionsArray()) radioInput.setAttribute("disabled", shouldDisable);
			};
			return self$1;
		};
		fn$1.createColorPicker = function(value) {
			const elt = document.createElement("input");
			let self$1;
			elt.type = "color";
			if (value) if (value instanceof p5$2.Color) elt.value = value.toString("#rrggbb");
			else {
				this.push();
				this.colorMode("rgb");
				elt.value = this.color(value).toString("#rrggbb");
				this.pop();
			}
			else elt.value = "#000000";
			self$1 = addElement(elt, this);
			const inst = this;
			self$1.color = function() {
				inst.push();
				if (value) {
					if (value.mode) inst.colorMode(value.mode, ...value?.maxes ? value.maxes[value.mode] || [] : []);
				}
				const c = inst.color(this.elt.value);
				inst.pop();
				return c;
			};
			return self$1;
		};
		fn$1.createInput = function(value = "", type$2 = "text") {
			let elt = document.createElement("input");
			elt.setAttribute("value", value);
			elt.setAttribute("type", type$2);
			return addElement(elt, this);
		};
		fn$1.createFileInput = function(callback, multiple = false) {
			const handleFileSelect = function(event) {
				for (const file$1 of event.target.files) File$1._load(file$1, callback);
			};
			if (!(window.File && window.FileReader && window.FileList && window.Blob)) {
				console.log("The File APIs are not fully supported in this browser. Cannot create element.");
				return;
			}
			const fileInput = document.createElement("input");
			fileInput.setAttribute("type", "file");
			if (multiple) fileInput.setAttribute("multiple", true);
			fileInput.addEventListener("change", handleFileSelect, false);
			return addElement(fileInput, this);
		};
	}
	if (typeof p5 !== "undefined") dom$1(p5, p5.prototype);
	function dom(p5$2) {
		p5$2.registerAddon(dom$1);
		p5$2.registerAddon(element);
		p5$2.registerAddon(media);
		p5$2.registerAddon(file);
	}
	function acceleration(p5$2, fn$1) {
		fn$1.deviceOrientation = window.innerWidth / window.innerHeight > 1 ? "landscape" : "portrait";
		fn$1.accelerationX = 0;
		fn$1.accelerationY = 0;
		fn$1.accelerationZ = 0;
		fn$1.pAccelerationX = 0;
		fn$1.pAccelerationY = 0;
		fn$1.pAccelerationZ = 0;
		fn$1._updatePAccelerations = function() {
			this.pAccelerationX = this.accelerationX;
			this.pAccelerationY = this.accelerationY;
			this.pAccelerationZ = this.accelerationZ;
		};
		fn$1.rotationX = 0;
		fn$1.rotationY = 0;
		fn$1.rotationZ = 0;
		fn$1.pRotationX = 0;
		fn$1.pRotationY = 0;
		fn$1.pRotationZ = 0;
		let startAngleX = 0;
		let startAngleY = 0;
		let startAngleZ = 0;
		let rotateDirectionX = "clockwise";
		let rotateDirectionY = "clockwise";
		let rotateDirectionZ = "clockwise";
		fn$1.pRotateDirectionX = void 0;
		fn$1.pRotateDirectionY = void 0;
		fn$1.pRotateDirectionZ = void 0;
		fn$1._updatePRotations = function() {
			this.pRotationX = this.rotationX;
			this.pRotationY = this.rotationY;
			this.pRotationZ = this.rotationZ;
		};
		fn$1.turnAxis = void 0;
		let move_threshold = .5;
		let shake_threshold = 30;
		fn$1.setMoveThreshold = function(val$1) {
			move_threshold = val$1;
		};
		fn$1.setShakeThreshold = function(val$1) {
			shake_threshold = val$1;
		};
		fn$1._ondeviceorientation = function(e$1) {
			this._updatePRotations();
			this.rotationX = this._fromDegrees(e$1.beta);
			this.rotationY = this._fromDegrees(e$1.gamma);
			this.rotationZ = this._fromDegrees(e$1.alpha);
			this._handleMotion();
		};
		fn$1._ondevicemotion = function(e$1) {
			this._updatePAccelerations();
			this.accelerationX = e$1.acceleration.x * 2;
			this.accelerationY = e$1.acceleration.y * 2;
			this.accelerationZ = e$1.acceleration.z * 2;
			this._handleMotion();
		};
		fn$1._handleMotion = function() {
			if (window.orientation === 90 || window.orientation === -90) this.deviceOrientation = "landscape";
			else if (window.orientation === 0) this.deviceOrientation = "portrait";
			else if (window.orientation === void 0) this.deviceOrientation = "undefined";
			const context = this._isGlobal ? window : this;
			if (typeof context.deviceMoved === "function") {
				if (Math.abs(this.accelerationX - this.pAccelerationX) > move_threshold || Math.abs(this.accelerationY - this.pAccelerationY) > move_threshold || Math.abs(this.accelerationZ - this.pAccelerationZ) > move_threshold) context.deviceMoved();
			}
			if (typeof context.deviceTurned === "function") {
				const wRX = this._toDegrees(this.rotationX) + 180;
				const wPRX = this._toDegrees(this.pRotationX) + 180;
				let wSAX = startAngleX + 180;
				if (wRX - wPRX > 0 && wRX - wPRX < 270 || wRX - wPRX < -270) rotateDirectionX = "clockwise";
				else if (wRX - wPRX < 0 || wRX - wPRX > 270) rotateDirectionX = "counter-clockwise";
				if (rotateDirectionX !== this.pRotateDirectionX) wSAX = wRX;
				if (Math.abs(wRX - wSAX) > 90 && Math.abs(wRX - wSAX) < 270) {
					wSAX = wRX;
					this.turnAxis = "X";
					context.deviceTurned();
				}
				this.pRotateDirectionX = rotateDirectionX;
				startAngleX = wSAX - 180;
				const wRY = this._toDegrees(this.rotationY) + 180;
				const wPRY = this._toDegrees(this.pRotationY) + 180;
				let wSAY = startAngleY + 180;
				if (wRY - wPRY > 0 && wRY - wPRY < 270 || wRY - wPRY < -270) rotateDirectionY = "clockwise";
				else if (wRY - wPRY < 0 || wRY - this.pRotationY > 270) rotateDirectionY = "counter-clockwise";
				if (rotateDirectionY !== this.pRotateDirectionY) wSAY = wRY;
				if (Math.abs(wRY - wSAY) > 90 && Math.abs(wRY - wSAY) < 270) {
					wSAY = wRY;
					this.turnAxis = "Y";
					context.deviceTurned();
				}
				this.pRotateDirectionY = rotateDirectionY;
				startAngleY = wSAY - 180;
				const rotZ = this._toDegrees(this.rotationZ);
				const pRotZ = this._toDegrees(this.pRotationZ);
				if (rotZ - pRotZ > 0 && rotZ - pRotZ < 270 || rotZ - pRotZ < -270) rotateDirectionZ = "clockwise";
				else if (rotZ - pRotZ < 0 || rotZ - pRotZ > 270) rotateDirectionZ = "counter-clockwise";
				if (rotateDirectionZ !== this.pRotateDirectionZ) startAngleZ = rotZ;
				if (Math.abs(rotZ - startAngleZ) > 90 && Math.abs(rotZ - startAngleZ) < 270) {
					startAngleZ = rotZ;
					this.turnAxis = "Z";
					context.deviceTurned();
				}
				this.pRotateDirectionZ = rotateDirectionZ;
				this.turnAxis = void 0;
			}
			if (typeof context.deviceShaken === "function") {
				let accelerationChangeX;
				let accelerationChangeY;
				if (this.pAccelerationX !== null) {
					accelerationChangeX = Math.abs(this.accelerationX - this.pAccelerationX);
					accelerationChangeY = Math.abs(this.accelerationY - this.pAccelerationY);
				}
				if (accelerationChangeX + accelerationChangeY > shake_threshold) context.deviceShaken();
			}
		};
	}
	if (typeof p5 !== "undefined") acceleration(p5, p5.prototype);
	function isCode(input) {
		if ([
			"Alt",
			"Shift",
			"Control",
			"Meta"
		].includes(input)) return false;
		if (typeof input !== "string") return false;
		return input.length > 1;
	}
	function keyboard(p5$2, fn$1) {
		fn$1.keyIsPressed = false;
		fn$1.key = "";
		fn$1.code = "";
		fn$1.keyCode = 0;
		fn$1._onkeydown = function(e$1) {
			if (this._downKeys[e$1.code]) return;
			this.keyIsPressed = true;
			this.keyCode = e$1.which;
			this.key = e$1.key;
			this.code = e$1.code;
			this._downKeyCodes[e$1.code] = true;
			this._downKeys[e$1.key] = true;
			const context = this._isGlobal ? window : this;
			if (typeof context.keyPressed === "function" && !e$1.charCode) {
				if (context.keyPressed(e$1) === false) e$1.preventDefault();
			}
		};
		fn$1._onkeyup = function(e$1) {
			const context = this._isGlobal ? window : this;
			if (typeof context.keyReleased === "function") {
				if (context.keyReleased(e$1) === false) e$1.preventDefault();
			}
			delete this._downKeyCodes[e$1.code];
			delete this._downKeys[e$1.key];
			if (!this._areDownKeys()) {
				this.keyIsPressed = false;
				this.key = "";
				this.code = "";
			} else {
				this.code = Object.keys(this._downKeyCodes).pop();
				this.key = Object.keys(this._downKeys).pop();
			}
		};
		fn$1._onkeypress = function(e$1) {
			if (e$1.which === this._lastKeyCodeTyped && e$1.repeat) return;
			this._lastKeyCodeTyped = e$1.which;
			this.key = e$1.key || String.fromCharCode(e$1.which) || e$1.which;
			const context = this._isGlobal ? window : this;
			if (typeof context.keyTyped === "function") {
				if (context.keyTyped(e$1) === false) e$1.preventDefault();
			}
		};
		fn$1._onblur = function(e$1) {
			this._downKeys = {};
		};
		fn$1.keyIsDown = function(input) {
			if (isCode(input)) return this._downKeyCodes[input] || this._downKeys[input] || false;
			else return this._downKeys[input] || this._downKeyCodes[input] || false;
		};
		fn$1._areDownKeys = function() {
			for (const key in this._downKeys) if (this._downKeys.hasOwnProperty(key) && this._downKeys[key] === true) return true;
			return false;
		};
	}
	if (typeof p5 !== "undefined") keyboard(p5, p5.prototype);
	function pointer(p5$2, fn$1) {
		fn$1.movedX = 0;
		fn$1.movedY = 0;
		fn$1._hasMouseInteracted = false;
		fn$1.mouseX = 0;
		fn$1.mouseY = 0;
		fn$1.pmouseX = 0;
		fn$1.pmouseY = 0;
		fn$1.winMouseX = 0;
		fn$1.winMouseY = 0;
		fn$1.pwinMouseX = 0;
		fn$1.pwinMouseY = 0;
		fn$1.mouseButton = {
			left: false,
			right: false,
			center: false
		};
		fn$1.touches = [];
		fn$1._activePointers = /* @__PURE__ */ new Map();
		fn$1.mouseIsPressed = false;
		fn$1._updatePointerCoords = function(e$1) {
			if (this._curElement !== null) {
				const canvas$1 = this._curElement.elt;
				const sx = canvas$1.scrollWidth / this.width || 1;
				const sy = canvas$1.scrollHeight / this.height || 1;
				if (e$1.pointerType == "touch") {
					const touches = [];
					for (const touch of this._activePointers.values()) touches.push(getTouchInfo(canvas$1, sx, sy, touch));
					this.touches = touches;
				}
				const mousePos = getMouseInfo(canvas$1, sx, sy, e$1);
				this.movedX = e$1.movementX || 0;
				this.movedY = e$1.movementY || 0;
				this.mouseX = mousePos.x;
				this.mouseY = mousePos.y;
				this.winMouseX = mousePos.winX;
				this.winMouseY = mousePos.winY;
				if (!this._hasMouseInteracted) {
					this._updateMouseCoords();
					this._hasMouseInteracted = true;
				}
			}
		};
		fn$1._updateMouseCoords = function() {
			this.pmouseX = this.mouseX;
			this.pmouseY = this.mouseY;
			this.pwinMouseX = this.winMouseX;
			this.pwinMouseY = this.winMouseY;
			this._pmouseWheelDeltaY = this._mouseWheelDeltaY;
		};
		function getMouseInfo(canvas$1, sx, sy, evt) {
			const rect = canvas$1.getBoundingClientRect();
			return {
				x: (evt.clientX - rect.left) / sx,
				y: (evt.clientY - rect.top) / sy,
				winX: evt.clientX,
				winY: evt.clientY
			};
		}
		function getTouchInfo(canvas$1, sx, sy, touch) {
			const rect = canvas$1.getBoundingClientRect();
			return {
				x: (touch.clientX - rect.left) / sx,
				y: (touch.clientY - rect.top) / sy,
				winX: touch.clientX,
				winY: touch.clientY,
				id: touch.pointerId
			};
		}
		fn$1._setMouseButton = function(e$1) {
			this.mouseButton.left = Array.from(this._activePointers.values()).some((touch) => (touch.buttons & 1) !== 0);
			this.mouseButton.center = Array.from(this._activePointers.values()).some((touch) => (touch.buttons & 4) !== 0);
			this.mouseButton.right = Array.from(this._activePointers.values()).some((touch) => (touch.buttons & 2) !== 0);
		};
		fn$1._onpointermove = function(e$1) {
			const context = this._isGlobal ? window : this;
			let executeDefault;
			this._updatePointerCoords(e$1);
			this._activePointers.set(e$1.pointerId, e$1);
			this._setMouseButton(e$1);
			if (!this.mouseIsPressed && typeof context.mouseMoved === "function") {
				executeDefault = context.mouseMoved(e$1);
				if (executeDefault === false) e$1.preventDefault();
			} else if (this.mouseIsPressed && typeof context.mouseDragged === "function") {
				executeDefault = context.mouseDragged(e$1);
				if (executeDefault === false) e$1.preventDefault();
			}
		};
		fn$1._onpointerdown = function(e$1) {
			const context = this._isGlobal ? window : this;
			let executeDefault;
			this.mouseIsPressed = true;
			this._activePointers.set(e$1.pointerId, e$1);
			this._setMouseButton(e$1);
			this._updatePointerCoords(e$1);
			if (typeof context.mousePressed === "function") {
				executeDefault = context.mousePressed(e$1);
				if (executeDefault === false) e$1.preventDefault();
			}
		};
		fn$1._onpointerup = function(e$1) {
			const context = this._isGlobal ? window : this;
			let executeDefault;
			this.mouseIsPressed = false;
			this._activePointers.delete(e$1.pointerId);
			this._setMouseButton(e$1);
			this._updatePointerCoords(e$1);
			if (typeof context.mouseReleased === "function") {
				executeDefault = context.mouseReleased(e$1);
				if (executeDefault === false) e$1.preventDefault();
			}
		};
		fn$1._ondragend = fn$1._onpointerup;
		fn$1._ondragover = fn$1._onpointermove;
		fn$1._onclick = function(e$1) {
			const context = this._isGlobal ? window : this;
			if (typeof context.mouseClicked === "function") {
				if (context.mouseClicked(e$1) === false) e$1.preventDefault();
			}
		};
		fn$1._ondblclick = function(e$1) {
			const context = this._isGlobal ? window : this;
			if (typeof context.doubleClicked === "function") {
				if (context.doubleClicked(e$1) === false) e$1.preventDefault();
			}
		};
		fn$1._mouseWheelDeltaY = 0;
		fn$1._pmouseWheelDeltaY = 0;
		fn$1._onwheel = function(e$1) {
			const context = this._isGlobal ? window : this;
			this._mouseWheelDeltaY = e$1.deltaY;
			if (typeof context.mouseWheel === "function") {
				e$1.delta = e$1.deltaY;
				if (context.mouseWheel(e$1) === false) e$1.preventDefault();
			}
		};
		fn$1.requestPointerLock = function() {
			const canvas$1 = this._curElement.elt;
			canvas$1.requestPointerLock = canvas$1.requestPointerLock || canvas$1.mozRequestPointerLock;
			if (!canvas$1.requestPointerLock) {
				console.log("requestPointerLock is not implemented in this browser");
				return false;
			}
			canvas$1.requestPointerLock();
			return true;
		};
		fn$1.exitPointerLock = function() {
			document.exitPointerLock();
		};
	}
	if (typeof p5 !== "undefined") pointer(p5, p5.prototype);
	function events(p5$2) {
		p5$2.registerAddon(acceleration);
		p5$2.registerAddon(keyboard);
		p5$2.registerAddon(pointer);
	}
	function image(p5$2) {
		p5$2.registerAddon(image$1);
		p5$2.registerAddon(loadingDisplaying);
		p5$2.registerAddon(image$2);
		p5$2.registerAddon(pixels);
		p5$2.registerAddon(shader);
		p5$2.registerAddon(texture);
	}
	var Table = class {
		constructor(rows) {
			this.columns = [];
			this.rows = [];
		}
		toString(separator = ",") {
			let rows = this.rows.map((row) => row.arr);
			if (!this.columns.some((column) => column === null)) rows = [this.columns, ...rows];
			return stringify(rows, { separator });
		}
		addRow(row) {
			const r = row || new p5.TableRow();
			if (typeof r.arr === "undefined" || typeof r.obj === "undefined") throw new Error(`invalid TableRow: ${r}`);
			r.table = this;
			this.rows.push(r);
			return r;
		}
		removeRow(id) {
			this.rows[id].table = null;
			const chunk = this.rows.splice(id + 1, this.rows.length);
			this.rows.pop();
			this.rows = this.rows.concat(chunk);
		}
		getRow(r) {
			return this.rows[r];
		}
		getRows() {
			return this.rows;
		}
		findRow(value, column) {
			if (typeof column === "string") {
				for (let i$1 = 0; i$1 < this.rows.length; i$1++) if (this.rows[i$1].obj[this.columns.indexOf(column)] === value) return this.rows[i$1];
			} else for (let j = 0; j < this.rows.length; j++) if (this.rows[j].arr[column] === value) return this.rows[j];
			return null;
		}
		findRows(value, column) {
			const ret = [];
			if (typeof column === "string") {
				for (let i$1 = 0; i$1 < this.rows.length; i$1++) if (this.rows[i$1].obj[this.columns.indexOf(column)] === value) ret.push(this.rows[i$1]);
			} else for (let j = 0; j < this.rows.length; j++) if (this.rows[j].arr[column] === value) ret.push(this.rows[j]);
			return ret;
		}
		matchRow(regexp, column) {
			if (typeof column === "number") {
				for (let j = 0; j < this.rows.length; j++) if (this.rows[j].arr[column].match(regexp)) return this.rows[j];
			} else for (let i$1 = 0; i$1 < this.rows.length; i$1++) if (this.rows[i$1].obj[this.columns.indexOf(column)].match(regexp)) return this.rows[i$1];
			return null;
		}
		matchRows(regexp, column) {
			const ret = [];
			if (typeof column === "number") {
				for (let j = 0; j < this.rows.length; j++) if (this.rows[j].arr[column].match(regexp)) ret.push(this.rows[j]);
			} else for (let i$1 = 0; i$1 < this.rows.length; i$1++) if (this.rows[i$1].obj[this.columns.indexOf(column)].match(regexp)) ret.push(this.rows[i$1]);
			return ret;
		}
		getColumn(value) {
			const ret = [];
			if (typeof value === "string") for (let i$1 = 0; i$1 < this.rows.length; i$1++) ret.push(this.rows[i$1].obj[this.columns.indexOf(value)]);
			else for (let j = 0; j < this.rows.length; j++) ret.push(this.rows[j].arr[value]);
			return ret;
		}
		clearRows() {
			delete this.rows;
			this.rows = [];
		}
		addColumn(title) {
			const t$1 = title || null;
			this.columns.push(t$1);
		}
		getColumnCount() {
			return this.columns.length;
		}
		getRowCount() {
			return this.rows.length;
		}
		removeTokens(chars, column) {
			const escape$1 = (s) => s.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
			const charArray = [];
			for (let i$1 = 0; i$1 < chars.length; i$1++) charArray.push(escape$1(chars.charAt(i$1)));
			const regex = new RegExp(charArray.join("|"), "g");
			if (typeof column === "undefined") for (let c = 0; c < this.columns.length; c++) for (let d$1 = 0; d$1 < this.rows.length; d$1++) {
				let s = this.rows[d$1].arr[c];
				s = s.replace(regex, "");
				this.rows[d$1].arr[c] = s;
				this.rows[d$1].obj[this.columns[c]] = s;
			}
			else if (typeof column === "string") for (let j = 0; j < this.rows.length; j++) {
				let val$1 = this.rows[j].obj[column];
				val$1 = val$1.replace(regex, "");
				this.rows[j].obj[column] = val$1;
				const pos = this.columns.indexOf(column);
				this.rows[j].arr[pos] = val$1;
			}
			else for (let k = 0; k < this.rows.length; k++) {
				let str = this.rows[k].arr[column];
				str = str.replace(regex, "");
				this.rows[k].arr[column] = str;
				this.rows[k].obj[this.columns[column]] = str;
			}
		}
		trim(column) {
			const regex = new RegExp(" ", "g");
			if (typeof column === "undefined") for (let c = 0; c < this.columns.length; c++) for (let d$1 = 0; d$1 < this.rows.length; d$1++) {
				let s = this.rows[d$1].arr[c];
				s = s.replace(regex, "");
				this.rows[d$1].arr[c] = s;
				this.rows[d$1].obj[this.columns[c]] = s;
			}
			else if (typeof column === "string") for (let j = 0; j < this.rows.length; j++) {
				let val$1 = this.rows[j].obj[column];
				val$1 = val$1.replace(regex, "");
				this.rows[j].obj[column] = val$1;
				const pos = this.columns.indexOf(column);
				this.rows[j].arr[pos] = val$1;
			}
			else for (let k = 0; k < this.rows.length; k++) {
				let str = this.rows[k].arr[column];
				str = str.replace(regex, "");
				this.rows[k].arr[column] = str;
				this.rows[k].obj[this.columns[column]] = str;
			}
		}
		removeColumn(c) {
			let cString;
			let cNumber;
			if (typeof c === "string") {
				cString = c;
				cNumber = this.columns.indexOf(c);
			} else {
				cNumber = c;
				cString = this.columns[c];
			}
			const chunk = this.columns.splice(cNumber + 1, this.columns.length);
			this.columns.pop();
			this.columns = this.columns.concat(chunk);
			for (let i$1 = 0; i$1 < this.rows.length; i$1++) {
				const tempR = this.rows[i$1].arr;
				const chip = tempR.splice(cNumber + 1, tempR.length);
				tempR.pop();
				this.rows[i$1].arr = tempR.concat(chip);
				delete this.rows[i$1].obj[cString];
			}
		}
		set(row, column, value) {
			this.rows[row].set(column, value);
		}
		setNum(row, column, value) {
			this.rows[row].setNum(column, value);
		}
		setString(row, column, value) {
			this.rows[row].setString(column, value);
		}
		get(row, column) {
			if (typeof column === "string") return this.rows[row].get(this.columns.indexOf(column));
			else return this.rows[row].get(column);
		}
		getNum(row, column) {
			return this.rows[row].getNum(column);
		}
		getString(row, column) {
			return this.rows[row].getString(column);
		}
		getObject(headerColumn) {
			const tableObject = {};
			let obj, cPos, index;
			for (let i$1 = 0; i$1 < this.rows.length; i$1++) {
				obj = this.rows[i$1].obj;
				if (typeof headerColumn === "string") {
					cPos = this.columns.indexOf(headerColumn);
					if (cPos >= 0) {
						index = obj[headerColumn];
						tableObject[index] = obj;
					} else throw new Error(`This table has no column named "${headerColumn}"`);
				} else tableObject[i$1] = this.rows[i$1].obj;
			}
			return tableObject;
		}
		getArray() {
			const tableArray = [];
			for (let i$1 = 0; i$1 < this.rows.length; i$1++) tableArray.push(this.rows[i$1].arr);
			return tableArray;
		}
	};
	function table(p5$2, fn$1) {
		p5$2.Table = Table;
	}
	if (typeof p5 !== "undefined") table(p5, p5.prototype);
	var TableRow = class {
		constructor(row = []) {
			let arr$1 = row;
			this.arr = arr$1;
			this.obj = Object.fromEntries(arr$1.entries());
			this.table = null;
		}
		set(column, value) {
			if (typeof column === "string") {
				const cPos = this.table.columns.indexOf(column);
				if (cPos >= 0) {
					this.obj[column] = value;
					this.arr[cPos] = value;
				} else throw new Error(`This table has no column named "${column}"`);
			} else if (column < this.table.columns.length) {
				this.arr[column] = value;
				const cTitle = this.table.columns[column];
				this.obj[cTitle] = value;
			} else throw new Error(`Column #${column} is out of the range of this table`);
		}
		setNum(column, value) {
			const floatVal = parseFloat(value);
			this.set(column, floatVal);
		}
		setString(column, value) {
			const stringVal = value.toString();
			this.set(column, stringVal);
		}
		get(column) {
			if (typeof column === "string") return this.obj[this.table.columns.indexOf(column)];
			else return this.arr[column];
		}
		getNum(column) {
			let ret;
			if (typeof column === "string") ret = parseFloat(this.obj[this.table.columns.indexOf(column)]);
			else ret = parseFloat(this.arr[column]);
			if (ret.toString() === "NaN") throw `Error: ${this.obj[column]} is NaN (Not a Number)`;
			return ret;
		}
		getString(column) {
			if (typeof column === "string") return this.obj[this.table.columns.indexOf(column)].toString();
			else return this.arr[column].toString();
		}
	};
	function tableRow(p5$2, fn$1) {
		p5$2.TableRow = TableRow;
	}
	if (typeof p5 !== "undefined") tableRow(p5, p5.prototype);
	function io(p5$2) {
		p5$2.registerAddon(files);
		p5$2.registerAddon(table);
		p5$2.registerAddon(tableRow);
		p5$2.registerAddon(xml);
	}
	function calculation(p5$2, fn$1) {
		fn$1.abs = Math.abs;
		fn$1.ceil = Math.ceil;
		fn$1.constrain = function(n$2, low, high) {
			return Math.max(Math.min(n$2, high), low);
		};
		fn$1.dist = function(...args) {
			if (args.length === 4) return Math.hypot(args[2] - args[0], args[3] - args[1]);
			else if (args.length === 6) return Math.hypot(args[3] - args[0], args[4] - args[1], args[5] - args[2]);
		};
		fn$1.exp = Math.exp;
		fn$1.floor = Math.floor;
		fn$1.lerp = function(start, stop, amt) {
			return amt * (stop - start) + start;
		};
		fn$1.log = Math.log;
		fn$1.mag = function(x$1, y) {
			return Math.hypot(x$1, y);
		};
		fn$1.map = function(n$2, start1, stop1, start2, stop2, withinBounds) {
			const newval = (n$2 - start1) / (stop1 - start1) * (stop2 - start2) + start2;
			if (!withinBounds) return newval;
			if (start2 < stop2) return this.constrain(newval, start2, stop2);
			else return this.constrain(newval, stop2, start2);
		};
		fn$1.max = function(...args) {
			const findMax = (arr$1) => {
				let max = -Infinity;
				for (let x$1 of arr$1) max = Math.max(max, x$1);
				return max;
			};
			if (args[0] instanceof Array) return findMax(args[0]);
			else return findMax(args);
		};
		fn$1.min = function(...args) {
			const findMin = (arr$1) => {
				let min = Infinity;
				for (let x$1 of arr$1) min = Math.min(min, x$1);
				return min;
			};
			if (args[0] instanceof Array) return findMin(args[0]);
			else return findMin(args);
		};
		fn$1.norm = function(n$2, start, stop) {
			return this.map(n$2, start, stop, 0, 1);
		};
		fn$1.pow = Math.pow;
		fn$1.round = function(n$2, decimals) {
			if (!decimals) return Math.round(n$2);
			const multiplier = Math.pow(10, decimals);
			return Math.round(n$2 * multiplier) / multiplier;
		};
		fn$1.sq = (n$2) => n$2 * n$2;
		fn$1.sqrt = Math.sqrt;
		fn$1.fract = function(toConvert) {
			let sign = 0;
			let num = Number(toConvert);
			if (isNaN(num) || Math.abs(num) === Infinity) return num;
			else if (num < 0) {
				num = -num;
				sign = 1;
			}
			if (String(num).includes(".") && !String(num).includes("e")) {
				let toFract = String(num);
				toFract = Number("0" + toFract.slice(toFract.indexOf(".")));
				return Math.abs(sign - toFract);
			} else if (num < 1) return Math.abs(sign - num);
			else return 0;
		};
	}
	if (typeof p5 !== "undefined") calculation(p5, p5.prototype);
	function noise(p5$2, fn$1) {
		const PERLIN_YWRAPB = 4;
		const PERLIN_YWRAP = 1 << PERLIN_YWRAPB;
		const PERLIN_ZWRAPB = 8;
		const PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;
		const PERLIN_SIZE = 4095;
		let perlin_octaves = 4;
		let perlin_amp_falloff = .5;
		const scaled_cosine = (i$1) => .5 * (1 - Math.cos(i$1 * Math.PI));
		let perlin;
		fn$1.noise = function(x$1, y = 0, z$1 = 0) {
			if (perlin == null) {
				perlin = new Array(PERLIN_SIZE + 1);
				for (let i$1 = 0; i$1 < PERLIN_SIZE + 1; i$1++) perlin[i$1] = Math.random();
			}
			if (x$1 < 0) x$1 = -x$1;
			if (y < 0) y = -y;
			if (z$1 < 0) z$1 = -z$1;
			let xi = Math.floor(x$1), yi = Math.floor(y), zi = Math.floor(z$1);
			let xf = x$1 - xi;
			let yf = y - yi;
			let zf = z$1 - zi;
			let rxf, ryf;
			let r = 0;
			let ampl = .5;
			let n1, n2, n3;
			for (let o = 0; o < perlin_octaves; o++) {
				let of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);
				rxf = scaled_cosine(xf);
				ryf = scaled_cosine(yf);
				n1 = perlin[of & PERLIN_SIZE];
				n1 += rxf * (perlin[of + 1 & PERLIN_SIZE] - n1);
				n2 = perlin[of + PERLIN_YWRAP & PERLIN_SIZE];
				n2 += rxf * (perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n2);
				n1 += ryf * (n2 - n1);
				of += PERLIN_ZWRAP;
				n2 = perlin[of & PERLIN_SIZE];
				n2 += rxf * (perlin[of + 1 & PERLIN_SIZE] - n2);
				n3 = perlin[of + PERLIN_YWRAP & PERLIN_SIZE];
				n3 += rxf * (perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n3);
				n2 += ryf * (n3 - n2);
				n1 += scaled_cosine(zf) * (n2 - n1);
				r += n1 * ampl;
				ampl *= perlin_amp_falloff;
				xi <<= 1;
				xf *= 2;
				yi <<= 1;
				yf *= 2;
				zi <<= 1;
				zf *= 2;
				if (xf >= 1) {
					xi++;
					xf--;
				}
				if (yf >= 1) {
					yi++;
					yf--;
				}
				if (zf >= 1) {
					zi++;
					zf--;
				}
			}
			return r;
		};
		fn$1.noiseDetail = function(lod, falloff) {
			if (lod > 0) perlin_octaves = lod;
			if (falloff > 0) perlin_amp_falloff = falloff;
		};
		fn$1.noiseSeed = function(seed) {
			const lcg = (() => {
				const m = 4294967296;
				const a = 1664525;
				const c = 1013904223;
				let seed$1, z$1;
				return {
					setSeed(val$1) {
						z$1 = seed$1 = (val$1 == null ? Math.random() * m : val$1) >>> 0;
					},
					getSeed() {
						return seed$1;
					},
					rand() {
						z$1 = (a * z$1 + c) % m;
						return z$1 / m;
					}
				};
			})();
			lcg.setSeed(seed);
			perlin = new Array(PERLIN_SIZE + 1);
			for (let i$1 = 0; i$1 < PERLIN_SIZE + 1; i$1++) perlin[i$1] = lcg.rand();
		};
	}
	if (typeof p5 !== "undefined") noise(p5, p5.prototype);
	function random(p5$2, fn$1) {
		const randomStateProp = "_lcg_random_state";
		const m = 4294967296;
		const a = 1664525;
		const c = 1013904223;
		let y2 = 0;
		fn$1._lcg = function(stateProperty) {
			this[stateProperty] = (a * this[stateProperty] + c) % m;
			return this[stateProperty] / m;
		};
		fn$1._lcgSetSeed = function(stateProperty, val$1) {
			this[stateProperty] = (val$1 == null ? Math.random() * m : val$1) >>> 0;
		};
		fn$1.randomSeed = function(seed) {
			this._lcgSetSeed(randomStateProp, seed);
			this._gaussian_previous = false;
		};
		fn$1.random = function(min, max) {
			let rand;
			if (this[randomStateProp] != null) rand = this._lcg(randomStateProp);
			else rand = Math.random();
			if (typeof min === "undefined") return rand;
			else if (typeof max === "undefined") if (min instanceof Array) return min[Math.floor(rand * min.length)];
			else return rand * min;
			else {
				if (min > max) {
					const tmp = min;
					min = max;
					max = tmp;
				}
				return rand * (max - min) + min;
			}
		};
		fn$1.randomGaussian = function(mean, sd = 1) {
			let y1, x1, x2, w;
			if (this._gaussian_previous) {
				y1 = y2;
				this._gaussian_previous = false;
			} else {
				do {
					x1 = this.random(2) - 1;
					x2 = this.random(2) - 1;
					w = x1 * x1 + x2 * x2;
				} while (w >= 1);
				w = Math.sqrt(-2 * Math.log(w) / w);
				y1 = x1 * w;
				y2 = x2 * w;
				this._gaussian_previous = true;
			}
			const m$1 = mean || 0;
			return y1 * sd + m$1;
		};
	}
	if (typeof p5 !== "undefined") random(p5, p5.prototype);
	function math$1(p5$2, fn$1) {
		fn$1.createVector = function(x$1, y, z$1) {
			if (this instanceof p5$2) return new p5$2.Vector(this._fromRadians.bind(this), this._toRadians.bind(this), ...arguments);
			else return new p5$2.Vector(x$1, y, z$1);
		};
		fn$1.createMatrix = function(...args) {
			return new p5$2.Matrix(...args);
		};
	}
	if (typeof p5 !== "undefined") math$1(p5, p5.prototype);
	function math(p5$2) {
		p5$2.registerAddon(calculation);
		p5$2.registerAddon(noise);
		p5$2.registerAddon(random);
		p5$2.registerAddon(trigonometry);
		p5$2.registerAddon(math$1);
		p5$2.registerAddon(vector);
	}
	function conversion(p5$2, fn$1) {
		fn$1.float = function(str) {
			if (str instanceof Array) return str.map(parseFloat);
			return parseFloat(str);
		};
		fn$1.int = function(n$2, radix = 10) {
			if (n$2 === Infinity || n$2 === "Infinity") return Infinity;
			else if (n$2 === -Infinity || n$2 === "-Infinity") return -Infinity;
			else if (typeof n$2 === "string") return parseInt(n$2, radix);
			else if (typeof n$2 === "number") return n$2 | 0;
			else if (typeof n$2 === "boolean") return n$2 ? 1 : 0;
			else if (n$2 instanceof Array) return n$2.map((n$3) => fn$1.int(n$3, radix));
		};
		fn$1.str = function(n$2) {
			if (n$2 instanceof Array) return n$2.map(fn$1.str);
			else return String(n$2);
		};
		fn$1.boolean = function(n$2) {
			if (typeof n$2 === "number") return n$2 !== 0;
			else if (typeof n$2 === "string") return n$2.toLowerCase() === "true";
			else if (typeof n$2 === "boolean") return n$2;
			else if (n$2 instanceof Array) return n$2.map(fn$1.boolean);
		};
		fn$1.byte = function(n$2) {
			const nn = fn$1.int(n$2, 10);
			if (typeof nn === "number") return (nn + 128) % 256 - 128;
			else if (nn instanceof Array) return nn.map(fn$1.byte);
		};
		fn$1.char = function(n$2) {
			if (typeof n$2 === "number" && !isNaN(n$2)) return String.fromCharCode(n$2);
			else if (n$2 instanceof Array) return n$2.map(fn$1.char);
			else if (typeof n$2 === "string") return fn$1.char(parseInt(n$2, 10));
		};
		fn$1.unchar = function(n$2) {
			if (typeof n$2 === "string" && n$2.length === 1) return n$2.charCodeAt(0);
			else if (n$2 instanceof Array) return n$2.map(fn$1.unchar);
		};
		fn$1.hex = function(n$2, digits) {
			digits = digits === void 0 || digits === null ? digits = 8 : digits;
			if (n$2 instanceof Array) return n$2.map((n$3) => fn$1.hex(n$3, digits));
			else if (n$2 === Infinity || n$2 === -Infinity) return (n$2 === Infinity ? "F" : "0").repeat(digits);
			else if (typeof n$2 === "number") {
				if (n$2 < 0) n$2 = 4294967295 + n$2 + 1;
				let hex = Number(n$2).toString(16).toUpperCase();
				while (hex.length < digits) hex = `0${hex}`;
				if (hex.length >= digits) hex = hex.substring(hex.length - digits, hex.length);
				return hex;
			}
		};
		fn$1.unhex = function(n$2) {
			if (n$2 instanceof Array) return n$2.map(fn$1.unhex);
			else return parseInt(`0x${n$2}`, 16);
		};
	}
	if (typeof p5 !== "undefined") conversion(p5, p5.prototype);
	function utilityFunctions(p5$2, fn$1) {
		fn$1.nf = function(nums, left, right) {
			if (nums instanceof Array) return nums.map((x$1) => doNf(x$1, left, right));
			else if (Object.prototype.toString.call(nums) === "[object Arguments]") if (nums.length === 3) return this.nf(nums[0], nums[1], nums[2]);
			else if (nums.length === 2) return this.nf(nums[0], nums[1]);
			else return this.nf(nums[0]);
			else return doNf(nums, left, right);
		};
		function doNf(num, left, right) {
			let isNegative = num < 0;
			num = Math.abs(num);
			let [leftPart, rightPart] = num.toString().split(".");
			if (typeof right === "undefined") {
				leftPart = leftPart.padStart(left, "0");
				let result = rightPart ? leftPart + "." + rightPart : leftPart;
				return isNegative ? "-" + result : result;
			} else {
				let roundedOff = num.toFixed(right);
				[leftPart, rightPart] = roundedOff.toString().split(".");
				leftPart = leftPart.padStart(left, "0");
				let result = typeof rightPart === "undefined" ? leftPart : leftPart + "." + rightPart;
				return isNegative ? "-" + result : result;
			}
		}
		fn$1.nfc = function(num, right) {
			if (num instanceof Array) return num.map((x$1) => doNfc(x$1, right));
			else return doNfc(num, right);
		};
		function doNfc(num, right) {
			num = num.toString();
			const dec = num.indexOf(".");
			let rem = dec !== -1 ? num.substring(dec) : "";
			let n$2 = dec !== -1 ? num.substring(0, dec) : num;
			n$2 = n$2.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
			if (right === 0) rem = "";
			else if (typeof right !== "undefined") if (right > rem.length) {
				rem += dec === -1 ? "." : "";
				const len = right - rem.length + 1;
				for (let i$1 = 0; i$1 < len; i$1++) rem += "0";
			} else rem = rem.substring(0, right + 1);
			return n$2 + rem;
		}
		fn$1.nfp = function(...args) {
			const nfRes = fn$1.nf.apply(this, args);
			if (nfRes instanceof Array) return nfRes.map(addNfp);
			else return addNfp(nfRes);
		};
		function addNfp(num) {
			return parseFloat(num) > 0 ? `+${num.toString()}` : num.toString();
		}
		fn$1.nfs = function(...args) {
			const nfRes = fn$1.nf.apply(this, args);
			if (nfRes instanceof Array) return nfRes.map(addNfs);
			else return addNfs(nfRes);
		};
		function addNfs(num) {
			return parseFloat(num) >= 0 ? ` ${num.toString()}` : num.toString();
		}
		fn$1.splitTokens = function(value, delims) {
			let d$1;
			if (typeof delims !== "undefined") {
				let str = delims;
				const sqc = /\]/g.exec(str);
				let sqo = /\[/g.exec(str);
				if (sqo && sqc) {
					str = str.slice(0, sqc.index) + str.slice(sqc.index + 1);
					sqo = /\[/g.exec(str);
					str = str.slice(0, sqo.index) + str.slice(sqo.index + 1);
					d$1 = new RegExp(`[\\[${str}\\]]`, "g");
				} else if (sqc) {
					str = str.slice(0, sqc.index) + str.slice(sqc.index + 1);
					d$1 = new RegExp(`[${str}\\]]`, "g");
				} else if (sqo) {
					str = str.slice(0, sqo.index) + str.slice(sqo.index + 1);
					d$1 = new RegExp(`[${str}\\[]`, "g");
				} else d$1 = new RegExp(`[${str}]`, "g");
			} else d$1 = /\s/g;
			return value.split(d$1).filter((n$2) => n$2);
		};
		fn$1.shuffle = function(arr$1, bool) {
			const isView = ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(arr$1);
			arr$1 = bool || isView ? arr$1 : arr$1.slice();
			let rnd, tmp, idx = arr$1.length;
			while (idx > 1) {
				rnd = this.random(0, 1) * idx | 0;
				tmp = arr$1[--idx];
				arr$1[idx] = arr$1[rnd];
				arr$1[rnd] = tmp;
			}
			return arr$1;
		};
	}
	if (typeof p5 !== "undefined") utilityFunctions(p5, p5.prototype);
	function timeDate(p5$2, fn$1) {
		fn$1.day = function() {
			return (/* @__PURE__ */ new Date()).getDate();
		};
		fn$1.hour = function() {
			return (/* @__PURE__ */ new Date()).getHours();
		};
		fn$1.minute = function() {
			return (/* @__PURE__ */ new Date()).getMinutes();
		};
		fn$1.millis = function() {
			if (this._millisStart === -1) return 0;
			else return window.performance.now() - this._millisStart;
		};
		fn$1.month = function() {
			return (/* @__PURE__ */ new Date()).getMonth() + 1;
		};
		fn$1.second = function() {
			return (/* @__PURE__ */ new Date()).getSeconds();
		};
		fn$1.year = function() {
			return (/* @__PURE__ */ new Date()).getFullYear();
		};
	}
	if (typeof p5 !== "undefined") timeDate(p5, p5.prototype);
	function utilities(p5$2) {
		p5$2.registerAddon(conversion);
		p5$2.registerAddon(utilityFunctions);
		p5$2.registerAddon(timeDate);
	}
	function interaction(p5$2, fn$1) {
		fn$1.orbitControl = function(sensitivityX, sensitivityY, sensitivityZ, options$1) {
			this._assert3d("orbitControl");
			const cam = this._renderer.states.curCamera;
			if (typeof sensitivityX === "undefined") sensitivityX = 1;
			if (typeof sensitivityY === "undefined") sensitivityY = sensitivityX;
			if (typeof sensitivityZ === "undefined") sensitivityZ = 1;
			if (typeof options$1 !== "object") options$1 = {};
			if (this.contextMenuDisabled !== true) {
				this.canvas.oncontextmenu = () => false;
				this.contextMenuDisabled = true;
			}
			if (this.wheelDefaultDisabled !== true) {
				this.canvas.onwheel = () => false;
				this.wheelDefaultDisabled = true;
			}
			const { disableTouchActions = true } = options$1;
			if (this.touchActionsDisabled !== true && disableTouchActions) {
				this.canvas.style["touch-action"] = "none";
				this.touchActionsDisabled = true;
			}
			const { freeRotation = false } = options$1;
			const movedTouches = [];
			this.touches.forEach((curTouch) => {
				this._renderer.prevTouches.forEach((prevTouch) => {
					if (curTouch.id === prevTouch.id) {
						const movedTouch = {
							x: curTouch.x,
							y: curTouch.y,
							px: prevTouch.x,
							py: prevTouch.y
						};
						movedTouches.push(movedTouch);
					}
				});
			});
			this._renderer.prevTouches = this.touches;
			let deltaRadius = 0;
			let deltaTheta = 0;
			let deltaPhi = 0;
			let moveDeltaX = 0;
			let moveDeltaY = 0;
			const damping = .85;
			const rotateAccelerationFactor = .6;
			const moveAccelerationFactor = .15;
			const mouseZoomScaleFactor = .01;
			const touchZoomScaleFactor = 4e-4;
			const scaleFactor = this.height < this.width ? this.height : this.width;
			let pointersInCanvas = false;
			if (movedTouches.length > 0) {
				pointersInCanvas = movedTouches[0].x > 0 && movedTouches[0].x < this.width && movedTouches[0].y > 0 && movedTouches[0].y < this.height;
				if (movedTouches.length === 1) {
					const t$1 = movedTouches[0];
					deltaTheta = -sensitivityX * (t$1.x - t$1.px) / scaleFactor;
					deltaPhi = sensitivityY * (t$1.y - t$1.py) / scaleFactor;
				} else {
					const t0 = movedTouches[0];
					const t1 = movedTouches[1];
					deltaRadius = -(Math.hypot(t0.x - t1.x, t0.y - t1.y) - Math.hypot(t0.px - t1.px, t0.py - t1.py)) * sensitivityZ * touchZoomScaleFactor;
					moveDeltaX = .5 * (t0.x + t1.x) - .5 * (t0.px + t1.px);
					moveDeltaY = .5 * (t0.y + t1.y) - .5 * (t0.py + t1.py);
				}
				if (this.touches.length > 0) {
					if (pointersInCanvas) {
						this._renderer.executeRotateAndMove = true;
						this._renderer.executeZoom = true;
					}
				} else {
					this._renderer.executeRotateAndMove = false;
					this._renderer.executeZoom = false;
				}
			} else {
				pointersInCanvas = this.mouseX > 0 && this.mouseX < this.width && this.mouseY > 0 && this.mouseY < this.height;
				if (this._mouseWheelDeltaY !== 0) {
					deltaRadius = Math.sign(this._mouseWheelDeltaY) * sensitivityZ;
					deltaRadius *= mouseZoomScaleFactor;
					this._mouseWheelDeltaY = 0;
					if (pointersInCanvas) this._renderer.executeZoom = true;
				} else this._renderer.executeZoom = false;
				if (this.mouseIsPressed) {
					if (this.mouseButton.left) {
						deltaTheta = -sensitivityX * this.movedX / scaleFactor;
						deltaPhi = sensitivityY * this.movedY / scaleFactor;
					} else if (this.mouseButton.right) {
						moveDeltaX = this.movedX;
						moveDeltaY = this.movedY * cam.yScale;
					}
					if (pointersInCanvas) this._renderer.executeRotateAndMove = true;
				} else this._renderer.executeRotateAndMove = false;
			}
			if (deltaRadius !== 0 && this._renderer.executeZoom) this._renderer.zoomVelocity += deltaRadius;
			if (Math.abs(this._renderer.zoomVelocity) > .001) {
				if (freeRotation) cam._orbitFree(0, 0, this._renderer.zoomVelocity);
				else cam._orbit(0, 0, this._renderer.zoomVelocity);
				if (cam.projMatrix.mat4[15] !== 0) {
					cam.projMatrix.mat4[0] *= Math.pow(10, -this._renderer.zoomVelocity);
					cam.projMatrix.mat4[5] *= Math.pow(10, -this._renderer.zoomVelocity);
					this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
					this._renderer.states.uPMatrix.mat4[0] = cam.projMatrix.mat4[0];
					this._renderer.states.uPMatrix.mat4[5] = cam.projMatrix.mat4[5];
				}
				this._renderer.zoomVelocity *= damping;
			} else this._renderer.zoomVelocity = 0;
			if ((deltaTheta !== 0 || deltaPhi !== 0) && this._renderer.executeRotateAndMove) this._renderer.rotateVelocity.add(deltaTheta * rotateAccelerationFactor, deltaPhi * rotateAccelerationFactor);
			if (this._renderer.rotateVelocity.magSq() > 1e-6) {
				if (freeRotation) cam._orbitFree(-this._renderer.rotateVelocity.x, this._renderer.rotateVelocity.y, 0);
				else cam._orbit(this._renderer.rotateVelocity.x, this._renderer.rotateVelocity.y, 0);
				this._renderer.rotateVelocity.mult(damping);
			} else this._renderer.rotateVelocity.set(0, 0);
			if ((moveDeltaX !== 0 || moveDeltaY !== 0) && this._renderer.executeRotateAndMove) {
				const ndcX = moveDeltaX * 2 / this.width;
				const ndcY = -moveDeltaY * 2 / this.height;
				this._renderer.moveVelocity.add(ndcX * moveAccelerationFactor, ndcY * moveAccelerationFactor);
			}
			if (this._renderer.moveVelocity.magSq() > 1e-6) {
				const local = cam._getLocalAxes();
				const diffX = cam.eyeX - cam.centerX;
				const diffY = cam.eyeY - cam.centerY;
				const diffZ = cam.eyeZ - cam.centerZ;
				const viewZ = Math.sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ);
				let cv = new Vector(cam.centerX, cam.centerY, cam.centerZ);
				cv = cam.cameraMatrix.multiplyPoint(cv);
				cv = this._renderer.states.uPMatrix.multiplyAndNormalizePoint(cv);
				cv.x -= this._renderer.moveVelocity.x;
				cv.y -= this._renderer.moveVelocity.y;
				let dx, dy;
				const uP = this._renderer.states.uPMatrix.mat4;
				if (uP[15] === 0) {
					dx = (uP[8] + cv.x) / uP[0] * viewZ;
					dy = (uP[9] + cv.y) / uP[5] * viewZ;
				} else {
					dx = (cv.x - uP[12]) / uP[0];
					dy = (cv.y - uP[13]) / uP[5];
				}
				cam.setPosition(cam.eyeX + dx * local.x[0] + dy * local.y[0], cam.eyeY + dx * local.x[1] + dy * local.y[1], cam.eyeZ + dx * local.x[2] + dy * local.y[2]);
				this._renderer.moveVelocity.mult(damping);
			} else this._renderer.moveVelocity.set(0, 0);
			return this;
		};
		fn$1.debugMode = function(...args) {
			this._assert3d("debugMode");
			for (let i$1 = p5$2.lifecycleHooks.postdraw.length - 1; i$1 >= 0; i$1--) if (p5$2.lifecycleHooks.postdraw[i$1].toString() === this._grid().toString() || p5$2.lifecycleHooks.postdraw[i$1].toString() === this._axesIcon().toString()) p5$2.lifecycleHooks.postdraw.splice(i$1, 1);
			if (args[0] === GRID) p5$2.lifecycleHooks.postdraw.push(this._grid(args[1], args[2], args[3], args[4], args[5]));
			else if (args[0] === AXES) p5$2.lifecycleHooks.postdraw.push(this._axesIcon(args[1], args[2], args[3], args[4]));
			else {
				p5$2.lifecycleHooks.postdraw.push(this._grid(args[0], args[1], args[2], args[3], args[4]));
				p5$2.lifecycleHooks.postdraw.push(this._axesIcon(args[5], args[6], args[7], args[8]));
			}
		};
		fn$1.noDebugMode = function() {
			this._assert3d("noDebugMode");
			for (let i$1 = p5$2.lifecycleHooks.postdraw.length - 1; i$1 >= 0; i$1--) if (p5$2.lifecycleHooks.postdraw[i$1].toString() === this._grid().toString() || p5$2.lifecycleHooks.postdraw[i$1].toString() === this._axesIcon().toString()) p5$2.lifecycleHooks.postdraw.splice(i$1, 1);
		};
		fn$1._grid = function(size, numDivs, xOff, yOff, zOff) {
			if (typeof size === "undefined") size = this.width / 2;
			if (typeof numDivs === "undefined") numDivs = Math.round(size / 30) < 4 ? 4 : Math.round(size / 30);
			if (typeof xOff === "undefined") xOff = 0;
			if (typeof yOff === "undefined") yOff = 0;
			if (typeof zOff === "undefined") zOff = 0;
			const spacing = size / numDivs;
			const halfSize = size / 2;
			return function() {
				this.push();
				this.stroke(this._renderer.states.curStrokeColor[0] * 255, this._renderer.states.curStrokeColor[1] * 255, this._renderer.states.curStrokeColor[2] * 255);
				this._renderer.states.setValue("uModelMatrix", this._renderer.states.uModelMatrix.clone());
				this._renderer.states.uModelMatrix.reset();
				for (let q = 0; q <= numDivs; q++) {
					this.beginShape(this.LINES);
					this.vertex(-halfSize + xOff, yOff, q * spacing - halfSize + zOff);
					this.vertex(+halfSize + xOff, yOff, q * spacing - halfSize + zOff);
					this.endShape();
				}
				for (let i$1 = 0; i$1 <= numDivs; i$1++) {
					this.beginShape(this.LINES);
					this.vertex(i$1 * spacing - halfSize + xOff, yOff, -halfSize + zOff);
					this.vertex(i$1 * spacing - halfSize + xOff, yOff, +halfSize + zOff);
					this.endShape();
				}
				this.pop();
			};
		};
		fn$1._axesIcon = function(size, xOff, yOff, zOff) {
			if (typeof size === "undefined") size = this.width / 20 > 40 ? this.width / 20 : 40;
			if (typeof xOff === "undefined") xOff = -this.width / 4;
			if (typeof yOff === "undefined") yOff = xOff;
			if (typeof zOff === "undefined") zOff = xOff;
			return () => {
				this.push();
				this._renderer.states.setValue("uModelMatrix", this._renderer.states.uModelMatrix.clone());
				this._renderer.states.uModelMatrix.reset();
				this.strokeWeight(2);
				this.stroke(255, 0, 0);
				this.beginShape(this.LINES);
				this.vertex(xOff, yOff, zOff);
				this.vertex(xOff + size, yOff, zOff);
				this.endShape();
				this.stroke(0, 255, 0);
				this.beginShape(this.LINES);
				this.vertex(xOff, yOff, zOff);
				this.vertex(xOff, yOff + size, zOff);
				this.endShape();
				this.stroke(0, 0, 255);
				this.beginShape(this.LINES);
				this.vertex(xOff, yOff, zOff);
				this.vertex(xOff, yOff, zOff + size);
				this.endShape();
				this.pop();
			};
		};
	}
	if (typeof p5 !== "undefined") interaction(p5, p5.prototype);
	async function fileExists(url) {
		try {
			return (await fetch(url, { method: "HEAD" })).ok;
		} catch (error$1) {
			return false;
		}
	}
	function loading$1(p5$2, fn$1) {
		fn$1.loadModel = async function(path$1, fileType, normalize$1, successCallback, failureCallback) {
			let flipU = false;
			let flipV = false;
			if (typeof fileType === "object") {
				normalize$1 = fileType.normalize || false;
				successCallback = fileType.successCallback;
				failureCallback = fileType.failureCallback;
				fileType = fileType.fileType || fileType;
				flipU = fileType.flipU || false;
				flipV = fileType.flipV || false;
			} else {
				if (typeof arguments[arguments.length - 1] === "function") if (typeof arguments[arguments.length - 2] === "function") {
					successCallback = arguments[arguments.length - 2];
					failureCallback = arguments[arguments.length - 1];
				} else successCallback = arguments[arguments.length - 1];
				if (typeof fileType === "string") {
					if (typeof normalize$1 !== "boolean") normalize$1 = false;
				} else if (typeof fileType === "boolean") {
					normalize$1 = fileType;
					fileType = path$1.slice(-4);
				} else {
					fileType = path$1.slice(-4);
					normalize$1 = false;
				}
			}
			if (fileType.toLowerCase() !== ".obj" && fileType.toLowerCase() !== ".stl") fileType = ".obj";
			const model = new Geometry(void 0, void 0, void 0, this._renderer);
			model.gid = `${path$1}|${normalize$1}`;
			async function getMaterials(lines) {
				const parsedMaterialPromises = [];
				for (let line of lines) {
					const mtllibMatch = line.match(/^mtllib (.+)/);
					if (mtllibMatch) {
						let mtlPath = "";
						const mtlFilename = mtllibMatch[1];
						const objPathParts = path$1.split("/");
						if (objPathParts.length > 1) {
							objPathParts.pop();
							mtlPath = objPathParts.join("/") + "/" + mtlFilename;
						} else mtlPath = mtlFilename;
						parsedMaterialPromises.push(fileExists(mtlPath).then((exists) => {
							if (exists) return parseMtl(mtlPath);
							else {
								console.warn(`MTL file not found or error in parsing; proceeding without materials: ${mtlPath}`);
								return {};
							}
						}).catch((error$1) => {
							console.warn(`Error loading MTL file: ${mtlPath}`, error$1);
							return {};
						}));
					}
				}
				try {
					const parsedMaterials = await Promise.all(parsedMaterialPromises);
					return Object.assign({}, ...parsedMaterials);
				} catch (error$1) {
					return {};
				}
			}
			try {
				if (fileType.match(/\.stl$/i)) {
					const { data: data$2 } = await request(path$1, "arrayBuffer");
					parseSTL(model, data$2);
					if (normalize$1) model.normalize();
					if (flipU) model.flipU();
					if (flipV) model.flipV();
					model._makeTriangleEdges();
					if (successCallback) return successCallback(model);
					else return model;
				} else if (fileType.match(/\.obj$/i)) {
					const { data: data$2 } = await request(path$1, "text");
					const lines = data$2.split("\n");
					parseObj(model, lines, await getMaterials(lines));
					if (normalize$1) model.normalize();
					if (flipU) model.flipU();
					if (flipV) model.flipV();
					model._makeTriangleEdges();
					if (successCallback) return successCallback(model);
					else return model;
				}
			} catch (err$1) {
				p5$2._friendlyFileLoadError(3, path$1);
				if (failureCallback) return failureCallback(err$1);
				else throw err$1;
			}
		};
		async function parseMtl(mtlPath) {
			let currentMaterial = null;
			let materials = {};
			const { data: data$2 } = await request(mtlPath, "text");
			const lines = data$2.split("\n");
			for (let line = 0; line < lines.length; ++line) {
				const tokens = lines[line].trim().split(/\s+/);
				if (tokens[0] === "newmtl") {
					currentMaterial = tokens[1];
					materials[currentMaterial] = {};
				} else if (tokens[0] === "Kd") materials[currentMaterial].diffuseColor = [
					parseFloat(tokens[1]),
					parseFloat(tokens[2]),
					parseFloat(tokens[3])
				];
				else if (tokens[0] === "Ka") materials[currentMaterial].ambientColor = [
					parseFloat(tokens[1]),
					parseFloat(tokens[2]),
					parseFloat(tokens[3])
				];
				else if (tokens[0] === "Ks") materials[currentMaterial].specularColor = [
					parseFloat(tokens[1]),
					parseFloat(tokens[2]),
					parseFloat(tokens[3])
				];
				else if (tokens[0] === "map_Kd") materials[currentMaterial].texturePath = tokens[1];
			}
			return materials;
		}
		function parseObj(model, lines, materials = {}) {
			const loadedVerts = {
				v: [],
				vt: [],
				vn: []
			};
			const usedVerts = {};
			let currentMaterial = null;
			let hasColoredVertices = false;
			let hasColorlessVertices = false;
			for (let line = 0; line < lines.length; ++line) {
				const tokens = lines[line].trim().split(/\b\s+/);
				if (tokens.length > 0) {
					if (tokens[0] === "usemtl") currentMaterial = tokens[1];
					else if (tokens[0] === "v" || tokens[0] === "vn") {
						const vertex$1 = new Vector(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));
						loadedVerts[tokens[0]].push(vertex$1);
					} else if (tokens[0] === "vt") {
						const texVertex = [parseFloat(tokens[1]), 1 - parseFloat(tokens[2])];
						loadedVerts[tokens[0]].push(texVertex);
					} else if (tokens[0] === "f") for (let tri = 3; tri < tokens.length; ++tri) {
						const face = [];
						const vertexTokens = [
							1,
							tri - 1,
							tri
						];
						for (let tokenInd = 0; tokenInd < vertexTokens.length; ++tokenInd) {
							const vertString = tokens[vertexTokens[tokenInd]];
							let vertParts = vertString.split("/");
							for (let i$1 = 0; i$1 < vertParts.length; i$1++) vertParts[i$1] = parseInt(vertParts[i$1]) - 1;
							if (!usedVerts[vertString]) usedVerts[vertString] = {};
							if (usedVerts[vertString][currentMaterial] === void 0) {
								const vertIndex = model.vertices.length;
								model.vertices.push(loadedVerts.v[vertParts[0]].copy());
								model.uvs.push(loadedVerts.vt[vertParts[1]] ? loadedVerts.vt[vertParts[1]].slice() : [0, 0]);
								model.vertexNormals.push(loadedVerts.vn[vertParts[2]] ? loadedVerts.vn[vertParts[2]].copy() : new Vector());
								usedVerts[vertString][currentMaterial] = vertIndex;
								face.push(vertIndex);
								if (currentMaterial && materials[currentMaterial] && materials[currentMaterial].diffuseColor) {
									hasColoredVertices = true;
									const materialDiffuseColor = materials[currentMaterial].diffuseColor;
									model.vertexColors.push(materialDiffuseColor[0]);
									model.vertexColors.push(materialDiffuseColor[1]);
									model.vertexColors.push(materialDiffuseColor[2]);
									model.vertexColors.push(1);
								} else hasColorlessVertices = true;
							} else face.push(usedVerts[vertString][currentMaterial]);
						}
						if (face[0] !== face[1] && face[0] !== face[2] && face[1] !== face[2]) model.faces.push(face);
					}
				}
			}
			if (model.vertexNormals.length === 0) model.computeNormals();
			if (hasColoredVertices === hasColorlessVertices) throw new Error("Model coloring is inconsistent. Either all vertices should have colors or none should.");
			return model;
		}
		function parseSTL(model, buffer) {
			if (isBinary(buffer)) parseBinarySTL(model, buffer);
			else {
				const reader = new DataView(buffer);
				if (!("TextDecoder" in window)) {
					console.warn("Sorry, ASCII STL loading only works in browsers that support TextDecoder (https://caniuse.com/#feat=textencoder)");
					return model;
				}
				parseASCIISTL(model, new TextDecoder("utf-8").decode(reader).split("\n"));
			}
			return model;
		}
		function isBinary(data$2) {
			const reader = new DataView(data$2);
			const solid = [
				115,
				111,
				108,
				105,
				100
			];
			for (let off = 0; off < 5; off++) if (matchDataViewAt(solid, reader, off)) return false;
			return true;
		}
		function matchDataViewAt(query, reader, offset) {
			for (let i$1 = 0, il = query.length; i$1 < il; i$1++) if (query[i$1] !== reader.getUint8(offset + i$1, false)) return false;
			return true;
		}
		function parseBinarySTL(model, buffer) {
			const reader = new DataView(buffer);
			const faces = reader.getUint32(80, true);
			let r, g$1, b$1, hasColors = false, colors;
			let defaultR, defaultG, defaultB;
			for (let index = 0; index < 70; index++) if (reader.getUint32(index, false) === 1129270351 && reader.getUint8(index + 4) === 82 && reader.getUint8(index + 5) === 61) {
				hasColors = true;
				colors = [];
				defaultR = reader.getUint8(index + 6) / 255;
				defaultG = reader.getUint8(index + 7) / 255;
				defaultB = reader.getUint8(index + 8) / 255;
			}
			const dataOffset = 84;
			const faceLength = 50;
			for (let face = 0; face < faces; face++) {
				const start = dataOffset + face * faceLength;
				const normalX = reader.getFloat32(start, true);
				const normalY = reader.getFloat32(start + 4, true);
				const normalZ = reader.getFloat32(start + 8, true);
				if (hasColors) {
					const packedColor = reader.getUint16(start + 48, true);
					if ((packedColor & 32768) === 0) {
						r = (packedColor & 31) / 31;
						g$1 = (packedColor >> 5 & 31) / 31;
						b$1 = (packedColor >> 10 & 31) / 31;
					} else {
						r = defaultR;
						g$1 = defaultG;
						b$1 = defaultB;
					}
				}
				const newNormal = new Vector(normalX, normalY, normalZ);
				for (let i$1 = 1; i$1 <= 3; i$1++) {
					const vertexstart = start + i$1 * 12;
					const newVertex = new Vector(reader.getFloat32(vertexstart, true), reader.getFloat32(vertexstart + 4, true), reader.getFloat32(vertexstart + 8, true));
					model.vertices.push(newVertex);
					model.vertexNormals.push(newNormal);
					if (hasColors) colors.push(r, g$1, b$1);
				}
				model.faces.push([
					3 * face,
					3 * face + 1,
					3 * face + 2
				]);
				model.uvs.push([0, 0], [0, 0], [0, 0]);
			}
			return model;
		}
		function parseASCIISTL(model, lines) {
			let state = "";
			let curVertexIndex = [];
			let newNormal, newVertex;
			for (let iterator = 0; iterator < lines.length; ++iterator) {
				const line = lines[iterator].trim();
				const parts = line.split(" ");
				for (let partsiterator = 0; partsiterator < parts.length; ++partsiterator) if (parts[partsiterator] === "") parts.splice(partsiterator, 1);
				if (parts.length === 0) continue;
				switch (state) {
					case "":
						if (parts[0] !== "solid") {
							console.error(line);
							console.error(`Invalid state "${parts[0]}", should be "solid"`);
							return;
						} else state = "solid";
						break;
					case "solid":
						if (parts[0] !== "facet" || parts[1] !== "normal") {
							console.error(line);
							console.error(`Invalid state "${parts[0]}", should be "facet normal"`);
							return;
						} else {
							newNormal = new Vector(parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4]));
							model.vertexNormals.push(newNormal, newNormal, newNormal);
							state = "facet normal";
						}
						break;
					case "facet normal":
						if (parts[0] !== "outer" || parts[1] !== "loop") {
							console.error(line);
							console.error(`Invalid state "${parts[0]}", should be "outer loop"`);
							return;
						} else state = "vertex";
						break;
					case "vertex":
						if (parts[0] === "vertex") {
							newVertex = new Vector(parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));
							model.vertices.push(newVertex);
							model.uvs.push([0, 0]);
							curVertexIndex.push(model.vertices.indexOf(newVertex));
						} else if (parts[0] === "endloop") {
							model.faces.push(curVertexIndex);
							curVertexIndex = [];
							state = "endloop";
						} else {
							console.error(line);
							console.error(`Invalid state "${parts[0]}", should be "vertex" or "endloop"`);
							return;
						}
						break;
					case "endloop":
						if (parts[0] !== "endfacet") {
							console.error(line);
							console.error(`Invalid state "${parts[0]}", should be "endfacet"`);
							return;
						} else state = "endfacet";
						break;
					case "endfacet":
						if (parts[0] === "endsolid");
						else if (parts[0] === "facet" && parts[1] === "normal") {
							newNormal = new Vector(parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4]));
							model.vertexNormals.push(newNormal, newNormal, newNormal);
							state = "facet normal";
						} else {
							console.error(line);
							console.error(`Invalid state "${parts[0]}", should be "endsolid" or "facet normal"`);
							return;
						}
						break;
					default:
						console.error(`Invalid state "${state}"`);
						break;
				}
			}
			return model;
		}
		fn$1.model = function(model, count = 1) {
			this._assert3d("model");
			this._renderer.model(model, count);
		};
		let modelCounter = 0;
		fn$1.createModel = function(modelString, fileType = " ", options$1) {
			let normalize$1 = false;
			let successCallback;
			let failureCallback;
			let flipU = false;
			let flipV = false;
			if (options$1 && typeof options$1 === "object") {
				normalize$1 = options$1.normalize || false;
				successCallback = options$1.successCallback;
				failureCallback = options$1.failureCallback;
				flipU = options$1.flipU || false;
				flipV = options$1.flipV || false;
			} else if (typeof options$1 === "boolean") {
				normalize$1 = options$1;
				successCallback = arguments[3];
				failureCallback = arguments[4];
			} else {
				successCallback = typeof arguments[2] === "function" ? arguments[2] : void 0;
				failureCallback = arguments[3];
			}
			const model = new p5$2.Geometry();
			model.gid = `${fileType}|${normalize$1}|${modelCounter++}`;
			if (fileType.match(/\.stl$/i)) try {
				let arrayBuffer = new TextEncoder().encode(modelString).buffer;
				parseSTL(model, arrayBuffer);
			} catch (error$1) {
				if (failureCallback) failureCallback(error$1);
				else p5$2._friendlyError("Error during parsing: " + error$1.message);
				return;
			}
			else if (fileType.match(/\.obj$/i)) try {
				parseObj(model, modelString.split("\n"));
			} catch (error$1) {
				if (failureCallback) failureCallback(error$1);
				else p5$2._friendlyError("Error during parsing: " + error$1.message);
				return;
			}
			else {
				p5$2._friendlyFileLoadError(3, modelString);
				if (failureCallback) failureCallback();
				else p5$2._friendlyError("Sorry, the file type is invalid. Only OBJ and STL files are supported.");
			}
			if (normalize$1) model.normalize();
			if (flipU) model.flipU();
			if (flipV) model.flipV();
			model._makeTriangleEdges();
			if (typeof successCallback === "function") successCallback(model);
			return model;
		};
	}
	if (typeof p5 !== "undefined") loading$1(p5, p5.prototype);
	const textCoreConstants = {
		IDEOGRAPHIC: "ideographic",
		RIGHT_TO_LEFT: "rtl",
		LEFT_TO_RIGHT: "ltr",
		_CTX_MIDDLE: "middle",
		_TEXT_BOUNDS: "_textBoundsSingle",
		_FONT_BOUNDS: "_fontBoundsSingle",
		HANGING: "hanging",
		START: "start",
		END: "end"
	};
	function textCore(p5$2, fn$1) {
		const LeadingScale = 1.275;
		const DefaultFill = "#000000";
		const LinebreakRe = /\r?\n/g;
		const CommaDelimRe = /,\s+/;
		const QuotedRe = /^".*"$/;
		const TabsRe = /\t/g;
		const FontVariationSettings = "fontVariationSettings";
		const VariableAxesRe = /* @__PURE__ */ new RegExp(`(?:${[
			"wght",
			"wdth",
			"ital",
			"slnt",
			"opsz"
		].join("|")})`);
		[
			"text",
			"textAlign",
			"textAscent",
			"textDescent",
			"textLeading",
			"textMode",
			"textFont",
			"textSize",
			"textStyle",
			"textWidth",
			"textWrap",
			"textBounds",
			"textDirection",
			"textProperty",
			"textProperties",
			"fontBounds",
			"fontWidth",
			"fontAscent",
			"fontDescent",
			"textWeight"
		].forEach((func) => {
			fn$1[func] = function(...args) {
				if (!(func in Renderer.prototype)) throw Error(`Renderer2D.prototype.${func} is not defined.`);
				return this._renderer[func](...args);
			};
			p5$2.Graphics.prototype[func] = function(...args) {
				return this._renderer[func](...args);
			};
		});
		const RendererTextProps = {
			textAlign: {
				default: fn$1.LEFT,
				type: "Context2d"
			},
			textBaseline: {
				default: fn$1.BASELINE,
				type: "Context2d"
			},
			textFont: { default: { family: "sans-serif" } },
			textLeading: { default: 15 },
			textSize: { default: 12 },
			textWrap: { default: fn$1.WORD },
			fontStretch: {
				default: fn$1.NORMAL,
				isShorthand: true
			},
			fontWeight: {
				default: fn$1.NORMAL,
				isShorthand: true
			},
			lineHeight: {
				default: fn$1.NORMAL,
				isShorthand: true
			},
			fontVariant: {
				default: fn$1.NORMAL,
				isShorthand: true
			},
			fontStyle: {
				default: fn$1.NORMAL,
				isShorthand: true
			},
			direction: { default: "inherit" }
		};
		const ContextTextProps = [
			"font",
			"direction",
			"fontKerning",
			"fontStretch",
			"fontVariantCaps",
			"letterSpacing",
			"textAlign",
			"textBaseline",
			"textRendering",
			"wordSpacing"
		];
		const ShorthandFontProps = Object.keys(RendererTextProps).filter((p$1) => RendererTextProps[p$1].isShorthand);
		const FontStretchKeys = [
			"ultra-condensed",
			"extra-condensed",
			"condensed",
			"semi-condensed",
			"normal",
			"semi-expanded",
			"expanded",
			"extra-expanded",
			"ultra-expanded"
		];
		let contextQueue, cachedDiv;
		Renderer.prototype.text = function(str, x$1, y, width, height) {
			let setBaseline = this.textDrawingContext().textBaseline;
			({x: x$1, y, width, height} = this._handleRectMode(x$1, y, width, height));
			let lines = this._processLines(str, width, height);
			lines = this._positionLines(x$1, y, width, height, lines);
			lines.forEach((line) => this._renderText(line.text, line.x, line.y));
			this.textDrawingContext().textBaseline = setBaseline;
		};
		Renderer.prototype.textBounds = function(str, x$1, y, width, height) {
			return this._computeBounds(textCoreConstants._TEXT_BOUNDS, str, x$1, y, width, height).bounds;
		};
		Renderer.prototype.fontBounds = function(str, x$1, y, width, height) {
			return this._computeBounds(textCoreConstants._FONT_BOUNDS, str, x$1, y, width, height).bounds;
		};
		Renderer.prototype.textWidth = function(theText) {
			let lines = this._processLines(theText);
			return Math.max(...lines.map((l) => this._textWidthSingle(l)));
		};
		Renderer.prototype.fontWidth = function(theText) {
			let lines = this._processLines(theText);
			return Math.max(...lines.map((l) => this._fontWidthSingle(l)));
		};
		Renderer.prototype.textAscent = function(txt = "") {
			if (!txt.length) return this.fontAscent();
			return this.textDrawingContext().measureText(txt).actualBoundingBoxAscent;
		};
		Renderer.prototype.fontAscent = function() {
			return this.textDrawingContext().measureText("_").fontBoundingBoxAscent;
		};
		Renderer.prototype.textDescent = function(txt = "") {
			if (!txt.length) return this.fontDescent();
			return this.textDrawingContext().measureText(txt).actualBoundingBoxDescent;
		};
		Renderer.prototype.fontDescent = function() {
			return this.textDrawingContext().measureText("_").fontBoundingBoxDescent;
		};
		Renderer.prototype.textAlign = function(h, v$1) {
			if (typeof h !== "undefined") {
				this.states.setValue("textAlign", h);
				if (typeof v$1 !== "undefined") {
					if (v$1 === fn$1.CENTER) v$1 = textCoreConstants._CTX_MIDDLE;
					this.states.setValue("textBaseline", v$1);
				}
				return this._applyTextProperties();
			}
			return {
				horizontal: this.states.textAlign,
				vertical: this.states.textBaseline
			};
		};
		Renderer.prototype._currentTextFont = function() {
			return this.states.textFont.font || this.states.textFont.family;
		};
		Renderer.prototype.textFont = function(font$1, size, options$1) {
			if (arguments.length === 0) return this._currentTextFont();
			let family = font$1;
			if (font$1 instanceof p5$2.Font) family = font$1.face.family;
			else if (font$1.data instanceof Uint8Array) {
				family = font$1.name.fontFamily;
				if (font$1.name?.fontSubfamily) family += "-" + font$1.name.fontSubfamily;
			} else if (typeof font$1 === "string") {
				if (typeof size === "undefined" && /[.0-9]+(%|em|p[xt])/.test(family)) ({family, size} = this._directSetFontString(family));
			}
			if (typeof family !== "string") throw Error("null font in textFont()");
			if (arguments.length === 2 && typeof size === "object") {
				options$1 = size;
				size = void 0;
			}
			this.states.setValue("textFont", {
				font: font$1,
				family,
				size
			});
			if (typeof size !== "undefined") this._setTextSize(size);
			if (typeof options$1 === "object") this.textProperties(options$1);
			return this._applyTextProperties();
		};
		Renderer.prototype._directSetFontString = function(font$1, debug = 0) {
			if (debug) console.log("_directSetFontString\"" + font$1 + "\"");
			let defaults$1 = ShorthandFontProps.reduce((props, p$1) => {
				props[p$1] = RendererTextProps[p$1].default;
				return props;
			}, {});
			let el = this._cachedDiv(defaults$1);
			el.style.font = font$1;
			let style = getComputedStyle(el);
			ShorthandFontProps.forEach((prop) => {
				this.states[prop] = style[prop];
				if (debug) console.log("  this.states." + prop + "=\"" + style[prop] + "\"");
			});
			return {
				family: style.fontFamily,
				size: style.fontSize
			};
		};
		Renderer.prototype.textLeading = function(leading) {
			if (typeof leading === "number") {
				this.states.setValue("leadingSet", true);
				this.states.setValue("textLeading", leading);
				return this._applyTextProperties();
			}
			return this.states.textLeading;
		};
		Renderer.prototype.textWeight = function(weight) {
			if (typeof weight === "number") {
				this.states.setValue("fontWeight", weight);
				this._applyTextProperties();
				if (!p5$2.prototype._isSafari()) this._setCanvasStyleProperty("font-variation-settings", `"wght" ${weight}`);
				return;
			}
			return this.states.fontWeight;
		};
		Renderer.prototype.textSize = function(size) {
			if (typeof size !== "undefined") {
				this._setTextSize(size);
				return this._applyTextProperties();
			}
			return this.states.textSize;
		};
		Renderer.prototype.textStyle = function(style) {
			if (typeof style !== "undefined") {
				this.states.setValue("fontStyle", style);
				return this._applyTextProperties();
			}
			return this.states.fontStyle;
		};
		Renderer.prototype.textWrap = function(wrapStyle) {
			if (wrapStyle === fn$1.WORD || wrapStyle === fn$1.CHAR) {
				this.states.setValue("textWrap", wrapStyle);
				return this._pInst;
			}
			return this.states.textWrap;
		};
		Renderer.prototype.textDirection = function(direction) {
			if (typeof direction !== "undefined") {
				this.states.setValue("direction", direction);
				return this._applyTextProperties();
			}
			return this.states.direction;
		};
		Renderer.prototype.textProperty = function(prop, value, opts) {
			let modified = false, debug = opts?.debug || false;
			if (typeof value === "undefined") {
				let props = this.textProperties();
				if (prop in props) return props[prop];
				throw Error("Unknown text option \"" + prop + "\"");
			}
			if (prop in this.states && this.states[prop] !== value) {
				this.states[prop] = value;
				modified = true;
				if (debug) console.log("this.states." + prop + "=\"" + options[prop] + "\"");
			} else if (prop in this.textDrawingContext()) {
				this._setContextProperty(prop, value, debug);
				modified = true;
			} else if (prop in this.textCanvas().style) {
				this._setCanvasStyleProperty(prop, value, debug);
				modified = true;
			} else console.warn("Ignoring unknown text option: \"" + prop + "\"\n");
			return modified ? this._applyTextProperties() : this._pInst;
		};
		Renderer.prototype.textProperties = function(properties) {
			if (typeof properties !== "undefined") {
				Object.keys(properties).forEach((opt) => {
					this.textProperty(opt, properties[opt]);
				});
				return this._pInst;
			}
			let context = this.textDrawingContext();
			properties = ContextTextProps.reduce((props, p$1) => {
				props[p$1] = context[p$1];
				return props;
			}, {});
			Object.keys(RendererTextProps).forEach((p$1) => {
				if (RendererTextProps[p$1]?.type === "Context2d") properties[p$1] = context[p$1];
				else if (p$1 === "textFont") {
					let current = this._currentTextFont();
					if (typeof current === "object" && "_pInst" in current) {
						current = Object.assign({}, current);
						delete current._pInst;
					}
					properties[p$1] = current;
				} else properties[p$1] = this.states[p$1];
			});
			return properties;
		};
		Renderer.prototype.textMode = function() {};
		Renderer.prototype._currentTextFont = function() {
			return this.states.textFont.font || this.states.textFont.family;
		};
		Renderer.prototype._computeBounds = function(type$2, str, x$1, y, width, height, opts) {
			let context = this.textDrawingContext();
			let setBaseline = context.textBaseline;
			let { textLeading, textAlign } = this.states;
			({width, height} = this._rectModeAdjust(x$1, y, width, height));
			let lines = this._processLines(str, width, height);
			let boxes = lines.map((line, i$1) => this[type$2].bind(this)(line, x$1, y + i$1 * textLeading));
			if (lines.length > 1) boxes.forEach((bb) => bb.x += p5$2.Renderer2D.prototype._xAlignOffset.call(this, textAlign, width));
			if (typeof height !== "undefined") p5$2.Renderer2D.prototype._yAlignOffset.call(this, boxes, height);
			let bounds = boxes[0];
			if (lines.length > 1) {
				bounds = this._aggregateBounds(boxes);
				if (!opts?.ignoreRectMode) this._rectModeAlign(bounds, width || 0, height || 0);
			}
			context.textBaseline = setBaseline;
			return {
				bounds,
				lines
			};
		};
		Renderer.prototype._rectModeAdjust = function(x$1, y, width, height) {
			if (typeof width !== "undefined") switch (this.states.rectMode) {
				case fn$1.CENTER: break;
				case fn$1.CORNERS:
					width -= x$1;
					height -= y;
					break;
				case fn$1.RADIUS:
					width *= 2;
					height *= 2;
					break;
			}
			return {
				x: x$1,
				y,
				width,
				height
			};
		};
		Renderer.prototype._setCanvasStyleProperty = function(opt, val$1, debug) {
			let value = val$1.toString();
			if (debug) console.log("canvas.style." + opt + "=\"" + value + "\"");
			if (opt === FontVariationSettings) this._handleFontVariationSettings(value);
			this.textCanvas().style[opt] = value;
			if (this.textCanvas().style[opt] !== value);
		};
		Renderer.prototype._handleFontVariationSettings = function(value, debug = false) {
			if (typeof value === "object") value = Object.keys(value).map((k) => k + " " + value[k]).join(", ");
			value.split(CommaDelimRe).forEach((v$1) => {
				v$1 = v$1.replace(/["']/g, "");
				let matches = VariableAxesRe.exec(v$1);
				if (matches && matches.length) {
					let axis = matches[0];
					let val$1 = parseFloat(parseFloat(v$1.replace(axis, "").trim()).toFixed(3));
					switch (axis) {
						case "wght":
							if (debug) console.log("setting font-weight=" + val$1);
							if (this.states.fontWeight !== val$1) this.textWeight(val$1);
							return val$1;
						case "wdth": break;
						case "ital":
							if (debug) console.log("setting font-style=" + (val$1 ? "italic" : "normal"));
							break;
						case "slnt":
							if (debug) console.log("setting font-style=" + (val$1 ? "oblique" : "normal"));
							break;
						case "opsz":
							if (debug) console.log("setting font-optical-size=" + val$1);
							break;
					}
				}
			});
		};
		Renderer.prototype._setContextProperty = function(prop, val$1, debug = false) {
			if (this.textDrawingContext()[prop] === val$1) return this._pInst;
			(contextQueue ??= []).push([prop, val$1]);
			if (debug) console.log("queued context2d." + prop + "=\"" + val$1 + "\"");
		};
		Renderer.prototype._handleRectMode = function(x$1, y, width, height) {
			let rectMode = this.states.rectMode;
			if (typeof width !== "undefined") switch (rectMode) {
				case fn$1.RADIUS:
					width *= 2;
					x$1 -= width / 2;
					if (typeof height !== "undefined") {
						height *= 2;
						y -= height / 2;
					}
					break;
				case fn$1.CENTER:
					x$1 -= width / 2;
					if (typeof height !== "undefined") y -= height / 2;
					break;
				case fn$1.CORNERS:
					width -= x$1;
					if (typeof height !== "undefined") height -= y;
					break;
			}
			return {
				x: x$1,
				y,
				width,
				height
			};
		};
		Renderer.prototype._fontSizePx = function(theSize, { family } = this.states.textFont) {
			const isNumString = (num) => !isNaN(num) && num.trim() !== "";
			if (isNumString(theSize)) return parseFloat(theSize);
			let ele = this._cachedDiv({ fontSize: theSize });
			ele.style.fontSize = theSize;
			ele.style.fontFamily = family;
			let fontSizeStr = getComputedStyle(ele).fontSize;
			let fontSize = parseFloat(fontSizeStr);
			if (typeof fontSize !== "number") throw Error("textSize: invalid font-size");
			return fontSize;
		};
		Renderer.prototype._cachedDiv = function(props) {
			if (typeof cachedDiv === "undefined") {
				let ele = document.createElement("div");
				ele.ariaHidden = "true";
				ele.style.display = "none";
				Object.entries(props).forEach(([prop, val$1]) => {
					ele.style[prop] = val$1;
				});
				this.textCanvas().appendChild(ele);
				cachedDiv = ele;
			}
			return cachedDiv;
		};
		Renderer.prototype._aggregateBounds = function(bboxes) {
			let minX = Math.min(...bboxes.map((b$1) => b$1.x));
			let minY = Math.min(...bboxes.map((b$1) => b$1.y));
			let maxY = Math.max(...bboxes.map((b$1) => b$1.y + b$1.h));
			return {
				x: minX,
				y: minY,
				w: Math.max(...bboxes.map((b$1) => b$1.x + b$1.w)) - minX,
				h: maxY - minY
			};
		};
		Renderer.prototype._processLines = function(str, width, height) {
			if (typeof width !== "undefined") {
				if (this.textDrawingContext().textBaseline === fn$1.BASELINE) this.drawingContext.textBaseline = fn$1.TOP;
			}
			let lines = this._splitOnBreaks(str.toString());
			let hasLineBreaks = lines.length > 1;
			let hasWidth = typeof width !== "undefined";
			let exceedsWidth = hasWidth && lines.some((l) => this._textWidthSingle(l) > width);
			let { textLeading: leading, textWrap } = this.states;
			if (hasLineBreaks || exceedsWidth) {
				if (hasWidth) lines = this._lineate(textWrap, lines, width);
			}
			if (hasWidth && typeof height !== "undefined") {
				if (typeof leading === "undefined") throw Error("leading is required if height is specified");
				for (let i$1 = 0; i$1 < lines.length; i$1++) if (leading * (i$1 + 1) > height) {
					lines = lines.slice(0, i$1);
					break;
				}
			}
			return lines;
		};
		Renderer.prototype._xAlignOffset = function(textAlign, width) {
			switch (textAlign) {
				case fn$1.LEFT: return 0;
				case fn$1.CENTER: return width / 2;
				case fn$1.RIGHT: return width;
				case textCoreConstants.START: return 0;
				case textCoreConstants.END: throw new Error("textBounds: END not yet supported for textAlign");
				default: return 0;
			}
		};
		Renderer.prototype._rectModeAlign = function(bb, width, height) {
			if (typeof width !== "undefined") {
				switch (this.states.rectMode) {
					case fn$1.CENTER:
						bb.x -= (width - bb.w) / 2;
						bb.y -= (height - bb.h) / 2;
						break;
					case fn$1.CORNERS:
						bb.w += bb.x;
						bb.h += bb.y;
						break;
					case fn$1.RADIUS:
						bb.x -= (width - bb.w) / 2;
						bb.y -= (height - bb.h) / 2;
						bb.w /= 2;
						bb.h /= 2;
						break;
				}
				return bb;
			}
		};
		Renderer.prototype._rectModeAlignRevert = function(bb, width, height) {
			if (typeof width !== "undefined") {
				switch (this.states.rectMode) {
					case fn$1.CENTER:
						bb.x += (width - bb.w) / 2;
						bb.y += (height - bb.h) / 2;
						break;
					case fn$1.CORNERS:
						bb.w -= bb.x;
						bb.h -= bb.y;
						break;
					case fn$1.RADIUS:
						bb.x += (width - bb.w) / 2;
						bb.y += (height - bb.h) / 2;
						bb.w *= 2;
						bb.h *= 2;
						break;
				}
				return bb;
			}
		};
		Renderer.prototype._textWidthSingle = function(s) {
			let metrics = this.textDrawingContext().measureText(s);
			let abl = metrics.actualBoundingBoxLeft;
			return metrics.actualBoundingBoxRight + abl;
		};
		Renderer.prototype._fontWidthSingle = function(s) {
			return this.textDrawingContext().measureText(s).width;
		};
		Renderer.prototype._textBoundsSingle = function(s, x$1 = 0, y = 0) {
			let metrics = this.textDrawingContext().measureText(s);
			let asc = metrics.actualBoundingBoxAscent;
			let desc = metrics.actualBoundingBoxDescent;
			let abl = metrics.actualBoundingBoxLeft;
			let abr = metrics.actualBoundingBoxRight;
			return {
				x: x$1 - abl,
				y: y - asc,
				w: abr + abl,
				h: asc + desc
			};
		};
		Renderer.prototype._fontBoundsSingle = function(s, x$1 = 0, y = 0) {
			let metrics = this.textDrawingContext().measureText(s);
			let asc = metrics.fontBoundingBoxAscent;
			let desc = metrics.fontBoundingBoxDescent;
			x$1 -= this._xAlignOffset(this.states.textAlign, metrics.width);
			return {
				x: x$1,
				y: y - asc,
				w: metrics.width,
				h: asc + desc
			};
		};
		Renderer.prototype._setTextSize = function(theSize) {
			if (typeof theSize === "string") theSize = this._fontSizePx(theSize);
			if (typeof theSize === "number") {
				if (this.states.textSize !== theSize) {
					this.states.setValue("textSize", theSize);
					if (!this.states.leadingSet) this.states.setValue("textLeading", this.states.textSize * LeadingScale);
					return true;
				}
			} else console.warn("textSize: invalid size: " + theSize);
			return false;
		};
		Renderer.prototype._lineate = function(textWrap, lines, maxWidth = Infinity, opts = {}) {
			let splitter = opts.splitChar ?? (textWrap === fn$1.WORD ? " " : "");
			let line, testLine, testWidth, words, newLines = [];
			for (let lidx = 0; lidx < lines.length; lidx++) {
				line = "";
				words = lines[lidx].split(splitter);
				for (let widx = 0; widx < words.length; widx++) {
					testLine = `${line + words[widx]}` + splitter;
					testWidth = this._textWidthSingle(testLine);
					if (line.length > 0 && testWidth > maxWidth) {
						newLines.push(line.trim());
						line = `${words[widx]}` + splitter;
					} else line = testLine;
				}
				newLines.push(line.trim());
			}
			return newLines;
		};
		Renderer.prototype._splitOnBreaks = function(s) {
			if (!s || s.length === 0) return [""];
			return s.replace(TabsRe, "  ").split(LinebreakRe);
		};
		Renderer.prototype._parseFontFamily = function(familyStr) {
			return familyStr.split(CommaDelimRe).map((part) => {
				part = part.trim();
				if (part.indexOf(" ") > -1 && !QuotedRe.test(part)) part = `"${part}"`;
				return part;
			}).join(", ");
		};
		Renderer.prototype._applyFontString = function() {
			let { textFont, textSize, lineHeight, fontStyle, fontWeight, fontVariant } = this.states;
			let drawingContext = this.textDrawingContext();
			let family = this._parseFontFamily(textFont.family);
			let style = fontStyle !== fn$1.NORMAL ? `${fontStyle} ` : "";
			let weight = fontWeight !== fn$1.NORMAL ? `${fontWeight} ` : "";
			let fontString = `${style}${fontVariant !== fn$1.NORMAL ? `${fontVariant} ` : ""}${weight}${`${textSize}px` + (lineHeight !== fn$1.NORMAL ? `/${lineHeight} ` : " ")}${family}`.trim();
			drawingContext.font = fontString;
			if (drawingContext.font !== fontString) {
				if (fontString !== drawingContext.font) return false;
			}
			return true;
		};
		Renderer.prototype._applyTextProperties = function(debug = false) {
			this._applyFontString();
			let context = this.textDrawingContext();
			context.direction = this.states.direction;
			context.textAlign = this.states.textAlign;
			context.textBaseline = this.states.textBaseline;
			let stretch = this.states.fontStretch;
			if (FontStretchKeys.includes(stretch) && context.fontStretch !== stretch) context.fontStretch = stretch;
			while (contextQueue?.length) {
				let [prop, val$1] = contextQueue.shift();
				if (debug) console.log("apply context property \"" + prop + "\" = \"" + val$1 + "\"");
				context[prop] = val$1;
				if (context[prop] !== val$1) {
					console.warn(`Unable to set '${prop}' property on context2d. It may not be supported.`);
					console.log("Expected \"" + val$1 + "\" but got: \"" + context[prop] + "\"");
				}
			}
			return this._pInst;
		};
		if (p5$2.Renderer2D) {
			p5$2.Renderer2D.prototype.textCanvas = function() {
				return this.canvas;
			};
			p5$2.Renderer2D.prototype.textDrawingContext = function() {
				return this.drawingContext;
			};
			p5$2.Renderer2D.prototype._renderText = function(text$1, x$1, y, maxY, minY) {
				let states = this.states;
				let context = this.textDrawingContext();
				if (y < minY || y >= maxY) return;
				this.push();
				if (states.strokeColor && states.strokeSet) context.strokeText(text$1, x$1, y);
				if (!this._clipping && states.fillColor) {
					if (!states.fillSet) this._setFill(DefaultFill);
					context.fillText(text$1, x$1, y);
				}
				this.pop();
			};
			p5$2.Renderer2D.prototype._positionLines = function(x$1, y, width, height, lines) {
				let { textLeading, textAlign } = this.states;
				let adjustedX, lineData = new Array(lines.length);
				let adjustedW = typeof width === "undefined" ? 0 : width;
				let adjustedH = typeof height === "undefined" ? 0 : height;
				for (let i$1 = 0; i$1 < lines.length; i$1++) {
					switch (textAlign) {
						case textCoreConstants.START: throw new Error("textBounds: START not yet supported for textAlign");
						case fn$1.LEFT:
							adjustedX = x$1;
							break;
						case fn$1.CENTER:
							adjustedX = x$1 + adjustedW / 2;
							break;
						case fn$1.RIGHT:
							adjustedX = x$1 + adjustedW;
							break;
						case textCoreConstants.END: throw new Error("textBounds: END not yet supported for textAlign");
					}
					lineData[i$1] = {
						text: lines[i$1],
						x: adjustedX,
						y: y + i$1 * textLeading
					};
				}
				return this._yAlignOffset(lineData, adjustedH);
			};
			p5$2.Renderer2D.prototype._yAlignOffset = function(dataArr, height) {
				if (typeof height === "undefined") throw Error("_yAlignOffset: height is required");
				let { textLeading, textBaseline } = this.states;
				let yOff = 0;
				let ydiff = height - textLeading * (dataArr.length - 1);
				switch (textBaseline) {
					case fn$1.TOP: break;
					case fn$1.BASELINE: break;
					case textCoreConstants._CTX_MIDDLE:
						yOff = ydiff / 2;
						break;
					case fn$1.BOTTOM:
						yOff = ydiff;
						break;
					case textCoreConstants.IDEOGRAPHIC:
						console.warn("textBounds: IDEOGRAPHIC not yet supported for textBaseline");
						break;
					case textCoreConstants.HANGING:
						console.warn("textBounds: HANGING not yet supported for textBaseline");
						break;
				}
				dataArr.forEach((ele) => ele.y += yOff);
				return dataArr;
			};
		}
		if (p5$2.RendererGL) {
			p5$2.RendererGL.prototype.textCanvas = function() {
				if (!this._textCanvas) {
					this._textCanvas = document.createElement("canvas");
					this._textCanvas.width = 1;
					this._textCanvas.height = 1;
					this._textCanvas.style.display = "none";
					this.canvas.parentElement.insertBefore(this._textCanvas, this.canvas);
				}
				return this._textCanvas;
			};
			p5$2.RendererGL.prototype.textDrawingContext = function() {
				if (!this._textDrawingContext) this._textDrawingContext = this.textCanvas().getContext("2d");
				return this._textDrawingContext;
			};
			const oldRemove = p5$2.RendererGL.prototype.remove;
			p5$2.RendererGL.prototype.remove = function() {
				if (this._textCanvas) this._textCanvas.parentElement.removeChild(this._textCanvas);
				oldRemove.call(this);
			};
			p5$2.RendererGL.prototype._positionLines = function(x$1, y, width, height, lines) {
				let { textLeading, textAlign } = this.states;
				const widths = lines.map((line) => this._fontWidthSingle(line));
				let adjustedX, lineData = new Array(lines.length);
				let adjustedW = typeof width === "undefined" ? Math.max(0, ...widths) : width;
				let adjustedH = typeof height === "undefined" ? 0 : height;
				for (let i$1 = 0; i$1 < lines.length; i$1++) {
					switch (textAlign) {
						case textCoreConstants.START: throw new Error("textBounds: START not yet supported for textAlign");
						case fn$1.LEFT:
							adjustedX = x$1;
							break;
						case fn$1.CENTER:
							adjustedX = x$1 + (adjustedW - widths[i$1]) / 2 - adjustedW / 2 + (width || 0) / 2;
							break;
						case fn$1.RIGHT:
							adjustedX = x$1 + adjustedW - widths[i$1] - adjustedW + (width || 0);
							break;
						case textCoreConstants.END: throw new Error("textBounds: END not yet supported for textAlign");
					}
					lineData[i$1] = {
						text: lines[i$1],
						x: adjustedX,
						y: y + i$1 * textLeading
					};
				}
				return this._yAlignOffset(lineData, adjustedH);
			};
			p5$2.RendererGL.prototype._yAlignOffset = function(dataArr, height) {
				if (typeof height === "undefined") throw Error("_yAlignOffset: height is required");
				let { textLeading, textBaseline, textSize, textFont } = this.states;
				let yOff = 0, numLines = dataArr.length;
				let totalHeight = textSize * numLines + (textLeading - textSize) * (numLines - 1);
				switch (textBaseline) {
					case fn$1.TOP:
						yOff = textSize;
						break;
					case fn$1.BASELINE: break;
					case textCoreConstants._CTX_MIDDLE:
						yOff = -totalHeight / 2 + textSize + (height || 0) / 2;
						break;
					case fn$1.BOTTOM:
						yOff = -(totalHeight - textSize) + (height || 0);
						break;
					default:
						console.warn(`${textBaseline} is not supported in WebGL mode.`);
						break;
				}
				yOff += this.states.textFont.font?._verticalAlign(textSize) || 0;
				dataArr.forEach((ele) => ele.y += yOff);
				return dataArr;
			};
		}
	}
	if (typeof p5 !== "undefined") textCore(p5, p5.prototype);
	var import_lib = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports) => {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.UnicodeRange = function() {
			function UnicodeRange$2() {}
			UnicodeRange$2.parse = function(arr$1) {
				var result = /* @__PURE__ */ new Set();
				for (var _i = 0, arr_1 = arr$1; _i < arr_1.length; _i++) {
					var range$1 = arr_1[_i];
					if (!UnicodeRange$2.REGEXP.test(range$1)) throw new TypeError("\"" + range$1 + "\" is invalid unicode-range.");
					var _a = range$1.match(UnicodeRange$2.REGEXP), single = _a[1], start = _a[2], end = _a[3];
					if (single) {
						if (/\?[^?]+$/.test(single)) throw new TypeError("\"" + range$1 + "\" is invalid unicode-range.");
						if (single.includes("?")) {
							var start_1 = single.replace(/\?/g, "0");
							var end_1 = single.replace(/\?/g, "F");
							var tmp = UnicodeRange$2.parse(["U+" + start_1 + "-" + end_1]);
							for (var _b = 0, tmp_1 = tmp; _b < tmp_1.length; _b++) {
								var codePoint = tmp_1[_b];
								result.add(codePoint);
							}
						} else result.add(parseInt(single, 16));
					}
					if (start && end) {
						var startCodePoint = parseInt(start, 16);
						var endCodePoint = parseInt(end, 16);
						for (var codePoint = startCodePoint; codePoint <= endCodePoint; codePoint++) result.add(codePoint);
					}
				}
				return Array.from(result).sort(function(a, b$1) {
					return a - b$1;
				});
			};
			UnicodeRange$2.stringify = function(arr$1) {
				var sorted = Array.from(new Set(arr$1)).sort(function(a, b$1) {
					return a - b$1;
				});
				var results = [];
				var rangeStart;
				for (var idx = 0; idx < sorted.length; idx++) {
					var current = sorted[idx];
					var prev = sorted[idx - 1];
					if (rangeStart && current - prev !== 1) {
						results.push(UnicodeRange$2.rangeString(rangeStart, prev));
						rangeStart = current;
					}
					if (!rangeStart) rangeStart = current;
					if (idx === sorted.length - 1) if (rangeStart === current) results.push(UnicodeRange$2.rangeString(current));
					else results.push(UnicodeRange$2.rangeString(rangeStart, current));
				}
				return results;
			};
			UnicodeRange$2.rangeString = function(start, end) {
				if (!end || start === end) return "U+" + start.toString(16);
				return "U+" + start.toString(16) + "-" + end.toString(16);
			};
			UnicodeRange$2.REGEXP = /^u\+(?:([0-9a-f]?[0-9a-f?]{1,5})|([0-9a-f]{1,6})-([0-9a-f]{1,6}))?$/i;
			return UnicodeRange$2;
		}();
	})))());
	const unicodeRanges = [
		{
			category: "control character",
			hexrange: ["0000", "001f"]
		},
		{
			category: "basic latin",
			hexrange: ["0000", "007f"]
		},
		{
			category: "latin-1 supplement",
			hexrange: ["0080", "00ff"]
		},
		{
			category: "latin extended-a",
			hexrange: ["0100", "017f"]
		},
		{
			category: "latin extended-b",
			hexrange: ["0180", "024f"]
		},
		{
			category: "ipa extensions",
			hexrange: ["0250", "02af"]
		},
		{
			category: "spacing modifier letters",
			hexrange: ["02b0", "02ff"]
		},
		{
			category: "combining diacritical marks",
			hexrange: ["0300", "036f"]
		},
		{
			category: "greek and coptic",
			hexrange: ["0370", "03ff"]
		},
		{
			category: "cyrillic",
			hexrange: ["0400", "04ff"]
		},
		{
			category: "cyrillic supplement",
			hexrange: ["0500", "052f"]
		},
		{
			category: "armenian",
			hexrange: ["0530", "058f"]
		},
		{
			category: "hebrew",
			hexrange: ["0590", "05ff"]
		},
		{
			category: "arabic",
			hexrange: ["0600", "06ff"]
		},
		{
			category: "syriac",
			hexrange: ["0700", "074f"]
		},
		{
			category: "arabic supplement",
			hexrange: ["0750", "077f"]
		},
		{
			category: "thaana",
			hexrange: ["0780", "07bf"]
		},
		{
			category: "nko",
			hexrange: ["07c0", "07ff"]
		},
		{
			category: "samaritan",
			hexrange: ["0800", "083f"]
		},
		{
			category: "mandaic",
			hexrange: ["0840", "085f"]
		},
		{
			category: "syriac supplement",
			hexrange: ["0860", "086f"]
		},
		{
			category: "arabic extended-b",
			hexrange: ["0870", "089f"]
		},
		{
			category: "arabic extended-a",
			hexrange: ["08a0", "08ff"]
		},
		{
			category: "devanagari",
			hexrange: ["0900", "097f"]
		},
		{
			category: "bengali",
			hexrange: ["0980", "09ff"]
		},
		{
			category: "gurmukhi",
			hexrange: ["0a00", "0a7f"]
		},
		{
			category: "gujarati",
			hexrange: ["0a80", "0aff"]
		},
		{
			category: "oriya",
			hexrange: ["0b00", "0b7f"]
		},
		{
			category: "tamil",
			hexrange: ["0b80", "0bff"]
		},
		{
			category: "telugu",
			hexrange: ["0c00", "0c7f"]
		},
		{
			category: "kannada",
			hexrange: ["0c80", "0cff"]
		},
		{
			category: "malayalam",
			hexrange: ["0d00", "0d7f"]
		},
		{
			category: "sinhala",
			hexrange: ["0d80", "0dff"]
		},
		{
			category: "thai",
			hexrange: ["0e00", "0e7f"]
		},
		{
			category: "lao",
			hexrange: ["0e80", "0eff"]
		},
		{
			category: "tibetan",
			hexrange: ["0f00", "0fff"]
		},
		{
			category: "myanmar",
			hexrange: ["1000", "109f"]
		},
		{
			category: "georgian",
			hexrange: ["10a0", "10ff"]
		},
		{
			category: "hangul jamo",
			hexrange: ["1100", "11ff"]
		},
		{
			category: "ethiopic",
			hexrange: ["1200", "137f"]
		},
		{
			category: "ethiopic supplement",
			hexrange: ["1380", "139f"]
		},
		{
			category: "cherokee",
			hexrange: ["13a0", "13ff"]
		},
		{
			category: "unified canadian aboriginal syllabics",
			hexrange: ["1400", "167f"]
		},
		{
			category: "ogham",
			hexrange: ["1680", "169f"]
		},
		{
			category: "runic",
			hexrange: ["16a0", "16ff"]
		},
		{
			category: "tagalog",
			hexrange: ["1700", "171f"]
		},
		{
			category: "hanunoo",
			hexrange: ["1720", "173f"]
		},
		{
			category: "buhid",
			hexrange: ["1740", "175f"]
		},
		{
			category: "tagbanwa",
			hexrange: ["1760", "177f"]
		},
		{
			category: "khmer",
			hexrange: ["1780", "17ff"]
		},
		{
			category: "mongolian",
			hexrange: ["1800", "18af"]
		},
		{
			category: "unified canadian aboriginal syllabics extended",
			hexrange: ["18b0", "18ff"]
		},
		{
			category: "limbu",
			hexrange: ["1900", "194f"]
		},
		{
			category: "tai le",
			hexrange: ["1950", "197f"]
		},
		{
			category: "new tai lue",
			hexrange: ["1980", "19df"]
		},
		{
			category: "khmer symbols",
			hexrange: ["19e0", "19ff"]
		},
		{
			category: "buginese",
			hexrange: ["1a00", "1a1f"]
		},
		{
			category: "tai tham",
			hexrange: ["1a20", "1aaf"]
		},
		{
			category: "combining diacritical marks extended",
			hexrange: ["1ab0", "1aff"]
		},
		{
			category: "balinese",
			hexrange: ["1b00", "1b7f"]
		},
		{
			category: "sundanese",
			hexrange: ["1b80", "1bbf"]
		},
		{
			category: "batak",
			hexrange: ["1bc0", "1bff"]
		},
		{
			category: "lepcha",
			hexrange: ["1c00", "1c4f"]
		},
		{
			category: "ol chiki",
			hexrange: ["1c50", "1c7f"]
		},
		{
			category: "cyrillic extended-c",
			hexrange: ["1c80", "1c8f"]
		},
		{
			category: "georgian extended",
			hexrange: ["1c90", "1cbf"]
		},
		{
			category: "sundanese supplement",
			hexrange: ["1cc0", "1ccf"]
		},
		{
			category: "vedic extensions",
			hexrange: ["1cd0", "1cff"]
		},
		{
			category: "phonetic extensions",
			hexrange: ["1d00", "1d7f"]
		},
		{
			category: "phonetic extensions supplement",
			hexrange: ["1d80", "1dbf"]
		},
		{
			category: "combining diacritical marks supplement",
			hexrange: ["1dc0", "1dff"]
		},
		{
			category: "latin extended additional",
			hexrange: ["1e00", "1eff"]
		},
		{
			category: "greek extended",
			hexrange: ["1f00", "1fff"]
		},
		{
			category: "general punctuation",
			hexrange: ["2000", "206f"]
		},
		{
			category: "superscripts and subscripts",
			hexrange: ["2070", "209f"]
		},
		{
			category: "currency symbols",
			hexrange: ["20a0", "20cf"]
		},
		{
			category: "combining diacritical marks for symbols",
			hexrange: ["20d0", "20ff"]
		},
		{
			category: "letterlike symbols",
			hexrange: ["2100", "214f"]
		},
		{
			category: "number forms",
			hexrange: ["2150", "218f"]
		},
		{
			category: "arrows",
			hexrange: ["2190", "21ff"]
		},
		{
			category: "mathematical operators",
			hexrange: ["2200", "22ff"]
		},
		{
			category: "miscellaneous technical",
			hexrange: ["2300", "23ff"]
		},
		{
			category: "control pictures",
			hexrange: ["2400", "243f"]
		},
		{
			category: "optical character recognition",
			hexrange: ["2440", "245f"]
		},
		{
			category: "enclosed alphanumerics",
			hexrange: ["2460", "24ff"]
		},
		{
			category: "box drawing",
			hexrange: ["2500", "257f"]
		},
		{
			category: "block elements",
			hexrange: ["2580", "259f"]
		},
		{
			category: "geometric shapes",
			hexrange: ["25a0", "25ff"]
		},
		{
			category: "miscellaneous symbols",
			hexrange: ["2600", "26ff"]
		},
		{
			category: "dingbats",
			hexrange: ["2700", "27bf"]
		},
		{
			category: "miscellaneous mathematical symbols-a",
			hexrange: ["27c0", "27ef"]
		},
		{
			category: "supplemental arrows-a",
			hexrange: ["27f0", "27ff"]
		},
		{
			category: "braille patterns",
			hexrange: ["2800", "28ff"]
		},
		{
			category: "supplemental arrows-b",
			hexrange: ["2900", "297f"]
		},
		{
			category: "miscellaneous mathematical symbols-b",
			hexrange: ["2980", "29ff"]
		},
		{
			category: "supplemental mathematical operators",
			hexrange: ["2a00", "2aff"]
		},
		{
			category: "miscellaneous symbols and arrows",
			hexrange: ["2b00", "2bff"]
		},
		{
			category: "glagolitic",
			hexrange: ["2c00", "2c5f"]
		},
		{
			category: "latin extended-c",
			hexrange: ["2c60", "2c7f"]
		},
		{
			category: "coptic",
			hexrange: ["2c80", "2cff"]
		},
		{
			category: "georgian supplement",
			hexrange: ["2d00", "2d2f"]
		},
		{
			category: "tifinagh",
			hexrange: ["2d30", "2d7f"]
		},
		{
			category: "ethiopic extended",
			hexrange: ["2d80", "2ddf"]
		},
		{
			category: "cyrillic extended-a",
			hexrange: ["2de0", "2dff"]
		},
		{
			category: "supplemental punctuation",
			hexrange: ["2e00", "2e7f"]
		},
		{
			category: "cjk radicals supplement",
			hexrange: ["2e80", "2eff"]
		},
		{
			category: "kangxi radicals",
			hexrange: ["2f00", "2fdf"]
		},
		{
			category: "ideographic description characters",
			hexrange: ["2ff0", "2fff"]
		},
		{
			category: "cjk symbols and punctuation",
			hexrange: ["3000", "303f"]
		},
		{
			category: "hiragana",
			hexrange: ["3040", "309f"]
		},
		{
			category: "katakana",
			hexrange: ["30a0", "30ff"]
		},
		{
			category: "bopomofo",
			hexrange: ["3100", "312f"]
		},
		{
			category: "hangul compatibility jamo",
			hexrange: ["3130", "318f"]
		},
		{
			category: "kanbun",
			hexrange: ["3190", "319f"]
		},
		{
			category: "bopomofo extended",
			hexrange: ["31a0", "31bf"]
		},
		{
			category: "cjk strokes",
			hexrange: ["31c0", "31ef"]
		},
		{
			category: "katakana phonetic extensions",
			hexrange: ["31f0", "31ff"]
		},
		{
			category: "enclosed cjk letters and months",
			hexrange: ["3200", "32ff"]
		},
		{
			category: "cjk compatibility",
			hexrange: ["3300", "33ff"]
		},
		{
			category: "cjk unified ideographs extension a",
			hexrange: ["3400", "4dbf"]
		},
		{
			category: "yijing hexagram symbols",
			hexrange: ["4dc0", "4dff"]
		},
		{
			category: "cjk unified ideographs",
			hexrange: ["4e00", "9fff"]
		},
		{
			category: "yi syllables",
			hexrange: ["a000", "a48f"]
		},
		{
			category: "yi radicals",
			hexrange: ["a490", "a4cf"]
		},
		{
			category: "lisu",
			hexrange: ["a4d0", "a4ff"]
		},
		{
			category: "vai",
			hexrange: ["a500", "a63f"]
		},
		{
			category: "cyrillic extended-b",
			hexrange: ["a640", "a69f"]
		},
		{
			category: "bamum",
			hexrange: ["a6a0", "a6ff"]
		},
		{
			category: "modifier tone letters",
			hexrange: ["a700", "a71f"]
		},
		{
			category: "latin extended-d",
			hexrange: ["a720", "a7ff"]
		},
		{
			category: "syloti nagri",
			hexrange: ["a800", "a82f"]
		},
		{
			category: "common indic number forms",
			hexrange: ["a830", "a83f"]
		},
		{
			category: "phags-pa",
			hexrange: ["a840", "a87f"]
		},
		{
			category: "saurashtra",
			hexrange: ["a880", "a8df"]
		},
		{
			category: "devanagari extended",
			hexrange: ["a8e0", "a8ff"]
		},
		{
			category: "kayah li",
			hexrange: ["a900", "a92f"]
		},
		{
			category: "rejang",
			hexrange: ["a930", "a95f"]
		},
		{
			category: "hangul jamo extended-a",
			hexrange: ["a960", "a97f"]
		},
		{
			category: "javanese",
			hexrange: ["a980", "a9df"]
		},
		{
			category: "myanmar extended-b",
			hexrange: ["a9e0", "a9ff"]
		},
		{
			category: "cham",
			hexrange: ["aa00", "aa5f"]
		},
		{
			category: "myanmar extended-a",
			hexrange: ["aa60", "aa7f"]
		},
		{
			category: "tai viet",
			hexrange: ["aa80", "aadf"]
		},
		{
			category: "meetei mayek extensions",
			hexrange: ["aae0", "aaff"]
		},
		{
			category: "ethiopic extended-a",
			hexrange: ["ab00", "ab2f"]
		},
		{
			category: "latin extended-e",
			hexrange: ["ab30", "ab6f"]
		},
		{
			category: "cherokee supplement",
			hexrange: ["ab70", "abbf"]
		},
		{
			category: "meetei mayek",
			hexrange: ["abc0", "abff"]
		},
		{
			category: "hangul syllables",
			hexrange: ["ac00", "d7af"]
		},
		{
			category: "hangul jamo extended-b",
			hexrange: ["d7b0", "d7ff"]
		},
		{
			category: "high surrogates",
			hexrange: ["d800", "db7f"]
		},
		{
			category: "high private use surrogates",
			hexrange: ["db80", "dbff"]
		},
		{
			category: "low surrogates",
			hexrange: ["dc00", "dfff"]
		},
		{
			category: "private use area",
			hexrange: ["e000", "f8ff"]
		},
		{
			category: "cjk compatibility ideographs",
			hexrange: ["f900", "faff"]
		},
		{
			category: "alphabetic presentation forms",
			hexrange: ["fb00", "fb4f"]
		},
		{
			category: "arabic presentation forms-a",
			hexrange: ["fb50", "fdff"]
		},
		{
			category: "variation selectors",
			hexrange: ["fe00", "fe0f"]
		},
		{
			category: "vertical forms",
			hexrange: ["fe10", "fe1f"]
		},
		{
			category: "combining half marks",
			hexrange: ["fe20", "fe2f"]
		},
		{
			category: "cjk compatibility forms",
			hexrange: ["fe30", "fe4f"]
		},
		{
			category: "small form variants",
			hexrange: ["fe50", "fe6f"]
		},
		{
			category: "arabic presentation forms-b",
			hexrange: ["fe70", "feff"]
		},
		{
			category: "halfwidth and fullwidth forms",
			hexrange: ["ff00", "ffef"]
		},
		{
			category: "specials",
			hexrange: ["fff0", "ffff"]
		},
		{
			category: "linear b syllabary",
			hexrange: ["10000", "1007f"]
		},
		{
			category: "linear b ideograms",
			hexrange: ["10080", "100ff"]
		},
		{
			category: "aegean numbers",
			hexrange: ["10100", "1013f"]
		},
		{
			category: "ancient greek numbers",
			hexrange: ["10140", "1018f"]
		},
		{
			category: "ancient symbols",
			hexrange: ["10190", "101cf"]
		},
		{
			category: "phaistos disc",
			hexrange: ["101d0", "101ff"]
		},
		{
			category: "lycian",
			hexrange: ["10280", "1029f"]
		},
		{
			category: "carian",
			hexrange: ["102a0", "102df"]
		},
		{
			category: "coptic epact numbers",
			hexrange: ["102e0", "102ff"]
		},
		{
			category: "old italic",
			hexrange: ["10300", "1032f"]
		},
		{
			category: "gothic",
			hexrange: ["10330", "1034f"]
		},
		{
			category: "old permic",
			hexrange: ["10350", "1037f"]
		},
		{
			category: "ugaritic",
			hexrange: ["10380", "1039f"]
		},
		{
			category: "old persian",
			hexrange: ["103a0", "103df"]
		},
		{
			category: "deseret",
			hexrange: ["10400", "1044f"]
		},
		{
			category: "shavian",
			hexrange: ["10450", "1047f"]
		},
		{
			category: "osmanya",
			hexrange: ["10480", "104af"]
		},
		{
			category: "osage",
			hexrange: ["104b0", "104ff"]
		},
		{
			category: "elbasan",
			hexrange: ["10500", "1052f"]
		},
		{
			category: "caucasian albanian",
			hexrange: ["10530", "1056f"]
		},
		{
			category: "vithkuqi",
			hexrange: ["10570", "105bf"]
		},
		{
			category: "linear a",
			hexrange: ["10600", "1077f"]
		},
		{
			category: "latin extended-f",
			hexrange: ["10780", "107bf"]
		},
		{
			category: "cypriot syllabary",
			hexrange: ["10800", "1083f"]
		},
		{
			category: "imperial aramaic",
			hexrange: ["10840", "1085f"]
		},
		{
			category: "palmyrene",
			hexrange: ["10860", "1087f"]
		},
		{
			category: "nabataean",
			hexrange: ["10880", "108af"]
		},
		{
			category: "hatran",
			hexrange: ["108e0", "108ff"]
		},
		{
			category: "phoenician",
			hexrange: ["10900", "1091f"]
		},
		{
			category: "lydian",
			hexrange: ["10920", "1093f"]
		},
		{
			category: "meroitic hieroglyphs",
			hexrange: ["10980", "1099f"]
		},
		{
			category: "meroitic cursive",
			hexrange: ["109a0", "109ff"]
		},
		{
			category: "kharoshthi",
			hexrange: ["10a00", "10a5f"]
		},
		{
			category: "old south arabian",
			hexrange: ["10a60", "10a7f"]
		},
		{
			category: "old north arabian",
			hexrange: ["10a80", "10a9f"]
		},
		{
			category: "manichaean",
			hexrange: ["10ac0", "10aff"]
		},
		{
			category: "avestan",
			hexrange: ["10b00", "10b3f"]
		},
		{
			category: "inscriptional parthian",
			hexrange: ["10b40", "10b5f"]
		},
		{
			category: "inscriptional pahlavi",
			hexrange: ["10b60", "10b7f"]
		},
		{
			category: "psalter pahlavi",
			hexrange: ["10b80", "10baf"]
		},
		{
			category: "old turkic",
			hexrange: ["10c00", "10c4f"]
		},
		{
			category: "old hungarian",
			hexrange: ["10c80", "10cff"]
		},
		{
			category: "hanifi rohingya",
			hexrange: ["10d00", "10d3f"]
		},
		{
			category: "rumi numeral symbols",
			hexrange: ["10e60", "10e7f"]
		},
		{
			category: "yezidi",
			hexrange: ["10e80", "10ebf"]
		},
		{
			category: "arabic extended-c",
			hexrange: ["10ec0", "10eff"]
		},
		{
			category: "old sogdian",
			hexrange: ["10f00", "10f2f"]
		},
		{
			category: "sogdian",
			hexrange: ["10f30", "10f6f"]
		},
		{
			category: "old uyghur",
			hexrange: ["10f70", "10faf"]
		},
		{
			category: "chorasmian",
			hexrange: ["10fb0", "10fdf"]
		},
		{
			category: "elymaic",
			hexrange: ["10fe0", "10fff"]
		},
		{
			category: "brahmi",
			hexrange: ["11000", "1107f"]
		},
		{
			category: "kaithi",
			hexrange: ["11080", "110cf"]
		},
		{
			category: "sora sompeng",
			hexrange: ["110d0", "110ff"]
		},
		{
			category: "chakma",
			hexrange: ["11100", "1114f"]
		},
		{
			category: "mahajani",
			hexrange: ["11150", "1117f"]
		},
		{
			category: "sharada",
			hexrange: ["11180", "111df"]
		},
		{
			category: "sinhala archaic numbers",
			hexrange: ["111e0", "111ff"]
		},
		{
			category: "khojki",
			hexrange: ["11200", "1124f"]
		},
		{
			category: "multani",
			hexrange: ["11280", "112af"]
		},
		{
			category: "khudawadi",
			hexrange: ["112b0", "112ff"]
		},
		{
			category: "grantha",
			hexrange: ["11300", "1137f"]
		},
		{
			category: "newa",
			hexrange: ["11400", "1147f"]
		},
		{
			category: "tirhuta",
			hexrange: ["11480", "114df"]
		},
		{
			category: "siddham",
			hexrange: ["11580", "115ff"]
		},
		{
			category: "modi",
			hexrange: ["11600", "1165f"]
		},
		{
			category: "mongolian supplement",
			hexrange: ["11660", "1167f"]
		},
		{
			category: "takri",
			hexrange: ["11680", "116cf"]
		},
		{
			category: "ahom",
			hexrange: ["11700", "1174f"]
		},
		{
			category: "dogra",
			hexrange: ["11800", "1184f"]
		},
		{
			category: "warang citi",
			hexrange: ["118a0", "118ff"]
		},
		{
			category: "dives akuru",
			hexrange: ["11900", "1195f"]
		},
		{
			category: "nandinagari",
			hexrange: ["119a0", "119ff"]
		},
		{
			category: "zanabazar square",
			hexrange: ["11a00", "11a4f"]
		},
		{
			category: "soyombo",
			hexrange: ["11a50", "11aaf"]
		},
		{
			category: "unified canadian aboriginal syllabics extended-a",
			hexrange: ["11ab0", "11abf"]
		},
		{
			category: "pau cin hau",
			hexrange: ["11ac0", "11aff"]
		},
		{
			category: "devanagari extended-a",
			hexrange: ["11b00", "11b5f"]
		},
		{
			category: "bhaiksuki",
			hexrange: ["11c00", "11c6f"]
		},
		{
			category: "marchen",
			hexrange: ["11c70", "11cbf"]
		},
		{
			category: "masaram gondi",
			hexrange: ["11d00", "11d5f"]
		},
		{
			category: "gunjala gondi",
			hexrange: ["11d60", "11daf"]
		},
		{
			category: "makasar",
			hexrange: ["11ee0", "11eff"]
		},
		{
			category: "kawi",
			hexrange: ["11f00", "11f5f"]
		},
		{
			category: "lisu supplement",
			hexrange: ["11fb0", "11fbf"]
		},
		{
			category: "tamil supplement",
			hexrange: ["11fc0", "11fff"]
		},
		{
			category: "cuneiform",
			hexrange: ["12000", "123ff"]
		},
		{
			category: "cuneiform numbers and punctuation",
			hexrange: ["12400", "1247f"]
		},
		{
			category: "early dynastic cuneiform",
			hexrange: ["12480", "1254f"]
		},
		{
			category: "cypro-minoan",
			hexrange: ["12f90", "12fff"]
		},
		{
			category: "egyptian hieroglyphs",
			hexrange: ["13000", "1342f"]
		},
		{
			category: "egyptian hieroglyph format controls",
			hexrange: ["13430", "1345f"]
		},
		{
			category: "anatolian hieroglyphs",
			hexrange: ["14400", "1467f"]
		},
		{
			category: "bamum supplement",
			hexrange: ["16800", "16a3f"]
		},
		{
			category: "mro",
			hexrange: ["16a40", "16a6f"]
		},
		{
			category: "tangsa",
			hexrange: ["16a70", "16acf"]
		},
		{
			category: "bassa vah",
			hexrange: ["16ad0", "16aff"]
		},
		{
			category: "pahawh hmong",
			hexrange: ["16b00", "16b8f"]
		},
		{
			category: "medefaidrin",
			hexrange: ["16e40", "16e9f"]
		},
		{
			category: "miao",
			hexrange: ["16f00", "16f9f"]
		},
		{
			category: "ideographic symbols and punctuation",
			hexrange: ["16fe0", "16fff"]
		},
		{
			category: "tangut",
			hexrange: ["17000", "187ff"]
		},
		{
			category: "tangut components",
			hexrange: ["18800", "18aff"]
		},
		{
			category: "khitan small script",
			hexrange: ["18b00", "18cff"]
		},
		{
			category: "tangut supplement",
			hexrange: ["18d00", "18d7f"]
		},
		{
			category: "kana extended-b",
			hexrange: ["1aff0", "1afff"]
		},
		{
			category: "kana supplement",
			hexrange: ["1b000", "1b0ff"]
		},
		{
			category: "kana extended-a",
			hexrange: ["1b100", "1b12f"]
		},
		{
			category: "small kana extension",
			hexrange: ["1b130", "1b16f"]
		},
		{
			category: "nushu",
			hexrange: ["1b170", "1b2ff"]
		},
		{
			category: "duployan",
			hexrange: ["1bc00", "1bc9f"]
		},
		{
			category: "shorthand format controls",
			hexrange: ["1bca0", "1bcaf"]
		},
		{
			category: "znamenny musical notation",
			hexrange: ["1cf00", "1cfcf"]
		},
		{
			category: "byzantine musical symbols",
			hexrange: ["1d000", "1d0ff"]
		},
		{
			category: "musical symbols",
			hexrange: ["1d100", "1d1ff"]
		},
		{
			category: "ancient greek musical notation",
			hexrange: ["1d200", "1d24f"]
		},
		{
			category: "kaktovik numerals",
			hexrange: ["1d2c0", "1d2df"]
		},
		{
			category: "mayan numerals",
			hexrange: ["1d2e0", "1d2ff"]
		},
		{
			category: "tai xuan jing symbols",
			hexrange: ["1d300", "1d35f"]
		},
		{
			category: "counting rod numerals",
			hexrange: ["1d360", "1d37f"]
		},
		{
			category: "mathematical alphanumeric symbols",
			hexrange: ["1d400", "1d7ff"]
		},
		{
			category: "sutton signwriting",
			hexrange: ["1d800", "1daaf"]
		},
		{
			category: "latin extended-g",
			hexrange: ["1df00", "1dfff"]
		},
		{
			category: "glagolitic supplement",
			hexrange: ["1e000", "1e02f"]
		},
		{
			category: "cyrillic extended-d",
			hexrange: ["1e030", "1e08f"]
		},
		{
			category: "nyiakeng puachue hmong",
			hexrange: ["1e100", "1e14f"]
		},
		{
			category: "toto",
			hexrange: ["1e290", "1e2bf"]
		},
		{
			category: "wancho",
			hexrange: ["1e2c0", "1e2ff"]
		},
		{
			category: "nag mundari",
			hexrange: ["1e4d0", "1e4ff"]
		},
		{
			category: "ethiopic extended-b",
			hexrange: ["1e7e0", "1e7ff"]
		},
		{
			category: "mende kikakui",
			hexrange: ["1e800", "1e8df"]
		},
		{
			category: "adlam",
			hexrange: ["1e900", "1e95f"]
		},
		{
			category: "indic siyaq numbers",
			hexrange: ["1ec70", "1ecbf"]
		},
		{
			category: "ottoman siyaq numbers",
			hexrange: ["1ed00", "1ed4f"]
		},
		{
			category: "arabic mathematical alphabetic symbols",
			hexrange: ["1ee00", "1eeff"]
		},
		{
			category: "mahjong tiles",
			hexrange: ["1f000", "1f02f"]
		},
		{
			category: "domino tiles",
			hexrange: ["1f030", "1f09f"]
		},
		{
			category: "playing cards",
			hexrange: ["1f0a0", "1f0ff"]
		},
		{
			category: "enclosed alphanumeric supplement",
			hexrange: ["1f100", "1f1ff"]
		},
		{
			category: "enclosed ideographic supplement",
			hexrange: ["1f200", "1f2ff"]
		},
		{
			category: "miscellaneous symbols and pictographs",
			hexrange: ["1f300", "1f5ff"]
		},
		{
			category: "emoticons (emoji)",
			hexrange: ["1f600", "1f64f"]
		},
		{
			category: "ornamental dingbats",
			hexrange: ["1f650", "1f67f"]
		},
		{
			category: "transport and map symbols",
			hexrange: ["1f680", "1f6ff"]
		},
		{
			category: "alchemical symbols",
			hexrange: ["1f700", "1f77f"]
		},
		{
			category: "geometric shapes extended",
			hexrange: ["1f780", "1f7ff"]
		},
		{
			category: "supplemental arrows-c",
			hexrange: ["1f800", "1f8ff"]
		},
		{
			category: "supplemental symbols and pictographs",
			hexrange: ["1f900", "1f9ff"]
		},
		{
			category: "chess symbols",
			hexrange: ["1fa00", "1fa6f"]
		},
		{
			category: "symbols and pictographs extended-a",
			hexrange: ["1fa70", "1faff"]
		},
		{
			category: "symbols for legacy computing",
			hexrange: ["1fb00", "1fbff"]
		},
		{
			category: "cjk unified ideographs extension b",
			hexrange: ["20000", "2a6df"]
		},
		{
			category: "cjk unified ideographs extension c",
			hexrange: ["2a700", "2b73f"]
		},
		{
			category: "cjk unified ideographs extension d",
			hexrange: ["2b740", "2b81f"]
		},
		{
			category: "cjk unified ideographs extension e",
			hexrange: ["2b820", "2ceaf"]
		},
		{
			category: "cjk unified ideographs extension f",
			hexrange: ["2ceb0", "2ebef"]
		},
		{
			category: "cjk unified ideographs extension i",
			hexrange: ["2ebf0", "2ee5f"]
		},
		{
			category: "cjk compatibility ideographs supplement",
			hexrange: ["2f800", "2fa1f"]
		},
		{
			category: "cjk unified ideographs extension g",
			hexrange: ["30000", "3134f"]
		},
		{
			category: "cjk unified ideographs extension h",
			hexrange: ["31350", "323af"]
		},
		{
			category: "tags",
			hexrange: ["e0000", "e007f"]
		},
		{
			category: "variation selectors supplement",
			hexrange: ["e0100", "e01ef"]
		},
		{
			category: "supplementary private use area-a",
			hexrange: ["f0000", "fffff"]
		},
		{
			category: "supplementary private use area-b",
			hexrange: ["100000", "10ffff"]
		}
	];
	/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
	const Z_FIXED$1 = 4;
	const Z_BINARY = 0;
	const Z_TEXT = 1;
	const Z_UNKNOWN$1 = 2;
	function zero$1(buf) {
		let len = buf.length;
		while (--len >= 0) buf[len] = 0;
	}
	const STORED_BLOCK = 0;
	const STATIC_TREES = 1;
	const DYN_TREES = 2;
	const MIN_MATCH$1 = 3;
	const MAX_MATCH$1 = 258;
	const LENGTH_CODES$1 = 29;
	const LITERALS$1 = 256;
	const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
	const D_CODES$1 = 30;
	const BL_CODES$1 = 19;
	const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
	const MAX_BITS$1 = 15;
	const Buf_size = 16;
	const MAX_BL_BITS = 7;
	const END_BLOCK = 256;
	const REP_3_6 = 16;
	const REPZ_3_10 = 17;
	const REPZ_11_138 = 18;
	const extra_lbits = new Uint8Array([
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		2,
		2,
		2,
		2,
		3,
		3,
		3,
		3,
		4,
		4,
		4,
		4,
		5,
		5,
		5,
		5,
		0
	]);
	const extra_dbits = new Uint8Array([
		0,
		0,
		0,
		0,
		1,
		1,
		2,
		2,
		3,
		3,
		4,
		4,
		5,
		5,
		6,
		6,
		7,
		7,
		8,
		8,
		9,
		9,
		10,
		10,
		11,
		11,
		12,
		12,
		13,
		13
	]);
	const extra_blbits = new Uint8Array([
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		2,
		3,
		7
	]);
	const bl_order = new Uint8Array([
		16,
		17,
		18,
		0,
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15
	]);
	const DIST_CODE_LEN = 512;
	const static_ltree = new Array((L_CODES$1 + 2) * 2);
	zero$1(static_ltree);
	const static_dtree = new Array(D_CODES$1 * 2);
	zero$1(static_dtree);
	const _dist_code = new Array(DIST_CODE_LEN);
	zero$1(_dist_code);
	const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
	zero$1(_length_code);
	const base_length = new Array(LENGTH_CODES$1);
	zero$1(base_length);
	const base_dist = new Array(D_CODES$1);
	zero$1(base_dist);
	function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
		this.static_tree = static_tree;
		this.extra_bits = extra_bits;
		this.extra_base = extra_base;
		this.elems = elems;
		this.max_length = max_length;
		this.has_stree = static_tree && static_tree.length;
	}
	let static_l_desc;
	let static_d_desc;
	let static_bl_desc;
	function TreeDesc(dyn_tree, stat_desc) {
		this.dyn_tree = dyn_tree;
		this.max_code = 0;
		this.stat_desc = stat_desc;
	}
	const d_code = (dist) => {
		return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
	};
	const put_short = (s, w) => {
		s.pending_buf[s.pending++] = w & 255;
		s.pending_buf[s.pending++] = w >>> 8 & 255;
	};
	const send_bits = (s, value, length) => {
		if (s.bi_valid > Buf_size - length) {
			s.bi_buf |= value << s.bi_valid & 65535;
			put_short(s, s.bi_buf);
			s.bi_buf = value >> Buf_size - s.bi_valid;
			s.bi_valid += length - Buf_size;
		} else {
			s.bi_buf |= value << s.bi_valid & 65535;
			s.bi_valid += length;
		}
	};
	const send_code = (s, c, tree) => {
		send_bits(s, tree[c * 2], tree[c * 2 + 1]);
	};
	const bi_reverse = (code, len) => {
		let res = 0;
		do {
			res |= code & 1;
			code >>>= 1;
			res <<= 1;
		} while (--len > 0);
		return res >>> 1;
	};
	const bi_flush = (s) => {
		if (s.bi_valid === 16) {
			put_short(s, s.bi_buf);
			s.bi_buf = 0;
			s.bi_valid = 0;
		} else if (s.bi_valid >= 8) {
			s.pending_buf[s.pending++] = s.bi_buf & 255;
			s.bi_buf >>= 8;
			s.bi_valid -= 8;
		}
	};
	const gen_bitlen = (s, desc) => {
		const tree = desc.dyn_tree;
		const max_code = desc.max_code;
		const stree = desc.stat_desc.static_tree;
		const has_stree = desc.stat_desc.has_stree;
		const extra = desc.stat_desc.extra_bits;
		const base$1 = desc.stat_desc.extra_base;
		const max_length = desc.stat_desc.max_length;
		let h;
		let n$2, m;
		let bits;
		let xbits;
		let f;
		let overflow = 0;
		for (bits = 0; bits <= MAX_BITS$1; bits++) s.bl_count[bits] = 0;
		tree[s.heap[s.heap_max] * 2 + 1] = 0;
		for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
			n$2 = s.heap[h];
			bits = tree[tree[n$2 * 2 + 1] * 2 + 1] + 1;
			if (bits > max_length) {
				bits = max_length;
				overflow++;
			}
			tree[n$2 * 2 + 1] = bits;
			if (n$2 > max_code) continue;
			s.bl_count[bits]++;
			xbits = 0;
			if (n$2 >= base$1) xbits = extra[n$2 - base$1];
			f = tree[n$2 * 2];
			s.opt_len += f * (bits + xbits);
			if (has_stree) s.static_len += f * (stree[n$2 * 2 + 1] + xbits);
		}
		if (overflow === 0) return;
		do {
			bits = max_length - 1;
			while (s.bl_count[bits] === 0) bits--;
			s.bl_count[bits]--;
			s.bl_count[bits + 1] += 2;
			s.bl_count[max_length]--;
			overflow -= 2;
		} while (overflow > 0);
		for (bits = max_length; bits !== 0; bits--) {
			n$2 = s.bl_count[bits];
			while (n$2 !== 0) {
				m = s.heap[--h];
				if (m > max_code) continue;
				if (tree[m * 2 + 1] !== bits) {
					s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
					tree[m * 2 + 1] = bits;
				}
				n$2--;
			}
		}
	};
	const gen_codes = (tree, max_code, bl_count) => {
		const next_code = new Array(MAX_BITS$1 + 1);
		let code = 0;
		let bits;
		let n$2;
		for (bits = 1; bits <= MAX_BITS$1; bits++) {
			code = code + bl_count[bits - 1] << 1;
			next_code[bits] = code;
		}
		for (n$2 = 0; n$2 <= max_code; n$2++) {
			let len = tree[n$2 * 2 + 1];
			if (len === 0) continue;
			tree[n$2 * 2] = bi_reverse(next_code[len]++, len);
		}
	};
	const tr_static_init = () => {
		let n$2;
		let bits;
		let length;
		let code;
		let dist;
		const bl_count = new Array(MAX_BITS$1 + 1);
		length = 0;
		for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
			base_length[code] = length;
			for (n$2 = 0; n$2 < 1 << extra_lbits[code]; n$2++) _length_code[length++] = code;
		}
		_length_code[length - 1] = code;
		dist = 0;
		for (code = 0; code < 16; code++) {
			base_dist[code] = dist;
			for (n$2 = 0; n$2 < 1 << extra_dbits[code]; n$2++) _dist_code[dist++] = code;
		}
		dist >>= 7;
		for (; code < D_CODES$1; code++) {
			base_dist[code] = dist << 7;
			for (n$2 = 0; n$2 < 1 << extra_dbits[code] - 7; n$2++) _dist_code[256 + dist++] = code;
		}
		for (bits = 0; bits <= MAX_BITS$1; bits++) bl_count[bits] = 0;
		n$2 = 0;
		while (n$2 <= 143) {
			static_ltree[n$2 * 2 + 1] = 8;
			n$2++;
			bl_count[8]++;
		}
		while (n$2 <= 255) {
			static_ltree[n$2 * 2 + 1] = 9;
			n$2++;
			bl_count[9]++;
		}
		while (n$2 <= 279) {
			static_ltree[n$2 * 2 + 1] = 7;
			n$2++;
			bl_count[7]++;
		}
		while (n$2 <= 287) {
			static_ltree[n$2 * 2 + 1] = 8;
			n$2++;
			bl_count[8]++;
		}
		gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
		for (n$2 = 0; n$2 < D_CODES$1; n$2++) {
			static_dtree[n$2 * 2 + 1] = 5;
			static_dtree[n$2 * 2] = bi_reverse(n$2, 5);
		}
		static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
		static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
		static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
	};
	const init_block = (s) => {
		let n$2;
		for (n$2 = 0; n$2 < L_CODES$1; n$2++) s.dyn_ltree[n$2 * 2] = 0;
		for (n$2 = 0; n$2 < D_CODES$1; n$2++) s.dyn_dtree[n$2 * 2] = 0;
		for (n$2 = 0; n$2 < BL_CODES$1; n$2++) s.bl_tree[n$2 * 2] = 0;
		s.dyn_ltree[END_BLOCK * 2] = 1;
		s.opt_len = s.static_len = 0;
		s.sym_next = s.matches = 0;
	};
	const bi_windup = (s) => {
		if (s.bi_valid > 8) put_short(s, s.bi_buf);
		else if (s.bi_valid > 0) s.pending_buf[s.pending++] = s.bi_buf;
		s.bi_buf = 0;
		s.bi_valid = 0;
	};
	const smaller = (tree, n$2, m, depth) => {
		const _n2 = n$2 * 2;
		const _m2 = m * 2;
		return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n$2] <= depth[m];
	};
	const pqdownheap = (s, tree, k) => {
		const v$1 = s.heap[k];
		let j = k << 1;
		while (j <= s.heap_len) {
			if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) j++;
			if (smaller(tree, v$1, s.heap[j], s.depth)) break;
			s.heap[k] = s.heap[j];
			k = j;
			j <<= 1;
		}
		s.heap[k] = v$1;
	};
	const compress_block = (s, ltree, dtree) => {
		let dist;
		let lc;
		let sx = 0;
		let code;
		let extra;
		if (s.sym_next !== 0) do {
			dist = s.pending_buf[s.sym_buf + sx++] & 255;
			dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
			lc = s.pending_buf[s.sym_buf + sx++];
			if (dist === 0) send_code(s, lc, ltree);
			else {
				code = _length_code[lc];
				send_code(s, code + LITERALS$1 + 1, ltree);
				extra = extra_lbits[code];
				if (extra !== 0) {
					lc -= base_length[code];
					send_bits(s, lc, extra);
				}
				dist--;
				code = d_code(dist);
				send_code(s, code, dtree);
				extra = extra_dbits[code];
				if (extra !== 0) {
					dist -= base_dist[code];
					send_bits(s, dist, extra);
				}
			}
		} while (sx < s.sym_next);
		send_code(s, END_BLOCK, ltree);
	};
	const build_tree = (s, desc) => {
		const tree = desc.dyn_tree;
		const stree = desc.stat_desc.static_tree;
		const has_stree = desc.stat_desc.has_stree;
		const elems = desc.stat_desc.elems;
		let n$2, m;
		let max_code = -1;
		let node;
		s.heap_len = 0;
		s.heap_max = HEAP_SIZE$1;
		for (n$2 = 0; n$2 < elems; n$2++) if (tree[n$2 * 2] !== 0) {
			s.heap[++s.heap_len] = max_code = n$2;
			s.depth[n$2] = 0;
		} else tree[n$2 * 2 + 1] = 0;
		while (s.heap_len < 2) {
			node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
			tree[node * 2] = 1;
			s.depth[node] = 0;
			s.opt_len--;
			if (has_stree) s.static_len -= stree[node * 2 + 1];
		}
		desc.max_code = max_code;
		for (n$2 = s.heap_len >> 1; n$2 >= 1; n$2--) pqdownheap(s, tree, n$2);
		node = elems;
		do {
			n$2 = s.heap[1];
			s.heap[1] = s.heap[s.heap_len--];
			pqdownheap(s, tree, 1);
			m = s.heap[1];
			s.heap[--s.heap_max] = n$2;
			s.heap[--s.heap_max] = m;
			tree[node * 2] = tree[n$2 * 2] + tree[m * 2];
			s.depth[node] = (s.depth[n$2] >= s.depth[m] ? s.depth[n$2] : s.depth[m]) + 1;
			tree[n$2 * 2 + 1] = tree[m * 2 + 1] = node;
			s.heap[1] = node++;
			pqdownheap(s, tree, 1);
		} while (s.heap_len >= 2);
		s.heap[--s.heap_max] = s.heap[1];
		gen_bitlen(s, desc);
		gen_codes(tree, max_code, s.bl_count);
	};
	const scan_tree = (s, tree, max_code) => {
		let n$2;
		let prevlen = -1;
		let curlen;
		let nextlen = tree[1];
		let count = 0;
		let max_count = 7;
		let min_count = 4;
		if (nextlen === 0) {
			max_count = 138;
			min_count = 3;
		}
		tree[(max_code + 1) * 2 + 1] = 65535;
		for (n$2 = 0; n$2 <= max_code; n$2++) {
			curlen = nextlen;
			nextlen = tree[(n$2 + 1) * 2 + 1];
			if (++count < max_count && curlen === nextlen) continue;
			else if (count < min_count) s.bl_tree[curlen * 2] += count;
			else if (curlen !== 0) {
				if (curlen !== prevlen) s.bl_tree[curlen * 2]++;
				s.bl_tree[REP_3_6 * 2]++;
			} else if (count <= 10) s.bl_tree[REPZ_3_10 * 2]++;
			else s.bl_tree[REPZ_11_138 * 2]++;
			count = 0;
			prevlen = curlen;
			if (nextlen === 0) {
				max_count = 138;
				min_count = 3;
			} else if (curlen === nextlen) {
				max_count = 6;
				min_count = 3;
			} else {
				max_count = 7;
				min_count = 4;
			}
		}
	};
	const send_tree = (s, tree, max_code) => {
		let n$2;
		let prevlen = -1;
		let curlen;
		let nextlen = tree[1];
		let count = 0;
		let max_count = 7;
		let min_count = 4;
		if (nextlen === 0) {
			max_count = 138;
			min_count = 3;
		}
		for (n$2 = 0; n$2 <= max_code; n$2++) {
			curlen = nextlen;
			nextlen = tree[(n$2 + 1) * 2 + 1];
			if (++count < max_count && curlen === nextlen) continue;
			else if (count < min_count) do
				send_code(s, curlen, s.bl_tree);
			while (--count !== 0);
			else if (curlen !== 0) {
				if (curlen !== prevlen) {
					send_code(s, curlen, s.bl_tree);
					count--;
				}
				send_code(s, REP_3_6, s.bl_tree);
				send_bits(s, count - 3, 2);
			} else if (count <= 10) {
				send_code(s, REPZ_3_10, s.bl_tree);
				send_bits(s, count - 3, 3);
			} else {
				send_code(s, REPZ_11_138, s.bl_tree);
				send_bits(s, count - 11, 7);
			}
			count = 0;
			prevlen = curlen;
			if (nextlen === 0) {
				max_count = 138;
				min_count = 3;
			} else if (curlen === nextlen) {
				max_count = 6;
				min_count = 3;
			} else {
				max_count = 7;
				min_count = 4;
			}
		}
	};
	const build_bl_tree = (s) => {
		let max_blindex;
		scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
		scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
		build_tree(s, s.bl_desc);
		for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) break;
		s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
		return max_blindex;
	};
	const send_all_trees = (s, lcodes, dcodes, blcodes) => {
		let rank$1;
		send_bits(s, lcodes - 257, 5);
		send_bits(s, dcodes - 1, 5);
		send_bits(s, blcodes - 4, 4);
		for (rank$1 = 0; rank$1 < blcodes; rank$1++) send_bits(s, s.bl_tree[bl_order[rank$1] * 2 + 1], 3);
		send_tree(s, s.dyn_ltree, lcodes - 1);
		send_tree(s, s.dyn_dtree, dcodes - 1);
	};
	const detect_data_type = (s) => {
		let block_mask = 4093624447;
		let n$2;
		for (n$2 = 0; n$2 <= 31; n$2++, block_mask >>>= 1) if (block_mask & 1 && s.dyn_ltree[n$2 * 2] !== 0) return Z_BINARY;
		if (s.dyn_ltree[18] !== 0 || s.dyn_ltree[20] !== 0 || s.dyn_ltree[26] !== 0) return Z_TEXT;
		for (n$2 = 32; n$2 < LITERALS$1; n$2++) if (s.dyn_ltree[n$2 * 2] !== 0) return Z_TEXT;
		return Z_BINARY;
	};
	let static_init_done = false;
	const _tr_init$1 = (s) => {
		if (!static_init_done) {
			tr_static_init();
			static_init_done = true;
		}
		s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
		s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
		s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
		s.bi_buf = 0;
		s.bi_valid = 0;
		init_block(s);
	};
	const _tr_stored_block$1 = (s, buf, stored_len, last$1) => {
		send_bits(s, (STORED_BLOCK << 1) + (last$1 ? 1 : 0), 3);
		bi_windup(s);
		put_short(s, stored_len);
		put_short(s, ~stored_len);
		if (stored_len) s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
		s.pending += stored_len;
	};
	const _tr_align$1 = (s) => {
		send_bits(s, STATIC_TREES << 1, 3);
		send_code(s, END_BLOCK, static_ltree);
		bi_flush(s);
	};
	const _tr_flush_block$1 = (s, buf, stored_len, last$1) => {
		let opt_lenb, static_lenb;
		let max_blindex = 0;
		if (s.level > 0) {
			if (s.strm.data_type === Z_UNKNOWN$1) s.strm.data_type = detect_data_type(s);
			build_tree(s, s.l_desc);
			build_tree(s, s.d_desc);
			max_blindex = build_bl_tree(s);
			opt_lenb = s.opt_len + 3 + 7 >>> 3;
			static_lenb = s.static_len + 3 + 7 >>> 3;
			if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
		} else opt_lenb = static_lenb = stored_len + 5;
		if (stored_len + 4 <= opt_lenb && buf !== -1) _tr_stored_block$1(s, buf, stored_len, last$1);
		else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
			send_bits(s, (STATIC_TREES << 1) + (last$1 ? 1 : 0), 3);
			compress_block(s, static_ltree, static_dtree);
		} else {
			send_bits(s, (DYN_TREES << 1) + (last$1 ? 1 : 0), 3);
			send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
			compress_block(s, s.dyn_ltree, s.dyn_dtree);
		}
		init_block(s);
		if (last$1) bi_windup(s);
	};
	const _tr_tally$1 = (s, dist, lc) => {
		s.pending_buf[s.sym_buf + s.sym_next++] = dist;
		s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
		s.pending_buf[s.sym_buf + s.sym_next++] = lc;
		if (dist === 0) s.dyn_ltree[lc * 2]++;
		else {
			s.matches++;
			dist--;
			s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
			s.dyn_dtree[d_code(dist) * 2]++;
		}
		return s.sym_next === s.sym_end;
	};
	var trees = {
		_tr_init: _tr_init$1,
		_tr_stored_block: _tr_stored_block$1,
		_tr_flush_block: _tr_flush_block$1,
		_tr_tally: _tr_tally$1,
		_tr_align: _tr_align$1
	};
	const adler32 = (adler, buf, len, pos) => {
		let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n$2 = 0;
		while (len !== 0) {
			n$2 = len > 2e3 ? 2e3 : len;
			len -= n$2;
			do {
				s1 = s1 + buf[pos++] | 0;
				s2 = s2 + s1 | 0;
			} while (--n$2);
			s1 %= 65521;
			s2 %= 65521;
		}
		return s1 | s2 << 16 | 0;
	};
	var adler32_1 = adler32;
	const makeTable = () => {
		let c, table$1 = [];
		for (var n$2 = 0; n$2 < 256; n$2++) {
			c = n$2;
			for (var k = 0; k < 8; k++) c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
			table$1[n$2] = c;
		}
		return table$1;
	};
	const crcTable = new Uint32Array(makeTable());
	const crc32 = (crc, buf, len, pos) => {
		const t$1 = crcTable;
		const end = pos + len;
		crc ^= -1;
		for (let i$1 = pos; i$1 < end; i$1++) crc = crc >>> 8 ^ t$1[(crc ^ buf[i$1]) & 255];
		return crc ^ -1;
	};
	var crc32_1 = crc32;
	var messages = {
		2: "need dictionary",
		1: "stream end",
		0: "",
		"-1": "file error",
		"-2": "stream error",
		"-3": "data error",
		"-4": "insufficient memory",
		"-5": "buffer error",
		"-6": "incompatible version"
	};
	var constants$2 = {
		Z_NO_FLUSH: 0,
		Z_PARTIAL_FLUSH: 1,
		Z_SYNC_FLUSH: 2,
		Z_FULL_FLUSH: 3,
		Z_FINISH: 4,
		Z_BLOCK: 5,
		Z_TREES: 6,
		Z_OK: 0,
		Z_STREAM_END: 1,
		Z_NEED_DICT: 2,
		Z_ERRNO: -1,
		Z_STREAM_ERROR: -2,
		Z_DATA_ERROR: -3,
		Z_MEM_ERROR: -4,
		Z_BUF_ERROR: -5,
		Z_NO_COMPRESSION: 0,
		Z_BEST_SPEED: 1,
		Z_BEST_COMPRESSION: 9,
		Z_DEFAULT_COMPRESSION: -1,
		Z_FILTERED: 1,
		Z_HUFFMAN_ONLY: 2,
		Z_RLE: 3,
		Z_FIXED: 4,
		Z_DEFAULT_STRATEGY: 0,
		Z_BINARY: 0,
		Z_TEXT: 1,
		Z_UNKNOWN: 2,
		Z_DEFLATED: 8
	};
	const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
	const { Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1, Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1, Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1, Z_UNKNOWN, Z_DEFLATED: Z_DEFLATED$2 } = constants$2;
	const MAX_MEM_LEVEL = 9;
	const MAX_WBITS$1 = 15;
	const DEF_MEM_LEVEL = 8;
	const L_CODES = 286;
	const D_CODES = 30;
	const BL_CODES = 19;
	const HEAP_SIZE = 2 * L_CODES + 1;
	const MAX_BITS = 15;
	const MIN_MATCH = 3;
	const MAX_MATCH = 258;
	const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
	const PRESET_DICT = 32;
	const INIT_STATE = 42;
	const GZIP_STATE = 57;
	const EXTRA_STATE = 69;
	const NAME_STATE = 73;
	const COMMENT_STATE = 91;
	const HCRC_STATE = 103;
	const BUSY_STATE = 113;
	const FINISH_STATE = 666;
	const BS_NEED_MORE = 1;
	const BS_BLOCK_DONE = 2;
	const BS_FINISH_STARTED = 3;
	const BS_FINISH_DONE = 4;
	const OS_CODE = 3;
	const err = (strm, errorCode) => {
		strm.msg = messages[errorCode];
		return errorCode;
	};
	const rank = (f) => {
		return f * 2 - (f > 4 ? 9 : 0);
	};
	const zero = (buf) => {
		let len = buf.length;
		while (--len >= 0) buf[len] = 0;
	};
	const slide_hash = (s) => {
		let n$2, m;
		let p$1;
		let wsize = s.w_size;
		n$2 = s.hash_size;
		p$1 = n$2;
		do {
			m = s.head[--p$1];
			s.head[p$1] = m >= wsize ? m - wsize : 0;
		} while (--n$2);
		n$2 = wsize;
		p$1 = n$2;
		do {
			m = s.prev[--p$1];
			s.prev[p$1] = m >= wsize ? m - wsize : 0;
		} while (--n$2);
	};
	let HASH_ZLIB = (s, prev, data$2) => (prev << s.hash_shift ^ data$2) & s.hash_mask;
	let HASH = HASH_ZLIB;
	const flush_pending = (strm) => {
		const s = strm.state;
		let len = s.pending;
		if (len > strm.avail_out) len = strm.avail_out;
		if (len === 0) return;
		strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
		strm.next_out += len;
		s.pending_out += len;
		strm.total_out += len;
		strm.avail_out -= len;
		s.pending -= len;
		if (s.pending === 0) s.pending_out = 0;
	};
	const flush_block_only = (s, last$1) => {
		_tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last$1);
		s.block_start = s.strstart;
		flush_pending(s.strm);
	};
	const put_byte = (s, b$1) => {
		s.pending_buf[s.pending++] = b$1;
	};
	const putShortMSB = (s, b$1) => {
		s.pending_buf[s.pending++] = b$1 >>> 8 & 255;
		s.pending_buf[s.pending++] = b$1 & 255;
	};
	const read_buf = (strm, buf, start, size) => {
		let len = strm.avail_in;
		if (len > size) len = size;
		if (len === 0) return 0;
		strm.avail_in -= len;
		buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
		if (strm.state.wrap === 1) strm.adler = adler32_1(strm.adler, buf, len, start);
		else if (strm.state.wrap === 2) strm.adler = crc32_1(strm.adler, buf, len, start);
		strm.next_in += len;
		strm.total_in += len;
		return len;
	};
	const longest_match = (s, cur_match) => {
		let chain_length = s.max_chain_length;
		let scan = s.strstart;
		let match;
		let len;
		let best_len = s.prev_length;
		let nice_match = s.nice_match;
		const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
		const _win = s.window;
		const wmask = s.w_mask;
		const prev = s.prev;
		const strend = s.strstart + MAX_MATCH;
		let scan_end1 = _win[scan + best_len - 1];
		let scan_end = _win[scan + best_len];
		if (s.prev_length >= s.good_match) chain_length >>= 2;
		if (nice_match > s.lookahead) nice_match = s.lookahead;
		do {
			match = cur_match;
			if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) continue;
			scan += 2;
			match++;
			do			;
while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
			len = MAX_MATCH - (strend - scan);
			scan = strend - MAX_MATCH;
			if (len > best_len) {
				s.match_start = cur_match;
				best_len = len;
				if (len >= nice_match) break;
				scan_end1 = _win[scan + best_len - 1];
				scan_end = _win[scan + best_len];
			}
		} while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
		if (best_len <= s.lookahead) return best_len;
		return s.lookahead;
	};
	const fill_window = (s) => {
		const _w_size = s.w_size;
		let n$2, more, str;
		do {
			more = s.window_size - s.lookahead - s.strstart;
			if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
				s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
				s.match_start -= _w_size;
				s.strstart -= _w_size;
				s.block_start -= _w_size;
				if (s.insert > s.strstart) s.insert = s.strstart;
				slide_hash(s);
				more += _w_size;
			}
			if (s.strm.avail_in === 0) break;
			n$2 = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
			s.lookahead += n$2;
			if (s.lookahead + s.insert >= MIN_MATCH) {
				str = s.strstart - s.insert;
				s.ins_h = s.window[str];
				s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
				while (s.insert) {
					s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
					s.prev[str & s.w_mask] = s.head[s.ins_h];
					s.head[s.ins_h] = str;
					str++;
					s.insert--;
					if (s.lookahead + s.insert < MIN_MATCH) break;
				}
			}
		} while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
	};
	const deflate_stored = (s, flush) => {
		let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
		let len, left, have, last$1 = 0;
		let used = s.strm.avail_in;
		do {
			len = 65535;
			have = s.bi_valid + 42 >> 3;
			if (s.strm.avail_out < have) break;
			have = s.strm.avail_out - have;
			left = s.strstart - s.block_start;
			if (len > left + s.strm.avail_in) len = left + s.strm.avail_in;
			if (len > have) len = have;
			if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) break;
			last$1 = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
			_tr_stored_block(s, 0, 0, last$1);
			s.pending_buf[s.pending - 4] = len;
			s.pending_buf[s.pending - 3] = len >> 8;
			s.pending_buf[s.pending - 2] = ~len;
			s.pending_buf[s.pending - 1] = ~len >> 8;
			flush_pending(s.strm);
			if (left) {
				if (left > len) left = len;
				s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
				s.strm.next_out += left;
				s.strm.avail_out -= left;
				s.strm.total_out += left;
				s.block_start += left;
				len -= left;
			}
			if (len) {
				read_buf(s.strm, s.strm.output, s.strm.next_out, len);
				s.strm.next_out += len;
				s.strm.avail_out -= len;
				s.strm.total_out += len;
			}
		} while (last$1 === 0);
		used -= s.strm.avail_in;
		if (used) {
			if (used >= s.w_size) {
				s.matches = 2;
				s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
				s.strstart = s.w_size;
				s.insert = s.strstart;
			} else {
				if (s.window_size - s.strstart <= used) {
					s.strstart -= s.w_size;
					s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
					if (s.matches < 2) s.matches++;
					if (s.insert > s.strstart) s.insert = s.strstart;
				}
				s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
				s.strstart += used;
				s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
			}
			s.block_start = s.strstart;
		}
		if (s.high_water < s.strstart) s.high_water = s.strstart;
		if (last$1) return BS_FINISH_DONE;
		if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) return BS_BLOCK_DONE;
		have = s.window_size - s.strstart;
		if (s.strm.avail_in > have && s.block_start >= s.w_size) {
			s.block_start -= s.w_size;
			s.strstart -= s.w_size;
			s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
			if (s.matches < 2) s.matches++;
			have += s.w_size;
			if (s.insert > s.strstart) s.insert = s.strstart;
		}
		if (have > s.strm.avail_in) have = s.strm.avail_in;
		if (have) {
			read_buf(s.strm, s.window, s.strstart, have);
			s.strstart += have;
			s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
		}
		if (s.high_water < s.strstart) s.high_water = s.strstart;
		have = s.bi_valid + 42 >> 3;
		have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
		min_block = have > s.w_size ? s.w_size : have;
		left = s.strstart - s.block_start;
		if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
			len = left > have ? have : left;
			last$1 = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
			_tr_stored_block(s, s.block_start, len, last$1);
			s.block_start += len;
			flush_pending(s.strm);
		}
		return last$1 ? BS_FINISH_STARTED : BS_NEED_MORE;
	};
	const deflate_fast = (s, flush) => {
		let hash_head;
		let bflush;
		for (;;) {
			if (s.lookahead < MIN_LOOKAHEAD) {
				fill_window(s);
				if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) return BS_NEED_MORE;
				if (s.lookahead === 0) break;
			}
			hash_head = 0;
			if (s.lookahead >= MIN_MATCH) {
				s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
				hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
				s.head[s.ins_h] = s.strstart;
			}
			if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) s.match_length = longest_match(s, hash_head);
			if (s.match_length >= MIN_MATCH) {
				bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
				s.lookahead -= s.match_length;
				if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
					s.match_length--;
					do {
						s.strstart++;
						s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
						hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
						s.head[s.ins_h] = s.strstart;
					} while (--s.match_length !== 0);
					s.strstart++;
				} else {
					s.strstart += s.match_length;
					s.match_length = 0;
					s.ins_h = s.window[s.strstart];
					s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
				}
			} else {
				bflush = _tr_tally(s, 0, s.window[s.strstart]);
				s.lookahead--;
				s.strstart++;
			}
			if (bflush) {
				flush_block_only(s, false);
				if (s.strm.avail_out === 0) return BS_NEED_MORE;
			}
		}
		s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
		if (flush === Z_FINISH$3) {
			flush_block_only(s, true);
			if (s.strm.avail_out === 0) return BS_FINISH_STARTED;
			return BS_FINISH_DONE;
		}
		if (s.sym_next) {
			flush_block_only(s, false);
			if (s.strm.avail_out === 0) return BS_NEED_MORE;
		}
		return BS_BLOCK_DONE;
	};
	const deflate_slow = (s, flush) => {
		let hash_head;
		let bflush;
		let max_insert;
		for (;;) {
			if (s.lookahead < MIN_LOOKAHEAD) {
				fill_window(s);
				if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) return BS_NEED_MORE;
				if (s.lookahead === 0) break;
			}
			hash_head = 0;
			if (s.lookahead >= MIN_MATCH) {
				s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
				hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
				s.head[s.ins_h] = s.strstart;
			}
			s.prev_length = s.match_length;
			s.prev_match = s.match_start;
			s.match_length = MIN_MATCH - 1;
			if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
				s.match_length = longest_match(s, hash_head);
				if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) s.match_length = MIN_MATCH - 1;
			}
			if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
				max_insert = s.strstart + s.lookahead - MIN_MATCH;
				bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
				s.lookahead -= s.prev_length - 1;
				s.prev_length -= 2;
				do
					if (++s.strstart <= max_insert) {
						s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
						hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
						s.head[s.ins_h] = s.strstart;
					}
				while (--s.prev_length !== 0);
				s.match_available = 0;
				s.match_length = MIN_MATCH - 1;
				s.strstart++;
				if (bflush) {
					flush_block_only(s, false);
					if (s.strm.avail_out === 0) return BS_NEED_MORE;
				}
			} else if (s.match_available) {
				bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
				if (bflush) flush_block_only(s, false);
				s.strstart++;
				s.lookahead--;
				if (s.strm.avail_out === 0) return BS_NEED_MORE;
			} else {
				s.match_available = 1;
				s.strstart++;
				s.lookahead--;
			}
		}
		if (s.match_available) {
			bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
			s.match_available = 0;
		}
		s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
		if (flush === Z_FINISH$3) {
			flush_block_only(s, true);
			if (s.strm.avail_out === 0) return BS_FINISH_STARTED;
			return BS_FINISH_DONE;
		}
		if (s.sym_next) {
			flush_block_only(s, false);
			if (s.strm.avail_out === 0) return BS_NEED_MORE;
		}
		return BS_BLOCK_DONE;
	};
	const deflate_rle = (s, flush) => {
		let bflush;
		let prev;
		let scan, strend;
		const _win = s.window;
		for (;;) {
			if (s.lookahead <= MAX_MATCH) {
				fill_window(s);
				if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) return BS_NEED_MORE;
				if (s.lookahead === 0) break;
			}
			s.match_length = 0;
			if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
				scan = s.strstart - 1;
				prev = _win[scan];
				if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
					strend = s.strstart + MAX_MATCH;
					do					;
while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
					s.match_length = MAX_MATCH - (strend - scan);
					if (s.match_length > s.lookahead) s.match_length = s.lookahead;
				}
			}
			if (s.match_length >= MIN_MATCH) {
				bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
				s.lookahead -= s.match_length;
				s.strstart += s.match_length;
				s.match_length = 0;
			} else {
				bflush = _tr_tally(s, 0, s.window[s.strstart]);
				s.lookahead--;
				s.strstart++;
			}
			if (bflush) {
				flush_block_only(s, false);
				if (s.strm.avail_out === 0) return BS_NEED_MORE;
			}
		}
		s.insert = 0;
		if (flush === Z_FINISH$3) {
			flush_block_only(s, true);
			if (s.strm.avail_out === 0) return BS_FINISH_STARTED;
			return BS_FINISH_DONE;
		}
		if (s.sym_next) {
			flush_block_only(s, false);
			if (s.strm.avail_out === 0) return BS_NEED_MORE;
		}
		return BS_BLOCK_DONE;
	};
	const deflate_huff = (s, flush) => {
		let bflush;
		for (;;) {
			if (s.lookahead === 0) {
				fill_window(s);
				if (s.lookahead === 0) {
					if (flush === Z_NO_FLUSH$2) return BS_NEED_MORE;
					break;
				}
			}
			s.match_length = 0;
			bflush = _tr_tally(s, 0, s.window[s.strstart]);
			s.lookahead--;
			s.strstart++;
			if (bflush) {
				flush_block_only(s, false);
				if (s.strm.avail_out === 0) return BS_NEED_MORE;
			}
		}
		s.insert = 0;
		if (flush === Z_FINISH$3) {
			flush_block_only(s, true);
			if (s.strm.avail_out === 0) return BS_FINISH_STARTED;
			return BS_FINISH_DONE;
		}
		if (s.sym_next) {
			flush_block_only(s, false);
			if (s.strm.avail_out === 0) return BS_NEED_MORE;
		}
		return BS_BLOCK_DONE;
	};
	function Config(good_length, max_lazy, nice_length, max_chain, func) {
		this.good_length = good_length;
		this.max_lazy = max_lazy;
		this.nice_length = nice_length;
		this.max_chain = max_chain;
		this.func = func;
	}
	const configuration_table = [
		new Config(0, 0, 0, 0, deflate_stored),
		new Config(4, 4, 8, 4, deflate_fast),
		new Config(4, 5, 16, 8, deflate_fast),
		new Config(4, 6, 32, 32, deflate_fast),
		new Config(4, 4, 16, 16, deflate_slow),
		new Config(8, 16, 32, 32, deflate_slow),
		new Config(8, 16, 128, 128, deflate_slow),
		new Config(8, 32, 128, 256, deflate_slow),
		new Config(32, 128, 258, 1024, deflate_slow),
		new Config(32, 258, 258, 4096, deflate_slow)
	];
	const lm_init = (s) => {
		s.window_size = 2 * s.w_size;
		zero(s.head);
		s.max_lazy_match = configuration_table[s.level].max_lazy;
		s.good_match = configuration_table[s.level].good_length;
		s.nice_match = configuration_table[s.level].nice_length;
		s.max_chain_length = configuration_table[s.level].max_chain;
		s.strstart = 0;
		s.block_start = 0;
		s.lookahead = 0;
		s.insert = 0;
		s.match_length = s.prev_length = MIN_MATCH - 1;
		s.match_available = 0;
		s.ins_h = 0;
	};
	function DeflateState() {
		this.strm = null;
		this.status = 0;
		this.pending_buf = null;
		this.pending_buf_size = 0;
		this.pending_out = 0;
		this.pending = 0;
		this.wrap = 0;
		this.gzhead = null;
		this.gzindex = 0;
		this.method = Z_DEFLATED$2;
		this.last_flush = -1;
		this.w_size = 0;
		this.w_bits = 0;
		this.w_mask = 0;
		this.window = null;
		this.window_size = 0;
		this.prev = null;
		this.head = null;
		this.ins_h = 0;
		this.hash_size = 0;
		this.hash_bits = 0;
		this.hash_mask = 0;
		this.hash_shift = 0;
		this.block_start = 0;
		this.match_length = 0;
		this.prev_match = 0;
		this.match_available = 0;
		this.strstart = 0;
		this.match_start = 0;
		this.lookahead = 0;
		this.prev_length = 0;
		this.max_chain_length = 0;
		this.max_lazy_match = 0;
		this.level = 0;
		this.strategy = 0;
		this.good_match = 0;
		this.nice_match = 0;
		this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
		this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
		this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
		zero(this.dyn_ltree);
		zero(this.dyn_dtree);
		zero(this.bl_tree);
		this.l_desc = null;
		this.d_desc = null;
		this.bl_desc = null;
		this.bl_count = new Uint16Array(MAX_BITS + 1);
		this.heap = new Uint16Array(2 * L_CODES + 1);
		zero(this.heap);
		this.heap_len = 0;
		this.heap_max = 0;
		this.depth = new Uint16Array(2 * L_CODES + 1);
		zero(this.depth);
		this.sym_buf = 0;
		this.lit_bufsize = 0;
		this.sym_next = 0;
		this.sym_end = 0;
		this.opt_len = 0;
		this.static_len = 0;
		this.matches = 0;
		this.insert = 0;
		this.bi_buf = 0;
		this.bi_valid = 0;
	}
	const deflateStateCheck = (strm) => {
		if (!strm) return 1;
		const s = strm.state;
		if (!s || s.strm !== strm || s.status !== INIT_STATE && s.status !== GZIP_STATE && s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) return 1;
		return 0;
	};
	const deflateResetKeep = (strm) => {
		if (deflateStateCheck(strm)) return err(strm, Z_STREAM_ERROR$2);
		strm.total_in = strm.total_out = 0;
		strm.data_type = Z_UNKNOWN;
		const s = strm.state;
		s.pending = 0;
		s.pending_out = 0;
		if (s.wrap < 0) s.wrap = -s.wrap;
		s.status = s.wrap === 2 ? GZIP_STATE : s.wrap ? INIT_STATE : BUSY_STATE;
		strm.adler = s.wrap === 2 ? 0 : 1;
		s.last_flush = -2;
		_tr_init(s);
		return Z_OK$3;
	};
	const deflateReset = (strm) => {
		const ret = deflateResetKeep(strm);
		if (ret === Z_OK$3) lm_init(strm.state);
		return ret;
	};
	const deflateSetHeader = (strm, head) => {
		if (deflateStateCheck(strm) || strm.state.wrap !== 2) return Z_STREAM_ERROR$2;
		strm.state.gzhead = head;
		return Z_OK$3;
	};
	const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
		if (!strm) return Z_STREAM_ERROR$2;
		let wrap = 1;
		if (level === Z_DEFAULT_COMPRESSION$1) level = 6;
		if (windowBits < 0) {
			wrap = 0;
			windowBits = -windowBits;
		} else if (windowBits > 15) {
			wrap = 2;
			windowBits -= 16;
		}
		if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) return err(strm, Z_STREAM_ERROR$2);
		if (windowBits === 8) windowBits = 9;
		const s = new DeflateState();
		strm.state = s;
		s.strm = strm;
		s.status = INIT_STATE;
		s.wrap = wrap;
		s.gzhead = null;
		s.w_bits = windowBits;
		s.w_size = 1 << s.w_bits;
		s.w_mask = s.w_size - 1;
		s.hash_bits = memLevel + 7;
		s.hash_size = 1 << s.hash_bits;
		s.hash_mask = s.hash_size - 1;
		s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
		s.window = new Uint8Array(s.w_size * 2);
		s.head = new Uint16Array(s.hash_size);
		s.prev = new Uint16Array(s.w_size);
		s.lit_bufsize = 1 << memLevel + 6;
		s.pending_buf_size = s.lit_bufsize * 4;
		s.pending_buf = new Uint8Array(s.pending_buf_size);
		s.sym_buf = s.lit_bufsize;
		s.sym_end = (s.lit_bufsize - 1) * 3;
		s.level = level;
		s.strategy = strategy;
		s.method = method;
		return deflateReset(strm);
	};
	const deflateInit = (strm, level) => {
		return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
	};
	const deflate$2 = (strm, flush) => {
		if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
		const s = strm.state;
		if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
		const old_flush = s.last_flush;
		s.last_flush = flush;
		if (s.pending !== 0) {
			flush_pending(strm);
			if (strm.avail_out === 0) {
				s.last_flush = -1;
				return Z_OK$3;
			}
		} else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) return err(strm, Z_BUF_ERROR$1);
		if (s.status === FINISH_STATE && strm.avail_in !== 0) return err(strm, Z_BUF_ERROR$1);
		if (s.status === INIT_STATE && s.wrap === 0) s.status = BUSY_STATE;
		if (s.status === INIT_STATE) {
			let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
			let level_flags = -1;
			if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) level_flags = 0;
			else if (s.level < 6) level_flags = 1;
			else if (s.level === 6) level_flags = 2;
			else level_flags = 3;
			header |= level_flags << 6;
			if (s.strstart !== 0) header |= PRESET_DICT;
			header += 31 - header % 31;
			putShortMSB(s, header);
			if (s.strstart !== 0) {
				putShortMSB(s, strm.adler >>> 16);
				putShortMSB(s, strm.adler & 65535);
			}
			strm.adler = 1;
			s.status = BUSY_STATE;
			flush_pending(strm);
			if (s.pending !== 0) {
				s.last_flush = -1;
				return Z_OK$3;
			}
		}
		if (s.status === GZIP_STATE) {
			strm.adler = 0;
			put_byte(s, 31);
			put_byte(s, 139);
			put_byte(s, 8);
			if (!s.gzhead) {
				put_byte(s, 0);
				put_byte(s, 0);
				put_byte(s, 0);
				put_byte(s, 0);
				put_byte(s, 0);
				put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
				put_byte(s, OS_CODE);
				s.status = BUSY_STATE;
				flush_pending(strm);
				if (s.pending !== 0) {
					s.last_flush = -1;
					return Z_OK$3;
				}
			} else {
				put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
				put_byte(s, s.gzhead.time & 255);
				put_byte(s, s.gzhead.time >> 8 & 255);
				put_byte(s, s.gzhead.time >> 16 & 255);
				put_byte(s, s.gzhead.time >> 24 & 255);
				put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
				put_byte(s, s.gzhead.os & 255);
				if (s.gzhead.extra && s.gzhead.extra.length) {
					put_byte(s, s.gzhead.extra.length & 255);
					put_byte(s, s.gzhead.extra.length >> 8 & 255);
				}
				if (s.gzhead.hcrc) strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
				s.gzindex = 0;
				s.status = EXTRA_STATE;
			}
		}
		if (s.status === EXTRA_STATE) {
			if (s.gzhead.extra) {
				let beg = s.pending;
				let left = (s.gzhead.extra.length & 65535) - s.gzindex;
				while (s.pending + left > s.pending_buf_size) {
					let copy$1 = s.pending_buf_size - s.pending;
					s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy$1), s.pending);
					s.pending = s.pending_buf_size;
					if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
					s.gzindex += copy$1;
					flush_pending(strm);
					if (s.pending !== 0) {
						s.last_flush = -1;
						return Z_OK$3;
					}
					beg = 0;
					left -= copy$1;
				}
				let gzhead_extra = new Uint8Array(s.gzhead.extra);
				s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
				s.pending += left;
				if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
				s.gzindex = 0;
			}
			s.status = NAME_STATE;
		}
		if (s.status === NAME_STATE) {
			if (s.gzhead.name) {
				let beg = s.pending;
				let val$1;
				do {
					if (s.pending === s.pending_buf_size) {
						if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
						flush_pending(strm);
						if (s.pending !== 0) {
							s.last_flush = -1;
							return Z_OK$3;
						}
						beg = 0;
					}
					if (s.gzindex < s.gzhead.name.length) val$1 = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
					else val$1 = 0;
					put_byte(s, val$1);
				} while (val$1 !== 0);
				if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
				s.gzindex = 0;
			}
			s.status = COMMENT_STATE;
		}
		if (s.status === COMMENT_STATE) {
			if (s.gzhead.comment) {
				let beg = s.pending;
				let val$1;
				do {
					if (s.pending === s.pending_buf_size) {
						if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
						flush_pending(strm);
						if (s.pending !== 0) {
							s.last_flush = -1;
							return Z_OK$3;
						}
						beg = 0;
					}
					if (s.gzindex < s.gzhead.comment.length) val$1 = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
					else val$1 = 0;
					put_byte(s, val$1);
				} while (val$1 !== 0);
				if (s.gzhead.hcrc && s.pending > beg) strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
			}
			s.status = HCRC_STATE;
		}
		if (s.status === HCRC_STATE) {
			if (s.gzhead.hcrc) {
				if (s.pending + 2 > s.pending_buf_size) {
					flush_pending(strm);
					if (s.pending !== 0) {
						s.last_flush = -1;
						return Z_OK$3;
					}
				}
				put_byte(s, strm.adler & 255);
				put_byte(s, strm.adler >> 8 & 255);
				strm.adler = 0;
			}
			s.status = BUSY_STATE;
			flush_pending(strm);
			if (s.pending !== 0) {
				s.last_flush = -1;
				return Z_OK$3;
			}
		}
		if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
			let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
			if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) s.status = FINISH_STATE;
			if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
				if (strm.avail_out === 0) s.last_flush = -1;
				return Z_OK$3;
			}
			if (bstate === BS_BLOCK_DONE) {
				if (flush === Z_PARTIAL_FLUSH) _tr_align(s);
				else if (flush !== Z_BLOCK$1) {
					_tr_stored_block(s, 0, 0, false);
					if (flush === Z_FULL_FLUSH$1) {
						zero(s.head);
						if (s.lookahead === 0) {
							s.strstart = 0;
							s.block_start = 0;
							s.insert = 0;
						}
					}
				}
				flush_pending(strm);
				if (strm.avail_out === 0) {
					s.last_flush = -1;
					return Z_OK$3;
				}
			}
		}
		if (flush !== Z_FINISH$3) return Z_OK$3;
		if (s.wrap <= 0) return Z_STREAM_END$3;
		if (s.wrap === 2) {
			put_byte(s, strm.adler & 255);
			put_byte(s, strm.adler >> 8 & 255);
			put_byte(s, strm.adler >> 16 & 255);
			put_byte(s, strm.adler >> 24 & 255);
			put_byte(s, strm.total_in & 255);
			put_byte(s, strm.total_in >> 8 & 255);
			put_byte(s, strm.total_in >> 16 & 255);
			put_byte(s, strm.total_in >> 24 & 255);
		} else {
			putShortMSB(s, strm.adler >>> 16);
			putShortMSB(s, strm.adler & 65535);
		}
		flush_pending(strm);
		if (s.wrap > 0) s.wrap = -s.wrap;
		return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
	};
	const deflateEnd = (strm) => {
		if (deflateStateCheck(strm)) return Z_STREAM_ERROR$2;
		const status = strm.state.status;
		strm.state = null;
		return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
	};
	const deflateSetDictionary = (strm, dictionary) => {
		let dictLength = dictionary.length;
		if (deflateStateCheck(strm)) return Z_STREAM_ERROR$2;
		const s = strm.state;
		const wrap = s.wrap;
		if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) return Z_STREAM_ERROR$2;
		if (wrap === 1) strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
		s.wrap = 0;
		if (dictLength >= s.w_size) {
			if (wrap === 0) {
				zero(s.head);
				s.strstart = 0;
				s.block_start = 0;
				s.insert = 0;
			}
			let tmpDict = new Uint8Array(s.w_size);
			tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
			dictionary = tmpDict;
			dictLength = s.w_size;
		}
		const avail = strm.avail_in;
		const next = strm.next_in;
		const input = strm.input;
		strm.avail_in = dictLength;
		strm.next_in = 0;
		strm.input = dictionary;
		fill_window(s);
		while (s.lookahead >= MIN_MATCH) {
			let str = s.strstart;
			let n$2 = s.lookahead - (MIN_MATCH - 1);
			do {
				s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
				s.prev[str & s.w_mask] = s.head[s.ins_h];
				s.head[s.ins_h] = str;
				str++;
			} while (--n$2);
			s.strstart = str;
			s.lookahead = MIN_MATCH - 1;
			fill_window(s);
		}
		s.strstart += s.lookahead;
		s.block_start = s.strstart;
		s.insert = s.lookahead;
		s.lookahead = 0;
		s.match_length = s.prev_length = MIN_MATCH - 1;
		s.match_available = 0;
		strm.next_in = next;
		strm.input = input;
		strm.avail_in = avail;
		s.wrap = wrap;
		return Z_OK$3;
	};
	var deflate_1$2 = {
		deflateInit,
		deflateInit2,
		deflateReset,
		deflateResetKeep,
		deflateSetHeader,
		deflate: deflate$2,
		deflateEnd,
		deflateSetDictionary,
		deflateInfo: "pako deflate (from Nodeca project)"
	};
	const _has = (obj, key) => {
		return Object.prototype.hasOwnProperty.call(obj, key);
	};
	var assign = function(obj) {
		const sources = Array.prototype.slice.call(arguments, 1);
		while (sources.length) {
			const source = sources.shift();
			if (!source) continue;
			if (typeof source !== "object") throw new TypeError(source + "must be non-object");
			for (const p$1 in source) if (_has(source, p$1)) obj[p$1] = source[p$1];
		}
		return obj;
	};
	var flattenChunks = (chunks) => {
		let len = 0;
		for (let i$1 = 0, l = chunks.length; i$1 < l; i$1++) len += chunks[i$1].length;
		const result = new Uint8Array(len);
		for (let i$1 = 0, pos = 0, l = chunks.length; i$1 < l; i$1++) {
			let chunk = chunks[i$1];
			result.set(chunk, pos);
			pos += chunk.length;
		}
		return result;
	};
	var common = {
		assign,
		flattenChunks
	};
	let STR_APPLY_UIA_OK = true;
	try {
		String.fromCharCode.apply(null, new Uint8Array(1));
	} catch (__) {
		STR_APPLY_UIA_OK = false;
	}
	const _utf8len = new Uint8Array(256);
	for (let q = 0; q < 256; q++) _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
	_utf8len[254] = _utf8len[254] = 1;
	var string2buf = (str) => {
		if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) return new TextEncoder().encode(str);
		let buf, c, c2$2, m_pos, i$1, str_len = str.length, buf_len = 0;
		for (m_pos = 0; m_pos < str_len; m_pos++) {
			c = str.charCodeAt(m_pos);
			if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
				c2$2 = str.charCodeAt(m_pos + 1);
				if ((c2$2 & 64512) === 56320) {
					c = 65536 + (c - 55296 << 10) + (c2$2 - 56320);
					m_pos++;
				}
			}
			buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
		}
		buf = new Uint8Array(buf_len);
		for (i$1 = 0, m_pos = 0; i$1 < buf_len; m_pos++) {
			c = str.charCodeAt(m_pos);
			if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
				c2$2 = str.charCodeAt(m_pos + 1);
				if ((c2$2 & 64512) === 56320) {
					c = 65536 + (c - 55296 << 10) + (c2$2 - 56320);
					m_pos++;
				}
			}
			if (c < 128) buf[i$1++] = c;
			else if (c < 2048) {
				buf[i$1++] = 192 | c >>> 6;
				buf[i$1++] = 128 | c & 63;
			} else if (c < 65536) {
				buf[i$1++] = 224 | c >>> 12;
				buf[i$1++] = 128 | c >>> 6 & 63;
				buf[i$1++] = 128 | c & 63;
			} else {
				buf[i$1++] = 240 | c >>> 18;
				buf[i$1++] = 128 | c >>> 12 & 63;
				buf[i$1++] = 128 | c >>> 6 & 63;
				buf[i$1++] = 128 | c & 63;
			}
		}
		return buf;
	};
	const buf2binstring = (buf, len) => {
		if (len < 65534) {
			if (buf.subarray && STR_APPLY_UIA_OK) return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
		}
		let result = "";
		for (let i$1 = 0; i$1 < len; i$1++) result += String.fromCharCode(buf[i$1]);
		return result;
	};
	var buf2string = (buf, max) => {
		const len = max || buf.length;
		if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) return new TextDecoder().decode(buf.subarray(0, max));
		let i$1, out;
		const utf16buf = new Array(len * 2);
		for (out = 0, i$1 = 0; i$1 < len;) {
			let c = buf[i$1++];
			if (c < 128) {
				utf16buf[out++] = c;
				continue;
			}
			let c_len = _utf8len[c];
			if (c_len > 4) {
				utf16buf[out++] = 65533;
				i$1 += c_len - 1;
				continue;
			}
			c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
			while (c_len > 1 && i$1 < len) {
				c = c << 6 | buf[i$1++] & 63;
				c_len--;
			}
			if (c_len > 1) {
				utf16buf[out++] = 65533;
				continue;
			}
			if (c < 65536) utf16buf[out++] = c;
			else {
				c -= 65536;
				utf16buf[out++] = 55296 | c >> 10 & 1023;
				utf16buf[out++] = 56320 | c & 1023;
			}
		}
		return buf2binstring(utf16buf, out);
	};
	var utf8border = (buf, max) => {
		max = max || buf.length;
		if (max > buf.length) max = buf.length;
		let pos = max - 1;
		while (pos >= 0 && (buf[pos] & 192) === 128) pos--;
		if (pos < 0) return max;
		if (pos === 0) return max;
		return pos + _utf8len[buf[pos]] > max ? pos : max;
	};
	var strings = {
		string2buf,
		buf2string,
		utf8border
	};
	function ZStream() {
		this.input = null;
		this.next_in = 0;
		this.avail_in = 0;
		this.total_in = 0;
		this.output = null;
		this.next_out = 0;
		this.avail_out = 0;
		this.total_out = 0;
		this.msg = "";
		this.state = null;
		this.data_type = 2;
		this.adler = 0;
	}
	var zstream = ZStream;
	const toString$1 = Object.prototype.toString;
	const { Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2, Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2, Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY, Z_DEFLATED: Z_DEFLATED$1 } = constants$2;
	function Deflate$1(options$1) {
		this.options = common.assign({
			level: Z_DEFAULT_COMPRESSION,
			method: Z_DEFLATED$1,
			chunkSize: 16384,
			windowBits: 15,
			memLevel: 8,
			strategy: Z_DEFAULT_STRATEGY
		}, options$1 || {});
		let opt = this.options;
		if (opt.raw && opt.windowBits > 0) opt.windowBits = -opt.windowBits;
		else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) opt.windowBits += 16;
		this.err = 0;
		this.msg = "";
		this.ended = false;
		this.chunks = [];
		this.strm = new zstream();
		this.strm.avail_out = 0;
		let status = deflate_1$2.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
		if (status !== Z_OK$2) throw new Error(messages[status]);
		if (opt.header) deflate_1$2.deflateSetHeader(this.strm, opt.header);
		if (opt.dictionary) {
			let dict;
			if (typeof opt.dictionary === "string") dict = strings.string2buf(opt.dictionary);
			else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") dict = new Uint8Array(opt.dictionary);
			else dict = opt.dictionary;
			status = deflate_1$2.deflateSetDictionary(this.strm, dict);
			if (status !== Z_OK$2) throw new Error(messages[status]);
			this._dict_set = true;
		}
	}
	Deflate$1.prototype.push = function(data$2, flush_mode) {
		const strm = this.strm;
		const chunkSize = this.options.chunkSize;
		let status, _flush_mode;
		if (this.ended) return false;
		if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
		else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
		if (typeof data$2 === "string") strm.input = strings.string2buf(data$2);
		else if (toString$1.call(data$2) === "[object ArrayBuffer]") strm.input = new Uint8Array(data$2);
		else strm.input = data$2;
		strm.next_in = 0;
		strm.avail_in = strm.input.length;
		for (;;) {
			if (strm.avail_out === 0) {
				strm.output = new Uint8Array(chunkSize);
				strm.next_out = 0;
				strm.avail_out = chunkSize;
			}
			if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
				this.onData(strm.output.subarray(0, strm.next_out));
				strm.avail_out = 0;
				continue;
			}
			status = deflate_1$2.deflate(strm, _flush_mode);
			if (status === Z_STREAM_END$2) {
				if (strm.next_out > 0) this.onData(strm.output.subarray(0, strm.next_out));
				status = deflate_1$2.deflateEnd(this.strm);
				this.onEnd(status);
				this.ended = true;
				return status === Z_OK$2;
			}
			if (strm.avail_out === 0) {
				this.onData(strm.output);
				continue;
			}
			if (_flush_mode > 0 && strm.next_out > 0) {
				this.onData(strm.output.subarray(0, strm.next_out));
				strm.avail_out = 0;
				continue;
			}
			if (strm.avail_in === 0) break;
		}
		return true;
	};
	Deflate$1.prototype.onData = function(chunk) {
		this.chunks.push(chunk);
	};
	Deflate$1.prototype.onEnd = function(status) {
		if (status === Z_OK$2) this.result = common.flattenChunks(this.chunks);
		this.chunks = [];
		this.err = status;
		this.msg = this.strm.msg;
	};
	function deflate$1(input, options$1) {
		const deflator = new Deflate$1(options$1);
		deflator.push(input, true);
		if (deflator.err) throw deflator.msg || messages[deflator.err];
		return deflator.result;
	}
	function deflateRaw$1(input, options$1) {
		options$1 = options$1 || {};
		options$1.raw = true;
		return deflate$1(input, options$1);
	}
	function gzip$1(input, options$1) {
		options$1 = options$1 || {};
		options$1.gzip = true;
		return deflate$1(input, options$1);
	}
	var deflate_1$1 = {
		Deflate: Deflate$1,
		deflate: deflate$1,
		deflateRaw: deflateRaw$1,
		gzip: gzip$1,
		constants: constants$2
	};
	const BAD$1 = 16209;
	const TYPE$1 = 16191;
	var inffast = function inflate_fast(strm, start) {
		let _in;
		let last$1;
		let _out;
		let beg;
		let end;
		let dmax;
		let wsize;
		let whave;
		let wnext;
		let s_window;
		let hold;
		let bits;
		let lcode;
		let dcode;
		let lmask;
		let dmask;
		let here;
		let op;
		let len;
		let dist;
		let from;
		let from_source;
		let input, output;
		const state = strm.state;
		_in = strm.next_in;
		input = strm.input;
		last$1 = _in + (strm.avail_in - 5);
		_out = strm.next_out;
		output = strm.output;
		beg = _out - (start - strm.avail_out);
		end = _out + (strm.avail_out - 257);
		dmax = state.dmax;
		wsize = state.wsize;
		whave = state.whave;
		wnext = state.wnext;
		s_window = state.window;
		hold = state.hold;
		bits = state.bits;
		lcode = state.lencode;
		dcode = state.distcode;
		lmask = (1 << state.lenbits) - 1;
		dmask = (1 << state.distbits) - 1;
		top: do {
			if (bits < 15) {
				hold += input[_in++] << bits;
				bits += 8;
				hold += input[_in++] << bits;
				bits += 8;
			}
			here = lcode[hold & lmask];
			dolen: for (;;) {
				op = here >>> 24;
				hold >>>= op;
				bits -= op;
				op = here >>> 16 & 255;
				if (op === 0) output[_out++] = here & 65535;
				else if (op & 16) {
					len = here & 65535;
					op &= 15;
					if (op) {
						if (bits < op) {
							hold += input[_in++] << bits;
							bits += 8;
						}
						len += hold & (1 << op) - 1;
						hold >>>= op;
						bits -= op;
					}
					if (bits < 15) {
						hold += input[_in++] << bits;
						bits += 8;
						hold += input[_in++] << bits;
						bits += 8;
					}
					here = dcode[hold & dmask];
					dodist: for (;;) {
						op = here >>> 24;
						hold >>>= op;
						bits -= op;
						op = here >>> 16 & 255;
						if (op & 16) {
							dist = here & 65535;
							op &= 15;
							if (bits < op) {
								hold += input[_in++] << bits;
								bits += 8;
								if (bits < op) {
									hold += input[_in++] << bits;
									bits += 8;
								}
							}
							dist += hold & (1 << op) - 1;
							if (dist > dmax) {
								strm.msg = "invalid distance too far back";
								state.mode = BAD$1;
								break top;
							}
							hold >>>= op;
							bits -= op;
							op = _out - beg;
							if (dist > op) {
								op = dist - op;
								if (op > whave) {
									if (state.sane) {
										strm.msg = "invalid distance too far back";
										state.mode = BAD$1;
										break top;
									}
								}
								from = 0;
								from_source = s_window;
								if (wnext === 0) {
									from += wsize - op;
									if (op < len) {
										len -= op;
										do
											output[_out++] = s_window[from++];
										while (--op);
										from = _out - dist;
										from_source = output;
									}
								} else if (wnext < op) {
									from += wsize + wnext - op;
									op -= wnext;
									if (op < len) {
										len -= op;
										do
											output[_out++] = s_window[from++];
										while (--op);
										from = 0;
										if (wnext < len) {
											op = wnext;
											len -= op;
											do
												output[_out++] = s_window[from++];
											while (--op);
											from = _out - dist;
											from_source = output;
										}
									}
								} else {
									from += wnext - op;
									if (op < len) {
										len -= op;
										do
											output[_out++] = s_window[from++];
										while (--op);
										from = _out - dist;
										from_source = output;
									}
								}
								while (len > 2) {
									output[_out++] = from_source[from++];
									output[_out++] = from_source[from++];
									output[_out++] = from_source[from++];
									len -= 3;
								}
								if (len) {
									output[_out++] = from_source[from++];
									if (len > 1) output[_out++] = from_source[from++];
								}
							} else {
								from = _out - dist;
								do {
									output[_out++] = output[from++];
									output[_out++] = output[from++];
									output[_out++] = output[from++];
									len -= 3;
								} while (len > 2);
								if (len) {
									output[_out++] = output[from++];
									if (len > 1) output[_out++] = output[from++];
								}
							}
						} else if ((op & 64) === 0) {
							here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
							continue dodist;
						} else {
							strm.msg = "invalid distance code";
							state.mode = BAD$1;
							break top;
						}
						break;
					}
				} else if ((op & 64) === 0) {
					here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
					continue dolen;
				} else if (op & 32) {
					state.mode = TYPE$1;
					break top;
				} else {
					strm.msg = "invalid literal/length code";
					state.mode = BAD$1;
					break top;
				}
				break;
			}
		} while (_in < last$1 && _out < end);
		len = bits >> 3;
		_in -= len;
		bits -= len << 3;
		hold &= (1 << bits) - 1;
		strm.next_in = _in;
		strm.next_out = _out;
		strm.avail_in = _in < last$1 ? 5 + (last$1 - _in) : 5 - (_in - last$1);
		strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
		state.hold = hold;
		state.bits = bits;
	};
	const MAXBITS = 15;
	const ENOUGH_LENS$1 = 852;
	const ENOUGH_DISTS$1 = 592;
	const CODES$1 = 0;
	const LENS$1 = 1;
	const DISTS$1 = 2;
	const lbase = new Uint16Array([
		3,
		4,
		5,
		6,
		7,
		8,
		9,
		10,
		11,
		13,
		15,
		17,
		19,
		23,
		27,
		31,
		35,
		43,
		51,
		59,
		67,
		83,
		99,
		115,
		131,
		163,
		195,
		227,
		258,
		0,
		0
	]);
	const lext = new Uint8Array([
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		16,
		17,
		17,
		17,
		17,
		18,
		18,
		18,
		18,
		19,
		19,
		19,
		19,
		20,
		20,
		20,
		20,
		21,
		21,
		21,
		21,
		16,
		72,
		78
	]);
	const dbase = new Uint16Array([
		1,
		2,
		3,
		4,
		5,
		7,
		9,
		13,
		17,
		25,
		33,
		49,
		65,
		97,
		129,
		193,
		257,
		385,
		513,
		769,
		1025,
		1537,
		2049,
		3073,
		4097,
		6145,
		8193,
		12289,
		16385,
		24577,
		0,
		0
	]);
	const dext = new Uint8Array([
		16,
		16,
		16,
		16,
		17,
		17,
		18,
		18,
		19,
		19,
		20,
		20,
		21,
		21,
		22,
		22,
		23,
		23,
		24,
		24,
		25,
		25,
		26,
		26,
		27,
		27,
		28,
		28,
		29,
		29,
		64,
		64
	]);
	const inflate_table = (type$2, lens, lens_index, codes, table$1, table_index, work, opts) => {
		const bits = opts.bits;
		let len = 0;
		let sym = 0;
		let min = 0, max = 0;
		let root = 0;
		let curr = 0;
		let drop = 0;
		let left = 0;
		let used = 0;
		let huff = 0;
		let incr;
		let fill;
		let low;
		let mask;
		let next;
		let base$1 = null;
		let match;
		const count = new Uint16Array(MAXBITS + 1);
		const offs = new Uint16Array(MAXBITS + 1);
		let extra = null;
		let here_bits, here_op, here_val;
		for (len = 0; len <= MAXBITS; len++) count[len] = 0;
		for (sym = 0; sym < codes; sym++) count[lens[lens_index + sym]]++;
		root = bits;
		for (max = MAXBITS; max >= 1; max--) if (count[max] !== 0) break;
		if (root > max) root = max;
		if (max === 0) {
			table$1[table_index++] = 20971520;
			table$1[table_index++] = 20971520;
			opts.bits = 1;
			return 0;
		}
		for (min = 1; min < max; min++) if (count[min] !== 0) break;
		if (root < min) root = min;
		left = 1;
		for (len = 1; len <= MAXBITS; len++) {
			left <<= 1;
			left -= count[len];
			if (left < 0) return -1;
		}
		if (left > 0 && (type$2 === CODES$1 || max !== 1)) return -1;
		offs[1] = 0;
		for (len = 1; len < MAXBITS; len++) offs[len + 1] = offs[len] + count[len];
		for (sym = 0; sym < codes; sym++) if (lens[lens_index + sym] !== 0) work[offs[lens[lens_index + sym]]++] = sym;
		if (type$2 === CODES$1) {
			base$1 = extra = work;
			match = 20;
		} else if (type$2 === LENS$1) {
			base$1 = lbase;
			extra = lext;
			match = 257;
		} else {
			base$1 = dbase;
			extra = dext;
			match = 0;
		}
		huff = 0;
		sym = 0;
		len = min;
		next = table_index;
		curr = root;
		drop = 0;
		low = -1;
		used = 1 << root;
		mask = used - 1;
		if (type$2 === LENS$1 && used > ENOUGH_LENS$1 || type$2 === DISTS$1 && used > ENOUGH_DISTS$1) return 1;
		for (;;) {
			here_bits = len - drop;
			if (work[sym] + 1 < match) {
				here_op = 0;
				here_val = work[sym];
			} else if (work[sym] >= match) {
				here_op = extra[work[sym] - match];
				here_val = base$1[work[sym] - match];
			} else {
				here_op = 96;
				here_val = 0;
			}
			incr = 1 << len - drop;
			fill = 1 << curr;
			min = fill;
			do {
				fill -= incr;
				table$1[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
			} while (fill !== 0);
			incr = 1 << len - 1;
			while (huff & incr) incr >>= 1;
			if (incr !== 0) {
				huff &= incr - 1;
				huff += incr;
			} else huff = 0;
			sym++;
			if (--count[len] === 0) {
				if (len === max) break;
				len = lens[lens_index + work[sym]];
			}
			if (len > root && (huff & mask) !== low) {
				if (drop === 0) drop = root;
				next += min;
				curr = len - drop;
				left = 1 << curr;
				while (curr + drop < max) {
					left -= count[curr + drop];
					if (left <= 0) break;
					curr++;
					left <<= 1;
				}
				used += 1 << curr;
				if (type$2 === LENS$1 && used > ENOUGH_LENS$1 || type$2 === DISTS$1 && used > ENOUGH_DISTS$1) return 1;
				low = huff & mask;
				table$1[low] = root << 24 | curr << 16 | next - table_index | 0;
			}
		}
		if (huff !== 0) table$1[next + huff] = len - drop << 24 | 4194304;
		opts.bits = root;
		return 0;
	};
	var inftrees = inflate_table;
	const CODES = 0;
	const LENS = 1;
	const DISTS = 2;
	const { Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES, Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR, Z_DEFLATED } = constants$2;
	const HEAD = 16180;
	const FLAGS = 16181;
	const TIME = 16182;
	const OS = 16183;
	const EXLEN = 16184;
	const EXTRA = 16185;
	const NAME = 16186;
	const COMMENT = 16187;
	const HCRC = 16188;
	const DICTID = 16189;
	const DICT = 16190;
	const TYPE = 16191;
	const TYPEDO = 16192;
	const STORED = 16193;
	const COPY_ = 16194;
	const COPY = 16195;
	const TABLE = 16196;
	const LENLENS = 16197;
	const CODELENS = 16198;
	const LEN_ = 16199;
	const LEN = 16200;
	const LENEXT = 16201;
	const DIST = 16202;
	const DISTEXT = 16203;
	const MATCH = 16204;
	const LIT = 16205;
	const CHECK = 16206;
	const LENGTH = 16207;
	const DONE = 16208;
	const BAD = 16209;
	const MEM = 16210;
	const SYNC = 16211;
	const ENOUGH_LENS = 852;
	const ENOUGH_DISTS = 592;
	const DEF_WBITS = 15;
	const zswap32 = (q) => {
		return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
	};
	function InflateState() {
		this.strm = null;
		this.mode = 0;
		this.last = false;
		this.wrap = 0;
		this.havedict = false;
		this.flags = 0;
		this.dmax = 0;
		this.check = 0;
		this.total = 0;
		this.head = null;
		this.wbits = 0;
		this.wsize = 0;
		this.whave = 0;
		this.wnext = 0;
		this.window = null;
		this.hold = 0;
		this.bits = 0;
		this.length = 0;
		this.offset = 0;
		this.extra = 0;
		this.lencode = null;
		this.distcode = null;
		this.lenbits = 0;
		this.distbits = 0;
		this.ncode = 0;
		this.nlen = 0;
		this.ndist = 0;
		this.have = 0;
		this.next = null;
		this.lens = new Uint16Array(320);
		this.work = new Uint16Array(288);
		this.lendyn = null;
		this.distdyn = null;
		this.sane = 0;
		this.back = 0;
		this.was = 0;
	}
	const inflateStateCheck = (strm) => {
		if (!strm) return 1;
		const state = strm.state;
		if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) return 1;
		return 0;
	};
	const inflateResetKeep = (strm) => {
		if (inflateStateCheck(strm)) return Z_STREAM_ERROR$1;
		const state = strm.state;
		strm.total_in = strm.total_out = state.total = 0;
		strm.msg = "";
		if (state.wrap) strm.adler = state.wrap & 1;
		state.mode = HEAD;
		state.last = 0;
		state.havedict = 0;
		state.flags = -1;
		state.dmax = 32768;
		state.head = null;
		state.hold = 0;
		state.bits = 0;
		state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
		state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
		state.sane = 1;
		state.back = -1;
		return Z_OK$1;
	};
	const inflateReset = (strm) => {
		if (inflateStateCheck(strm)) return Z_STREAM_ERROR$1;
		const state = strm.state;
		state.wsize = 0;
		state.whave = 0;
		state.wnext = 0;
		return inflateResetKeep(strm);
	};
	const inflateReset2 = (strm, windowBits) => {
		let wrap;
		if (inflateStateCheck(strm)) return Z_STREAM_ERROR$1;
		const state = strm.state;
		if (windowBits < 0) {
			wrap = 0;
			windowBits = -windowBits;
		} else {
			wrap = (windowBits >> 4) + 5;
			if (windowBits < 48) windowBits &= 15;
		}
		if (windowBits && (windowBits < 8 || windowBits > 15)) return Z_STREAM_ERROR$1;
		if (state.window !== null && state.wbits !== windowBits) state.window = null;
		state.wrap = wrap;
		state.wbits = windowBits;
		return inflateReset(strm);
	};
	const inflateInit2 = (strm, windowBits) => {
		if (!strm) return Z_STREAM_ERROR$1;
		const state = new InflateState();
		strm.state = state;
		state.strm = strm;
		state.window = null;
		state.mode = HEAD;
		const ret = inflateReset2(strm, windowBits);
		if (ret !== Z_OK$1) strm.state = null;
		return ret;
	};
	const inflateInit = (strm) => {
		return inflateInit2(strm, DEF_WBITS);
	};
	let virgin = true;
	let lenfix, distfix;
	const fixedtables = (state) => {
		if (virgin) {
			lenfix = new Int32Array(512);
			distfix = new Int32Array(32);
			let sym = 0;
			while (sym < 144) state.lens[sym++] = 8;
			while (sym < 256) state.lens[sym++] = 9;
			while (sym < 280) state.lens[sym++] = 7;
			while (sym < 288) state.lens[sym++] = 8;
			inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
			sym = 0;
			while (sym < 32) state.lens[sym++] = 5;
			inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
			virgin = false;
		}
		state.lencode = lenfix;
		state.lenbits = 9;
		state.distcode = distfix;
		state.distbits = 5;
	};
	const updatewindow = (strm, src, end, copy$1) => {
		let dist;
		const state = strm.state;
		if (state.window === null) {
			state.wsize = 1 << state.wbits;
			state.wnext = 0;
			state.whave = 0;
			state.window = new Uint8Array(state.wsize);
		}
		if (copy$1 >= state.wsize) {
			state.window.set(src.subarray(end - state.wsize, end), 0);
			state.wnext = 0;
			state.whave = state.wsize;
		} else {
			dist = state.wsize - state.wnext;
			if (dist > copy$1) dist = copy$1;
			state.window.set(src.subarray(end - copy$1, end - copy$1 + dist), state.wnext);
			copy$1 -= dist;
			if (copy$1) {
				state.window.set(src.subarray(end - copy$1, end), 0);
				state.wnext = copy$1;
				state.whave = state.wsize;
			} else {
				state.wnext += dist;
				if (state.wnext === state.wsize) state.wnext = 0;
				if (state.whave < state.wsize) state.whave += dist;
			}
		}
		return 0;
	};
	const inflate$2 = (strm, flush) => {
		let state;
		let input, output;
		let next;
		let put;
		let have, left;
		let hold;
		let bits;
		let _in, _out;
		let copy$1;
		let from;
		let from_source;
		let here = 0;
		let here_bits, here_op, here_val;
		let last_bits, last_op, last_val;
		let len;
		let ret;
		const hbuf = new Uint8Array(4);
		let opts;
		let n$2;
		const order = new Uint8Array([
			16,
			17,
			18,
			0,
			8,
			7,
			9,
			6,
			10,
			5,
			11,
			4,
			12,
			3,
			13,
			2,
			14,
			1,
			15
		]);
		if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) return Z_STREAM_ERROR$1;
		state = strm.state;
		if (state.mode === TYPE) state.mode = TYPEDO;
		put = strm.next_out;
		output = strm.output;
		left = strm.avail_out;
		next = strm.next_in;
		input = strm.input;
		have = strm.avail_in;
		hold = state.hold;
		bits = state.bits;
		_in = have;
		_out = left;
		ret = Z_OK$1;
		inf_leave: for (;;) switch (state.mode) {
			case HEAD:
				if (state.wrap === 0) {
					state.mode = TYPEDO;
					break;
				}
				while (bits < 16) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				if (state.wrap & 2 && hold === 35615) {
					if (state.wbits === 0) state.wbits = 15;
					state.check = 0;
					hbuf[0] = hold & 255;
					hbuf[1] = hold >>> 8 & 255;
					state.check = crc32_1(state.check, hbuf, 2, 0);
					hold = 0;
					bits = 0;
					state.mode = FLAGS;
					break;
				}
				if (state.head) state.head.done = false;
				if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
					strm.msg = "incorrect header check";
					state.mode = BAD;
					break;
				}
				if ((hold & 15) !== Z_DEFLATED) {
					strm.msg = "unknown compression method";
					state.mode = BAD;
					break;
				}
				hold >>>= 4;
				bits -= 4;
				len = (hold & 15) + 8;
				if (state.wbits === 0) state.wbits = len;
				if (len > 15 || len > state.wbits) {
					strm.msg = "invalid window size";
					state.mode = BAD;
					break;
				}
				state.dmax = 1 << state.wbits;
				state.flags = 0;
				strm.adler = state.check = 1;
				state.mode = hold & 512 ? DICTID : TYPE;
				hold = 0;
				bits = 0;
				break;
			case FLAGS:
				while (bits < 16) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				state.flags = hold;
				if ((state.flags & 255) !== Z_DEFLATED) {
					strm.msg = "unknown compression method";
					state.mode = BAD;
					break;
				}
				if (state.flags & 57344) {
					strm.msg = "unknown header flags set";
					state.mode = BAD;
					break;
				}
				if (state.head) state.head.text = hold >> 8 & 1;
				if (state.flags & 512 && state.wrap & 4) {
					hbuf[0] = hold & 255;
					hbuf[1] = hold >>> 8 & 255;
					state.check = crc32_1(state.check, hbuf, 2, 0);
				}
				hold = 0;
				bits = 0;
				state.mode = TIME;
			case TIME:
				while (bits < 32) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				if (state.head) state.head.time = hold;
				if (state.flags & 512 && state.wrap & 4) {
					hbuf[0] = hold & 255;
					hbuf[1] = hold >>> 8 & 255;
					hbuf[2] = hold >>> 16 & 255;
					hbuf[3] = hold >>> 24 & 255;
					state.check = crc32_1(state.check, hbuf, 4, 0);
				}
				hold = 0;
				bits = 0;
				state.mode = OS;
			case OS:
				while (bits < 16) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				if (state.head) {
					state.head.xflags = hold & 255;
					state.head.os = hold >> 8;
				}
				if (state.flags & 512 && state.wrap & 4) {
					hbuf[0] = hold & 255;
					hbuf[1] = hold >>> 8 & 255;
					state.check = crc32_1(state.check, hbuf, 2, 0);
				}
				hold = 0;
				bits = 0;
				state.mode = EXLEN;
			case EXLEN:
				if (state.flags & 1024) {
					while (bits < 16) {
						if (have === 0) break inf_leave;
						have--;
						hold += input[next++] << bits;
						bits += 8;
					}
					state.length = hold;
					if (state.head) state.head.extra_len = hold;
					if (state.flags & 512 && state.wrap & 4) {
						hbuf[0] = hold & 255;
						hbuf[1] = hold >>> 8 & 255;
						state.check = crc32_1(state.check, hbuf, 2, 0);
					}
					hold = 0;
					bits = 0;
				} else if (state.head) state.head.extra = null;
				state.mode = EXTRA;
			case EXTRA:
				if (state.flags & 1024) {
					copy$1 = state.length;
					if (copy$1 > have) copy$1 = have;
					if (copy$1) {
						if (state.head) {
							len = state.head.extra_len - state.length;
							if (!state.head.extra) state.head.extra = new Uint8Array(state.head.extra_len);
							state.head.extra.set(input.subarray(next, next + copy$1), len);
						}
						if (state.flags & 512 && state.wrap & 4) state.check = crc32_1(state.check, input, copy$1, next);
						have -= copy$1;
						next += copy$1;
						state.length -= copy$1;
					}
					if (state.length) break inf_leave;
				}
				state.length = 0;
				state.mode = NAME;
			case NAME:
				if (state.flags & 2048) {
					if (have === 0) break inf_leave;
					copy$1 = 0;
					do {
						len = input[next + copy$1++];
						if (state.head && len && state.length < 65536) state.head.name += String.fromCharCode(len);
					} while (len && copy$1 < have);
					if (state.flags & 512 && state.wrap & 4) state.check = crc32_1(state.check, input, copy$1, next);
					have -= copy$1;
					next += copy$1;
					if (len) break inf_leave;
				} else if (state.head) state.head.name = null;
				state.length = 0;
				state.mode = COMMENT;
			case COMMENT:
				if (state.flags & 4096) {
					if (have === 0) break inf_leave;
					copy$1 = 0;
					do {
						len = input[next + copy$1++];
						if (state.head && len && state.length < 65536) state.head.comment += String.fromCharCode(len);
					} while (len && copy$1 < have);
					if (state.flags & 512 && state.wrap & 4) state.check = crc32_1(state.check, input, copy$1, next);
					have -= copy$1;
					next += copy$1;
					if (len) break inf_leave;
				} else if (state.head) state.head.comment = null;
				state.mode = HCRC;
			case HCRC:
				if (state.flags & 512) {
					while (bits < 16) {
						if (have === 0) break inf_leave;
						have--;
						hold += input[next++] << bits;
						bits += 8;
					}
					if (state.wrap & 4 && hold !== (state.check & 65535)) {
						strm.msg = "header crc mismatch";
						state.mode = BAD;
						break;
					}
					hold = 0;
					bits = 0;
				}
				if (state.head) {
					state.head.hcrc = state.flags >> 9 & 1;
					state.head.done = true;
				}
				strm.adler = state.check = 0;
				state.mode = TYPE;
				break;
			case DICTID:
				while (bits < 32) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				strm.adler = state.check = zswap32(hold);
				hold = 0;
				bits = 0;
				state.mode = DICT;
			case DICT:
				if (state.havedict === 0) {
					strm.next_out = put;
					strm.avail_out = left;
					strm.next_in = next;
					strm.avail_in = have;
					state.hold = hold;
					state.bits = bits;
					return Z_NEED_DICT$1;
				}
				strm.adler = state.check = 1;
				state.mode = TYPE;
			case TYPE: if (flush === Z_BLOCK || flush === Z_TREES) break inf_leave;
			case TYPEDO:
				if (state.last) {
					hold >>>= bits & 7;
					bits -= bits & 7;
					state.mode = CHECK;
					break;
				}
				while (bits < 3) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				state.last = hold & 1;
				hold >>>= 1;
				bits -= 1;
				switch (hold & 3) {
					case 0:
						state.mode = STORED;
						break;
					case 1:
						fixedtables(state);
						state.mode = LEN_;
						if (flush === Z_TREES) {
							hold >>>= 2;
							bits -= 2;
							break inf_leave;
						}
						break;
					case 2:
						state.mode = TABLE;
						break;
					case 3:
						strm.msg = "invalid block type";
						state.mode = BAD;
				}
				hold >>>= 2;
				bits -= 2;
				break;
			case STORED:
				hold >>>= bits & 7;
				bits -= bits & 7;
				while (bits < 32) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
					strm.msg = "invalid stored block lengths";
					state.mode = BAD;
					break;
				}
				state.length = hold & 65535;
				hold = 0;
				bits = 0;
				state.mode = COPY_;
				if (flush === Z_TREES) break inf_leave;
			case COPY_: state.mode = COPY;
			case COPY:
				copy$1 = state.length;
				if (copy$1) {
					if (copy$1 > have) copy$1 = have;
					if (copy$1 > left) copy$1 = left;
					if (copy$1 === 0) break inf_leave;
					output.set(input.subarray(next, next + copy$1), put);
					have -= copy$1;
					next += copy$1;
					left -= copy$1;
					put += copy$1;
					state.length -= copy$1;
					break;
				}
				state.mode = TYPE;
				break;
			case TABLE:
				while (bits < 14) {
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				state.nlen = (hold & 31) + 257;
				hold >>>= 5;
				bits -= 5;
				state.ndist = (hold & 31) + 1;
				hold >>>= 5;
				bits -= 5;
				state.ncode = (hold & 15) + 4;
				hold >>>= 4;
				bits -= 4;
				if (state.nlen > 286 || state.ndist > 30) {
					strm.msg = "too many length or distance symbols";
					state.mode = BAD;
					break;
				}
				state.have = 0;
				state.mode = LENLENS;
			case LENLENS:
				while (state.have < state.ncode) {
					while (bits < 3) {
						if (have === 0) break inf_leave;
						have--;
						hold += input[next++] << bits;
						bits += 8;
					}
					state.lens[order[state.have++]] = hold & 7;
					hold >>>= 3;
					bits -= 3;
				}
				while (state.have < 19) state.lens[order[state.have++]] = 0;
				state.lencode = state.lendyn;
				state.lenbits = 7;
				opts = { bits: state.lenbits };
				ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
				state.lenbits = opts.bits;
				if (ret) {
					strm.msg = "invalid code lengths set";
					state.mode = BAD;
					break;
				}
				state.have = 0;
				state.mode = CODELENS;
			case CODELENS:
				while (state.have < state.nlen + state.ndist) {
					for (;;) {
						here = state.lencode[hold & (1 << state.lenbits) - 1];
						here_bits = here >>> 24;
						here_op = here >>> 16 & 255;
						here_val = here & 65535;
						if (here_bits <= bits) break;
						if (have === 0) break inf_leave;
						have--;
						hold += input[next++] << bits;
						bits += 8;
					}
					if (here_val < 16) {
						hold >>>= here_bits;
						bits -= here_bits;
						state.lens[state.have++] = here_val;
					} else {
						if (here_val === 16) {
							n$2 = here_bits + 2;
							while (bits < n$2) {
								if (have === 0) break inf_leave;
								have--;
								hold += input[next++] << bits;
								bits += 8;
							}
							hold >>>= here_bits;
							bits -= here_bits;
							if (state.have === 0) {
								strm.msg = "invalid bit length repeat";
								state.mode = BAD;
								break;
							}
							len = state.lens[state.have - 1];
							copy$1 = 3 + (hold & 3);
							hold >>>= 2;
							bits -= 2;
						} else if (here_val === 17) {
							n$2 = here_bits + 3;
							while (bits < n$2) {
								if (have === 0) break inf_leave;
								have--;
								hold += input[next++] << bits;
								bits += 8;
							}
							hold >>>= here_bits;
							bits -= here_bits;
							len = 0;
							copy$1 = 3 + (hold & 7);
							hold >>>= 3;
							bits -= 3;
						} else {
							n$2 = here_bits + 7;
							while (bits < n$2) {
								if (have === 0) break inf_leave;
								have--;
								hold += input[next++] << bits;
								bits += 8;
							}
							hold >>>= here_bits;
							bits -= here_bits;
							len = 0;
							copy$1 = 11 + (hold & 127);
							hold >>>= 7;
							bits -= 7;
						}
						if (state.have + copy$1 > state.nlen + state.ndist) {
							strm.msg = "invalid bit length repeat";
							state.mode = BAD;
							break;
						}
						while (copy$1--) state.lens[state.have++] = len;
					}
				}
				if (state.mode === BAD) break;
				if (state.lens[256] === 0) {
					strm.msg = "invalid code -- missing end-of-block";
					state.mode = BAD;
					break;
				}
				state.lenbits = 9;
				opts = { bits: state.lenbits };
				ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
				state.lenbits = opts.bits;
				if (ret) {
					strm.msg = "invalid literal/lengths set";
					state.mode = BAD;
					break;
				}
				state.distbits = 6;
				state.distcode = state.distdyn;
				opts = { bits: state.distbits };
				ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
				state.distbits = opts.bits;
				if (ret) {
					strm.msg = "invalid distances set";
					state.mode = BAD;
					break;
				}
				state.mode = LEN_;
				if (flush === Z_TREES) break inf_leave;
			case LEN_: state.mode = LEN;
			case LEN:
				if (have >= 6 && left >= 258) {
					strm.next_out = put;
					strm.avail_out = left;
					strm.next_in = next;
					strm.avail_in = have;
					state.hold = hold;
					state.bits = bits;
					inffast(strm, _out);
					put = strm.next_out;
					output = strm.output;
					left = strm.avail_out;
					next = strm.next_in;
					input = strm.input;
					have = strm.avail_in;
					hold = state.hold;
					bits = state.bits;
					if (state.mode === TYPE) state.back = -1;
					break;
				}
				state.back = 0;
				for (;;) {
					here = state.lencode[hold & (1 << state.lenbits) - 1];
					here_bits = here >>> 24;
					here_op = here >>> 16 & 255;
					here_val = here & 65535;
					if (here_bits <= bits) break;
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				if (here_op && (here_op & 240) === 0) {
					last_bits = here_bits;
					last_op = here_op;
					last_val = here_val;
					for (;;) {
						here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
						here_bits = here >>> 24;
						here_op = here >>> 16 & 255;
						here_val = here & 65535;
						if (last_bits + here_bits <= bits) break;
						if (have === 0) break inf_leave;
						have--;
						hold += input[next++] << bits;
						bits += 8;
					}
					hold >>>= last_bits;
					bits -= last_bits;
					state.back += last_bits;
				}
				hold >>>= here_bits;
				bits -= here_bits;
				state.back += here_bits;
				state.length = here_val;
				if (here_op === 0) {
					state.mode = LIT;
					break;
				}
				if (here_op & 32) {
					state.back = -1;
					state.mode = TYPE;
					break;
				}
				if (here_op & 64) {
					strm.msg = "invalid literal/length code";
					state.mode = BAD;
					break;
				}
				state.extra = here_op & 15;
				state.mode = LENEXT;
			case LENEXT:
				if (state.extra) {
					n$2 = state.extra;
					while (bits < n$2) {
						if (have === 0) break inf_leave;
						have--;
						hold += input[next++] << bits;
						bits += 8;
					}
					state.length += hold & (1 << state.extra) - 1;
					hold >>>= state.extra;
					bits -= state.extra;
					state.back += state.extra;
				}
				state.was = state.length;
				state.mode = DIST;
			case DIST:
				for (;;) {
					here = state.distcode[hold & (1 << state.distbits) - 1];
					here_bits = here >>> 24;
					here_op = here >>> 16 & 255;
					here_val = here & 65535;
					if (here_bits <= bits) break;
					if (have === 0) break inf_leave;
					have--;
					hold += input[next++] << bits;
					bits += 8;
				}
				if ((here_op & 240) === 0) {
					last_bits = here_bits;
					last_op = here_op;
					last_val = here_val;
					for (;;) {
						here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
						here_bits = here >>> 24;
						here_op = here >>> 16 & 255;
						here_val = here & 65535;
						if (last_bits + here_bits <= bits) break;
						if (have === 0) break inf_leave;
						have--;
						hold += input[next++] << bits;
						bits += 8;
					}
					hold >>>= last_bits;
					bits -= last_bits;
					state.back += last_bits;
				}
				hold >>>= here_bits;
				bits -= here_bits;
				state.back += here_bits;
				if (here_op & 64) {
					strm.msg = "invalid distance code";
					state.mode = BAD;
					break;
				}
				state.offset = here_val;
				state.extra = here_op & 15;
				state.mode = DISTEXT;
			case DISTEXT:
				if (state.extra) {
					n$2 = state.extra;
					while (bits < n$2) {
						if (have === 0) break inf_leave;
						have--;
						hold += input[next++] << bits;
						bits += 8;
					}
					state.offset += hold & (1 << state.extra) - 1;
					hold >>>= state.extra;
					bits -= state.extra;
					state.back += state.extra;
				}
				if (state.offset > state.dmax) {
					strm.msg = "invalid distance too far back";
					state.mode = BAD;
					break;
				}
				state.mode = MATCH;
			case MATCH:
				if (left === 0) break inf_leave;
				copy$1 = _out - left;
				if (state.offset > copy$1) {
					copy$1 = state.offset - copy$1;
					if (copy$1 > state.whave) {
						if (state.sane) {
							strm.msg = "invalid distance too far back";
							state.mode = BAD;
							break;
						}
					}
					if (copy$1 > state.wnext) {
						copy$1 -= state.wnext;
						from = state.wsize - copy$1;
					} else from = state.wnext - copy$1;
					if (copy$1 > state.length) copy$1 = state.length;
					from_source = state.window;
				} else {
					from_source = output;
					from = put - state.offset;
					copy$1 = state.length;
				}
				if (copy$1 > left) copy$1 = left;
				left -= copy$1;
				state.length -= copy$1;
				do
					output[put++] = from_source[from++];
				while (--copy$1);
				if (state.length === 0) state.mode = LEN;
				break;
			case LIT:
				if (left === 0) break inf_leave;
				output[put++] = state.length;
				left--;
				state.mode = LEN;
				break;
			case CHECK:
				if (state.wrap) {
					while (bits < 32) {
						if (have === 0) break inf_leave;
						have--;
						hold |= input[next++] << bits;
						bits += 8;
					}
					_out -= left;
					strm.total_out += _out;
					state.total += _out;
					if (state.wrap & 4 && _out) strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
					_out = left;
					if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
						strm.msg = "incorrect data check";
						state.mode = BAD;
						break;
					}
					hold = 0;
					bits = 0;
				}
				state.mode = LENGTH;
			case LENGTH:
				if (state.wrap && state.flags) {
					while (bits < 32) {
						if (have === 0) break inf_leave;
						have--;
						hold += input[next++] << bits;
						bits += 8;
					}
					if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
						strm.msg = "incorrect length check";
						state.mode = BAD;
						break;
					}
					hold = 0;
					bits = 0;
				}
				state.mode = DONE;
			case DONE:
				ret = Z_STREAM_END$1;
				break inf_leave;
			case BAD:
				ret = Z_DATA_ERROR$1;
				break inf_leave;
			case MEM: return Z_MEM_ERROR$1;
			case SYNC:
			default: return Z_STREAM_ERROR$1;
		}
		strm.next_out = put;
		strm.avail_out = left;
		strm.next_in = next;
		strm.avail_in = have;
		state.hold = hold;
		state.bits = bits;
		if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
			if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out));
		}
		_in -= strm.avail_in;
		_out -= strm.avail_out;
		strm.total_in += _in;
		strm.total_out += _out;
		state.total += _out;
		if (state.wrap & 4 && _out) strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
		strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
		if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) ret = Z_BUF_ERROR;
		return ret;
	};
	const inflateEnd = (strm) => {
		if (inflateStateCheck(strm)) return Z_STREAM_ERROR$1;
		let state = strm.state;
		if (state.window) state.window = null;
		strm.state = null;
		return Z_OK$1;
	};
	const inflateGetHeader = (strm, head) => {
		if (inflateStateCheck(strm)) return Z_STREAM_ERROR$1;
		const state = strm.state;
		if ((state.wrap & 2) === 0) return Z_STREAM_ERROR$1;
		state.head = head;
		head.done = false;
		return Z_OK$1;
	};
	const inflateSetDictionary = (strm, dictionary) => {
		const dictLength = dictionary.length;
		let state;
		let dictid;
		let ret;
		if (inflateStateCheck(strm)) return Z_STREAM_ERROR$1;
		state = strm.state;
		if (state.wrap !== 0 && state.mode !== DICT) return Z_STREAM_ERROR$1;
		if (state.mode === DICT) {
			dictid = 1;
			dictid = adler32_1(dictid, dictionary, dictLength, 0);
			if (dictid !== state.check) return Z_DATA_ERROR$1;
		}
		ret = updatewindow(strm, dictionary, dictLength, dictLength);
		if (ret) {
			state.mode = MEM;
			return Z_MEM_ERROR$1;
		}
		state.havedict = 1;
		return Z_OK$1;
	};
	var inflate_1$2 = {
		inflateReset,
		inflateReset2,
		inflateResetKeep,
		inflateInit,
		inflateInit2,
		inflate: inflate$2,
		inflateEnd,
		inflateGetHeader,
		inflateSetDictionary,
		inflateInfo: "pako inflate (from Nodeca project)"
	};
	function GZheader() {
		this.text = 0;
		this.time = 0;
		this.xflags = 0;
		this.os = 0;
		this.extra = null;
		this.extra_len = 0;
		this.name = "";
		this.comment = "";
		this.hcrc = 0;
		this.done = false;
	}
	var gzheader = GZheader;
	const toString = Object.prototype.toString;
	const { Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR } = constants$2;
	function Inflate$1(options$1) {
		this.options = common.assign({
			chunkSize: 1024 * 64,
			windowBits: 15,
			to: ""
		}, options$1 || {});
		const opt = this.options;
		if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
			opt.windowBits = -opt.windowBits;
			if (opt.windowBits === 0) opt.windowBits = -15;
		}
		if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options$1 && options$1.windowBits)) opt.windowBits += 32;
		if (opt.windowBits > 15 && opt.windowBits < 48) {
			if ((opt.windowBits & 15) === 0) opt.windowBits |= 15;
		}
		this.err = 0;
		this.msg = "";
		this.ended = false;
		this.chunks = [];
		this.strm = new zstream();
		this.strm.avail_out = 0;
		let status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);
		if (status !== Z_OK) throw new Error(messages[status]);
		this.header = new gzheader();
		inflate_1$2.inflateGetHeader(this.strm, this.header);
		if (opt.dictionary) {
			if (typeof opt.dictionary === "string") opt.dictionary = strings.string2buf(opt.dictionary);
			else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") opt.dictionary = new Uint8Array(opt.dictionary);
			if (opt.raw) {
				status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
				if (status !== Z_OK) throw new Error(messages[status]);
			}
		}
	}
	Inflate$1.prototype.push = function(data$2, flush_mode) {
		const strm = this.strm;
		const chunkSize = this.options.chunkSize;
		const dictionary = this.options.dictionary;
		let status, _flush_mode, last_avail_out;
		if (this.ended) return false;
		if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
		else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
		if (toString.call(data$2) === "[object ArrayBuffer]") strm.input = new Uint8Array(data$2);
		else strm.input = data$2;
		strm.next_in = 0;
		strm.avail_in = strm.input.length;
		for (;;) {
			if (strm.avail_out === 0) {
				strm.output = new Uint8Array(chunkSize);
				strm.next_out = 0;
				strm.avail_out = chunkSize;
			}
			status = inflate_1$2.inflate(strm, _flush_mode);
			if (status === Z_NEED_DICT && dictionary) {
				status = inflate_1$2.inflateSetDictionary(strm, dictionary);
				if (status === Z_OK) status = inflate_1$2.inflate(strm, _flush_mode);
				else if (status === Z_DATA_ERROR) status = Z_NEED_DICT;
			}
			while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data$2[strm.next_in] !== 0) {
				inflate_1$2.inflateReset(strm);
				status = inflate_1$2.inflate(strm, _flush_mode);
			}
			switch (status) {
				case Z_STREAM_ERROR:
				case Z_DATA_ERROR:
				case Z_NEED_DICT:
				case Z_MEM_ERROR:
					this.onEnd(status);
					this.ended = true;
					return false;
			}
			last_avail_out = strm.avail_out;
			if (strm.next_out) {
				if (strm.avail_out === 0 || status === Z_STREAM_END) if (this.options.to === "string") {
					let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
					let tail = strm.next_out - next_out_utf8;
					let utf8str = strings.buf2string(strm.output, next_out_utf8);
					strm.next_out = tail;
					strm.avail_out = chunkSize - tail;
					if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
					this.onData(utf8str);
				} else this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
			}
			if (status === Z_OK && last_avail_out === 0) continue;
			if (status === Z_STREAM_END) {
				status = inflate_1$2.inflateEnd(this.strm);
				this.onEnd(status);
				this.ended = true;
				return true;
			}
			if (strm.avail_in === 0) break;
		}
		return true;
	};
	Inflate$1.prototype.onData = function(chunk) {
		this.chunks.push(chunk);
	};
	Inflate$1.prototype.onEnd = function(status) {
		if (status === Z_OK) if (this.options.to === "string") this.result = this.chunks.join("");
		else this.result = common.flattenChunks(this.chunks);
		this.chunks = [];
		this.err = status;
		this.msg = this.strm.msg;
	};
	function inflate$1(input, options$1) {
		const inflator = new Inflate$1(options$1);
		inflator.push(input);
		if (inflator.err) throw inflator.msg || messages[inflator.err];
		return inflator.result;
	}
	function inflateRaw$1(input, options$1) {
		options$1 = options$1 || {};
		options$1.raw = true;
		return inflate$1(input, options$1);
	}
	var inflate_1$1 = {
		Inflate: Inflate$1,
		inflate: inflate$1,
		inflateRaw: inflateRaw$1,
		ungzip: inflate$1,
		constants: constants$2
	};
	const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
	const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
	const pako = { inflate };
	var Typr = {};
	Typr["parse"] = function(buff) {
		var bin = Typr["B"];
		var readFont = function(data$3, idx, offset$1, tmap$1) {
			var T$1 = Typr["T"];
			var prsr = {
				"cmap": T$1.cmap,
				"head": T$1.head,
				"hhea": T$1.hhea,
				"maxp": T$1.maxp,
				"hmtx": T$1.hmtx,
				"name": T$1.name,
				"OS/2": T$1.OS2,
				"post": T$1.post,
				"loca": T$1.loca,
				"kern": T$1.kern,
				"glyf": T$1.glyf,
				"CFF ": T$1.CFF,
				"GSUB": T$1.GSUB,
				"CBLC": T$1.CBLC,
				"CBDT": T$1.CBDT,
				"SVG ": T$1.SVG,
				"COLR": T$1.colr,
				"CPAL": T$1.cpal,
				"sbix": T$1.sbix,
				"fvar": T$1.fvar,
				"gvar": T$1.gvar,
				"avar": T$1.avar,
				"HVAR": T$1.HVAR
			};
			var obj$1 = {
				"_data": data$3,
				"_index": idx,
				"_offset": offset$1
			};
			for (var t$1 in prsr) {
				var tab = Typr["findTable"](data$3, t$1, offset$1);
				if (tab) {
					var off = tab[0], tobj = tmap$1[off];
					if (tobj == null) tobj = prsr[t$1].parseTab(data$3, off, tab[1], obj$1);
					obj$1[t$1] = tmap$1[off] = tobj;
				}
			}
			return obj$1;
		};
		function woffToOtf(data$3) {
			var numTables = bin.readUshort(data$3, 12);
			var totalSize = bin.readUint(data$3, 16);
			var otf = new Uint8Array(totalSize), toff = 12 + numTables * 16;
			bin.writeASCII(otf, 0, "OTTO");
			bin.writeUshort(otf, 4, numTables);
			var off = 44;
			for (var i$2 = 0; i$2 < numTables; i$2++) {
				var tag = bin.readASCII(data$3, off, 4);
				var tof = bin.readUint(data$3, off + 4);
				var cLe = bin.readUint(data$3, off + 8);
				var oLe = bin.readUint(data$3, off + 12);
				off += 20;
				var tab = data$3.slice(tof, tof + cLe);
				if (cLe != oLe) tab = pako["inflate"](tab);
				var to$1 = 12 + i$2 * 16;
				bin.writeASCII(otf, to$1, tag);
				bin.writeUint(otf, to$1 + 8, toff);
				bin.writeUint(otf, to$1 + 12, oLe);
				otf.set(tab, toff);
				toff += oLe;
			}
			return otf;
		}
		var data$2 = new Uint8Array(buff);
		let compressedData;
		if (data$2[0] == 119) {
			compressedData = data$2;
			data$2 = woffToOtf(data$2);
		}
		var tmap = {};
		if (bin.readASCII(data$2, 0, 4) == "ttcf") {
			var offset = 4;
			bin.readUshort(data$2, offset);
			offset += 2;
			bin.readUshort(data$2, offset);
			offset += 2;
			var numF = bin.readUint(data$2, offset);
			offset += 4;
			var fnts = [];
			for (var i$1 = 0; i$1 < numF; i$1++) {
				var foff = bin.readUint(data$2, offset);
				offset += 4;
				fnts.push(readFont(data$2, i$1, foff, tmap));
			}
			return fnts;
		}
		var fnt = readFont(data$2, 0, 0, tmap);
		fnt._compressedData = compressedData;
		var fvar = fnt["fvar"];
		if (fvar) {
			var out = [fnt];
			for (var i$1 = 0; i$1 < fvar[1].length; i$1++) {
				var fv = fvar[1][i$1];
				var obj = {};
				out.push(obj);
				for (var p$1 in fnt) obj[p$1] = fnt[p$1];
				obj["_index"] = i$1;
				var name = obj["name"] = JSON.parse(JSON.stringify(obj["name"]));
				name["fontSubfamily"] = fv[0];
				if (fv[3] == null) fv[3] = (name["fontFamily"] + "-" + name["fontSubfamily"])["replaceAll"](" ", "");
				name["postScriptName"] = fv[3];
			}
			return out;
		}
		return [fnt];
	};
	Typr["findTable"] = function(data$2, tab, foff) {
		var bin = Typr["B"];
		var numTables = bin.readUshort(data$2, foff + 4);
		var offset = foff + 12;
		for (var i$1 = 0; i$1 < numTables; i$1++) {
			var tag = bin.readASCII(data$2, offset, 4);
			bin.readUint(data$2, offset + 4);
			var toffset = bin.readUint(data$2, offset + 8);
			var length = bin.readUint(data$2, offset + 12);
			if (tag == tab) return [toffset, length];
			offset += 16;
		}
		return null;
	};
	Typr["T"] = {};
	Typr["B"] = {
		readFixed: function(data$2, o) {
			return (data$2[o] << 8 | data$2[o + 1]) + (data$2[o + 2] << 8 | data$2[o + 3]) / 65540;
		},
		readF2dot14: function(data$2, o) {
			return Typr["B"].readShort(data$2, o) / 16384;
		},
		readInt: function(buff, p$1) {
			var a = Typr["B"].t.uint8;
			a[0] = buff[p$1 + 3];
			a[1] = buff[p$1 + 2];
			a[2] = buff[p$1 + 1];
			a[3] = buff[p$1];
			return Typr["B"].t.int32[0];
		},
		readInt8: function(buff, p$1) {
			var a = Typr["B"].t.uint8;
			a[0] = buff[p$1];
			return Typr["B"].t.int8[0];
		},
		readShort: function(buff, p$1) {
			var a = Typr["B"].t.uint16;
			a[0] = buff[p$1] << 8 | buff[p$1 + 1];
			return Typr["B"].t.int16[0];
		},
		readUshort: function(buff, p$1) {
			return buff[p$1] << 8 | buff[p$1 + 1];
		},
		writeUshort: function(buff, p$1, n$2) {
			buff[p$1] = n$2 >> 8 & 255;
			buff[p$1 + 1] = n$2 & 255;
		},
		readUshorts: function(buff, p$1, len) {
			var arr$1 = [];
			for (var i$1 = 0; i$1 < len; i$1++) {
				var v$1 = Typr["B"].readUshort(buff, p$1 + i$1 * 2);
				arr$1.push(v$1);
			}
			return arr$1;
		},
		readUint: function(buff, p$1) {
			var a = Typr["B"].t.uint8;
			a[3] = buff[p$1];
			a[2] = buff[p$1 + 1];
			a[1] = buff[p$1 + 2];
			a[0] = buff[p$1 + 3];
			return Typr["B"].t.uint32[0];
		},
		writeUint: function(buff, p$1, n$2) {
			buff[p$1] = n$2 >> 24 & 255;
			buff[p$1 + 1] = n$2 >> 16 & 255;
			buff[p$1 + 2] = n$2 >> 8 & 255;
			buff[p$1 + 3] = n$2 >> 0 & 255;
		},
		readUint64: function(buff, p$1) {
			return Typr["B"].readUint(buff, p$1) * 4294967296 + Typr["B"].readUint(buff, p$1 + 4);
		},
		readASCII: function(buff, p$1, l) {
			var s = "";
			for (var i$1 = 0; i$1 < l; i$1++) s += String.fromCharCode(buff[p$1 + i$1]);
			return s;
		},
		writeASCII: function(buff, p$1, s) {
			for (var i$1 = 0; i$1 < s.length; i$1++) buff[p$1 + i$1] = s.charCodeAt(i$1);
		},
		readUnicode: function(buff, p$1, l) {
			var s = "";
			for (var i$1 = 0; i$1 < l; i$1++) {
				var c = buff[p$1++] << 8 | buff[p$1++];
				s += String.fromCharCode(c);
			}
			return s;
		},
		_tdec: window["TextDecoder"] ? new window["TextDecoder"]() : null,
		readUTF8: function(buff, p$1, l) {
			var tdec = Typr["B"]._tdec;
			if (tdec && p$1 == 0 && l == buff.length) return tdec["decode"](buff);
			return Typr["B"].readASCII(buff, p$1, l);
		},
		readBytes: function(buff, p$1, l) {
			var arr$1 = [];
			for (var i$1 = 0; i$1 < l; i$1++) arr$1.push(buff[p$1 + i$1]);
			return arr$1;
		},
		readASCIIArray: function(buff, p$1, l) {
			var s = [];
			for (var i$1 = 0; i$1 < l; i$1++) s.push(String.fromCharCode(buff[p$1 + i$1]));
			return s;
		},
		t: function() {
			var ab = /* @__PURE__ */ new ArrayBuffer(8);
			return {
				buff: ab,
				int8: new Int8Array(ab),
				uint8: new Uint8Array(ab),
				int16: new Int16Array(ab),
				uint16: new Uint16Array(ab),
				int32: new Int32Array(ab),
				uint32: new Uint32Array(ab)
			};
		}()
	};
	Typr["T"].CFF = {
		parseTab: function(data$2, offset, length) {
			var bin = Typr["B"];
			var CFF = Typr["T"].CFF;
			data$2 = new Uint8Array(data$2.buffer, offset, length);
			offset = 0;
			data$2[offset];
			offset++;
			data$2[offset];
			offset++;
			data$2[offset];
			offset++;
			data$2[offset];
			offset++;
			var ninds = [];
			offset = CFF.readIndex(data$2, offset, ninds);
			var names = [];
			for (var i$1 = 0; i$1 < ninds.length - 1; i$1++) names.push(bin.readASCII(data$2, offset + ninds[i$1], ninds[i$1 + 1] - ninds[i$1]));
			offset += ninds[ninds.length - 1];
			var tdinds = [];
			offset = CFF.readIndex(data$2, offset, tdinds);
			var topDicts = [];
			for (var i$1 = 0; i$1 < tdinds.length - 1; i$1++) topDicts.push(CFF.readDict(data$2, offset + tdinds[i$1], offset + tdinds[i$1 + 1]));
			offset += tdinds[tdinds.length - 1];
			var topdict = topDicts[0];
			var sinds = [];
			offset = CFF.readIndex(data$2, offset, sinds);
			var strings$2 = [];
			for (var i$1 = 0; i$1 < sinds.length - 1; i$1++) strings$2.push(bin.readASCII(data$2, offset + sinds[i$1], sinds[i$1 + 1] - sinds[i$1]));
			offset += sinds[sinds.length - 1];
			CFF.readSubrs(data$2, offset, topdict);
			if (topdict["CharStrings"]) topdict["CharStrings"] = CFF.readBytes(data$2, topdict["CharStrings"]);
			if (topdict["ROS"]) {
				offset = topdict["FDArray"];
				var fdind = [];
				offset = CFF.readIndex(data$2, offset, fdind);
				topdict["FDArray"] = [];
				for (var i$1 = 0; i$1 < fdind.length - 1; i$1++) {
					var dict = CFF.readDict(data$2, offset + fdind[i$1], offset + fdind[i$1 + 1]);
					CFF._readFDict(data$2, dict, strings$2);
					topdict["FDArray"].push(dict);
				}
				offset += fdind[fdind.length - 1];
				offset = topdict["FDSelect"];
				topdict["FDSelect"] = [];
				var fmt = data$2[offset];
				offset++;
				if (fmt == 3) {
					var rns = bin.readUshort(data$2, offset);
					offset += 2;
					for (var i$1 = 0; i$1 < rns + 1; i$1++) {
						topdict["FDSelect"].push(bin.readUshort(data$2, offset), data$2[offset + 2]);
						offset += 3;
					}
				} else throw fmt;
			}
			if (topdict["charset"]) topdict["charset"] = CFF.readCharset(data$2, topdict["charset"], topdict["CharStrings"].length);
			CFF._readFDict(data$2, topdict, strings$2);
			return topdict;
		},
		_readFDict: function(data$2, dict, ss) {
			var CFF = Typr["T"].CFF;
			var offset;
			if (dict["Private"]) {
				offset = dict["Private"][1];
				dict["Private"] = CFF.readDict(data$2, offset, offset + dict["Private"][0]);
				if (dict["Private"]["Subrs"]) CFF.readSubrs(data$2, offset + dict["Private"]["Subrs"], dict["Private"]);
			}
			for (var p$1 in dict) if ([
				"FamilyName",
				"FontName",
				"FullName",
				"Notice",
				"version",
				"Copyright"
			].indexOf(p$1) != -1) dict[p$1] = ss[dict[p$1] - 426 + 35];
		},
		readSubrs: function(data$2, offset, obj) {
			obj["Subrs"] = Typr["T"].CFF.readBytes(data$2, offset);
			var bias, nSubrs = obj["Subrs"].length + 1;
			if (nSubrs < 1240) bias = 107;
			else if (nSubrs < 33900) bias = 1131;
			else bias = 32768;
			obj["Bias"] = bias;
		},
		readBytes: function(data$2, offset) {
			Typr["B"];
			var arr$1 = [];
			offset = Typr["T"].CFF.readIndex(data$2, offset, arr$1);
			var subrs = [], arl = arr$1.length - 1, no = data$2.byteOffset + offset;
			for (var i$1 = 0; i$1 < arl; i$1++) {
				var ari = arr$1[i$1];
				subrs.push(new Uint8Array(data$2.buffer, no + ari, arr$1[i$1 + 1] - ari));
			}
			return subrs;
		},
		tableSE: [
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			1,
			2,
			3,
			4,
			5,
			6,
			7,
			8,
			9,
			10,
			11,
			12,
			13,
			14,
			15,
			16,
			17,
			18,
			19,
			20,
			21,
			22,
			23,
			24,
			25,
			26,
			27,
			28,
			29,
			30,
			31,
			32,
			33,
			34,
			35,
			36,
			37,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			46,
			47,
			48,
			49,
			50,
			51,
			52,
			53,
			54,
			55,
			56,
			57,
			58,
			59,
			60,
			61,
			62,
			63,
			64,
			65,
			66,
			67,
			68,
			69,
			70,
			71,
			72,
			73,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			82,
			83,
			84,
			85,
			86,
			87,
			88,
			89,
			90,
			91,
			92,
			93,
			94,
			95,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			96,
			97,
			98,
			99,
			100,
			101,
			102,
			103,
			104,
			105,
			106,
			107,
			108,
			109,
			110,
			0,
			111,
			112,
			113,
			114,
			0,
			115,
			116,
			117,
			118,
			119,
			120,
			121,
			122,
			0,
			123,
			0,
			124,
			125,
			126,
			127,
			128,
			129,
			130,
			131,
			0,
			132,
			133,
			0,
			134,
			135,
			136,
			137,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			138,
			0,
			139,
			0,
			0,
			0,
			0,
			140,
			141,
			142,
			143,
			0,
			0,
			0,
			0,
			0,
			144,
			0,
			0,
			0,
			145,
			0,
			0,
			146,
			147,
			148,
			149,
			0,
			0,
			0,
			0
		],
		glyphByUnicode: function(cff, code) {
			for (var i$1 = 0; i$1 < cff["charset"].length; i$1++) if (cff["charset"][i$1] == code) return i$1;
			return -1;
		},
		glyphBySE: function(cff, charcode) {
			if (charcode < 0 || charcode > 255) return -1;
			return Typr["T"].CFF.glyphByUnicode(cff, Typr["T"].CFF.tableSE[charcode]);
		},
		readCharset: function(data$2, offset, num) {
			var bin = Typr["B"];
			var charset = [".notdef"];
			var format = data$2[offset];
			offset++;
			if (format == 0) for (var i$1 = 0; i$1 < num; i$1++) {
				var first = bin.readUshort(data$2, offset);
				offset += 2;
				charset.push(first);
			}
			else if (format == 1 || format == 2) while (charset.length < num) {
				var first = bin.readUshort(data$2, offset);
				offset += 2;
				var nLeft = 0;
				if (format == 1) {
					nLeft = data$2[offset];
					offset++;
				} else {
					nLeft = bin.readUshort(data$2, offset);
					offset += 2;
				}
				for (var i$1 = 0; i$1 <= nLeft; i$1++) {
					charset.push(first);
					first++;
				}
			}
			else throw "error: format: " + format;
			return charset;
		},
		readIndex: function(data$2, offset, inds) {
			var bin = Typr["B"];
			var count = bin.readUshort(data$2, offset) + 1;
			offset += 2;
			var offsize = data$2[offset];
			offset++;
			if (offsize == 1) for (var i$1 = 0; i$1 < count; i$1++) inds.push(data$2[offset + i$1]);
			else if (offsize == 2) for (var i$1 = 0; i$1 < count; i$1++) inds.push(bin.readUshort(data$2, offset + i$1 * 2));
			else if (offsize == 3) for (var i$1 = 0; i$1 < count; i$1++) inds.push(bin.readUint(data$2, offset + i$1 * 3 - 1) & 16777215);
			else if (offsize == 4) for (var i$1 = 0; i$1 < count; i$1++) inds.push(bin.readUint(data$2, offset + i$1 * 4));
			else if (count != 1) throw "unsupported offset size: " + offsize + ", count: " + count;
			offset += count * offsize;
			return offset - 1;
		},
		getCharString: function(data$2, offset, o) {
			var bin = Typr["B"];
			var b0 = data$2[offset], b1 = data$2[offset + 1];
			data$2[offset + 2];
			data$2[offset + 3];
			data$2[offset + 4];
			var vs = 1;
			var op = null, val$1 = null;
			if (b0 <= 20) {
				op = b0;
				vs = 1;
			}
			if (b0 == 12) {
				op = b0 * 100 + b1;
				vs = 2;
			}
			if (21 <= b0 && b0 <= 27) {
				op = b0;
				vs = 1;
			}
			if (b0 == 28) {
				val$1 = bin.readShort(data$2, offset + 1);
				vs = 3;
			}
			if (29 <= b0 && b0 <= 31) {
				op = b0;
				vs = 1;
			}
			if (32 <= b0 && b0 <= 246) {
				val$1 = b0 - 139;
				vs = 1;
			}
			if (247 <= b0 && b0 <= 250) {
				val$1 = (b0 - 247) * 256 + b1 + 108;
				vs = 2;
			}
			if (251 <= b0 && b0 <= 254) {
				val$1 = -(b0 - 251) * 256 - b1 - 108;
				vs = 2;
			}
			if (b0 == 255) {
				val$1 = bin.readInt(data$2, offset + 1) / 65535;
				vs = 5;
			}
			o.val = val$1 != null ? val$1 : "o" + op;
			o.size = vs;
		},
		readCharString: function(data$2, offset, length) {
			var end = offset + length;
			var bin = Typr["B"];
			var arr$1 = [];
			while (offset < end) {
				var b0 = data$2[offset], b1 = data$2[offset + 1];
				data$2[offset + 2];
				data$2[offset + 3];
				data$2[offset + 4];
				var vs = 1;
				var op = null, val$1 = null;
				if (b0 <= 20) {
					op = b0;
					vs = 1;
				}
				if (b0 == 12) {
					op = b0 * 100 + b1;
					vs = 2;
				}
				if (b0 == 19 || b0 == 20) {
					op = b0;
					vs = 2;
				}
				if (21 <= b0 && b0 <= 27) {
					op = b0;
					vs = 1;
				}
				if (b0 == 28) {
					val$1 = bin.readShort(data$2, offset + 1);
					vs = 3;
				}
				if (29 <= b0 && b0 <= 31) {
					op = b0;
					vs = 1;
				}
				if (32 <= b0 && b0 <= 246) {
					val$1 = b0 - 139;
					vs = 1;
				}
				if (247 <= b0 && b0 <= 250) {
					val$1 = (b0 - 247) * 256 + b1 + 108;
					vs = 2;
				}
				if (251 <= b0 && b0 <= 254) {
					val$1 = -(b0 - 251) * 256 - b1 - 108;
					vs = 2;
				}
				if (b0 == 255) {
					val$1 = bin.readInt(data$2, offset + 1) / 65535;
					vs = 5;
				}
				arr$1.push(val$1 != null ? val$1 : "o" + op);
				offset += vs;
			}
			return arr$1;
		},
		readDict: function(data$2, offset, end) {
			var bin = Typr["B"];
			var dict = {};
			var carr = [];
			while (offset < end) {
				var b0 = data$2[offset], b1 = data$2[offset + 1];
				data$2[offset + 2];
				data$2[offset + 3];
				data$2[offset + 4];
				var vs = 1;
				var key = null, val$1 = null;
				if (b0 == 28) {
					val$1 = bin.readShort(data$2, offset + 1);
					vs = 3;
				}
				if (b0 == 29) {
					val$1 = bin.readInt(data$2, offset + 1);
					vs = 5;
				}
				if (32 <= b0 && b0 <= 246) {
					val$1 = b0 - 139;
					vs = 1;
				}
				if (247 <= b0 && b0 <= 250) {
					val$1 = (b0 - 247) * 256 + b1 + 108;
					vs = 2;
				}
				if (251 <= b0 && b0 <= 254) {
					val$1 = -(b0 - 251) * 256 - b1 - 108;
					vs = 2;
				}
				if (b0 == 255) {
					val$1 = bin.readInt(data$2, offset + 1) / 65535;
					vs = 5;
					throw "unknown number";
				}
				if (b0 == 30) {
					var nibs = [];
					vs = 1;
					while (true) {
						var b$1 = data$2[offset + vs];
						vs++;
						var nib0 = b$1 >> 4, nib1 = b$1 & 15;
						if (nib0 != 15) nibs.push(nib0);
						if (nib1 != 15) nibs.push(nib1);
						if (nib1 == 15) break;
					}
					var s = "";
					var chars = [
						0,
						1,
						2,
						3,
						4,
						5,
						6,
						7,
						8,
						9,
						".",
						"e",
						"e-",
						"reserved",
						"-",
						"endOfNumber"
					];
					for (var i$1 = 0; i$1 < nibs.length; i$1++) s += chars[nibs[i$1]];
					val$1 = parseFloat(s);
				}
				if (b0 <= 21) {
					var keys = [
						"version",
						"Notice",
						"FullName",
						"FamilyName",
						"Weight",
						"FontBBox",
						"BlueValues",
						"OtherBlues",
						"FamilyBlues",
						"FamilyOtherBlues",
						"StdHW",
						"StdVW",
						"escape",
						"UniqueID",
						"XUID",
						"charset",
						"Encoding",
						"CharStrings",
						"Private",
						"Subrs",
						"defaultWidthX",
						"nominalWidthX"
					];
					key = keys[b0];
					vs = 1;
					if (b0 == 12) {
						var keys = [
							"Copyright",
							"isFixedPitch",
							"ItalicAngle",
							"UnderlinePosition",
							"UnderlineThickness",
							"PaintType",
							"CharstringType",
							"FontMatrix",
							"StrokeWidth",
							"BlueScale",
							"BlueShift",
							"BlueFuzz",
							"StemSnapH",
							"StemSnapV",
							"ForceBold",
							"",
							"",
							"LanguageGroup",
							"ExpansionFactor",
							"initialRandomSeed",
							"SyntheticBase",
							"PostScript",
							"BaseFontName",
							"BaseFontBlend",
							"",
							"",
							"",
							"",
							"",
							"",
							"ROS",
							"CIDFontVersion",
							"CIDFontRevision",
							"CIDFontType",
							"CIDCount",
							"UIDBase",
							"FDArray",
							"FDSelect",
							"FontName"
						];
						key = keys[b1];
						vs = 2;
					}
				}
				if (key != null) {
					dict[key] = carr.length == 1 ? carr[0] : carr;
					carr = [];
				} else carr.push(val$1);
				offset += vs;
			}
			return dict;
		}
	};
	Typr["T"].cmap = {
		parseTab: function(data$2, offset, length) {
			var obj = {
				tables: [],
				ids: {},
				off: offset
			};
			data$2 = new Uint8Array(data$2.buffer, offset, length);
			offset = 0;
			var bin = Typr["B"], rU = bin.readUshort, cmap = Typr["T"].cmap;
			rU(data$2, offset);
			offset += 2;
			var numTables = rU(data$2, offset);
			offset += 2;
			var offs = [];
			for (var i$1 = 0; i$1 < numTables; i$1++) {
				var platformID = rU(data$2, offset);
				offset += 2;
				var encodingID = rU(data$2, offset);
				offset += 2;
				var noffset = bin.readUint(data$2, offset);
				offset += 4;
				var id = "p" + platformID + "e" + encodingID;
				var tind = offs.indexOf(noffset);
				if (tind == -1) {
					tind = obj.tables.length;
					var subt = {};
					offs.push(noffset);
					var format = subt.format = rU(data$2, noffset);
					if (format == 0) subt = cmap.parse0(data$2, noffset, subt);
					else if (format == 4) subt = cmap.parse4(data$2, noffset, subt);
					else if (format == 6) subt = cmap.parse6(data$2, noffset, subt);
					else if (format == 12) subt = cmap.parse12(data$2, noffset, subt);
					obj.tables.push(subt);
				}
				if (obj.ids[id] != null) console.log("multiple tables for one platform+encoding: " + id);
				obj.ids[id] = tind;
			}
			return obj;
		},
		parse0: function(data$2, offset, obj) {
			var bin = Typr["B"];
			offset += 2;
			var len = bin.readUshort(data$2, offset);
			offset += 2;
			bin.readUshort(data$2, offset);
			offset += 2;
			obj.map = [];
			for (var i$1 = 0; i$1 < len - 6; i$1++) obj.map.push(data$2[offset + i$1]);
			return obj;
		},
		parse4: function(data$2, offset, obj) {
			var bin = Typr["B"], rU = bin.readUshort, rUs = bin.readUshorts;
			var offset0 = offset;
			offset += 2;
			var length = rU(data$2, offset);
			offset += 2;
			rU(data$2, offset);
			offset += 2;
			var segCountX2 = rU(data$2, offset);
			offset += 2;
			var segCount = segCountX2 >>> 1;
			obj.searchRange = rU(data$2, offset);
			offset += 2;
			obj.entrySelector = rU(data$2, offset);
			offset += 2;
			obj.rangeShift = rU(data$2, offset);
			offset += 2;
			obj.endCount = rUs(data$2, offset, segCount);
			offset += segCount * 2;
			offset += 2;
			obj.startCount = rUs(data$2, offset, segCount);
			offset += segCount * 2;
			obj.idDelta = [];
			for (var i$1 = 0; i$1 < segCount; i$1++) {
				obj.idDelta.push(bin.readShort(data$2, offset));
				offset += 2;
			}
			obj.idRangeOffset = rUs(data$2, offset, segCount);
			offset += segCount * 2;
			obj.glyphIdArray = rUs(data$2, offset, offset0 + length - offset >> 1);
			return obj;
		},
		parse6: function(data$2, offset, obj) {
			var bin = Typr["B"];
			offset += 2;
			bin.readUshort(data$2, offset);
			offset += 2;
			bin.readUshort(data$2, offset);
			offset += 2;
			obj.firstCode = bin.readUshort(data$2, offset);
			offset += 2;
			var entryCount = bin.readUshort(data$2, offset);
			offset += 2;
			obj.glyphIdArray = [];
			for (var i$1 = 0; i$1 < entryCount; i$1++) {
				obj.glyphIdArray.push(bin.readUshort(data$2, offset));
				offset += 2;
			}
			return obj;
		},
		parse12: function(data$2, offset, obj) {
			var rU = Typr["B"].readUint;
			offset += 4;
			rU(data$2, offset);
			offset += 4;
			rU(data$2, offset);
			offset += 4;
			var nGroups = rU(data$2, offset) * 3;
			offset += 4;
			var gps = obj.groups = new Uint32Array(nGroups);
			for (var i$1 = 0; i$1 < nGroups; i$1 += 3) {
				gps[i$1] = rU(data$2, offset + (i$1 << 2));
				gps[i$1 + 1] = rU(data$2, offset + (i$1 << 2) + 4);
				gps[i$1 + 2] = rU(data$2, offset + (i$1 << 2) + 8);
			}
			return obj;
		}
	};
	Typr["T"].CBLC = { parseTab: function(data$2, offset, length) {
		var bin = Typr["B"], ooff = offset;
		bin.readUshort(data$2, offset);
		offset += 2;
		bin.readUshort(data$2, offset);
		offset += 2;
		var numSizes = bin.readUint(data$2, offset);
		offset += 4;
		var out = [];
		for (var i$1 = 0; i$1 < numSizes; i$1++) {
			var off = bin.readUint(data$2, offset);
			offset += 4;
			bin.readUint(data$2, offset);
			offset += 4;
			bin.readUint(data$2, offset);
			offset += 4;
			offset += 4;
			offset += 24;
			bin.readUshort(data$2, offset);
			offset += 2;
			bin.readUshort(data$2, offset);
			offset += 2;
			offset += 4;
			var coff = ooff + off;
			for (var j = 0; j < 3; j++) {
				var fgI = bin.readUshort(data$2, coff);
				coff += 2;
				var lgI = bin.readUshort(data$2, coff);
				coff += 2;
				var nxt = bin.readUint(data$2, coff);
				coff += 4;
				var gcnt = lgI - fgI + 1;
				var ioff = ooff + off + nxt;
				var inF = bin.readUshort(data$2, ioff);
				ioff += 2;
				if (inF != 1) throw inF;
				var imF = bin.readUshort(data$2, ioff);
				ioff += 2;
				var imgo = bin.readUint(data$2, ioff);
				ioff += 4;
				var oarr = [];
				for (var gi = 0; gi < gcnt; gi++) {
					var sbitO = bin.readUint(data$2, ioff + gi * 4);
					oarr.push(imgo + sbitO);
				}
				out.push([
					fgI,
					lgI,
					imF,
					oarr
				]);
			}
		}
		return out;
	} };
	Typr["T"].CBDT = { parseTab: function(data$2, offset, length) {
		Typr["B"];
		return new Uint8Array(data$2.buffer, data$2.byteOffset + offset, length);
	} };
	Typr["T"].glyf = {
		parseTab: function(data$2, offset, length, font$1) {
			var obj = [], ng = font$1["maxp"]["numGlyphs"];
			for (var g$1 = 0; g$1 < ng; g$1++) obj.push(null);
			return obj;
		},
		_parseGlyf: function(font$1, g$1) {
			var bin = Typr["B"];
			var data$2 = font$1["_data"], loca = font$1["loca"];
			if (loca[g$1] == loca[g$1 + 1]) return null;
			var offset = Typr["findTable"](data$2, "glyf", font$1["_offset"])[0] + loca[g$1];
			var gl = {};
			gl.noc = bin.readShort(data$2, offset);
			offset += 2;
			gl.xMin = bin.readShort(data$2, offset);
			offset += 2;
			gl.yMin = bin.readShort(data$2, offset);
			offset += 2;
			gl.xMax = bin.readShort(data$2, offset);
			offset += 2;
			gl.yMax = bin.readShort(data$2, offset);
			offset += 2;
			if (gl.xMin >= gl.xMax || gl.yMin >= gl.yMax) return null;
			if (gl.noc > 0) {
				gl.endPts = [];
				for (var i$1 = 0; i$1 < gl.noc; i$1++) {
					gl.endPts.push(bin.readUshort(data$2, offset));
					offset += 2;
				}
				var instructionLength = bin.readUshort(data$2, offset);
				offset += 2;
				if (data$2.length - offset < instructionLength) return null;
				gl.instructions = bin.readBytes(data$2, offset, instructionLength);
				offset += instructionLength;
				var crdnum = gl.endPts[gl.noc - 1] + 1;
				gl.flags = [];
				for (var i$1 = 0; i$1 < crdnum; i$1++) {
					var flag = data$2[offset];
					offset++;
					gl.flags.push(flag);
					if ((flag & 8) != 0) {
						var rep = data$2[offset];
						offset++;
						for (var j = 0; j < rep; j++) {
							gl.flags.push(flag);
							i$1++;
						}
					}
				}
				gl.xs = [];
				for (var i$1 = 0; i$1 < crdnum; i$1++) {
					var i8 = (gl.flags[i$1] & 2) != 0, same = (gl.flags[i$1] & 16) != 0;
					if (i8) {
						gl.xs.push(same ? data$2[offset] : -data$2[offset]);
						offset++;
					} else if (same) gl.xs.push(0);
					else {
						gl.xs.push(bin.readShort(data$2, offset));
						offset += 2;
					}
				}
				gl.ys = [];
				for (var i$1 = 0; i$1 < crdnum; i$1++) {
					var i8 = (gl.flags[i$1] & 4) != 0, same = (gl.flags[i$1] & 32) != 0;
					if (i8) {
						gl.ys.push(same ? data$2[offset] : -data$2[offset]);
						offset++;
					} else if (same) gl.ys.push(0);
					else {
						gl.ys.push(bin.readShort(data$2, offset));
						offset += 2;
					}
				}
				var x$1 = 0, y = 0;
				for (var i$1 = 0; i$1 < crdnum; i$1++) {
					x$1 += gl.xs[i$1];
					y += gl.ys[i$1];
					gl.xs[i$1] = x$1;
					gl.ys[i$1] = y;
				}
			} else {
				var ARG_1_AND_2_ARE_WORDS = 1;
				var ARGS_ARE_XY_VALUES = 2;
				var WE_HAVE_A_SCALE = 8;
				var MORE_COMPONENTS = 32;
				var WE_HAVE_AN_X_AND_Y_SCALE = 64;
				var WE_HAVE_A_TWO_BY_TWO = 128;
				var WE_HAVE_INSTRUCTIONS = 256;
				gl.parts = [];
				var flags;
				do {
					flags = bin.readUshort(data$2, offset);
					offset += 2;
					var part = {
						m: {
							a: 1,
							b: 0,
							c: 0,
							d: 1,
							tx: 0,
							ty: 0
						},
						p1: -1,
						p2: -1
					};
					gl.parts.push(part);
					part.glyphIndex = bin.readUshort(data$2, offset);
					offset += 2;
					if (flags & ARG_1_AND_2_ARE_WORDS) {
						var arg1 = bin.readShort(data$2, offset);
						offset += 2;
						var arg2 = bin.readShort(data$2, offset);
						offset += 2;
					} else {
						var arg1 = bin.readInt8(data$2, offset);
						offset++;
						var arg2 = bin.readInt8(data$2, offset);
						offset++;
					}
					if (flags & ARGS_ARE_XY_VALUES) {
						part.m.tx = arg1;
						part.m.ty = arg2;
					} else {
						part.p1 = arg1;
						part.p2 = arg2;
					}
					if (flags & WE_HAVE_A_SCALE) {
						part.m.a = part.m.d = bin.readF2dot14(data$2, offset);
						offset += 2;
					} else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
						part.m.a = bin.readF2dot14(data$2, offset);
						offset += 2;
						part.m.d = bin.readF2dot14(data$2, offset);
						offset += 2;
					} else if (flags & WE_HAVE_A_TWO_BY_TWO) {
						part.m.a = bin.readF2dot14(data$2, offset);
						offset += 2;
						part.m.b = bin.readF2dot14(data$2, offset);
						offset += 2;
						part.m.c = bin.readF2dot14(data$2, offset);
						offset += 2;
						part.m.d = bin.readF2dot14(data$2, offset);
						offset += 2;
					}
				} while (flags & MORE_COMPONENTS);
				if (flags & WE_HAVE_INSTRUCTIONS) {
					var numInstr = bin.readUshort(data$2, offset);
					offset += 2;
					gl.instr = [];
					for (var i$1 = 0; i$1 < numInstr; i$1++) {
						gl.instr.push(data$2[offset]);
						offset++;
					}
				}
			}
			return gl;
		}
	};
	Typr["T"].head = { parseTab: function(data$2, offset, length) {
		var bin = Typr["B"];
		var obj = {};
		bin.readFixed(data$2, offset);
		offset += 4;
		obj["fontRevision"] = bin.readFixed(data$2, offset);
		offset += 4;
		bin.readUint(data$2, offset);
		offset += 4;
		bin.readUint(data$2, offset);
		offset += 4;
		obj["flags"] = bin.readUshort(data$2, offset);
		offset += 2;
		obj["unitsPerEm"] = bin.readUshort(data$2, offset);
		offset += 2;
		obj["created"] = bin.readUint64(data$2, offset);
		offset += 8;
		obj["modified"] = bin.readUint64(data$2, offset);
		offset += 8;
		obj["xMin"] = bin.readShort(data$2, offset);
		offset += 2;
		obj["yMin"] = bin.readShort(data$2, offset);
		offset += 2;
		obj["xMax"] = bin.readShort(data$2, offset);
		offset += 2;
		obj["yMax"] = bin.readShort(data$2, offset);
		offset += 2;
		obj["macStyle"] = bin.readUshort(data$2, offset);
		offset += 2;
		obj["lowestRecPPEM"] = bin.readUshort(data$2, offset);
		offset += 2;
		obj["fontDirectionHint"] = bin.readShort(data$2, offset);
		offset += 2;
		obj["indexToLocFormat"] = bin.readShort(data$2, offset);
		offset += 2;
		obj["glyphDataFormat"] = bin.readShort(data$2, offset);
		offset += 2;
		return obj;
	} };
	Typr["T"].hhea = { parseTab: function(data$2, offset, length) {
		var bin = Typr["B"];
		var obj = {};
		bin.readFixed(data$2, offset);
		offset += 4;
		var keys = [
			"ascender",
			"descender",
			"lineGap",
			"advanceWidthMax",
			"minLeftSideBearing",
			"minRightSideBearing",
			"xMaxExtent",
			"caretSlopeRise",
			"caretSlopeRun",
			"caretOffset",
			"res0",
			"res1",
			"res2",
			"res3",
			"metricDataFormat",
			"numberOfHMetrics"
		];
		for (var i$1 = 0; i$1 < keys.length; i$1++) {
			var key = keys[i$1];
			obj[key] = (key == "advanceWidthMax" || key == "numberOfHMetrics" ? bin.readUshort : bin.readShort)(data$2, offset + i$1 * 2);
		}
		return obj;
	} };
	Typr["T"].hmtx = { parseTab: function(data$2, offset, length, font$1) {
		var bin = Typr["B"];
		var aWidth = [];
		var lsBearing = [];
		var nG = font$1["maxp"]["numGlyphs"], nH = font$1["hhea"]["numberOfHMetrics"];
		var aw = 0, lsb = 0, i$1 = 0;
		while (i$1 < nH) {
			aw = bin.readUshort(data$2, offset + (i$1 << 2));
			lsb = bin.readShort(data$2, offset + (i$1 << 2) + 2);
			aWidth.push(aw);
			lsBearing.push(lsb);
			i$1++;
		}
		while (i$1 < nG) {
			aWidth.push(aw);
			lsBearing.push(lsb);
			i$1++;
		}
		return {
			aWidth,
			lsBearing
		};
	} };
	Typr["T"].kern = {
		parseTab: function(data$2, offset, length, font$1) {
			var bin = Typr["B"], kern = Typr["T"].kern;
			if (bin.readUshort(data$2, offset) == 1) return kern.parseV1(data$2, offset, length, font$1);
			var nTables = bin.readUshort(data$2, offset + 2);
			offset += 4;
			var map$1 = {
				glyph1: [],
				rval: []
			};
			for (var i$1 = 0; i$1 < nTables; i$1++) {
				offset += 2;
				var length = bin.readUshort(data$2, offset);
				offset += 2;
				var coverage = bin.readUshort(data$2, offset);
				offset += 2;
				var format = coverage >>> 8;
				format &= 15;
				if (format == 0) offset = kern.readFormat0(data$2, offset, map$1);
			}
			return map$1;
		},
		parseV1: function(data$2, offset, length, font$1) {
			var bin = Typr["B"], kern = Typr["T"].kern;
			bin.readFixed(data$2, offset);
			var nTables = bin.readUint(data$2, offset + 4);
			offset += 8;
			var map$1 = {
				glyph1: [],
				rval: []
			};
			for (var i$1 = 0; i$1 < nTables; i$1++) {
				bin.readUint(data$2, offset);
				offset += 4;
				var coverage = bin.readUshort(data$2, offset);
				offset += 2;
				bin.readUshort(data$2, offset);
				offset += 2;
				if ((coverage & 255) == 0) offset = kern.readFormat0(data$2, offset, map$1);
			}
			return map$1;
		},
		readFormat0: function(data$2, offset, map$1) {
			var bin = Typr["B"], rUs = bin.readUshort;
			var pleft = -1;
			var nPairs = rUs(data$2, offset);
			rUs(data$2, offset + 2);
			rUs(data$2, offset + 4);
			rUs(data$2, offset + 6);
			offset += 8;
			for (var j = 0; j < nPairs; j++) {
				var left = rUs(data$2, offset);
				offset += 2;
				var right = rUs(data$2, offset);
				offset += 2;
				var value = bin.readShort(data$2, offset);
				offset += 2;
				if (left != pleft) {
					map$1.glyph1.push(left);
					map$1.rval.push({
						glyph2: [],
						vals: []
					});
				}
				var rval = map$1.rval[map$1.rval.length - 1];
				rval.glyph2.push(right);
				rval.vals.push(value);
				pleft = left;
			}
			return offset;
		}
	};
	Typr["T"].loca = { parseTab: function(data$2, offset, length, font$1) {
		var bin = Typr["B"];
		var obj = [];
		var ver = font$1["head"]["indexToLocFormat"];
		var len = font$1["maxp"]["numGlyphs"] + 1;
		if (ver == 0) for (var i$1 = 0; i$1 < len; i$1++) obj.push(bin.readUshort(data$2, offset + (i$1 << 1)) << 1);
		if (ver == 1) for (var i$1 = 0; i$1 < len; i$1++) obj.push(bin.readUint(data$2, offset + (i$1 << 2)));
		return obj;
	} };
	Typr["T"].maxp = { parseTab: function(data$2, offset, length) {
		var bin = Typr["B"], rU = bin.readUshort;
		var obj = {};
		bin.readUint(data$2, offset);
		offset += 4;
		obj["numGlyphs"] = rU(data$2, offset);
		offset += 2;
		return obj;
	} };
	Typr["T"].name = {
		parseTab: function(data$2, offset, length) {
			var bin = Typr["B"];
			var obj = {};
			bin.readUshort(data$2, offset);
			offset += 2;
			var count = bin.readUshort(data$2, offset);
			offset += 2;
			var stringOffset = bin.readUshort(data$2, offset);
			offset += 2;
			var ooo = offset - 6 + stringOffset;
			var names = [
				"copyright",
				"fontFamily",
				"fontSubfamily",
				"ID",
				"fullName",
				"version",
				"postScriptName",
				"trademark",
				"manufacturer",
				"designer",
				"description",
				"urlVendor",
				"urlDesigner",
				"licence",
				"licenceURL",
				"---",
				"typoFamilyName",
				"typoSubfamilyName",
				"compatibleFull",
				"sampleText",
				"postScriptCID",
				"wwsFamilyName",
				"wwsSubfamilyName",
				"lightPalette",
				"darkPalette"
			];
			var rU = bin.readUshort;
			for (var i$1 = 0; i$1 < count; i$1++) {
				var platformID = rU(data$2, offset);
				offset += 2;
				var encodingID = rU(data$2, offset);
				offset += 2;
				var languageID = rU(data$2, offset);
				offset += 2;
				var nameID = rU(data$2, offset);
				offset += 2;
				var slen = rU(data$2, offset);
				offset += 2;
				var noffset = rU(data$2, offset);
				offset += 2;
				var soff = ooo + noffset;
				var str;
				if (platformID == 0) str = bin.readUnicode(data$2, soff, slen / 2);
				else if (platformID == 3 && encodingID == 0) str = bin.readUnicode(data$2, soff, slen / 2);
				else if (platformID == 1 && encodingID == 25) str = bin.readUnicode(data$2, soff, slen / 2);
				else if (encodingID == 0) str = bin.readASCII(data$2, soff, slen);
				else if (encodingID == 1) str = bin.readUnicode(data$2, soff, slen / 2);
				else if (encodingID == 3) str = bin.readUnicode(data$2, soff, slen / 2);
				else if (encodingID == 4) str = bin.readUnicode(data$2, soff, slen / 2);
				else if (encodingID == 5) str = bin.readUnicode(data$2, soff, slen / 2);
				else if (encodingID == 10) str = bin.readUnicode(data$2, soff, slen / 2);
				else if (platformID == 1) {
					str = bin.readASCII(data$2, soff, slen);
					console.log("reading unknown MAC encoding " + encodingID + " as ASCII");
				} else {
					console.log("unknown encoding " + encodingID + ", platformID: " + platformID);
					str = bin.readASCII(data$2, soff, slen);
				}
				var tid = "p" + platformID + "," + languageID.toString(16);
				if (obj[tid] == null) obj[tid] = {};
				var name = names[nameID];
				if (name == null) name = "_" + nameID;
				obj[tid][name] = str;
				obj[tid]["_lang"] = languageID;
			}
			var out = Typr["T"].name.selectOne(obj), ff = "fontFamily";
			if (out[ff] == null) {
				for (var p$1 in obj) if (obj[p$1][ff] != null) out[ff] = obj[p$1][ff];
			}
			return out;
		},
		selectOne: function(obj) {
			var psn = "postScriptName";
			for (var p$1 in obj) if (obj[p$1][psn] != null && obj[p$1]["_lang"] == 1033) return obj[p$1];
			for (var p$1 in obj) if (obj[p$1][psn] != null && obj[p$1]["_lang"] == 0) return obj[p$1];
			for (var p$1 in obj) if (obj[p$1][psn] != null && obj[p$1]["_lang"] == 3084) return obj[p$1];
			for (var p$1 in obj) if (obj[p$1][psn] != null) return obj[p$1];
			var out;
			for (var p$1 in obj) {
				out = obj[p$1];
				break;
			}
			console.log("returning name table with languageID " + out._lang);
			if (out[psn] == null && out["ID"] != null) out[psn] = out["ID"];
			return out;
		}
	};
	Typr["T"].OS2 = {
		parseTab: function(data$2, offset, length) {
			var ver = Typr["B"].readUshort(data$2, offset);
			offset += 2;
			var OS2 = Typr["T"].OS2;
			var obj = {};
			if (ver == 0) OS2.version0(data$2, offset, obj);
			else if (ver == 1) OS2.version1(data$2, offset, obj);
			else if (ver == 2 || ver == 3 || ver == 4) OS2.version2(data$2, offset, obj);
			else if (ver == 5) OS2.version5(data$2, offset, obj);
			else throw "unknown OS/2 table version: " + ver;
			return obj;
		},
		version0: function(data$2, offset, obj) {
			var bin = Typr["B"];
			obj["xAvgCharWidth"] = bin.readShort(data$2, offset);
			offset += 2;
			obj["usWeightClass"] = bin.readUshort(data$2, offset);
			offset += 2;
			obj["usWidthClass"] = bin.readUshort(data$2, offset);
			offset += 2;
			obj["fsType"] = bin.readUshort(data$2, offset);
			offset += 2;
			obj["ySubscriptXSize"] = bin.readShort(data$2, offset);
			offset += 2;
			obj["ySubscriptYSize"] = bin.readShort(data$2, offset);
			offset += 2;
			obj["ySubscriptXOffset"] = bin.readShort(data$2, offset);
			offset += 2;
			obj["ySubscriptYOffset"] = bin.readShort(data$2, offset);
			offset += 2;
			obj["ySuperscriptXSize"] = bin.readShort(data$2, offset);
			offset += 2;
			obj["ySuperscriptYSize"] = bin.readShort(data$2, offset);
			offset += 2;
			obj["ySuperscriptXOffset"] = bin.readShort(data$2, offset);
			offset += 2;
			obj["ySuperscriptYOffset"] = bin.readShort(data$2, offset);
			offset += 2;
			obj["yStrikeoutSize"] = bin.readShort(data$2, offset);
			offset += 2;
			obj["yStrikeoutPosition"] = bin.readShort(data$2, offset);
			offset += 2;
			obj["sFamilyClass"] = bin.readShort(data$2, offset);
			offset += 2;
			obj["panose"] = bin.readBytes(data$2, offset, 10);
			offset += 10;
			obj["ulUnicodeRange1"] = bin.readUint(data$2, offset);
			offset += 4;
			obj["ulUnicodeRange2"] = bin.readUint(data$2, offset);
			offset += 4;
			obj["ulUnicodeRange3"] = bin.readUint(data$2, offset);
			offset += 4;
			obj["ulUnicodeRange4"] = bin.readUint(data$2, offset);
			offset += 4;
			obj["achVendID"] = bin.readASCII(data$2, offset, 4);
			offset += 4;
			obj["fsSelection"] = bin.readUshort(data$2, offset);
			offset += 2;
			obj["usFirstCharIndex"] = bin.readUshort(data$2, offset);
			offset += 2;
			obj["usLastCharIndex"] = bin.readUshort(data$2, offset);
			offset += 2;
			obj["sTypoAscender"] = bin.readShort(data$2, offset);
			offset += 2;
			obj["sTypoDescender"] = bin.readShort(data$2, offset);
			offset += 2;
			obj["sTypoLineGap"] = bin.readShort(data$2, offset);
			offset += 2;
			obj["usWinAscent"] = bin.readUshort(data$2, offset);
			offset += 2;
			obj["usWinDescent"] = bin.readUshort(data$2, offset);
			offset += 2;
			return offset;
		},
		version1: function(data$2, offset, obj) {
			var bin = Typr["B"];
			offset = Typr["T"].OS2.version0(data$2, offset, obj);
			obj["ulCodePageRange1"] = bin.readUint(data$2, offset);
			offset += 4;
			obj["ulCodePageRange2"] = bin.readUint(data$2, offset);
			offset += 4;
			return offset;
		},
		version2: function(data$2, offset, obj) {
			var bin = Typr["B"], rU = bin.readUshort;
			offset = Typr["T"].OS2.version1(data$2, offset, obj);
			obj["sxHeight"] = bin.readShort(data$2, offset);
			offset += 2;
			obj["sCapHeight"] = bin.readShort(data$2, offset);
			offset += 2;
			obj["usDefault"] = rU(data$2, offset);
			offset += 2;
			obj["usBreak"] = rU(data$2, offset);
			offset += 2;
			obj["usMaxContext"] = rU(data$2, offset);
			offset += 2;
			return offset;
		},
		version5: function(data$2, offset, obj) {
			var rU = Typr["B"].readUshort;
			offset = Typr["T"].OS2.version2(data$2, offset, obj);
			obj["usLowerOpticalPointSize"] = rU(data$2, offset);
			offset += 2;
			obj["usUpperOpticalPointSize"] = rU(data$2, offset);
			offset += 2;
			return offset;
		}
	};
	Typr["T"].post = { parseTab: function(data$2, offset, length) {
		var bin = Typr["B"];
		var obj = {};
		obj["version"] = bin.readFixed(data$2, offset);
		offset += 4;
		obj["italicAngle"] = bin.readFixed(data$2, offset);
		offset += 4;
		obj["underlinePosition"] = bin.readShort(data$2, offset);
		offset += 2;
		obj["underlineThickness"] = bin.readShort(data$2, offset);
		offset += 2;
		return obj;
	} };
	Typr["T"].SVG = { parseTab: function(data$2, offset, length) {
		var bin = Typr["B"];
		var obj = {
			entries: [],
			svgs: []
		};
		var offset0 = offset;
		bin.readUshort(data$2, offset);
		offset += 2;
		var svgDocIndexOffset = bin.readUint(data$2, offset);
		offset += 4;
		bin.readUint(data$2, offset);
		offset += 4;
		offset = svgDocIndexOffset + offset0;
		var numEntries = bin.readUshort(data$2, offset);
		offset += 2;
		for (var i$1 = 0; i$1 < numEntries; i$1++) {
			var startGlyphID = bin.readUshort(data$2, offset);
			offset += 2;
			var endGlyphID = bin.readUshort(data$2, offset);
			offset += 2;
			var svgDocOffset = bin.readUint(data$2, offset);
			offset += 4;
			var svgDocLength = bin.readUint(data$2, offset);
			offset += 4;
			var sbuf = new Uint8Array(data$2.buffer, offset0 + svgDocOffset + svgDocIndexOffset, svgDocLength);
			if (sbuf[0] == 31 && sbuf[1] == 139 && sbuf[2] == 8) sbuf = pako["inflate"](sbuf);
			var svg = bin.readUTF8(sbuf, 0, sbuf.length);
			for (var f = startGlyphID; f <= endGlyphID; f++) obj.entries[f] = obj.svgs.length;
			obj.svgs.push(svg);
		}
		return obj;
	} };
	Typr["T"].sbix = { parseTab: function(data$2, offset, length, obj) {
		var numGlyphs = obj["maxp"]["numGlyphs"];
		var ooff = offset;
		var bin = Typr["B"];
		var numStrikes = bin.readUint(data$2, offset + 4);
		var out = [];
		for (var si = numStrikes - 1; si < numStrikes; si++) {
			var off = ooff + bin.readUint(data$2, offset + 8 + si * 4);
			for (var gi = 0; gi < numGlyphs; gi++) {
				var aoff = bin.readUint(data$2, off + 4 + gi * 4);
				var noff = bin.readUint(data$2, off + 4 + gi * 4 + 4);
				if (aoff == noff) {
					out[gi] = null;
					continue;
				}
				var go = off + aoff;
				var tag = bin.readASCII(data$2, go + 4, 4);
				if (tag != "png ") throw tag;
				out[gi] = new Uint8Array(data$2.buffer, data$2.byteOffset + go + 8, noff - aoff - 8);
			}
		}
		return out;
	} };
	Typr["T"].colr = { parseTab: function(data$2, offset, length) {
		var bin = Typr["B"];
		var ooff = offset;
		offset += 2;
		var num = bin.readUshort(data$2, offset);
		offset += 2;
		var boff = bin.readUint(data$2, offset);
		offset += 4;
		var loff = bin.readUint(data$2, offset);
		offset += 4;
		var lnum = bin.readUshort(data$2, offset);
		offset += 2;
		var base$1 = {};
		var coff = ooff + boff;
		for (var i$1 = 0; i$1 < num; i$1++) {
			base$1["g" + bin.readUshort(data$2, coff)] = [bin.readUshort(data$2, coff + 2), bin.readUshort(data$2, coff + 4)];
			coff += 6;
		}
		var lays = [];
		coff = ooff + loff;
		for (var i$1 = 0; i$1 < lnum; i$1++) {
			lays.push(bin.readUshort(data$2, coff), bin.readUshort(data$2, coff + 2));
			coff += 4;
		}
		return [base$1, lays];
	} };
	Typr["T"].cpal = { parseTab: function(data$2, offset, length) {
		var bin = Typr["B"];
		var ooff = offset;
		var vsn = bin.readUshort(data$2, offset);
		offset += 2;
		if (vsn == 0) {
			bin.readUshort(data$2, offset);
			offset += 2;
			bin.readUshort(data$2, offset);
			offset += 2;
			var tot = bin.readUshort(data$2, offset);
			offset += 2;
			var fst = bin.readUint(data$2, offset);
			offset += 4;
			return new Uint8Array(data$2.buffer, ooff + fst, tot * 4);
		} else throw vsn;
	} };
	Typr["T"].GSUB = { parseTab: function(data$2, offset, length, obj) {
		var bin = Typr["B"], rU = bin.readUshort;
		bin.readUint;
		var off = offset;
		rU(data$2, off);
		off += 2;
		rU(data$2, off);
		off += 2;
		rU(data$2, off);
		off += 2;
		var flO = rU(data$2, off);
		off += 2;
		rU(data$2, off);
		off += 2;
		off = offset + flO;
		var fmap = {};
		var cnt = rU(data$2, off);
		off += 2;
		for (var i$1 = 0; i$1 < cnt; i$1++) {
			var tag = bin.readASCII(data$2, off, 4);
			off += 4;
			rU(data$2, off);
			off += 2;
			fmap[tag] = true;
		}
		return fmap;
	} };
	Typr["T"].fvar = { parseTab: function(data$2, offset, length, obj) {
		var name = obj["name"];
		var off = offset;
		var bin = Typr["B"];
		var axes = [], inst = [];
		off += 8;
		var acnt = bin.readUshort(data$2, off);
		off += 2;
		off += 2;
		var icnt = bin.readUshort(data$2, off);
		off += 2;
		var isiz = bin.readUshort(data$2, off);
		off += 2;
		for (var i$1 = 0; i$1 < acnt; i$1++) {
			var tag = bin.readASCII(data$2, off, 4);
			var min = bin.readFixed(data$2, off + 4);
			var def = bin.readFixed(data$2, off + 8);
			var max = bin.readFixed(data$2, off + 12);
			var flg = bin.readUshort(data$2, off + 16);
			var nid = bin.readUshort(data$2, off + 18);
			axes.push([
				tag,
				min,
				def,
				max,
				flg,
				name["_" + nid]
			]);
			off += 20;
		}
		for (var i$1 = 0; i$1 < icnt; i$1++) {
			var snid = bin.readUshort(data$2, off), pnid = null;
			var flg = bin.readUshort(data$2, off + 2);
			var crd = [];
			for (var j = 0; j < acnt; j++) crd.push(bin.readFixed(data$2, off + 4 + j * 4));
			off += 4 + acnt * 4;
			if ((isiz & 3) == 2) {
				pnid = bin.readUshort(data$2, off);
				off += 2;
			}
			inst.push([
				name["_" + snid],
				flg,
				crd,
				pnid
			]);
		}
		return [axes, inst];
	} };
	Typr["T"].gvar = (function() {
		var EMBEDDED_PEAK_TUPLE = 32768;
		var INTERMEDIATE_REGION = 16384;
		var PRIVATE_POINT_NUMBERS = 8192;
		var DELTAS_ARE_ZERO = 128;
		var DELTAS_ARE_WORDS = 64;
		var POINTS_ARE_WORDS = 128;
		var SHARED_POINT_NUMBERS = 32768;
		var bin = Typr["B"];
		function readTuple(data$2, o, acnt) {
			var tup = [];
			for (var j = 0; j < acnt; j++) tup.push(bin.readF2dot14(data$2, o + j * 2));
			return tup;
		}
		function readTupleVarHeader(data$2, off, vcnt, acnt, eoff) {
			var out = [];
			for (var j = 0; j < vcnt; j++) {
				var dsiz = bin.readUshort(data$2, off);
				off += 2;
				var tind = bin.readUshort(data$2, off), flag = tind & 61440;
				tind = tind & 4095;
				off += 2;
				var peak = null, start = null, end = null;
				if (flag & EMBEDDED_PEAK_TUPLE) {
					peak = readTuple(data$2, off, acnt);
					off += acnt * 2;
				}
				if (flag & INTERMEDIATE_REGION) {
					start = readTuple(data$2, off, acnt);
					off += acnt * 2;
				}
				if (flag & INTERMEDIATE_REGION) {
					end = readTuple(data$2, off, acnt);
					off += acnt * 2;
				}
				out.push([
					dsiz,
					tind,
					flag,
					start,
					peak,
					end
				]);
			}
			return out;
		}
		function readPointNumbers(data$2, off, gid) {
			var cnt = data$2[off];
			off++;
			if (cnt == 0) return [[], off];
			if (127 < cnt) cnt = (cnt & 127) << 8 | data$2[off++];
			var pts = [], last$1 = 0;
			while (pts.length < cnt) {
				var v$1 = data$2[off];
				off++;
				var wds = (v$1 & POINTS_ARE_WORDS) != 0;
				v$1 = (v$1 & 127) + 1;
				for (var i$1 = 0; i$1 < v$1; i$1++) {
					var dif = 0;
					if (wds) {
						dif = bin.readUshort(data$2, off);
						off += 2;
					} else {
						dif = data$2[off];
						off++;
					}
					last$1 += dif;
					pts.push(last$1);
				}
			}
			return [pts, off];
		}
		function parseTab(data$2, offset, length, obj) {
			var off = offset + 4;
			var acnt = bin.readUshort(data$2, off);
			off += 2;
			var tcnt = bin.readUshort(data$2, off);
			off += 2;
			var toff = bin.readUint(data$2, off);
			off += 4;
			var gcnt = bin.readUshort(data$2, off);
			off += 2;
			bin.readUshort(data$2, off);
			off += 2;
			var goff = bin.readUint(data$2, off);
			off += 4;
			var offs = [];
			for (var i$1 = 0; i$1 < gcnt + 1; i$1++) offs.push(bin.readUint(data$2, off + i$1 * 4));
			var tups = [], mins = [], maxs = [];
			off = offset + toff;
			for (var i$1 = 0; i$1 < tcnt; i$1++) {
				var peak = readTuple(data$2, off + i$1 * acnt * 2, acnt), imin = [], imax = [];
				tups.push(peak);
				mins.push(imin);
				maxs.push(imax);
				for (var k = 0; k < acnt; k++) {
					imin[k] = Math.min(peak[k], 0);
					imax[k] = Math.max(peak[k], 0);
				}
			}
			var i8 = new Int8Array(data$2.buffer);
			var tabs = [];
			for (var i$1 = 0; i$1 < gcnt; i$1++) {
				off = offset + goff + offs[i$1];
				var vcnt = bin.readUshort(data$2, off);
				off += 2;
				var snum = vcnt & SHARED_POINT_NUMBERS;
				vcnt &= 4095;
				var soff = bin.readUshort(data$2, off);
				off += 2;
				var hdr = readTupleVarHeader(data$2, off, vcnt, acnt);
				var tab = [];
				tabs.push(tab);
				off = offset + goff + offs[i$1] + soff;
				var sind = null;
				if (snum) {
					var oo = readPointNumbers(data$2, off);
					sind = oo[0];
					off = oo[1];
				}
				for (var j = 0; j < vcnt; j++) {
					var vr = hdr[j], end = off + vr[0];
					var ind = sind;
					if (vr[2] & PRIVATE_POINT_NUMBERS) {
						var oo = readPointNumbers(data$2, off);
						ind = oo[0];
						off = oo[1];
					}
					var ds = [];
					while (off < end) {
						var cb = data$2[off++];
						var cnt = (cb & 63) + 1;
						if (cb & DELTAS_ARE_ZERO) for (var k = 0; k < cnt; k++) ds.push(0);
						else if (cb & DELTAS_ARE_WORDS) {
							for (var k = 0; k < cnt; k++) ds.push(bin.readShort(data$2, off + k * 2));
							off += cnt * 2;
						} else {
							for (var k = 0; k < cnt; k++) ds.push(i8[off + k]);
							off += cnt;
						}
					}
					var ti = vr[1];
					tab.push([
						[
							vr[3] ? vr[3] : mins[ti],
							vr[4] ? vr[4] : tups[ti],
							vr[5] ? vr[5] : maxs[ti]
						],
						ds,
						ind.length == 0 ? null : ind
					]);
					if (ind.length != 0 && ind.length * 2 != ds.length) throw "e";
				}
			}
			return tabs;
		}
		return { parseTab };
	})();
	Typr["T"].avar = { parseTab: function(data$2, offset, length, obj) {
		var off = offset;
		var bin = Typr["B"], out = [];
		off += 6;
		var acnt = bin.readUshort(data$2, off);
		off += 2;
		for (var ai = 0; ai < acnt; ai++) {
			var cnt = bin.readUshort(data$2, off);
			off += 2;
			var poly = [];
			out.push(poly);
			for (var i$1 = 0; i$1 < cnt; i$1++) {
				var x$1 = bin.readF2dot14(data$2, off);
				var y = bin.readF2dot14(data$2, off + 2);
				off += 4;
				poly.push(x$1, y);
			}
		}
		return out;
	} };
	Typr["T"].HVAR = { parseTab: function(data$2, offset, length, obj) {
		var off = offset, oo = offset;
		var bin = Typr["B"];
		off += 4;
		var varO = bin.readUint(data$2, off);
		off += 4;
		var advO = bin.readUint(data$2, off);
		off += 4;
		var lsbO = bin.readUint(data$2, off);
		off += 4;
		var rsbO = bin.readUint(data$2, off);
		off += 4;
		if (lsbO != 0 || rsbO != 0) throw lsbO;
		off = oo + varO;
		var ioff = off;
		var fmt = bin.readUshort(data$2, off);
		off += 2;
		if (fmt != 1) throw "e";
		var vregO = bin.readUint(data$2, off);
		off += 4;
		var vcnt = bin.readUshort(data$2, off);
		off += 2;
		var offs = [];
		for (var i$1 = 0; i$1 < vcnt; i$1++) offs.push(bin.readUint(data$2, off + i$1 * 4));
		off += vcnt * 4;
		off = ioff + vregO;
		var acnt = bin.readUshort(data$2, off);
		off += 2;
		var rcnt = bin.readUshort(data$2, off);
		off += 2;
		var regs = [];
		for (var i$1 = 0; i$1 < rcnt; i$1++) {
			var crd = [
				[],
				[],
				[]
			];
			regs.push(crd);
			for (var j = 0; j < acnt; j++) {
				crd[0].push(bin.readF2dot14(data$2, off + 0));
				crd[1].push(bin.readF2dot14(data$2, off + 2));
				crd[2].push(bin.readF2dot14(data$2, off + 4));
				off += 6;
			}
		}
		var i8 = new Int8Array(data$2.buffer);
		var varStore = [];
		for (var i$1 = 0; i$1 < offs.length; i$1++) {
			off = oo + varO + offs[i$1];
			var vdata = [];
			varStore.push(vdata);
			var icnt = bin.readUshort(data$2, off);
			off += 2;
			var dcnt = bin.readUshort(data$2, off);
			off += 2;
			if (dcnt & 32768) throw "e";
			var rcnt = bin.readUshort(data$2, off);
			off += 2;
			var ixs = [];
			for (var j = 0; j < rcnt; j++) ixs.push(bin.readUshort(data$2, off + j * 2));
			off += rcnt * 2;
			for (var k = 0; k < icnt; k++) {
				var deltaData = [];
				for (var ri = 0; ri < rcnt; ri++) {
					deltaData.push(ri < dcnt ? bin.readShort(data$2, off) : i8[off]);
					off += ri < dcnt ? 2 : 1;
				}
				var dd = new Array(regs.length);
				dd.fill(0);
				vdata.push(dd);
				for (var j = 0; j < ixs.length; j++) dd[ixs[j]] = deltaData[j];
			}
		}
		off = oo + advO;
		var fmt = data$2[off++];
		if (fmt != 0) throw "e";
		var entryFormat = data$2[off++];
		var mapCount = bin.readUshort(data$2, off);
		off += 2;
		var INNER_INDEX_BIT_COUNT_MASK = 15;
		var entrySize = ((entryFormat & 48) >> 4) + 1;
		var dfs = [];
		for (var i$1 = 0; i$1 < mapCount; i$1++) {
			var entry = 0;
			if (entrySize == 1) entry = data$2[off++];
			else {
				entry = bin.readUshort(data$2, off);
				off += 2;
			}
			var outerIndex = entry >> (entryFormat & INNER_INDEX_BIT_COUNT_MASK) + 1;
			var innerIndex = entry & (1 << (entryFormat & INNER_INDEX_BIT_COUNT_MASK) + 1) - 1;
			dfs.push(varStore[outerIndex][innerIndex]);
		}
		return [regs, dfs];
	} };
	Typr["U"] = function() {
		var P$1 = {
			MoveTo: function(p$1, x$1, y) {
				p$1.cmds.push("M");
				p$1.crds.push(x$1, y);
			},
			LineTo: function(p$1, x$1, y) {
				p$1.cmds.push("L");
				p$1.crds.push(x$1, y);
			},
			CurveTo: function(p$1, a, b$1, c, d$1, e$1, f) {
				p$1.cmds.push("C");
				p$1.crds.push(a, b$1, c, d$1, e$1, f);
			},
			qCurveTo: function(p$1, a, b$1, c, d$1) {
				p$1.cmds.push("Q");
				p$1.crds.push(a, b$1, c, d$1);
			},
			ClosePath: function(p$1) {
				p$1.cmds.push("Z");
			}
		};
		function getGlyphPosition(font$1, gls, i1, ltr) {
			var g1 = gls[i1], g2 = gls[i1 + 1], kern = font$1["kern"];
			if (kern) {
				var ind1 = kern.glyph1.indexOf(g1);
				if (ind1 != -1) {
					var ind2 = kern.rval[ind1].glyph2.indexOf(g2);
					if (ind2 != -1) return [
						0,
						0,
						kern.rval[ind1].vals[ind2],
						0
					];
				}
			}
			return [
				0,
				0,
				0,
				0
			];
		}
		function shape$1(font$1, str, prm) {
			if (prm == null) prm = {};
			prm["ltr"];
			prm["fts"];
			var axs = prm["axs"];
			if (font$1["fvar"] && axs == null) axs = font$1["fvar"][1][font$1["_index"]][2];
			var HVAR = font$1["HVAR"];
			if (axs && HVAR) axs = _normalizeAxis(font$1, axs);
			var gls = [];
			for (var i$2 = 0; i$2 < str.length; i$2++) {
				var cc = str.codePointAt(i$2);
				if (cc > 65535) i$2++;
				gls.push(codeToGlyph(font$1, cc));
			}
			var shape$2 = [];
			for (var i$2 = 0; i$2 < gls.length; i$2++) {
				var padj = getGlyphPosition(font$1, gls, i$2);
				var gid = gls[i$2];
				var ax = font$1["hmtx"].aWidth[gid] + padj[2];
				if (HVAR && HVAR[1][gid]) {
					var difs = HVAR[1][gid];
					for (var j = 0; j < HVAR[0].length; j++) ax += _interpolate(HVAR[0][j], axs) * difs[j];
				}
				shape$2.push({
					"g": gid,
					"cl": i$2,
					"dx": 0,
					"dy": 0,
					"ax": ax,
					"ay": 0
				});
			}
			return shape$2;
		}
		function shapeToPath(font$1, shape$2, prm) {
			var tpath = {
				cmds: [],
				crds: []
			};
			var x$1 = 0, y = 0, clr, axs;
			if (prm) {
				clr = prm["clr"];
				axs = prm["axs"];
			}
			for (var i$2 = 0; i$2 < shape$2.length; i$2++) {
				var it = shape$2[i$2];
				var path$1 = glyphToPath(font$1, it["g"], false, axs), crds = path$1["crds"];
				for (var j = 0; j < crds.length; j += 2) {
					tpath.crds.push(crds[j] + x$1 + it["dx"]);
					tpath.crds.push(crds[j + 1] + y + it["dy"]);
				}
				if (clr) tpath.cmds.push(clr);
				for (var j = 0; j < path$1["cmds"].length; j++) tpath.cmds.push(path$1["cmds"][j]);
				var clen = tpath.cmds.length;
				if (clr) {
					if (clen != 0 && tpath.cmds[clen - 1] != "X") tpath.cmds.push("X");
				}
				x$1 += it["ax"];
				y += it["ay"];
			}
			return {
				"cmds": tpath.cmds,
				"crds": tpath.crds
			};
		}
		function arrSearch(arr$1, k, v$1) {
			var l = 0, r = ~~(arr$1.length / k);
			while (l + 1 != r) {
				var mid = l + (r - l >>> 1);
				if (arr$1[mid * k] <= v$1) l = mid;
				else r = mid;
			}
			return l * k;
		}
		var wha = [
			9,
			10,
			11,
			12,
			13,
			32,
			133,
			160,
			5760,
			6158,
			8232,
			8233,
			8239,
			8288,
			12288,
			65279
		], whm = {};
		for (var i$1 = 0; i$1 < wha.length; i$1++) whm[wha[i$1]] = 1;
		for (var i$1 = 8192; i$1 <= 8205; i$1++) whm[i$1] = 1;
		function codeToGlyph(font$1, code) {
			if (font$1["_ctab"] == null) {
				var cmap = font$1["cmap"];
				var tind = -1, pps = [
					"p3e10",
					"p0e4",
					"p3e1",
					"p1e0",
					"p0e3",
					"p0e1",
					"p3e0",
					"p3e5"
				];
				for (var i$2 = 0; i$2 < pps.length; i$2++) if (cmap.ids[pps[i$2]] != null) {
					tind = cmap.ids[pps[i$2]];
					break;
				}
				if (tind == -1) throw "no familiar platform and encoding!";
				font$1["_ctab"] = cmap.tables[tind];
			}
			var tab = font$1["_ctab"], fmt = tab.format, gid = -1;
			if (fmt == 0) if (code >= tab.map.length) gid = 0;
			else gid = tab.map[code];
			else if (fmt == 4) {
				var ec = tab.endCount;
				gid = 0;
				if (code <= ec[ec.length - 1]) {
					var sind = arrSearch(ec, 1, code);
					if (ec[sind] < code) sind++;
					if (code >= tab.startCount[sind]) {
						var gli = 0;
						if (tab.idRangeOffset[sind] != 0) gli = tab.glyphIdArray[code - tab.startCount[sind] + (tab.idRangeOffset[sind] >> 1) - (tab.idRangeOffset.length - sind)];
						else gli = code + tab.idDelta[sind];
						gid = gli & 65535;
					}
				}
			} else if (fmt == 6) {
				var off = code - tab.firstCode, arr$1 = tab.glyphIdArray;
				if (off < 0 || off >= arr$1.length) gid = 0;
				else gid = arr$1[off];
			} else if (fmt == 12) {
				var grp = tab.groups;
				gid = 0;
				if (code <= grp[grp.length - 2]) {
					var i$2 = arrSearch(grp, 3, code);
					if (grp[i$2] <= code && code <= grp[i$2 + 1]) gid = grp[i$2 + 2] + (code - grp[i$2]);
				}
			} else throw "unknown cmap table format " + tab.format;
			var SVG = font$1["SVG "], loca = font$1["loca"];
			if (gid != 0 && font$1["CFF "] == null && (SVG == null || SVG.entries[gid] == null) && loca && loca[gid] == loca[gid + 1] && whm[code] == null) gid = 0;
			return gid;
		}
		function glyphToPath(font$1, gid, noColor, axs) {
			var path$1 = {
				cmds: [],
				crds: []
			};
			if (font$1["fvar"]) {
				if (axs == null) axs = font$1["fvar"][1][font$1["_index"]][2];
				axs = _normalizeAxis(font$1, axs);
			}
			var SVG = font$1["SVG "], CFF = font$1["CFF "], COLR = font$1["COLR"], CBLC = font$1["CBLC"], CBDT = font$1["CBDT"], sbix = font$1["sbix"], upng = window["UPNG"];
			var strike = null;
			if (CBLC && upng) {
				for (var i$2 = 0; i$2 < CBLC.length; i$2++) if (CBLC[i$2][0] <= gid && gid <= CBLC[i$2][1]) strike = CBLC[i$2];
			}
			if (strike || sbix && sbix[gid]) {
				if (strike && strike[2] != 17) throw "not a PNG";
				if (font$1["__tmp"] == null) font$1["__tmp"] = {};
				var cmd = font$1["__tmp"]["g" + gid];
				if (cmd == null) {
					var bmp, len;
					if (sbix) {
						bmp = sbix[gid];
						len = bmp.length;
					} else {
						var boff = strike[3][gid - strike[0]] + 5;
						len = CBDT[boff + 1] << 16 | CBDT[boff + 2] << 8 | CBDT[boff + 3];
						boff += 4;
						bmp = new Uint8Array(CBDT.buffer, CBDT.byteOffset + boff, len);
					}
					var str = "";
					for (var i$2 = 0; i$2 < len; i$2++) str += String.fromCharCode(bmp[i$2]);
					cmd = font$1["__tmp"]["g" + gid] = "data:image/png;base64," + btoa(str);
				}
				path$1.cmds.push(cmd);
				var upe = font$1["head"]["unitsPerEm"] * 1.15;
				var gw = Math.round(upe), gh = Math.round(upe), dy = Math.round(-gh * .15);
				path$1.crds.push(0, gh + dy, gw, gh + dy, gw, dy, 0, dy);
			} else if (SVG && SVG.entries[gid]) {
				var p$1 = SVG.entries[gid];
				if (p$1 != null) {
					if (typeof p$1 == "number") {
						var svg = SVG.svgs[p$1];
						if (typeof svg == "string") {
							var doc = new DOMParser()["parseFromString"](svg, "image/svg+xml");
							svg = SVG.svgs[p$1] = doc.getElementsByTagName("svg")[0];
						}
						p$1 = Typr["U"]["SVG"].toPath(svg, gid);
						SVG.entries[gid] = p$1;
					}
					path$1 = p$1;
				}
			} else if (noColor != true && COLR && COLR[0]["g" + gid] && COLR[0]["g" + gid][1] > 1) {
				function toHex(n$2) {
					var o = n$2.toString(16);
					return (o.length == 1 ? "0" : "") + o;
				}
				var CPAL = font$1["CPAL"], gl = COLR[0]["g" + gid];
				for (var i$2 = 0; i$2 < gl[1]; i$2++) {
					var lid = gl[0] + i$2;
					var cgl = COLR[1][2 * lid], pid = COLR[1][2 * lid + 1] * 4;
					var pth = glyphToPath(font$1, cgl, cgl == gid);
					var col = "#" + toHex(CPAL[pid + 2]) + toHex(CPAL[pid + 1]) + toHex(CPAL[pid + 0]);
					path$1.cmds.push(col);
					path$1.cmds = path$1.cmds.concat(pth["cmds"]);
					path$1.crds = path$1.crds.concat(pth["crds"]);
					path$1.cmds.push("X");
				}
			} else if (CFF) {
				var pdct = CFF["Private"];
				var state = {
					x: 0,
					y: 0,
					stack: [],
					nStems: 0,
					haveWidth: false,
					width: pdct ? pdct["defaultWidthX"] : 0,
					open: false
				};
				if (CFF["ROS"]) {
					var gi = 0;
					while (CFF["FDSelect"][gi + 2] <= gid) gi += 2;
					pdct = CFF["FDArray"][CFF["FDSelect"][gi + 1]]["Private"];
				}
				_drawCFF(CFF["CharStrings"][gid], state, CFF, pdct, path$1);
			} else if (font$1["glyf"]) _drawGlyf(gid, font$1, path$1, axs);
			return {
				"cmds": path$1.cmds,
				"crds": path$1.crds
			};
		}
		function _drawGlyf(gid, font$1, path$1, axs) {
			var gl = font$1["glyf"][gid];
			if (gl == null) gl = font$1["glyf"][gid] = Typr["T"].glyf._parseGlyf(font$1, gid);
			if (gl != null) if (gl.noc > -1) _simpleGlyph(gl, font$1, gid, path$1, axs);
			else _compoGlyph(gl, font$1, gid, path$1, axs);
		}
		function _interpolate(axs, v$1) {
			v$1.length;
			var S$1 = 1;
			var s = axs[0];
			var p$1 = axs[1];
			var e$1 = axs[2];
			for (var i$2 = 0; i$2 < v$1.length; i$2++) {
				var AS = 1;
				if (s[i$2] > p$1[i$2] || p$1[i$2] > e$1[i$2]) AS = 1;
				else if (s[i$2] < 0 && e$1[i$2] > 0 && p$1[i$2] != 0) AS = 1;
				else if (p$1[i$2] == 0) AS = 1;
				else if (v$1[i$2] < s[i$2] || v$1[i$2] > e$1[i$2]) AS = 0;
				else if (v$1[i$2] == p$1[i$2]) AS = 1;
				else if (v$1[i$2] < p$1[i$2]) AS = (v$1[i$2] - s[i$2]) / (p$1[i$2] - s[i$2]);
				else AS = (e$1[i$2] - v$1[i$2]) / (e$1[i$2] - p$1[i$2]);
				S$1 = S$1 * AS;
			}
			return S$1;
		}
		function _normalizeAxis(font$1, vv) {
			var fvar = font$1["fvar"], avar = font$1["avar"];
			var fv = fvar ? fvar[0] : null;
			var nv = [];
			for (var i$2 = 0; i$2 < fv.length; i$2++) {
				var min = fv[i$2][1], def = fv[i$2][2], max = fv[i$2][3], v$1 = Math.max(min, Math.min(max, vv[i$2]));
				if (v$1 < def) nv[i$2] = (def - v$1) / (min - def);
				else if (v$1 > def) nv[i$2] = (v$1 - def) / (max - def);
				else nv[i$2] = 0;
				if (avar && nv[i$2] != -1) {
					var av = avar[i$2], j = 0;
					for (; j < av.length; j += 2) if (av[j] >= nv[i$2]) break;
					var f = (nv[i$2] - av[j - 2]) / (av[j] - av[j - 2]);
					nv[i$2] = f * av[j + 1] + (1 - f) * av[j - 1];
				}
			}
			return nv;
		}
		function interpolateDeltas(dfs, ind, xs, ys, endPts) {
			var N$1 = xs.length, ndfs = new Array(N$1 * 2 + 8);
			ndfs.fill(0);
			for (var i$2 = 0; i$2 < N$1; i$2++) {
				var dx = 0, dy = 0, ii = ind.indexOf(i$2);
				if (ii != -1) {
					dx = dfs[ii];
					dy = dfs[ind.length + ii];
				} else {
					var cmp = 0;
					while (endPts[cmp] < i$2) cmp++;
					var cmp0 = cmp == 0 ? 0 : endPts[cmp - 1] + 1;
					var cmp1 = endPts[cmp];
					var i0 = -1, i1 = -1;
					for (var j = 0; j < ind.length; j++) {
						var v$1 = ind[j];
						if (v$1 < cmp0 || v$1 > cmp1 || v$1 >= N$1) continue;
						i0 = j;
						if (i1 == -1) i1 = j;
					}
					for (var j = 0; j < ind.length; j++) {
						var v$1 = ind[j];
						if (v$1 < cmp0 || v$1 > cmp1 || v$1 >= N$1) continue;
						if (v$1 < i$2) i0 = j;
						if (i$2 < v$1) {
							i1 = j;
							break;
						}
					}
					for (var ax = 0; ax < 2; ax++) {
						var crd = ax == 0 ? xs : ys, ofs = ax * ind.length, dlt = 0;
						var c0 = crd[ind[i0]], c1$2 = crd[ind[i1]], cC = crd[i$2];
						var d0$1 = dfs[ofs + i0], d1 = dfs[ofs + i1];
						if (c0 == c1$2) if (d0$1 == d1) dlt = d0$1;
						else dlt = 0;
						else if (cC <= Math.min(c0, c1$2)) if (c0 < c1$2) dlt = d0$1;
						else dlt = d1;
						else if (Math.max(c0, c1$2) <= cC) if (c0 < c1$2) dlt = d1;
						else dlt = d0$1;
						else {
							var prop = (cC - c0) / (c1$2 - c0);
							dlt = prop * d1 + (1 - prop) * d0$1;
						}
						if (ax == 0) dx = dlt;
						else dy = dlt;
					}
				}
				ndfs[i$2] = dx;
				ndfs[N$1 + 4 + i$2] = dy;
			}
			return ndfs;
		}
		function _simpleGlyph(gl, font$1, gid, p$1, axs) {
			var xs = gl.xs, ys = gl.ys;
			if (font$1["fvar"] && axs) {
				xs = xs.slice(0);
				ys = ys.slice(0);
				var gvar = font$1["gvar"];
				var gv = gvar ? gvar[gid] : null;
				for (var vi = 0; vi < gv.length; vi++) {
					var axv = gv[vi][0];
					var S$1 = _interpolate(axv, axs);
					if (S$1 < 1e-9) continue;
					var dfs = gv[vi][1], ind = gv[vi][2];
					if (ind) {
						dfs = gv[vi][1] = interpolateDeltas(dfs, ind, xs, ys, gl.endPts);
						gv[vi][2] = null;
					}
					if (dfs.length == xs.length * 2 + 8) for (var i$2 = 0; i$2 < xs.length; i$2++) {
						xs[i$2] += S$1 * dfs[i$2];
						ys[i$2] += S$1 * dfs[i$2 + xs.length + 4];
					}
				}
			}
			for (var c = 0; c < gl.noc; c++) {
				var i0 = c == 0 ? 0 : gl.endPts[c - 1] + 1;
				var il = gl.endPts[c];
				for (var i$2 = i0; i$2 <= il; i$2++) {
					var pr = i$2 == i0 ? il : i$2 - 1;
					var nx = i$2 == il ? i0 : i$2 + 1;
					var onCurve = gl.flags[i$2] & 1;
					var prOnCurve = gl.flags[pr] & 1;
					var nxOnCurve = gl.flags[nx] & 1;
					var x$1 = xs[i$2], y = ys[i$2];
					if (i$2 == i0) if (onCurve) if (prOnCurve) P$1.MoveTo(p$1, xs[pr], ys[pr]);
					else {
						P$1.MoveTo(p$1, x$1, y);
						continue;
					}
					else if (prOnCurve) P$1.MoveTo(p$1, xs[pr], ys[pr]);
					else P$1.MoveTo(p$1, Math.floor((xs[pr] + x$1) * .5), Math.floor((ys[pr] + y) * .5));
					if (onCurve) {
						if (prOnCurve) P$1.LineTo(p$1, x$1, y);
					} else if (nxOnCurve) P$1.qCurveTo(p$1, x$1, y, xs[nx], ys[nx]);
					else P$1.qCurveTo(p$1, x$1, y, Math.floor((x$1 + xs[nx]) * .5), Math.floor((y + ys[nx]) * .5));
				}
				P$1.ClosePath(p$1);
			}
		}
		function _compoGlyph(gl, font$1, gid, p$1, axs) {
			var dx = [
				0,
				0,
				0,
				0,
				0,
				0
			], dy = [
				0,
				0,
				0,
				0,
				0,
				0
			], ccnt = gl.parts.length;
			if (font$1["fvar"] && axs) {
				var gvar = font$1["gvar"];
				var gv = gvar ? gvar[gid] : null;
				for (var vi = 0; vi < gv.length; vi++) {
					var axv = gv[vi][0];
					var S$1 = _interpolate(axv, axs);
					if (S$1 < 1e-6) continue;
					var dfs = gv[vi][1], ind = gv[vi][2];
					if (ind == null) for (var i$2 = 0; i$2 < ccnt; i$2++) {
						dx[i$2] += S$1 * dfs[i$2];
						dy[i$2] += S$1 * dfs[i$2 + ccnt + 4];
					}
					else for (var j = 0; j < ind.length; j++) {
						var i$2 = ind[j];
						dx[i$2] += S$1 * dfs[0];
						dy[i$2] += S$1 * dfs[0 + ccnt];
					}
				}
			}
			for (var j = 0; j < ccnt; j++) {
				var path$1 = {
					cmds: [],
					crds: []
				};
				var prt = gl.parts[j];
				_drawGlyf(prt.glyphIndex, font$1, path$1, axs);
				var m = prt.m, tx = m.tx + dx[j], ty = m.ty + dy[j];
				for (var i$2 = 0; i$2 < path$1.crds.length; i$2 += 2) {
					var x$1 = path$1.crds[i$2], y = path$1.crds[i$2 + 1];
					p$1.crds.push(x$1 * m.a + y * m.c + tx);
					p$1.crds.push(x$1 * m.b + y * m.d + ty);
				}
				for (var i$2 = 0; i$2 < path$1.cmds.length; i$2++) p$1.cmds.push(path$1.cmds[i$2]);
			}
		}
		function pathToSVG(path$1, prec) {
			var cmds = path$1["cmds"], crds = path$1["crds"];
			if (prec == null) prec = 5;
			function num(v$1) {
				return parseFloat(v$1.toFixed(prec));
			}
			function merge$1(o) {
				var no = [], lstF = false, lstC = "";
				for (var i$3 = 0; i$3 < o.length; i$3++) {
					var it = o[i$3], isF = typeof it == "number";
					if (!isF) {
						if (it == lstC && it.length == 1 && it != "m") continue;
						lstC = it;
					}
					if (lstF && isF && it >= 0) no.push(" ");
					no.push(it);
					lstF = isF;
				}
				return no.join("");
			}
			var out = [], co = 0, lmap = {
				"M": 2,
				"L": 2,
				"Q": 4,
				"C": 6
			};
			var x$1 = 0, y = 0, ex = 0, ey = 0, mx = 0, my = 0;
			for (var i$2 = 0; i$2 < cmds.length; i$2++) {
				var cmd = cmds[i$2], cc = lmap[cmd] ? lmap[cmd] : 0;
				var o0 = [], dx, dy, rx, ry;
				if (cmd == "L") {
					dx = crds[co] - x$1;
					dy = crds[co + 1] - y;
					rx = num(dx + ex);
					ry = num(dy + ey);
					if (cmds[i$2 + 1] == "Z" && crds[co] == mx && crds[co + 1] == my) {
						rx = dx;
						ry = dy;
					} else if (rx == 0 && ry == 0);
					else if (rx == 0) o0.push("v", ry);
					else if (ry == 0) o0.push("h", rx);
					else o0.push("l", rx, ry);
				} else {
					o0.push(cmd.toLowerCase());
					for (var j = 0; j < cc; j += 2) {
						dx = crds[co + j] - x$1;
						dy = crds[co + j + 1] - y;
						rx = num(dx + ex);
						ry = num(dy + ey);
						o0.push(rx, ry);
					}
				}
				if (cc != 0) {
					ex += dx - rx;
					ey += dy - ry;
				}
				var ou = o0;
				for (var j = 0; j < ou.length; j++) out.push(ou[j]);
				if (cc != 0) {
					co += cc;
					x$1 = crds[co - 2];
					y = crds[co - 1];
				}
				if (cmd == "M") {
					mx = x$1;
					my = y;
				}
				if (cmd == "Z") {
					x$1 = mx;
					y = my;
				}
			}
			return merge$1(out);
		}
		function SVGToPath(d$1) {
			var pth = {
				cmds: [],
				crds: []
			};
			Typr["U"]["SVG"].svgToPath(d$1, pth);
			return {
				"cmds": pth.cmds,
				"crds": pth.crds
			};
		}
		function mipmapB(buff, w, h, hlp) {
			var nw = w >> 1, nh = h >> 1;
			var nbuf = new Uint8Array(nw * nh * 4);
			var sb32 = new Uint32Array(buff.buffer), nb32 = new Uint32Array(nbuf.buffer);
			for (var y = 0; y < nh; y++) for (var x$1 = 0; x$1 < nw; x$1++) {
				var ti = y * nw + x$1, si = (y << 1) * w + (x$1 << 1);
				var c0 = sb32[si], c1$2 = sb32[si + 1], c2$2 = sb32[si + w], c3$2 = sb32[si + w + 1];
				var a0 = c0 >>> 24, a1 = c1$2 >>> 24, a2 = c2$2 >>> 24, a3 = c3$2 >>> 24, a = a0 + a1 + a2 + a3;
				if (a == 1020) {
					var r = (c0 >>> 0 & 255) + (c1$2 >>> 0 & 255) + (c2$2 >>> 0 & 255) + (c3$2 >>> 0 & 255) + 2 >>> 2;
					var g$1 = (c0 >>> 8 & 255) + (c1$2 >>> 8 & 255) + (c2$2 >>> 8 & 255) + (c3$2 >>> 8 & 255) + 2 >>> 2;
					var b$1 = (c0 >>> 16 & 255) + (c1$2 >>> 16 & 255) + (c2$2 >>> 16 & 255) + (c3$2 >>> 16 & 255) + 2 >>> 2;
					nb32[ti] = 255 << 24 | b$1 << 16 | g$1 << 8 | r;
				} else if (a == 0) nb32[ti] = 0;
				else {
					var r = (c0 >>> 0 & 255) * a0 + (c1$2 >>> 0 & 255) * a1 + (c2$2 >>> 0 & 255) * a2 + (c3$2 >>> 0 & 255) * a3;
					var g$1 = (c0 >>> 8 & 255) * a0 + (c1$2 >>> 8 & 255) * a1 + (c2$2 >>> 8 & 255) * a2 + (c3$2 >>> 8 & 255) * a3;
					var b$1 = (c0 >>> 16 & 255) * a0 + (c1$2 >>> 16 & 255) * a1 + (c2$2 >>> 16 & 255) * a2 + (c3$2 >>> 16 & 255) * a3;
					var ia$1 = 1 / a;
					r = ~~(r * ia$1 + .5);
					g$1 = ~~(g$1 * ia$1 + .5);
					b$1 = ~~(b$1 * ia$1 + .5);
					nb32[ti] = a + 2 >>> 2 << 24 | b$1 << 16 | g$1 << 8 | r;
				}
			}
			return {
				buff: nbuf,
				w: nw,
				h: nh
			};
		}
		var __cnv, __ct;
		function pathToContext(path$1, ctx) {
			var c = 0, cmds = path$1["cmds"], crds = path$1["crds"];
			for (var j = 0; j < cmds.length; j++) {
				var cmd = cmds[j];
				if (cmd == "M") {
					ctx.moveTo(crds[c], crds[c + 1]);
					c += 2;
				} else if (cmd == "L") {
					ctx.lineTo(crds[c], crds[c + 1]);
					c += 2;
				} else if (cmd == "C") {
					ctx.bezierCurveTo(crds[c], crds[c + 1], crds[c + 2], crds[c + 3], crds[c + 4], crds[c + 5]);
					c += 6;
				} else if (cmd == "Q") {
					ctx.quadraticCurveTo(crds[c], crds[c + 1], crds[c + 2], crds[c + 3]);
					c += 4;
				} else if (cmd[0] == "d") {
					var upng = window["UPNG"];
					var x0 = crds[c], y0 = crds[c + 1], x1 = crds[c + 2], y1 = crds[c + 3], x2 = crds[c + 4], y2 = crds[c + 5], x3 = crds[c + 6], y3 = crds[c + 7];
					c += 8;
					if (upng == null) {
						ctx.moveTo(x0, y0);
						ctx.lineTo(x1, y1);
						ctx.lineTo(x2, y2);
						ctx.lineTo(x3, y3);
						ctx.closePath();
						continue;
					}
					var dx0 = x1 - x0, dy0 = y1 - y0, dx1 = x3 - x0, dy1 = y3 - y0;
					var sbmp = atob(cmd.slice(22));
					var bmp = new Uint8Array(sbmp.length);
					for (var i$2 = 0; i$2 < sbmp.length; i$2++) bmp[i$2] = sbmp.charCodeAt(i$2);
					var img = upng["decode"](bmp.buffer), w = img["width"], h = img["height"];
					var nbmp = new Uint8Array(upng["toRGBA8"](img)[0]);
					var tr = ctx["getTransform"]();
					var scl = Math.sqrt(Math.abs(tr["a"] * tr["d"] - tr["b"] * tr["c"])) * Math.sqrt(dx1 * dx1 + dy1 * dy1) / h;
					while (scl < .5) {
						var nd = mipmapB(nbmp, w, h);
						nbmp = nd.buff;
						w = nd.w;
						h = nd.h;
						scl *= 2;
					}
					if (__cnv == null) {
						__cnv = document.createElement("canvas");
						__ct = __cnv.getContext("2d");
					}
					if (__cnv.width != w || __cnv.height != h) {
						__cnv.width = w;
						__cnv.height = h;
					}
					__ct.putImageData(new ImageData(new Uint8ClampedArray(nbmp.buffer), w, h), 0, 0);
					ctx.save();
					ctx.transform(dx0, dy0, dx1, dy1, x0, y0);
					ctx.scale(1 / w, 1 / h);
					ctx.drawImage(__cnv, 0, 0);
					ctx.restore();
				} else if (cmd.charAt(0) == "#" || cmd.charAt(0) == "r") {
					ctx.beginPath();
					ctx.fillStyle = cmd;
				} else if (cmd.charAt(0) == "O" && cmd != "OX") {
					ctx.beginPath();
					var pts = cmd.split("-");
					ctx.lineWidth = parseFloat(pts[2]);
					ctx.lineCap = [
						"butt",
						"round",
						"square"
					][parseFloat(pts[3])];
					ctx.lineJoin = [
						"miter",
						"round",
						"bevel"
					][parseFloat(pts[4])];
					ctx.miterLimit = parseFloat(pts[5]);
					ctx.lineDashOffset = parseFloat(pts[6]);
					ctx.setLineDash(pts[7].split(",").map(parseFloat));
					ctx.strokeStyle = pts[1];
				} else if (cmd == "Z") ctx.closePath();
				else if (cmd == "X") ctx.fill();
				else if (cmd == "OX") ctx.stroke();
			}
		}
		function _drawCFF(cmds, state, font$1, pdct, p$1) {
			var stack = state.stack;
			var nStems = state.nStems, haveWidth = state.haveWidth, width = state.width, open = state.open;
			var i$2 = 0;
			var x$1 = state.x, y = state.y, c1x = 0, c1y = 0, c2x = 0, c2y = 0, c3x = 0, c3y = 0, c4x = 0, c4y = 0, jpx = 0, jpy = 0;
			var CFF = Typr["T"].CFF;
			var nominalWidthX = pdct["nominalWidthX"];
			var o = {
				val: 0,
				size: 0
			};
			while (i$2 < cmds.length) {
				CFF.getCharString(cmds, i$2, o);
				var v$1 = o.val;
				i$2 += o.size;
				if (v$1 == "o1" || v$1 == "o18") {
					var hasWidthArg = stack.length % 2 !== 0;
					if (hasWidthArg && !haveWidth) width = stack.shift() + nominalWidthX;
					nStems += stack.length >> 1;
					stack.length = 0;
					haveWidth = true;
				} else if (v$1 == "o3" || v$1 == "o23") {
					var hasWidthArg = stack.length % 2 !== 0;
					if (hasWidthArg && !haveWidth) width = stack.shift() + nominalWidthX;
					nStems += stack.length >> 1;
					stack.length = 0;
					haveWidth = true;
				} else if (v$1 == "o4") {
					if (stack.length > 1 && !haveWidth) {
						width = stack.shift() + nominalWidthX;
						haveWidth = true;
					}
					if (open) P$1.ClosePath(p$1);
					y += stack.pop();
					P$1.MoveTo(p$1, x$1, y);
					open = true;
				} else if (v$1 == "o5") while (stack.length > 0) {
					x$1 += stack.shift();
					y += stack.shift();
					P$1.LineTo(p$1, x$1, y);
				}
				else if (v$1 == "o6" || v$1 == "o7") {
					var count = stack.length;
					var isX = v$1 == "o6";
					for (var j = 0; j < count; j++) {
						var sval = stack.shift();
						if (isX) x$1 += sval;
						else y += sval;
						isX = !isX;
						P$1.LineTo(p$1, x$1, y);
					}
				} else if (v$1 == "o8" || v$1 == "o24") {
					var count = stack.length;
					var index = 0;
					while (index + 6 <= count) {
						c1x = x$1 + stack.shift();
						c1y = y + stack.shift();
						c2x = c1x + stack.shift();
						c2y = c1y + stack.shift();
						x$1 = c2x + stack.shift();
						y = c2y + stack.shift();
						P$1.CurveTo(p$1, c1x, c1y, c2x, c2y, x$1, y);
						index += 6;
					}
					if (v$1 == "o24") {
						x$1 += stack.shift();
						y += stack.shift();
						P$1.LineTo(p$1, x$1, y);
					}
				} else if (v$1 == "o11") break;
				else if (v$1 == "o1234" || v$1 == "o1235" || v$1 == "o1236" || v$1 == "o1237") {
					if (v$1 == "o1234") {
						c1x = x$1 + stack.shift();
						c1y = y;
						c2x = c1x + stack.shift();
						c2y = c1y + stack.shift();
						jpx = c2x + stack.shift();
						jpy = c2y;
						c3x = jpx + stack.shift();
						c3y = c2y;
						c4x = c3x + stack.shift();
						c4y = y;
						x$1 = c4x + stack.shift();
						P$1.CurveTo(p$1, c1x, c1y, c2x, c2y, jpx, jpy);
						P$1.CurveTo(p$1, c3x, c3y, c4x, c4y, x$1, y);
					}
					if (v$1 == "o1235") {
						c1x = x$1 + stack.shift();
						c1y = y + stack.shift();
						c2x = c1x + stack.shift();
						c2y = c1y + stack.shift();
						jpx = c2x + stack.shift();
						jpy = c2y + stack.shift();
						c3x = jpx + stack.shift();
						c3y = jpy + stack.shift();
						c4x = c3x + stack.shift();
						c4y = c3y + stack.shift();
						x$1 = c4x + stack.shift();
						y = c4y + stack.shift();
						stack.shift();
						P$1.CurveTo(p$1, c1x, c1y, c2x, c2y, jpx, jpy);
						P$1.CurveTo(p$1, c3x, c3y, c4x, c4y, x$1, y);
					}
					if (v$1 == "o1236") {
						c1x = x$1 + stack.shift();
						c1y = y + stack.shift();
						c2x = c1x + stack.shift();
						c2y = c1y + stack.shift();
						jpx = c2x + stack.shift();
						jpy = c2y;
						c3x = jpx + stack.shift();
						c3y = c2y;
						c4x = c3x + stack.shift();
						c4y = c3y + stack.shift();
						x$1 = c4x + stack.shift();
						P$1.CurveTo(p$1, c1x, c1y, c2x, c2y, jpx, jpy);
						P$1.CurveTo(p$1, c3x, c3y, c4x, c4y, x$1, y);
					}
					if (v$1 == "o1237") {
						c1x = x$1 + stack.shift();
						c1y = y + stack.shift();
						c2x = c1x + stack.shift();
						c2y = c1y + stack.shift();
						jpx = c2x + stack.shift();
						jpy = c2y + stack.shift();
						c3x = jpx + stack.shift();
						c3y = jpy + stack.shift();
						c4x = c3x + stack.shift();
						c4y = c3y + stack.shift();
						if (Math.abs(c4x - x$1) > Math.abs(c4y - y)) x$1 = c4x + stack.shift();
						else y = c4y + stack.shift();
						P$1.CurveTo(p$1, c1x, c1y, c2x, c2y, jpx, jpy);
						P$1.CurveTo(p$1, c3x, c3y, c4x, c4y, x$1, y);
					}
				} else if (v$1 == "o14") {
					if (stack.length > 0 && stack.length != 4 && !haveWidth) {
						width = stack.shift() + font$1["nominalWidthX"];
						haveWidth = true;
					}
					if (stack.length == 4) {
						var adx = stack.shift();
						var ady = stack.shift();
						var bchar = stack.shift();
						var achar = stack.shift();
						var bind = CFF.glyphBySE(font$1, bchar);
						var aind = CFF.glyphBySE(font$1, achar);
						_drawCFF(font$1["CharStrings"][bind], state, font$1, pdct, p$1);
						state.x = adx;
						state.y = ady;
						_drawCFF(font$1["CharStrings"][aind], state, font$1, pdct, p$1);
					}
					if (open) {
						P$1.ClosePath(p$1);
						open = false;
					}
				} else if (v$1 == "o19" || v$1 == "o20") {
					var hasWidthArg = stack.length % 2 !== 0;
					if (hasWidthArg && !haveWidth) width = stack.shift() + nominalWidthX;
					nStems += stack.length >> 1;
					stack.length = 0;
					haveWidth = true;
					i$2 += nStems + 7 >> 3;
				} else if (v$1 == "o21") {
					if (stack.length > 2 && !haveWidth) {
						width = stack.shift() + nominalWidthX;
						haveWidth = true;
					}
					y += stack.pop();
					x$1 += stack.pop();
					if (open) P$1.ClosePath(p$1);
					P$1.MoveTo(p$1, x$1, y);
					open = true;
				} else if (v$1 == "o22") {
					if (stack.length > 1 && !haveWidth) {
						width = stack.shift() + nominalWidthX;
						haveWidth = true;
					}
					x$1 += stack.pop();
					if (open) P$1.ClosePath(p$1);
					P$1.MoveTo(p$1, x$1, y);
					open = true;
				} else if (v$1 == "o25") {
					while (stack.length > 6) {
						x$1 += stack.shift();
						y += stack.shift();
						P$1.LineTo(p$1, x$1, y);
					}
					c1x = x$1 + stack.shift();
					c1y = y + stack.shift();
					c2x = c1x + stack.shift();
					c2y = c1y + stack.shift();
					x$1 = c2x + stack.shift();
					y = c2y + stack.shift();
					P$1.CurveTo(p$1, c1x, c1y, c2x, c2y, x$1, y);
				} else if (v$1 == "o26") {
					if (stack.length % 2) x$1 += stack.shift();
					while (stack.length > 0) {
						c1x = x$1;
						c1y = y + stack.shift();
						c2x = c1x + stack.shift();
						c2y = c1y + stack.shift();
						x$1 = c2x;
						y = c2y + stack.shift();
						P$1.CurveTo(p$1, c1x, c1y, c2x, c2y, x$1, y);
					}
				} else if (v$1 == "o27") {
					if (stack.length % 2) y += stack.shift();
					while (stack.length > 0) {
						c1x = x$1 + stack.shift();
						c1y = y;
						c2x = c1x + stack.shift();
						c2y = c1y + stack.shift();
						x$1 = c2x + stack.shift();
						y = c2y;
						P$1.CurveTo(p$1, c1x, c1y, c2x, c2y, x$1, y);
					}
				} else if (v$1 == "o10" || v$1 == "o29") {
					var obj = v$1 == "o10" ? pdct : font$1;
					if (stack.length == 0) console.log("error: empty stack");
					else {
						var ind = stack.pop();
						var subr = obj["Subrs"][ind + obj["Bias"]];
						state.x = x$1;
						state.y = y;
						state.nStems = nStems;
						state.haveWidth = haveWidth;
						state.width = width;
						state.open = open;
						_drawCFF(subr, state, font$1, pdct, p$1);
						x$1 = state.x;
						y = state.y;
						nStems = state.nStems;
						haveWidth = state.haveWidth;
						width = state.width;
						open = state.open;
					}
				} else if (v$1 == "o30" || v$1 == "o31") {
					var count, count1 = stack.length;
					var index = 0;
					var alternate = v$1 == "o31";
					count = count1 & -3;
					index += count1 - count;
					while (index < count) {
						if (alternate) {
							c1x = x$1 + stack.shift();
							c1y = y;
							c2x = c1x + stack.shift();
							c2y = c1y + stack.shift();
							y = c2y + stack.shift();
							if (count - index == 5) {
								x$1 = c2x + stack.shift();
								index++;
							} else x$1 = c2x;
							alternate = false;
						} else {
							c1x = x$1;
							c1y = y + stack.shift();
							c2x = c1x + stack.shift();
							c2y = c1y + stack.shift();
							x$1 = c2x + stack.shift();
							if (count - index == 5) {
								y = c2y + stack.shift();
								index++;
							} else y = c2y;
							alternate = true;
						}
						P$1.CurveTo(p$1, c1x, c1y, c2x, c2y, x$1, y);
						index += 4;
					}
				} else if ((v$1 + "").charAt(0) == "o") {
					console.log("Unknown operation: " + v$1, cmds);
					throw v$1;
				} else stack.push(v$1);
			}
			state.x = x$1;
			state.y = y;
			state.nStems = nStems;
			state.haveWidth = haveWidth;
			state.width = width;
			state.open = open;
		}
		function initHB(hurl, resp) {
			var codeLength = function(code) {
				var len = 0;
				if ((code & 4294967168) == 0) len = 1;
				else if ((code & 4294965248) == 0) len = 2;
				else if ((code & 4294901760) == 0) len = 3;
				else if ((code & 4292870144) == 0) len = 4;
				return len;
			};
			fetch(hurl).then(function(x$1) {
				return x$1["arrayBuffer"]();
			}).then(function(ab) {
				return WebAssembly["instantiate"](ab);
			}).then(function(res) {
				console.log("HB ready");
				var exp = res["instance"]["exports"], mem = exp["memory"];
				var heapu8, u32, i32, f32;
				var __lastFnt, blob, blobPtr, face, font$1;
				Typr["U"]["shapeHB"] = function() {
					var toJson = function(ptr) {
						var length = exp["hb_buffer_get_length"](ptr);
						var result = [];
						var iPtr32 = exp["hb_buffer_get_glyph_infos"](ptr, 0) >>> 2;
						var pPtr32 = exp["hb_buffer_get_glyph_positions"](ptr, 0) >>> 2;
						for (var i$2 = 0; i$2 < length; ++i$2) {
							var a = iPtr32 + i$2 * 5, b$1 = pPtr32 + i$2 * 5;
							result.push({
								"g": u32[a + 0],
								"cl": u32[a + 2],
								"ax": i32[b$1 + 0],
								"ay": i32[b$1 + 1],
								"dx": i32[b$1 + 2],
								"dy": i32[b$1 + 3]
							});
						}
						return result;
					};
					var te;
					return function(fnt, str, prm) {
						var fdata = fnt["_data"], fn$1 = fnt["name"]["postScriptName"];
						var ltr = prm["ltr"], fts = prm["fts"], axs = prm["axs"];
						if (fnt["fvar"] && axs == null) axs = fnt["fvar"][1][fnt["_index"]][2];
						heapu8 = new Uint8Array(mem.buffer);
						u32 = new Uint32Array(mem.buffer);
						i32 = new Int32Array(mem.buffer);
						f32 = new Float32Array(mem.buffer);
						if (__lastFnt != fn$1) {
							if (blob != null) {
								exp["hb_blob_destroy"](blob);
								exp["free"](blobPtr);
								exp["hb_face_destroy"](face);
								exp["hb_font_destroy"](font$1);
							}
							blobPtr = exp["malloc"](fdata.byteLength);
							heapu8.set(fdata, blobPtr);
							blob = exp["hb_blob_create"](blobPtr, fdata.byteLength, 2, 0, 0);
							face = exp["hb_face_create"](blob, fnt["_index"]);
							font$1 = exp["hb_font_create"](face);
							__lastFnt = fn$1;
						}
						if (window["TextEncoder"] == null) {
							alert("Your browser is too old. Please, update it.");
							return;
						}
						if (te == null) te = new window["TextEncoder"]("utf8");
						var buffer = exp["hb_buffer_create"]();
						var bytes = te["encode"](str);
						var len = bytes.length, strp = exp["malloc"](len);
						heapu8.set(bytes, strp);
						exp["hb_buffer_add_utf8"](buffer, strp, len, 0, len);
						exp["free"](strp);
						var bin = Typr["B"];
						var feat = 0;
						if (fts) {
							feat = exp["malloc"](16 * fts.length);
							for (var i$2 = 0; i$2 < fts.length; i$2++) {
								var fe = fts[i$2];
								var off = feat + i$2 * 16, qo = off >>> 2;
								bin.writeASCII(heapu8, off, fe[0].split("").reverse().join(""));
								u32[qo + 1] = fe[1];
								u32[qo + 2] = fe[2];
								u32[qo + 3] = fe[3];
							}
						}
						var vdat = 0;
						if (axs && fnt["fvar"]) {
							var axes = fnt["fvar"][0];
							vdat = exp["malloc"](8 * axs.length);
							for (var i$2 = 0; i$2 < axs.length; i$2++) {
								var off = vdat + i$2 * 8, qo = off >>> 2;
								bin.writeASCII(heapu8, off, axes[i$2][0].split("").reverse().join(""));
								f32[qo + 1] = axs[i$2];
							}
						}
						if (axs) exp["hb_font_set_variations"](font$1, vdat, axs.length);
						exp["hb_buffer_set_direction"](buffer, ltr ? 4 : 5);
						exp["hb_buffer_guess_segment_properties"](buffer);
						exp["hb_shape"](font$1, buffer, feat, fts ? fts.length : 0);
						var json = toJson(buffer);
						exp["hb_buffer_destroy"](buffer);
						if (fts) exp["free"](feat);
						if (axs) exp["free"](vdat);
						var arr$1 = json.slice(0);
						if (!ltr) arr$1.reverse();
						var ci = 0, bi = 0;
						for (var i$2 = 1; i$2 < arr$1.length; i$2++) {
							var gl = arr$1[i$2], cl = gl["cl"];
							while (true) {
								var cpt = str.codePointAt(ci), cln = codeLength(cpt);
								if (bi + cln <= cl) {
									bi += cln;
									ci += cpt <= 65535 ? 1 : 2;
								} else break;
							}
							gl["cl"] = ci;
						}
						return json;
					};
				}();
				resp();
			});
		}
		return {
			"shape": shape$1,
			"shapeToPath": shapeToPath,
			"codeToGlyph": codeToGlyph,
			"glyphToPath": glyphToPath,
			"pathToSVG": pathToSVG,
			"SVGToPath": SVGToPath,
			"pathToContext": pathToContext,
			"initHB": initHB
		};
	}();
	var import_bezier_path = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports, module) => {
		(function(t$1, e$1) {
			"object" == typeof exports && "object" == typeof module ? module.exports = e$1() : "function" == typeof define && define.amd ? define([], e$1) : "object" == typeof exports ? exports.BezierPath = e$1() : t$1.BezierPath = e$1();
		})(self, (() => (() => {
			var t$1 = {
				177: (t$2, e$2, s) => {
					Object.defineProperty(e$2, "__esModule", { value: !0 }), e$2.BezierPath = void 0;
					const i$1 = s(558), h = s(188);
					e$2.BezierPath = class {
						constructor(t$3) {
							this.samples = [], this.segments = t$3;
							const e$3 = t$3.map(((t$4) => t$4.getTotalLength())), s$1 = [0];
							for (let t$4 = 1; t$4 < e$3.length; t$4++) s$1.push(s$1[t$4 - 1] + e$3[t$4 - 1]);
							this._totalLength = s$1[s$1.length - 1] + e$3[e$3.length - 1];
							const a = t$3.map(((t$4) => Math.max(4, Math.ceil(t$4.getTotalLength() / i$1.BezierSegment.sampleSpacing())))), n$2 = a.reduce(((t$4, e$4) => t$4 + e$4)), r = 1 / n$2 / 10, o = this._totalLength / n$2;
							this.samples.push({
								dist: 0,
								pt: this.segments[0].A,
								tan: this.segments[0].tangentAtParameter(0),
								segIdx: 0,
								t: 0
							}), t$3.forEach(((t$4, e$4) => {
								const i$2 = a[e$4], n$3 = (0, h.times)(i$2 + 1).map(((t$5) => t$5 / i$2)), x$1 = n$3.map(((e$5) => t$4.pointAtParameter(e$5)));
								let y;
								for (let e$5 = 0; e$5 < 4; e$5++) {
									y = (0, h.times)(i$2).map(((t$5) => Math.hypot(x$1[t$5 + 1].x - x$1[t$5].x, x$1[t$5 + 1].y - x$1[t$5].y)));
									const e$6 = y.map(((t$5) => t$5 - o));
									let s$2 = 0;
									for (let i$3 = 1; i$3 < n$3.length - 1; i$3++) s$2 += e$6[i$3 - 1], n$3[i$3] -= r * s$2, x$1[i$3] = t$4.pointAtParameter(n$3[i$3]);
								}
								let p$1 = 0;
								x$1.slice(1).forEach(((t$5, i$3) => {
									p$1 += y[i$3], this.samples.push({
										dist: s$1[e$4] + p$1,
										pt: t$5,
										tan: this.segments[e$4].tangentAtParameter(n$3[i$3 + 1]),
										segIdx: e$4,
										t: n$3[i$3 + 1]
									});
								}));
							})), this._jumps = [], this.segmentStartEnds = [{
								start: 0,
								end: 0
							}];
							for (let t$4 = 1; t$4 < this.samples.length; t$4++) {
								const e$4 = this.samples[t$4 - 1], s$2 = this.samples[t$4];
								if (s$2.segIdx === e$4.segIdx ? this.segmentStartEnds[this.segmentStartEnds.length - 1].end = s$2.dist : this.segmentStartEnds[s$2.segIdx] = {
									start: s$2.dist,
									end: s$2.dist
								}, e$4.segIdx !== s$2.segIdx && (this.segments[e$4.segIdx].D.x !== this.segments[s$2.segIdx].A.x || this.segments[e$4.segIdx].D.y !== this.segments[s$2.segIdx].A.y)) {
									const i$2 = (e$4.dist + s$2.dist) / 2, h$1 = {
										dist: i$2 - 1e-8,
										pt: this.segments[e$4.segIdx].D,
										tan: this.segments[e$4.segIdx].tangentAtParameter(1),
										segIdx: e$4.segIdx,
										t: 1
									}, a$1 = {
										dist: i$2 + 1e-8,
										pt: this.segments[s$2.segIdx].A,
										tan: this.segments[s$2.segIdx].tangentAtParameter(0),
										segIdx: s$2.segIdx,
										t: 0
									};
									this._jumps.push(i$2), this.samples.splice(t$4, 0, h$1, a$1), t$4 += 2;
								}
							}
						}
						jumps() {
							return [...this._jumps];
						}
						getTotalLength() {
							return this._totalLength;
						}
						findClosestSampleIdx(t$3) {
							let e$3 = 0, s$1 = this.samples.length - 1;
							for (; e$3 < s$1;) {
								const i$2 = Math.floor((e$3 + s$1) / 2);
								if (this.samples[i$2].dist > t$3) s$1 = i$2 - 1;
								else {
									if (!(this.samples[i$2].dist < t$3)) return i$2;
									e$3 = i$2 + 1;
								}
							}
							return Math.max(0, Math.min(this.samples.length - 1, Math.floor((e$3 + s$1) / 2)));
						}
						getPointAtLength(t$3, e$3 = !1) {
							if (t$3 <= 0) return this.samples[0].pt;
							if (t$3 >= this._totalLength) return this.samples[this.samples.length - 1].pt;
							const s$1 = this.findClosestSampleIdx(t$3), i$2 = this.samples[s$1].dist < t$3 ? Math.min(s$1 + 1, this.samples.length - 1) : Math.max(0, s$1 - 1), h$1 = Math.abs(this.samples[i$2].dist - this.samples[s$1].dist) < 1e-6 ? 0 : (t$3 - this.samples[s$1].dist) / (this.samples[i$2].dist - this.samples[s$1].dist);
							if (e$3 || this.samples[s$1].segIdx > this.samples[i$2].segIdx) return {
								x: (1 - h$1) * this.samples[s$1].pt.x + h$1 * this.samples[i$2].pt.x,
								y: (1 - h$1) * this.samples[s$1].pt.y + h$1 * this.samples[i$2].pt.y
							};
							if (this.samples[s$1].segIdx !== this.samples[i$2].segIdx) {
								if (h$1 < .5) {
									const t$4 = this.segments[this.samples[s$1].segIdx], e$4 = 2 * h$1, i$3 = (1 - e$4) * this.samples[s$1].t + e$4;
									return t$4.pointAtParameter(i$3);
								}
								{
									const t$4 = this.segments[this.samples[i$2].segIdx], e$4 = 2 * (h$1 - .5) * this.samples[i$2].t;
									return t$4.pointAtParameter(e$4);
								}
							}
							{
								const t$4 = this.segments[this.samples[s$1].segIdx], e$4 = (1 - h$1) * this.samples[s$1].t + h$1 * this.samples[i$2].t;
								return t$4.pointAtParameter(e$4);
							}
						}
						getAngleAtLength(t$3, e$3 = !1) {
							const s$1 = this.getTangentAtLength(t$3, e$3);
							return Math.atan2(s$1.y, s$1.x);
						}
						getTangentAtLength(t$3, e$3 = !1) {
							if (t$3 <= 0) return this.samples[0].tan;
							if (t$3 >= this._totalLength) return this.samples[this.samples.length - 1].tan;
							const s$1 = this.findClosestSampleIdx(t$3), i$2 = this.samples[s$1].dist < t$3 ? Math.min(s$1 + 1, this.samples.length - 1) : Math.max(0, s$1 - 1), h$1 = (t$3 - this.samples[s$1].dist) / (this.samples[i$2].dist - this.samples[s$1].dist);
							if (e$3 || this.samples[s$1].segIdx > this.samples[i$2].segIdx) {
								let t$4 = (1 - h$1) * this.samples[s$1].tan.x + h$1 * this.samples[i$2].tan.x, e$4 = (1 - h$1) * this.samples[s$1].tan.y + h$1 * this.samples[i$2].tan.y;
								const a = Math.max(Math.hypot(t$4, e$4), 1e-4);
								return t$4 /= a, e$4 /= a, {
									x: t$4,
									y: e$4
								};
							}
							if (this.samples[s$1].segIdx !== this.samples[i$2].segIdx) {
								if (h$1 < .5) {
									const t$4 = this.segments[this.samples[s$1].segIdx], e$4 = 2 * h$1, i$3 = (1 - e$4) * this.samples[s$1].t + e$4;
									return t$4.tangentAtParameter(i$3);
								}
								{
									const t$4 = this.segments[this.samples[i$2].segIdx], e$4 = 2 * (h$1 - .5) * this.samples[i$2].t;
									return t$4.tangentAtParameter(e$4);
								}
							}
							{
								const t$4 = this.segments[this.samples[s$1].segIdx], e$4 = (1 - h$1) * this.samples[s$1].t + h$1 * this.samples[i$2].t;
								return t$4.tangentAtParameter(e$4);
							}
						}
					};
				},
				558: (t$2, e$2, s) => {
					Object.defineProperty(e$2, "__esModule", { value: !0 }), e$2.BezierSegment = void 0;
					const i$1 = s(188);
					class h {
						constructor(t$3, e$3, s$1, i$2) {
							this._totalLength = void 0, this.A = t$3, this.B = e$3, this.C = s$1, this.D = i$2;
						}
						static sampleSpacing() {
							return 2;
						}
						tangentAtParameter(t$3) {
							const e$3 = Math.max(0, Math.min(1, t$3));
							if (0 === e$3 || 1 === e$3) {
								let t$4, s$2;
								0 === e$3 ? this.A.x === this.B.x && this.A.y === this.B.y ? (t$4 = this.C.x - this.A.x, s$2 = this.C.y - this.A.y) : (t$4 = this.B.x - this.A.x, s$2 = this.B.y - this.A.y) : this.D.x === this.C.x && this.D.y === this.C.y ? (t$4 = this.D.x - this.B.x, s$2 = this.D.y - this.B.y) : (t$4 = this.D.x - this.C.x, s$2 = this.D.y - this.C.y);
								const i$3 = Math.hypot(t$4, s$2);
								return Math.abs(i$3) > 1e-4 && (t$4 /= i$3, s$2 /= i$3), {
									x: t$4,
									y: s$2
								};
							}
							const s$1 = 1 - e$3;
							let i$2 = 3 * this.D.x * Math.pow(e$3, 2) - 3 * this.C.x * Math.pow(e$3, 2) + 6 * this.C.x * s$1 * e$3 - 6 * this.B.x * s$1 * e$3 + 3 * this.B.x * Math.pow(s$1, 2) - 3 * this.A.x * Math.pow(s$1, 2), h$1 = 3 * this.D.y * Math.pow(e$3, 2) - 3 * this.C.y * Math.pow(e$3, 2) + 6 * this.C.y * s$1 * e$3 - 6 * this.B.y * s$1 * e$3 + 3 * this.B.y * Math.pow(s$1, 2) - 3 * this.A.y * Math.pow(s$1, 2);
							const a = Math.hypot(i$2, h$1);
							return Math.abs(a) > 1e-4 && (i$2 /= a, h$1 /= a), {
								x: i$2,
								y: h$1
							};
						}
						isLinear() {
							return this.A.x === this.B.x && this.A.y === this.B.y && this.C.x === this.D.x && this.C.y === this.D.y;
						}
						pointAtParameter(t$3) {
							const e$3 = Math.max(0, Math.min(1, t$3));
							return {
								x: Math.pow(1 - e$3, 3) * this.A.x + 3 * Math.pow(1 - e$3, 2) * e$3 * this.B.x + 3 * (1 - e$3) * Math.pow(e$3, 2) * this.C.x + Math.pow(e$3, 3) * this.D.x,
								y: Math.pow(1 - e$3, 3) * this.A.y + 3 * Math.pow(1 - e$3, 2) * e$3 * this.B.y + 3 * (1 - e$3) * Math.pow(e$3, 2) * this.C.y + Math.pow(e$3, 3) * this.D.y
							};
						}
						getTotalLength() {
							if (void 0 === this._totalLength) if (this.isLinear()) this._totalLength = Math.hypot(this.D.x - this.A.x, this.D.y - this.A.y);
							else {
								const t$3 = Math.max(10, Math.ceil((Math.hypot(this.B.x - this.A.x, this.B.y - this.A.y) + Math.hypot(this.C.x - this.B.x, this.C.y - this.B.y) + Math.hypot(this.D.x - this.C.x, this.D.y - this.C.y)) / h.sampleSpacing())), e$3 = (0, i$1.times)(t$3).map(((e$4) => this.pointAtParameter(e$4 / (t$3 - 1))));
								let s$1 = 0;
								for (let t$4 = 1; t$4 < e$3.length; t$4++) s$1 += Math.hypot(e$3[t$4].x - e$3[t$4 - 1].x, e$3[t$4].y - e$3[t$4 - 1].y);
								this._totalLength = s$1;
							}
							return this._totalLength;
						}
					}
					e$2.BezierSegment = h;
				},
				729: (t$2, e$2, s) => {
					Object.defineProperty(e$2, "__esModule", { value: !0 }), e$2.createFromCommands = e$2.create = e$2.createFromElement = e$2.createFromCircle = e$2.createFromLine = e$2.createFromPath = void 0;
					const i$1 = s(821), h = s(558), a = {
						M: ["x", "y"],
						m: ["dx", "dy"],
						H: ["x"],
						h: ["dx"],
						V: ["y"],
						v: ["dy"],
						L: ["x", "y"],
						l: ["dx", "dy"],
						Z: [],
						C: [
							"x1",
							"y1",
							"x2",
							"y2",
							"x",
							"y"
						],
						c: [
							"dx1",
							"dy1",
							"dx2",
							"dy2",
							"dx",
							"dy"
						],
						S: [
							"x2",
							"y2",
							"x",
							"y"
						],
						s: [
							"dx2",
							"dy2",
							"dx",
							"dy"
						],
						Q: [
							"x1",
							"y1",
							"x",
							"y"
						],
						q: [
							"dx1",
							"dy1",
							"dx",
							"dy"
						],
						T: ["x", "y"],
						t: ["dx", "dy"],
						A: [
							"rx",
							"ry",
							"rotation",
							"large-arc",
							"sweep",
							"x",
							"y"
						],
						a: [
							"rx",
							"ry",
							"rotation",
							"large-arc",
							"sweep",
							"dx",
							"dy"
						]
					};
					e$2.createFromPath = (t$3) => {
						const e$3 = function(t$4) {
							const e$4 = t$4.replace(/[\n\r]/g, "").replace(/-/g, " -").replace(/(\d*\.)(\d+)(?=\.)/g, "$1$2 ").replace(/(\d)([A-Za-z])/g, "$1 $2").replace(/([A-Za-z])(\d)/g, "$1 $2").trim().split(/\s*,|\s+/), s$2 = [];
							let i$2 = "", h$1 = {};
							for (; e$4.length > 0;) {
								let t$5 = e$4.shift();
								a.hasOwnProperty(t$5) ? i$2 = t$5 : e$4.unshift(t$5), h$1 = { type: i$2 }, a[i$2].forEach(((s$3) => {
									t$5 = e$4.shift(), h$1[s$3] = parseFloat(t$5);
								})), "M" === i$2 ? i$2 = "L" : "m" === i$2 && (i$2 = "l"), s$2.push(h$1);
							}
							return s$2;
						}(t$3.getAttribute("d"));
						if (e$3.length < 2) throw new Error(`Path doesn't have enough commands: ${JSON.stringify(e$3)}`);
						if ("M" !== e$3[0].type) throw new Error(`Path starts with ${e$3[0].type} instead of M!`);
						let s$1 = {
							x: e$3[0].x,
							y: e$3[0].y
						};
						e$3.shift();
						const n$2 = [];
						for (; e$3.length > 0;) {
							const t$4 = e$3.shift();
							if ("C" === t$4.type) n$2.push(new h.BezierSegment(s$1, {
								x: t$4.x1,
								y: t$4.y1
							}, {
								x: t$4.x2,
								y: t$4.y2
							}, {
								x: t$4.x,
								y: t$4.y
							})), s$1 = {
								x: t$4.x,
								y: t$4.y
							};
							else if ("L" === t$4.type) n$2.push(new h.BezierSegment(s$1, s$1, {
								x: t$4.x,
								y: t$4.y
							}, {
								x: t$4.x,
								y: t$4.y
							})), s$1 = {
								x: t$4.x,
								y: t$4.y
							};
							else if ("H" === t$4.type) n$2.push(new h.BezierSegment(s$1, s$1, {
								x: t$4.x,
								y: s$1.y
							}, {
								x: t$4.x,
								y: s$1.y
							})), s$1 = {
								x: t$4.x,
								y: s$1.y
							};
							else if ("V" === t$4.type) n$2.push(new h.BezierSegment(s$1, s$1, {
								x: s$1.x,
								y: t$4.y
							}, {
								x: s$1.x,
								y: t$4.y
							})), s$1 = {
								x: s$1.x,
								y: t$4.y
							};
							else if ("Z" !== t$4.type) throw new Error(`Unsupported path command ${t$4.type}; use only H, V, M, L, C, Z!`);
						}
						return new i$1.BezierPath(n$2);
					}, e$2.createFromLine = (t$3) => {
						const [e$3, s$1, a$1, n$2] = [
							"x1",
							"x2",
							"y1",
							"y2"
						].map(((e$4) => parseFloat(t$3.getAttribute(e$4) || "0")));
						return new i$1.BezierPath([new h.BezierSegment({
							x: e$3,
							y: a$1
						}, {
							x: e$3,
							y: a$1
						}, {
							x: s$1,
							y: n$2
						}, {
							x: s$1,
							y: n$2
						})]);
					}, e$2.createFromCircle = (t$3) => {
						const [e$3, s$1, a$1] = [
							"cx",
							"cy",
							"r"
						].map(((e$4) => parseFloat(t$3.getAttribute(e$4) || "0"))), n$2 = 1.3;
						return new i$1.BezierPath([new h.BezierSegment({
							x: e$3 - a$1,
							y: s$1
						}, {
							x: e$3 - a$1,
							y: s$1 - n$2 * a$1
						}, {
							x: e$3 + a$1,
							y: s$1 - n$2 * a$1
						}, {
							x: e$3 + a$1,
							y: s$1
						}), new h.BezierSegment({
							x: e$3 + a$1,
							y: s$1
						}, {
							x: e$3 + a$1,
							y: s$1 + n$2 * a$1
						}, {
							x: e$3 - a$1,
							y: s$1 + n$2 * a$1
						}, {
							x: e$3 - a$1,
							y: s$1
						})]);
					}, e$2.createFromElement = (t$3) => {
						const s$1 = t$3.tagName.toLowerCase();
						if ("path" === s$1) return (0, e$2.createFromPath)(t$3);
						if ("line" === s$1) return (0, e$2.createFromLine)(t$3);
						if ("circle" === s$1) return (0, e$2.createFromCircle)(t$3);
						throw new Error(`Unsupported SVG tag: ${s$1}`);
					}, e$2.create = (t$3) => {
						const e$3 = [];
						for (let s$1 = 1; s$1 < t$3.length; s$1++) {
							const i$2 = t$3[s$1 - 1], a$1 = t$3[s$1];
							e$3.push(new h.BezierSegment(i$2.pt, i$2.right || i$2.pt, a$1.left || a$1.pt, a$1.pt));
						}
						return new i$1.BezierPath(e$3);
					}, e$2.createFromCommands = (t$3) => {
						const e$3 = t$3.slice();
						if (e$3.length < 2) throw new Error(`Path doesn't have enough commands: ${JSON.stringify(e$3)}`);
						if ("M" !== e$3[0].type) throw new Error(`Path starts with ${e$3[0].type} instead of M!`);
						let s$1 = {
							x: e$3[0].x,
							y: e$3[0].y
						}, a$1 = Object.assign({}, s$1);
						const n$2 = [];
						for (; e$3.length > 0;) {
							const t$4 = e$3.shift();
							if ("M" === t$4.type) a$1 = {
								x: t$4.x,
								y: t$4.y
							}, s$1 = a$1;
							else if ("C" === t$4.type) n$2.push(new h.BezierSegment(s$1, {
								x: t$4.x1,
								y: t$4.y1
							}, {
								x: t$4.x2,
								y: t$4.y2
							}, {
								x: t$4.x,
								y: t$4.y
							})), s$1 = {
								x: t$4.x,
								y: t$4.y
							};
							else if ("L" === t$4.type) t$4.x === s$1.x && t$4.y === s$1.y || n$2.push(new h.BezierSegment(s$1, s$1, {
								x: t$4.x,
								y: t$4.y
							}, {
								x: t$4.x,
								y: t$4.y
							})), s$1 = {
								x: t$4.x,
								y: t$4.y
							};
							else if ("H" === t$4.type) t$4.x !== s$1.x && n$2.push(new h.BezierSegment(s$1, s$1, {
								x: t$4.x,
								y: s$1.y
							}, {
								x: t$4.x,
								y: s$1.y
							})), s$1 = {
								x: t$4.x,
								y: s$1.y
							};
							else if ("V" === t$4.type) t$4.y !== s$1.y && n$2.push(new h.BezierSegment(s$1, s$1, {
								x: s$1.x,
								y: t$4.y
							}, {
								x: s$1.x,
								y: t$4.y
							})), s$1 = {
								x: s$1.x,
								y: t$4.y
							};
							else if ("Q" === t$4.type) n$2.push(new h.BezierSegment(s$1, {
								x: s$1.x + 2 / 3 * (t$4.x1 - s$1.x),
								y: s$1.y + 2 / 3 * (t$4.y1 - s$1.y)
							}, {
								x: t$4.x + 2 / 3 * (t$4.x1 - t$4.x),
								y: t$4.y + 2 / 3 * (t$4.y1 - t$4.y)
							}, {
								x: t$4.x,
								y: t$4.y
							})), s$1 = {
								x: t$4.x,
								y: t$4.y
							};
							else {
								if ("Z" !== t$4.type) throw new Error(`Unsupported path command ${t$4.type}; use only H, V, M, L, C, Z!`);
								Math.hypot(s$1.x - a$1.x, s$1.y - a$1.y) > 0 && n$2.push(new h.BezierSegment(s$1, s$1, a$1, a$1));
							}
						}
						return new i$1.BezierPath(n$2);
					};
				},
				821: function(t$2, e$2, s) {
					var i$1 = this && this.__createBinding || (Object.create ? function(t$3, e$3, s$1, i$2) {
						void 0 === i$2 && (i$2 = s$1);
						var h$1 = Object.getOwnPropertyDescriptor(e$3, s$1);
						h$1 && !("get" in h$1 ? !e$3.__esModule : h$1.writable || h$1.configurable) || (h$1 = {
							enumerable: !0,
							get: function() {
								return e$3[s$1];
							}
						}), Object.defineProperty(t$3, i$2, h$1);
					} : function(t$3, e$3, s$1, i$2) {
						void 0 === i$2 && (i$2 = s$1), t$3[i$2] = e$3[s$1];
					}), h = this && this.__exportStar || function(t$3, e$3) {
						for (var s$1 in t$3) "default" === s$1 || Object.prototype.hasOwnProperty.call(e$3, s$1) || i$1(e$3, t$3, s$1);
					};
					Object.defineProperty(e$2, "__esModule", { value: !0 }), h(s(177), e$2), h(s(558), e$2), h(s(729), e$2), h(s(856), e$2);
				},
				856: (t$2, e$2) => {
					Object.defineProperty(e$2, "__esModule", { value: !0 });
				},
				188: (t$2, e$2) => {
					Object.defineProperty(e$2, "__esModule", { value: !0 }), e$2.times = void 0, e$2.times = function(t$3) {
						const e$3 = [];
						for (let s = 0; s < t$3; s++) e$3.push(s);
						return e$3;
					};
				}
			}, e$1 = {};
			return function s(i$1) {
				var h = e$1[i$1];
				if (void 0 !== h) return h.exports;
				var a = e$1[i$1] = { exports: {} };
				return t$1[i$1].call(a.exports, a, a.exports, s), a.exports;
			}(821);
		})()));
	})))());
	const pathArgCounts = {
		M: 2,
		L: 2,
		C: 6,
		Q: 4
	};
	const validFontTypes = [
		"ttf",
		"otf",
		"woff"
	];
	const validFontTypesRe = new RegExp(`\\.(${validFontTypes.join("|")})`, "i");
	const extractFontNameRe = new RegExp(`([^/]+)(\\.(?:${validFontTypes.join("|")}))`, "i");
	const invalidFontError = "Sorry, only TTF, OTF and WOFF files are supported.";
	const fontFaceVariations = [
		"weight",
		"stretch",
		"style"
	];
	var Font = class {
		constructor(p$1, fontFace, name, path$1, data$2) {
			if (!(fontFace instanceof FontFace)) throw Error("FontFace is required");
			this._pInst = p$1;
			this.name = name;
			this.path = path$1;
			this.data = data$2;
			this.face = fontFace;
		}
		static hasGlyphData(textFont) {
			let { font: font$1 } = textFont;
			return typeof font$1 === "object" && typeof font$1.data !== "undefined";
		}
		fontBounds(str, x$1, y, width, height, options$1) {
			({width, height, options: options$1} = this._parseArgs(width, height, options$1));
			let renderer$1 = options$1?.graphics?._renderer || this._pInst._renderer;
			if (!renderer$1) throw Error("p5 or graphics required for fontBounds()");
			return renderer$1.fontBounds(str, x$1, y, width, height);
		}
		textBounds(str, x$1, y, width, height, options$1) {
			({width, height, options: options$1} = this._parseArgs(width, height, options$1));
			let renderer$1 = options$1?.graphics?._renderer || this._pInst._renderer;
			if (!renderer$1) throw Error("p5 or graphics required for fontBounds()");
			return renderer$1.textBounds(str, x$1, y, width, height);
		}
		textToPaths(str, x$1, y, width, height, options$1) {
			({width, height, options: options$1} = this._parseArgs(width, height, options$1));
			if (!this.data) throw Error("No font data available for \"" + this.name + "\"\nTry downloading a local copy of the font file");
			return this._lineateAndPathify(str, x$1, y, width, height, options$1).map((o) => o.glyphs).flat().map((g$1) => g$1.path.commands).flat();
		}
		textToPoints(str, x$1, y, width, height, options$1) {
			return this.textToContours(str, x$1, y, width, height, options$1).reduce((acc, next) => {
				acc.push(...next);
				return acc;
			}, []);
		}
		textToContours(str, x$1 = 0, y = 0, width, height, options$1) {
			({width, height, options: options$1} = this._parseArgs(width, height, options$1));
			const cmds = this.textToPaths(str, x$1, y, width, height, options$1);
			const cmdContours = [];
			for (const cmd of cmds) {
				if (cmd[0] === "M") cmdContours.push([]);
				cmdContours[cmdContours.length - 1].push(cmd);
			}
			return cmdContours.map((commands) => pathToPoints(commands, options$1, this));
		}
		textToModel(str, x$1, y, width, height, options$1) {
			({width, height, options: options$1} = this._parseArgs(width, height, options$1));
			const extrude = options$1?.extrude || 0;
			const contours = this.textToContours(str, x$1, y, width, height, options$1);
			const geom = this._pInst.buildGeometry(() => {
				if (extrude === 0) {
					const prevValidateFaces = this._pInst._renderer._validateFaces;
					this._pInst._renderer._validateFaces = true;
					this._pInst.beginShape();
					this._pInst.normal(0, 0, 1);
					for (const contour of contours) {
						this._pInst.beginContour();
						for (const { x: x$2, y: y$1 } of contour) this._pInst.vertex(x$2, y$1);
						this._pInst.endContour(this._pInst.CLOSE);
					}
					this._pInst.endShape();
					this._pInst._renderer._validateFaces = prevValidateFaces;
				} else {
					const prevValidateFaces = this._pInst._renderer._validateFaces;
					this._pInst._renderer._validateFaces = true;
					for (const side of [1, -1]) {
						this._pInst.beginShape();
						for (const contour of contours) {
							this._pInst.beginContour();
							for (const { x: x$2, y: y$1 } of contour) this._pInst.vertex(x$2, y$1, side * extrude * .5);
							this._pInst.endContour(this._pInst.CLOSE);
						}
						this._pInst.endShape();
					}
					this._pInst._renderer._validateFaces = prevValidateFaces;
					for (const contour of contours) {
						this._pInst.beginShape(this._pInst.QUAD_STRIP);
						for (const v$1 of contour) for (const side of [-1, 1]) this._pInst.vertex(v$1.x, v$1.y, side * extrude * .5);
						this._pInst.endShape();
					}
				}
			});
			if (extrude !== 0) {
				geom.computeNormals();
				for (const face of geom.faces) if (face.every((idx) => geom.vertices[idx].z <= -extrude * .5 + .1)) {
					for (const idx of face) geom.vertexNormals[idx].set(0, 0, -1);
					face.reverse();
				}
			}
			return geom;
		}
		variations() {
			let vars = {};
			if (this.data) {
				let axes = this.face?.axes;
				if (axes) axes.forEach((ax) => {
					vars[ax.tag] = ax.value;
				});
			}
			fontFaceVariations.forEach((v$1) => {
				let val$1 = this.face[v$1];
				if (val$1 !== "normal") vars[v$1] = vars[v$1] || val$1;
			});
			return vars;
		}
		metadata() {
			let meta = this.data?.name || {};
			for (let p$1 in this.face) if (!/^load/.test(p$1)) meta[p$1] = meta[p$1] || this.face[p$1];
			return meta;
		}
		static async list(log = false) {
			if (log) {
				console.log("There are", document.fonts.size, "font-faces\n");
				let loaded = 0;
				for (let fontFace of document.fonts.values()) {
					console.log("FontFace: {");
					for (let property in fontFace) console.log("  " + property + ": " + fontFace[property]);
					console.log("}\n");
					if (fontFace.status === "loaded") loaded++;
				}
				console.log(loaded + " loaded");
			}
			return await Array.from(document.fonts);
		}
		_verticalAlign(size) {
			const { sCapHeight } = this.data?.["OS/2"] || {};
			const { unitsPerEm = 1e3 } = this.data?.head || {};
			const { ascender = 0, descender = 0 } = this.data?.hhea || {};
			const current = ascender / 2;
			return ((sCapHeight || ascender + descender) / 2 - current) * size / unitsPerEm;
		}
		_lineateAndPathify(str, x$1, y, width, height, options$1 = {}) {
			let renderer$1 = options$1?.graphics?._renderer || this._pInst._renderer;
			let setBaseline = renderer$1.drawingContext.textBaseline;
			let { lines, bounds } = renderer$1._computeBounds(textCoreConstants._FONT_BOUNDS, str, x$1, y, width, height, {
				ignoreRectMode: true,
				...options$1
			});
			lines = this._position(renderer$1, lines, bounds, width, height);
			let uPE = this.data?.head?.unitsPerEm || 1e3;
			let scale = renderer$1.states.textSize / uPE;
			const axs = this._currentAxes(renderer$1);
			let pathsForLine = lines.map((l) => this._lineToGlyphs(l, {
				scale,
				axs
			}));
			renderer$1.drawingContext.textBaseline = setBaseline;
			return pathsForLine;
		}
		_currentAxes(renderer$1) {
			let axs;
			if ((this.data?.fvar?.length ?? 0) > 0) axs = this.data.fvar[0].map(([tag, minVal, defaultVal, maxVal, flags, name]) => {
				if (!renderer$1) return defaultVal;
				if (tag === "wght") return renderer$1.states.fontWeight;
				else if (tag === "wdth") return 100;
				else if (renderer$1.textCanvas().style.fontVariationSettings) {
					const match = (/* @__PURE__ */ new RegExp(`\\b${tag}\s+(\d+)`)).exec(renderer$1.textCanvas().style.fontVariationSettings);
					if (match) return parseInt(match[1]);
					else return defaultVal;
				} else return defaultVal;
			});
			return axs;
		}
		_textToPathPoints(str, x$1, y, width, height, options$1) {
			({width, height, options: options$1} = this._parseArgs(width, height, options$1));
			let cmds = this.textToPaths(str, x$1, y, width, height, options$1);
			const subdivide = (pts$1, pt1, pt2, md) => {
				if (fn.dist(pt1.x, pt1.y, pt2.x, pt2.y) > md) {
					let middle = {
						x: (pt1.x + pt2.x) / 2,
						y: (pt1.y + pt2.y) / 2
					};
					pts$1.push(middle);
					subdivide(pts$1, pt1, middle, md);
					subdivide(pts$1, middle, pt2, md);
				}
			};
			let pts = [];
			let { textSize } = this._pInst._renderer.states;
			let maxDist = textSize / this.data.head.unitsPerEm * 500;
			for (let i$1 = 0; i$1 < cmds.length; i$1++) {
				let { type: type$2, data: d$1 } = cmds[i$1];
				if (type$2 !== "Z") {
					let pt = {
						x: d$1[d$1.length - 2],
						y: d$1[d$1.length - 1]
					};
					if (type$2 === "L" && pts.length && !options$1?.nodivide > 0) subdivide(pts, pts[pts.length - 1], pt, maxDist);
					pts.push(pt);
				}
			}
			return pts;
		}
		_parseArgs(width, height, options$1 = {}) {
			if (typeof width === "object") {
				options$1 = width;
				width = height = void 0;
			} else if (typeof height === "object") {
				options$1 = height;
				height = void 0;
			}
			return {
				width,
				height,
				options: options$1
			};
		}
		_position(renderer$1, lines, bounds, width, height) {
			let { textAlign, textLeading } = renderer$1.states;
			let ascent = this._measureTextDefault(renderer$1, "X").fontBoundingBoxAscent;
			let coordify = (text$1, i$1) => {
				let x$1 = bounds.x;
				let y = bounds.y + i$1 * textLeading + ascent;
				let lineWidth = renderer$1._fontWidthSingle(text$1);
				if (textAlign === CENTER) x$1 += (bounds.w - lineWidth) / 2;
				else if (textAlign === RIGHT) x$1 += bounds.w - lineWidth;
				if (typeof width !== "undefined") switch (renderer$1.states.rectMode) {
					case CENTER:
						x$1 -= width / 2;
						y -= height / 2;
						break;
					case RADIUS:
						x$1 -= width;
						y -= height;
						break;
				}
				return {
					text: text$1,
					x: x$1,
					y
				};
			};
			return lines.map(coordify);
		}
		_lineToGlyphs(line, { scale = 1, axs } = {}) {
			if (!this.data) throw Error("No font data available for \"" + this.name + "\"\nTry downloading a local copy of the font file");
			let glyphShapes = Typr.U.shape(this.data, line.text, { axs });
			line.glyphShapes = glyphShapes;
			line.glyphs = this._shapeToPaths(glyphShapes, line, {
				scale,
				axs
			});
			return line;
		}
		_positionGlyphs(text$1, options$1) {
			let renderer$1 = options$1?.graphics?._renderer || this._pInst._renderer;
			const axs = this._currentAxes(renderer$1);
			const glyphShapes = Typr.U.shape(this.data, text$1, { axs });
			const positionedGlyphs = [];
			let x$1 = 0;
			for (const glyph of glyphShapes) {
				positionedGlyphs.push({
					x: x$1,
					index: glyph.g,
					shape: glyph
				});
				x$1 += glyph.ax;
			}
			return positionedGlyphs;
		}
		_singleShapeToPath(shape$1, { scale = 1, x: x$1 = 0, y = 0, lineX = 0, lineY = 0, axs } = {}) {
			let font$1 = this.data;
			let crdIdx = 0;
			let { g: g$1, ax, ay, dx, dy } = shape$1;
			let { crds, cmds } = Typr.U.glyphToPath(font$1, g$1, true, axs);
			let glyph = { path: { commands: [] } };
			for (let j = 0; j < cmds.length; j++) {
				let type$2 = cmds[j], command = [type$2];
				if (type$2 in pathArgCounts) {
					let argCount = pathArgCounts[type$2];
					for (let k = 0; k < argCount; k += 2) {
						let gx = crds[k + crdIdx] + x$1 + dx;
						let gy = crds[k + crdIdx + 1] + y + dy;
						let fx = lineX + gx * scale;
						let fy = lineY + gy * -scale;
						command.push(fx);
						command.push(fy);
					}
					crdIdx += argCount;
				}
				glyph.path.commands.push(command);
			}
			return {
				glyph,
				ax,
				ay
			};
		}
		_shapeToPaths(glyphs, line, { scale = 1, axs } = {}) {
			let x$1 = 0, y = 0, paths = [];
			if (glyphs.length !== line.text.length) throw Error("Invalid shape data");
			for (let i$1 = 0; i$1 < glyphs.length; i$1++) {
				const { glyph, ax, ay } = this._singleShapeToPath(glyphs[i$1], {
					scale,
					x: x$1,
					y,
					lineX: line.x,
					lineY: line.y,
					axs
				});
				paths.push(glyph);
				x$1 += ax;
				y += ay;
			}
			return paths;
		}
		_measureTextDefault(renderer$1, str) {
			let { textAlign, textBaseline } = renderer$1.states;
			let ctx = renderer$1.textDrawingContext();
			ctx.textAlign = "left";
			ctx.textBaseline = "alphabetic";
			let metrics = ctx.measureText(str);
			ctx.textAlign = textAlign;
			ctx.textBaseline = textBaseline;
			return metrics;
		}
		drawPaths(ctx, commands, opts) {
			ctx.strokeStyle = opts?.stroke || ctx.strokeStyle;
			ctx.fillStyle = opts?.fill || ctx.fillStyle;
			ctx.beginPath();
			commands.forEach(([type$2, ...data$2]) => {
				if (type$2 === "M") ctx.moveTo(...data$2);
				else if (type$2 === "L") ctx.lineTo(...data$2);
				else if (type$2 === "C") ctx.bezierCurveTo(...data$2);
				else if (type$2 === "Q") ctx.quadraticCurveTo(...data$2);
				else if (type$2 === "Z") ctx.closePath();
			});
			if (opts?.fill) ctx.fill();
			if (opts?.stroke) ctx.stroke();
		}
		_pathsToCommands(paths, scale) {
			let commands = [];
			for (let i$1 = 0; i$1 < paths.length; i$1++) {
				let { x: x$1, y, path: path$1 } = paths[i$1];
				let { crds, cmds } = path$1;
				for (let c = 0, j = 0; j < cmds.length; j++) {
					let cmd = cmds[j], obj = {
						type: cmd,
						data: []
					};
					if (cmd == "M" || cmd == "L") {
						obj.data.push(x$1 + crds[c] * scale, y + crds[c + 1] * -scale);
						c += 2;
					} else if (cmd == "C") {
						for (let i$2 = 0; i$2 < 6; i$2 += 2) obj.data.push(x$1 + crds[c + i$2] * scale, y + crds[c + i$2 + 1] * -scale);
						c += 6;
					} else if (cmd == "Q") {
						for (let i$2 = 0; i$2 < 4; i$2 += 2) obj.data.push(x$1 + crds[c + i$2] * scale, y + crds[c + i$2 + 1] * -scale);
						c += 4;
					}
					commands.push(obj);
				}
			}
			return commands;
		}
	};
	async function create(pInst, name, path$1, descriptors, rawFont) {
		let face = createFontFace(name, path$1, descriptors, rawFont);
		if (face.status !== "loaded") await face.load();
		document.fonts.add(face);
		await document.fonts.ready;
		return new Font(pInst, face, name, path$1, rawFont);
	}
	function createFontFace(name, path$1, descriptors, rawFont) {
		if (name.includes(" ")) name = "'" + name + "'";
		let fontArg = rawFont?._compressedData ?? rawFont?._data;
		if (!fontArg) {
			if (!validFontTypesRe.test(path$1)) throw Error(invalidFontError);
			if (!path$1.startsWith("url(")) path$1 = "url(" + path$1 + ")";
			fontArg = path$1;
		}
		if ((rawFont?.fvar?.length ?? 0) > 0) {
			descriptors = descriptors || {};
			for (const [tag, minVal, defaultVal, maxVal, flags, name$1] of rawFont.fvar[0]) if (tag === "wght") descriptors.weight = `${minVal} ${maxVal}`;
			else if (tag === "wdth") descriptors.stretch = `${minVal}% ${maxVal}%`;
		}
		let face = new FontFace(name, fontArg, descriptors);
		if (face.status === "error") throw Error("Failed to create FontFace for \"" + name + "\"");
		return face;
	}
	function extractFontName(font$1, path$1) {
		let result, meta = font$1?.name;
		if (meta) {
			if (meta.fullName) return meta.fullName;
			if (meta.familyName) result = meta.familyName;
		}
		if (!result) {
			let matches = extractFontNameRe.exec(path$1);
			if (matches && matches.length >= 3) result = matches[1];
			else result = path$1;
		}
		if (result.includes(" ")) result = result.replace(/ /g, "_");
		return result;
	}
	function pathToPoints(cmds, options$1, font$1) {
		const parseOpts = (options$2, defaults$1) => {
			if (typeof options$2 !== "object") options$2 = defaults$1;
			else for (const key in defaults$1) if (typeof options$2[key] === "undefined") options$2[key] = defaults$1[key];
			return options$2;
		};
		const at = (v$1, i$1) => {
			const s = v$1.length;
			return v$1[i$1 < 0 ? i$1 % s + s : i$1 % s];
		};
		const simplify = (pts, angle) => {
			angle = angle || 0;
			let num = 0;
			for (let i$1 = pts.length - 1; pts.length > 3 && i$1 >= 0; --i$1) if (collinear(at(pts, i$1 - 1), at(pts, i$1), at(pts, i$1 + 1), angle)) {
				pts.splice(i$1 % pts.length, 1);
				num++;
			}
			return num;
		};
		const path$1 = (0, import_bezier_path.createFromCommands)(arrayCommandsToObjects(cmds));
		let opts = parseOpts(options$1, {
			sampleFactor: .1,
			simplifyThreshold: 0
		});
		const totalPoints = Math.max(1, Math.ceil(path$1.getTotalLength() * opts.sampleFactor));
		let points = [];
		const mode = font$1._pInst.angleMode();
		const DEGREES = font$1._pInst.DEGREES;
		for (let i$1 = 0; i$1 < totalPoints; i$1++) {
			const length = path$1.getTotalLength() * (totalPoints === 1 ? 0 : i$1 / (totalPoints - 1));
			points.push({
				...path$1.getPointAtLength(length),
				get angle() {
					const angle = path$1.getAngleAtLength(length);
					if (mode === DEGREES) return angle * 180 / Math.PI;
					else return angle;
				},
				get alpha() {
					return this.angle;
				}
			});
		}
		if (opts.simplifyThreshold) simplify(points, opts.simplifyThreshold);
		return points;
	}
	function unquote(name) {
		if ((name.startsWith("\"") || name.startsWith("'")) && name.at(0) === name.at(-1)) return name.slice(1, -1).replace(/\/(['"])/g, "$1");
		return name;
	}
	function parseCreateArgs(...args) {
		let path$1 = args.shift();
		if (typeof path$1 !== "string" || path$1.length === 0) p5._friendlyError(invalidFontError, "p5.loadFont");
		let name;
		if (typeof args[0] === "string") name = args.shift();
		let success, error$1, options$1;
		for (let i$1 = 0; i$1 < args.length; i$1++) {
			const arg = args[i$1];
			if (typeof arg === "function") if (!success) success = arg;
			else error$1 = arg;
			else if (typeof arg === "object") options$1 = arg;
		}
		return {
			path: path$1,
			name,
			success,
			error: error$1,
			options: options$1
		};
	}
	function font(p5$2, fn$1) {
		p5$2.Font = Font;
		fn$1.parseFontData = async function(pathOrData) {
			let result = pathOrData instanceof Uint8Array ? pathOrData : await fn$1.loadBytes(pathOrData);
			if (!result) throw Error("Failed to load font data");
			let fonts = Typr.parse(result);
			if (fonts.length === 0 || fonts[0].cmap === void 0) throw Error("parsing font data");
			return fonts[0];
		};
		fn$1.loadFont = async function(...args) {
			let { path: path$1, name, success, error: error$1, options: { sets: sets$1,...descriptors } = {} } = parseCreateArgs(...args);
			let isCSS = path$1.includes("@font-face");
			if (!isCSS) {
				if ((await fetch(path$1, { method: "HEAD" })).headers.get("content-type")?.startsWith("text/css")) {
					isCSS = true;
					path$1 = await fetch(path$1).then((res) => res.text());
				}
			}
			if (isCSS) {
				const stylesheet = new CSSStyleSheet();
				await stylesheet.replace(path$1);
				const possibleFonts = [];
				for (const rule of stylesheet.cssRules) if (rule instanceof CSSFontFaceRule) {
					const style = rule.style;
					let name$1 = unquote(style.getPropertyValue("font-family"));
					const src = style.getPropertyValue("src");
					const fontDescriptors = { ...descriptors || {} };
					for (const key of style) {
						if (key === "font-family" || key === "src") continue;
						const camelCaseKey = key.replace(/^font-/, "").split("-").map((v$1, i$1) => i$1 === 0 ? v$1 : `${v$1[0].toUpperCase()}${v$1.slice(1)}`).join("");
						fontDescriptors[camelCaseKey] = style.getPropertyValue(key);
					}
					possibleFonts.push({
						name: name$1,
						src,
						fontDescriptors,
						loadWithData: async () => {
							let fontData;
							try {
								const urlMatch = /url\(([^\)]+)\)/.exec(src);
								if (urlMatch) {
									let url = urlMatch[1];
									if (/^['"]/.exec(url) && url.at(0) === url.at(-1)) url = url.slice(1, -1);
									fontData = await fn$1.parseFontData(url);
								}
							} catch (_e) {}
							return create(this, name$1, src, fontDescriptors, fontData);
						},
						loadWithoutData: () => create(this, name$1, src, fontDescriptors)
					});
				}
				sets$1 = sets$1 || ["latin"];
				const requestedGroups = (sets$1 instanceof Array ? sets$1 : [sets$1]).map((s) => s.toLowerCase());
				const requestedCategories = unicodeRanges.filter((r) => requestedGroups.some((g$1) => r.category.includes(g$1) && r.category.includes("ext") === g$1.includes("ext")));
				const requestedRanges = new Set(import_lib.UnicodeRange.parse(requestedCategories.map((c) => `U+${c.hexrange[0]}-${c.hexrange[1]}`)));
				let closestRangeOverlap = 0;
				let closestDescriptorOverlap = 0;
				let closestMatch = void 0;
				for (const font$1 of possibleFonts) {
					if (!font$1.fontDescriptors.unicodeRange) continue;
					const rangeOverlap = [...new Set(import_lib.UnicodeRange.parse(font$1.fontDescriptors.unicodeRange.split(/,\s*/g))).values()].filter((v$1) => requestedRanges.has(v$1)).length;
					const targetDescriptors = {
						style: "normal",
						weight: 400,
						...descriptors
					};
					const descriptorOverlap = Object.keys(font$1.fontDescriptors).filter((k) => font$1.fontDescriptors[k] === targetDescriptors[k]).length;
					if (descriptorOverlap > closestDescriptorOverlap || descriptorOverlap === closestDescriptorOverlap && rangeOverlap >= closestRangeOverlap) {
						closestDescriptorOverlap = descriptorOverlap;
						closestRangeOverlap = rangeOverlap;
						closestMatch = font$1;
					}
				}
				const picked = closestMatch || possibleFonts.at(-1);
				for (const font$1 of possibleFonts) if (font$1 !== picked) font$1.loadWithoutData();
				return picked?.loadWithData();
			}
			let pfont;
			try {
				const fontData = await fn$1.parseFontData(path$1);
				name = name || extractFontName(fontData, path$1);
				pfont = await create(this, name, path$1, descriptors, fontData);
			} catch (err$1) {
				let ident = name || path$1.substring(path$1.lastIndexOf("/") + 1).replace(/\.[^/.]+$/, "");
				console.warn(`WARN: No glyph data for '${ident}', retrying as FontFace`);
				try {
					pfont = await create(this, ident, path$1, descriptors);
				} catch (err$2) {
					if (error$1) return error$1(err$2);
					throw err$2;
				}
			}
			if (success) return success(pfont);
			return pfont;
		};
	}
	const arrayCommandsToObjects = (commands) => commands.map((command) => {
		const type$2 = command[0];
		switch (type$2) {
			case "Z": return { type: type$2 };
			case "M":
			case "L": {
				const [, x$1, y] = command;
				return {
					type: type$2,
					x: x$1,
					y
				};
			}
			case "Q": {
				const [, x1, y1, x$1, y] = command;
				return {
					type: type$2,
					x1,
					y1,
					x: x$1,
					y
				};
			}
			case "C": {
				const [, x1, y1, x2, y2, x$1, y] = command;
				return {
					type: type$2,
					x1,
					y1,
					x2,
					y2,
					x: x$1,
					y
				};
			}
			default: throw new Error(`Unexpected path command: ${type$2}`);
		}
	});
	if (typeof p5 !== "undefined") font(p5, p5.prototype);
	function text(p5$2, fn$1) {
		RendererGL.prototype.maxCachedGlyphs = function() {
			return 200;
		};
		Font.prototype._getFontInfo = function(axs) {
			this._fontInfos = this._fontInfos || {};
			const key = JSON.stringify(axs);
			if (this._fontInfos[key]) return this._fontInfos[key];
			else {
				const val$1 = new FontInfo(this, { axs });
				this._fontInfos[key] = val$1;
				return val$1;
			}
		};
		const charGridWidth = 9;
		const charGridHeight = charGridWidth;
		const strokeImageWidth = 64;
		const strokeImageHeight = 64;
		const gridImageWidth = 64;
		const gridImageHeight = 64;
		const cellImageWidth = 64;
		const cellImageHeight = 64;
		class ImageInfos {
			constructor(width, height) {
				this.width = width;
				this.height = height;
				this.infos = [];
			}
			findImage(space) {
				const imageSize = this.width * this.height;
				if (space > imageSize) throw new Error("font is too complex to render in 3D");
				let imageInfo, imageData;
				for (let ii = this.infos.length - 1; ii >= 0; --ii) {
					const imageInfoTest = this.infos[ii];
					if (imageInfoTest.index + space < imageSize) {
						imageInfo = imageInfoTest;
						imageData = imageInfoTest.imageData;
						break;
					}
				}
				if (!imageInfo) {
					try {
						imageData = new ImageData(this.width, this.height);
					} catch (err$1) {
						let canvas$1 = document.getElementsByTagName("canvas")[0];
						const created = !canvas$1;
						if (!canvas$1) {
							canvas$1 = document.createElement("canvas");
							canvas$1.style.display = "none";
							document.body.appendChild(canvas$1);
						}
						const ctx = canvas$1.getContext("2d");
						if (ctx) imageData = ctx.createImageData(this.width, this.height);
						if (created) document.body.removeChild(canvas$1);
					}
					imageInfo = {
						index: 0,
						imageData
					};
					this.infos.push(imageInfo);
				}
				const index = imageInfo.index;
				imageInfo.index += space;
				imageData._dirty = true;
				return {
					imageData,
					index
				};
			}
		}
		function setPixel(imageInfo, r, g$1, b$1, a) {
			const pixels$1 = imageInfo.imageData.data;
			let index = imageInfo.index++ * 4;
			pixels$1[index++] = r;
			pixels$1[index++] = g$1;
			pixels$1[index++] = b$1;
			pixels$1[index++] = a;
		}
		const SQRT3 = Math.sqrt(3);
		class FontInfo {
			constructor(font$1, { axs } = {}) {
				this.font = font$1;
				this.axs = axs;
				this.strokeImageInfos = new ImageInfos(strokeImageWidth, strokeImageHeight);
				this.colDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);
				this.rowDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);
				this.colCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);
				this.rowCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);
				this.glyphInfos = {};
			}
			getGlyphInfo(glyph) {
				let gi = this.glyphInfos[glyph.index];
				if (gi) return gi;
				const axs = this.axs;
				const { glyph: { path: { commands } } } = this.font._singleShapeToPath(glyph.shape, { axs });
				let xMin = Infinity;
				let xMax = -Infinity;
				let yMin = Infinity;
				let yMax = -Infinity;
				for (const cmd of commands) for (let i$2 = 1; i$2 < cmd.length; i$2 += 2) {
					xMin = Math.min(xMin, cmd[i$2]);
					xMax = Math.max(xMax, cmd[i$2]);
					yMin = Math.min(yMin, cmd[i$2 + 1]);
					yMax = Math.max(yMax, cmd[i$2 + 1]);
				}
				if (xMin >= xMax || yMin >= yMax || !commands.length) return this.glyphInfos[glyph.index] = {};
				const gWidth = xMax - xMin;
				const gHeight = yMax - yMin;
				const cmds = arrayCommandsToObjects(commands);
				let i$1;
				const strokes = [];
				const rows = [];
				const cols = [];
				for (i$1 = charGridWidth - 1; i$1 >= 0; --i$1) cols.push([]);
				for (i$1 = charGridHeight - 1; i$1 >= 0; --i$1) rows.push([]);
				function push(xs$1, ys$1, v$1) {
					const index = strokes.length;
					strokes.push(v$1);
					function minMax(rg, min, max) {
						for (let i$2 = rg.length; i$2-- > 0;) {
							const v$2 = rg[i$2];
							if (min > v$2) min = v$2;
							if (max < v$2) max = v$2;
						}
						return {
							min,
							max
						};
					}
					const cellOffset = .5;
					const mmX = minMax(xs$1, 1, 0);
					const ixMin = Math.max(Math.floor(mmX.min * charGridWidth - cellOffset), 0);
					const ixMax = Math.min(Math.ceil(mmX.max * charGridWidth + cellOffset), charGridWidth);
					for (let iCol = ixMin; iCol < ixMax; ++iCol) cols[iCol].push(index);
					const mmY = minMax(ys$1, 1, 0);
					const iyMin = Math.max(Math.floor(mmY.min * charGridHeight - cellOffset), 0);
					const iyMax = Math.min(Math.ceil(mmY.max * charGridHeight + cellOffset), charGridHeight);
					for (let iRow = iyMin; iRow < iyMax; ++iRow) rows[iRow].push(index);
				}
				function clamp$2(v$1, min, max) {
					if (v$1 < min) return min;
					if (v$1 > max) return max;
					return v$1;
				}
				function byte(v$1) {
					return clamp$2(255 * v$1, 0, 255);
				}
				class Cubic {
					constructor(p0, c0, c1$2, p1) {
						this.p0 = p0;
						this.c0 = c0;
						this.c1 = c1$2;
						this.p1 = p1;
					}
					toQuadratic() {
						return {
							x: this.p0.x,
							y: this.p0.y,
							x1: this.p1.x,
							y1: this.p1.y,
							cx: ((this.c0.x + this.c1.x) * 3 - (this.p0.x + this.p1.x)) / 4,
							cy: ((this.c0.y + this.c1.y) * 3 - (this.p0.y + this.p1.y)) / 4
						};
					}
					quadError() {
						return Vector.sub(Vector.sub(this.p1, this.p0), Vector.mult(Vector.sub(this.c1, this.c0), 3)).mag() / 2;
					}
					split(t$1) {
						const m1$2 = Vector.lerp(this.p0, this.c0, t$1);
						const m2$1 = Vector.lerp(this.c0, this.c1, t$1);
						const mm1 = Vector.lerp(m1$2, m2$1, t$1);
						this.c1 = Vector.lerp(this.c1, this.p1, t$1);
						this.c0 = Vector.lerp(m2$1, this.c1, t$1);
						const pt = Vector.lerp(mm1, this.c0, t$1);
						const part1 = new Cubic(this.p0, m1$2, mm1, pt);
						this.p0 = pt;
						return part1;
					}
					splitInflections() {
						const a = Vector.sub(this.c0, this.p0);
						const b$1 = Vector.sub(Vector.sub(this.c1, this.c0), a);
						const c = Vector.sub(Vector.sub(Vector.sub(this.p1, this.c1), a), Vector.mult(b$1, 2));
						const cubics = [];
						let A$1 = b$1.x * c.y - b$1.y * c.x;
						if (A$1 !== 0) {
							let B$1 = a.x * c.y - a.y * c.x;
							let C$1 = a.x * b$1.y - a.y * b$1.x;
							const disc = B$1 * B$1 - 4 * A$1 * C$1;
							if (disc >= 0) {
								if (A$1 < 0) {
									A$1 = -A$1;
									B$1 = -B$1;
									C$1 = -C$1;
								}
								const Q$1 = Math.sqrt(disc);
								const t0 = (-B$1 - Q$1) / (2 * A$1);
								let t1 = (-B$1 + Q$1) / (2 * A$1);
								if (t0 > 0 && t0 < 1) {
									cubics.push(this.split(t0));
									t1 = 1 - (1 - t1) / (1 - t0);
								}
								if (t1 > 0 && t1 < 1) cubics.push(this.split(t1));
							}
						}
						cubics.push(this);
						return cubics;
					}
				}
				function cubicToQuadratics(x0$1, y0$1, cx0, cy0, cx1, cy1, x1, y1) {
					const cubics = new Cubic(new Vector(x0$1, y0$1), new Vector(cx0, cy0), new Vector(cx1, cy1), new Vector(x1, y1)).splitInflections();
					const qs = [];
					const precision = 30 / SQRT3;
					for (let cubic of cubics) {
						const tail = [];
						let t3;
						for (;;) {
							t3 = precision / cubic.quadError();
							if (t3 >= .5 * .5 * .5) break;
							const t$1 = Math.pow(t3, 1 / 3);
							const start = cubic.split(t$1);
							const middle = cubic.split(1 - t$1 / (1 - t$1));
							qs.push(start);
							tail.push(cubic);
							cubic = middle;
						}
						if (t3 < 1) qs.push(cubic.split(.5));
						qs.push(cubic);
						Array.prototype.push.apply(qs, tail.reverse());
					}
					return qs;
				}
				function pushLine(x0$1, y0$1, x1, y1) {
					const mx = (x0$1 + x1) / 2;
					const my = (y0$1 + y1) / 2;
					push([x0$1, x1], [y0$1, y1], {
						x: x0$1,
						y: y0$1,
						cx: mx,
						cy: my
					});
				}
				function samePoint(x0$1, y0$1, x1, y1) {
					return Math.abs(x1 - x0$1) < 1e-5 && Math.abs(y1 - y0$1) < 1e-5;
				}
				let x0, y0, xs, ys;
				for (const cmd of cmds) {
					const x1 = (cmd.x - xMin) / gWidth;
					const y1 = (cmd.y - yMin) / gHeight;
					if (samePoint(x0, y0, x1, y1)) continue;
					switch (cmd.type) {
						case "M":
							xs = x1;
							ys = y1;
							break;
						case "L":
							pushLine(x0, y0, x1, y1);
							break;
						case "Q": {
							const cx = (cmd.x1 - xMin) / gWidth;
							const cy = (cmd.y1 - yMin) / gHeight;
							push([
								x0,
								x1,
								cx
							], [
								y0,
								y1,
								cy
							], {
								x: x0,
								y: y0,
								cx,
								cy
							});
							break;
						}
						case "Z":
							if (!samePoint(x0, y0, xs, ys)) {
								pushLine(x0, y0, xs, ys);
								strokes.push({
									x: xs,
									y: ys
								});
							} else strokes.push({
								x: x0,
								y: y0
							});
							break;
						case "C": {
							const cx1 = (cmd.x1 - xMin) / gWidth;
							const cy1 = (cmd.y1 - yMin) / gHeight;
							const cx2 = (cmd.x2 - xMin) / gWidth;
							const cy2 = (cmd.y2 - yMin) / gHeight;
							const qs = cubicToQuadratics(x0, y0, cx1, cy1, cx2, cy2, x1, y1);
							for (let iq = 0; iq < qs.length; iq++) {
								const q = qs[iq].toQuadratic();
								push([
									q.x,
									q.x1,
									q.cx
								], [
									q.y,
									q.y1,
									q.cy
								], q);
							}
							break;
						}
						default: throw new Error(`unknown command type: ${cmd.type}`);
					}
					x0 = x1;
					y0 = y1;
				}
				const strokeCount = strokes.length;
				const strokeImageInfo = this.strokeImageInfos.findImage(strokeCount);
				const strokeOffset = strokeImageInfo.index;
				for (let il = 0; il < strokeCount; ++il) {
					const s = strokes[il];
					setPixel(strokeImageInfo, byte(s.x), byte(s.y), byte(s.cx), byte(s.cy));
				}
				function layout(dim, dimImageInfos, cellImageInfos) {
					const dimLength = dim.length;
					const dimImageInfo = dimImageInfos.findImage(dimLength);
					const dimOffset = dimImageInfo.index;
					let totalStrokes = 0;
					for (let id = 0; id < dimLength; ++id) totalStrokes += dim[id].length;
					const cellImageInfo = cellImageInfos.findImage(totalStrokes);
					for (let i$2 = 0; i$2 < dimLength; ++i$2) {
						const strokeIndices = dim[i$2];
						const strokeCount$1 = strokeIndices.length;
						const cellLineIndex = cellImageInfo.index;
						setPixel(dimImageInfo, cellLineIndex >> 7, cellLineIndex & 127, strokeCount$1 >> 7, strokeCount$1 & 127);
						for (let iil = 0; iil < strokeCount$1; ++iil) {
							const strokeIndex = strokeIndices[iil] + strokeOffset;
							setPixel(cellImageInfo, strokeIndex >> 7, strokeIndex & 127, 0, 0);
						}
					}
					return {
						cellImageInfo,
						dimOffset,
						dimImageInfo
					};
				}
				gi = this.glyphInfos[glyph.index] = {
					glyph,
					uGlyphRect: [
						xMin,
						yMin,
						xMax,
						yMax
					],
					strokeImageInfo,
					strokes,
					colInfo: layout(cols, this.colDimImageInfos, this.colCellImageInfos),
					rowInfo: layout(rows, this.rowDimImageInfos, this.rowCellImageInfos)
				};
				gi.uGridOffset = [gi.colInfo.dimOffset, gi.rowInfo.dimOffset];
				return gi;
			}
		}
		RendererGL.prototype._renderText = function(line, x$1, y, maxY, minY) {
			if (!this.states.textFont || typeof this.states.textFont === "string") {
				console.log("WEBGL: you must load and set a font before drawing text. See `loadFont` and `textFont` for more details.");
				return;
			}
			if (y >= maxY || !this.states.fillColor) return;
			if (!p5$2.Font.hasGlyphData(this.states.textFont)) {
				console.log("WEBGL: only Opentype (.otf) and Truetype (.ttf) fonts with glyph data are supported");
				return;
			}
			this.push();
			const doStroke = this.states.strokeColor;
			const drawMode = this.states.drawMode;
			this.states.setValue("strokeColor", null);
			this.states.setValue("drawMode", TEXTURE);
			const { font: font$1 } = this.states.textFont;
			if (!font$1) throw new Error("In WebGL mode, textFont() needs to be given the result of loadFont() instead of a font family name.");
			const axs = font$1._currentAxes(this);
			let fontInfo = font$1._getFontInfo(axs);
			const pos = {
				x: x$1,
				y
			};
			const scale = this.states.textSize / (font$1.data?.head?.unitsPerEm || 1e3);
			this.translate(pos.x, pos.y, 0);
			this.scale(scale, scale, 1);
			const gl = this.GL;
			const initializeShader = !this._defaultFontShader;
			const sh = this._getFontShader();
			sh.init();
			sh.bindShader();
			if (initializeShader) {
				sh.setUniform("uGridImageSize", [gridImageWidth, gridImageHeight]);
				sh.setUniform("uCellsImageSize", [cellImageWidth, cellImageHeight]);
				sh.setUniform("uStrokeImageSize", [strokeImageWidth, strokeImageHeight]);
				sh.setUniform("uGridSize", [charGridWidth, charGridHeight]);
			}
			const curFillColor = this.states.fillSet ? this.states.curFillColor : [
				0,
				0,
				0,
				255
			];
			this._setGlobalUniforms(sh);
			this._applyColorBlend(curFillColor);
			let g$1 = this.geometryBufferCache.getGeometryByID("glyph");
			if (!g$1) {
				g$1 = this._textGeom = new Geometry(1, 1, function() {
					for (let i$1 = 0; i$1 <= 1; i$1++) for (let j = 0; j <= 1; j++) {
						this.vertices.push(new Vector(j, i$1, 0));
						this.uvs.push(j, i$1);
					}
				}, this);
				g$1.gid = "glyph";
				g$1.computeFaces().computeNormals();
				this.geometryBufferCache.ensureCached(g$1);
			}
			for (const buff of this.buffers.text) buff._prepareBuffer(g$1, sh);
			this._bindBuffer(this.geometryBufferCache.cache.glyph.indexBuffer, gl.ELEMENT_ARRAY_BUFFER);
			sh.setUniform("uMaterialColor", curFillColor);
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
			this.glyphDataCache = this.glyphDataCache || /* @__PURE__ */ new Set();
			try {
				const glyphs = font$1._positionGlyphs(line);
				for (const glyph of glyphs) {
					const gi = fontInfo.getGlyphInfo(glyph);
					if (gi.uGlyphRect) {
						const rowInfo = gi.rowInfo;
						const colInfo = gi.colInfo;
						const glyphResources = [
							gi.strokeImageInfo.imageData,
							rowInfo.cellImageInfo.imageData,
							rowInfo.dimImageInfo.imageData,
							colInfo.cellImageInfo.imageData,
							colInfo.dimImageInfo.imageData
						];
						for (const resource of glyphResources) {
							this.glyphDataCache.delete(resource);
							this.glyphDataCache.add(resource);
						}
						while (this.glyphDataCache.size > this.maxCachedGlyphs()) {
							const data$2 = this.glyphDataCache.values().next().value;
							this.glyphDataCache.delete(data$2);
							const tex = this.textures.get(data$2);
							if (tex) {
								tex.remove();
								this.textures.delete(data$2);
							}
						}
						sh.setUniform("uSamplerStrokes", gi.strokeImageInfo.imageData);
						sh.setUniform("uSamplerRowStrokes", rowInfo.cellImageInfo.imageData);
						sh.setUniform("uSamplerRows", rowInfo.dimImageInfo.imageData);
						sh.setUniform("uSamplerColStrokes", colInfo.cellImageInfo.imageData);
						sh.setUniform("uSamplerCols", colInfo.dimImageInfo.imageData);
						sh.setUniform("uGridOffset", gi.uGridOffset);
						sh.setUniform("uGlyphRect", gi.uGlyphRect);
						sh.setUniform("uGlyphOffset", glyph.x);
						sh.bindTextures();
						gl.drawElements(gl.TRIANGLES, 6, this.GL.UNSIGNED_SHORT, 0);
					}
				}
			} finally {
				sh.unbindShader();
				this.states.setValue("strokeColor", doStroke);
				this.states.setValue("drawMode", drawMode);
				gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
				this.pop();
			}
		};
	}
	var require_estraverse = /* @__PURE__ */ __commonJSMin(((exports) => {
		(function clone$2(exports$1) {
			var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE$1;
			function deepCopy(obj) {
				var ret = {}, key, val$1;
				for (key in obj) if (obj.hasOwnProperty(key)) {
					val$1 = obj[key];
					if (typeof val$1 === "object" && val$1 !== null) ret[key] = deepCopy(val$1);
					else ret[key] = val$1;
				}
				return ret;
			}
			function upperBound(array$1, func) {
				var diff, len = array$1.length, i$1 = 0, current;
				while (len) {
					diff = len >>> 1;
					current = i$1 + diff;
					if (func(array$1[current])) len = diff;
					else {
						i$1 = current + 1;
						len -= diff + 1;
					}
				}
				return i$1;
			}
			Syntax = {
				AssignmentExpression: "AssignmentExpression",
				AssignmentPattern: "AssignmentPattern",
				ArrayExpression: "ArrayExpression",
				ArrayPattern: "ArrayPattern",
				ArrowFunctionExpression: "ArrowFunctionExpression",
				AwaitExpression: "AwaitExpression",
				BlockStatement: "BlockStatement",
				BinaryExpression: "BinaryExpression",
				BreakStatement: "BreakStatement",
				CallExpression: "CallExpression",
				CatchClause: "CatchClause",
				ChainExpression: "ChainExpression",
				ClassBody: "ClassBody",
				ClassDeclaration: "ClassDeclaration",
				ClassExpression: "ClassExpression",
				ComprehensionBlock: "ComprehensionBlock",
				ComprehensionExpression: "ComprehensionExpression",
				ConditionalExpression: "ConditionalExpression",
				ContinueStatement: "ContinueStatement",
				DebuggerStatement: "DebuggerStatement",
				DirectiveStatement: "DirectiveStatement",
				DoWhileStatement: "DoWhileStatement",
				EmptyStatement: "EmptyStatement",
				ExportAllDeclaration: "ExportAllDeclaration",
				ExportDefaultDeclaration: "ExportDefaultDeclaration",
				ExportNamedDeclaration: "ExportNamedDeclaration",
				ExportSpecifier: "ExportSpecifier",
				ExpressionStatement: "ExpressionStatement",
				ForStatement: "ForStatement",
				ForInStatement: "ForInStatement",
				ForOfStatement: "ForOfStatement",
				FunctionDeclaration: "FunctionDeclaration",
				FunctionExpression: "FunctionExpression",
				GeneratorExpression: "GeneratorExpression",
				Identifier: "Identifier",
				IfStatement: "IfStatement",
				ImportExpression: "ImportExpression",
				ImportDeclaration: "ImportDeclaration",
				ImportDefaultSpecifier: "ImportDefaultSpecifier",
				ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
				ImportSpecifier: "ImportSpecifier",
				Literal: "Literal",
				LabeledStatement: "LabeledStatement",
				LogicalExpression: "LogicalExpression",
				MemberExpression: "MemberExpression",
				MetaProperty: "MetaProperty",
				MethodDefinition: "MethodDefinition",
				ModuleSpecifier: "ModuleSpecifier",
				NewExpression: "NewExpression",
				ObjectExpression: "ObjectExpression",
				ObjectPattern: "ObjectPattern",
				PrivateIdentifier: "PrivateIdentifier",
				Program: "Program",
				Property: "Property",
				PropertyDefinition: "PropertyDefinition",
				RestElement: "RestElement",
				ReturnStatement: "ReturnStatement",
				SequenceExpression: "SequenceExpression",
				SpreadElement: "SpreadElement",
				Super: "Super",
				SwitchStatement: "SwitchStatement",
				SwitchCase: "SwitchCase",
				TaggedTemplateExpression: "TaggedTemplateExpression",
				TemplateElement: "TemplateElement",
				TemplateLiteral: "TemplateLiteral",
				ThisExpression: "ThisExpression",
				ThrowStatement: "ThrowStatement",
				TryStatement: "TryStatement",
				UnaryExpression: "UnaryExpression",
				UpdateExpression: "UpdateExpression",
				VariableDeclaration: "VariableDeclaration",
				VariableDeclarator: "VariableDeclarator",
				WhileStatement: "WhileStatement",
				WithStatement: "WithStatement",
				YieldExpression: "YieldExpression"
			};
			VisitorKeys = {
				AssignmentExpression: ["left", "right"],
				AssignmentPattern: ["left", "right"],
				ArrayExpression: ["elements"],
				ArrayPattern: ["elements"],
				ArrowFunctionExpression: ["params", "body"],
				AwaitExpression: ["argument"],
				BlockStatement: ["body"],
				BinaryExpression: ["left", "right"],
				BreakStatement: ["label"],
				CallExpression: ["callee", "arguments"],
				CatchClause: ["param", "body"],
				ChainExpression: ["expression"],
				ClassBody: ["body"],
				ClassDeclaration: [
					"id",
					"superClass",
					"body"
				],
				ClassExpression: [
					"id",
					"superClass",
					"body"
				],
				ComprehensionBlock: ["left", "right"],
				ComprehensionExpression: [
					"blocks",
					"filter",
					"body"
				],
				ConditionalExpression: [
					"test",
					"consequent",
					"alternate"
				],
				ContinueStatement: ["label"],
				DebuggerStatement: [],
				DirectiveStatement: [],
				DoWhileStatement: ["body", "test"],
				EmptyStatement: [],
				ExportAllDeclaration: ["source"],
				ExportDefaultDeclaration: ["declaration"],
				ExportNamedDeclaration: [
					"declaration",
					"specifiers",
					"source"
				],
				ExportSpecifier: ["exported", "local"],
				ExpressionStatement: ["expression"],
				ForStatement: [
					"init",
					"test",
					"update",
					"body"
				],
				ForInStatement: [
					"left",
					"right",
					"body"
				],
				ForOfStatement: [
					"left",
					"right",
					"body"
				],
				FunctionDeclaration: [
					"id",
					"params",
					"body"
				],
				FunctionExpression: [
					"id",
					"params",
					"body"
				],
				GeneratorExpression: [
					"blocks",
					"filter",
					"body"
				],
				Identifier: [],
				IfStatement: [
					"test",
					"consequent",
					"alternate"
				],
				ImportExpression: ["source"],
				ImportDeclaration: ["specifiers", "source"],
				ImportDefaultSpecifier: ["local"],
				ImportNamespaceSpecifier: ["local"],
				ImportSpecifier: ["imported", "local"],
				Literal: [],
				LabeledStatement: ["label", "body"],
				LogicalExpression: ["left", "right"],
				MemberExpression: ["object", "property"],
				MetaProperty: ["meta", "property"],
				MethodDefinition: ["key", "value"],
				ModuleSpecifier: [],
				NewExpression: ["callee", "arguments"],
				ObjectExpression: ["properties"],
				ObjectPattern: ["properties"],
				PrivateIdentifier: [],
				Program: ["body"],
				Property: ["key", "value"],
				PropertyDefinition: ["key", "value"],
				RestElement: ["argument"],
				ReturnStatement: ["argument"],
				SequenceExpression: ["expressions"],
				SpreadElement: ["argument"],
				Super: [],
				SwitchStatement: ["discriminant", "cases"],
				SwitchCase: ["test", "consequent"],
				TaggedTemplateExpression: ["tag", "quasi"],
				TemplateElement: [],
				TemplateLiteral: ["quasis", "expressions"],
				ThisExpression: [],
				ThrowStatement: ["argument"],
				TryStatement: [
					"block",
					"handler",
					"finalizer"
				],
				UnaryExpression: ["argument"],
				UpdateExpression: ["argument"],
				VariableDeclaration: ["declarations"],
				VariableDeclarator: ["id", "init"],
				WhileStatement: ["test", "body"],
				WithStatement: ["object", "body"],
				YieldExpression: ["argument"]
			};
			BREAK = {};
			SKIP = {};
			REMOVE$1 = {};
			VisitorOption = {
				Break: BREAK,
				Skip: SKIP,
				Remove: REMOVE$1
			};
			function Reference(parent, key) {
				this.parent = parent;
				this.key = key;
			}
			Reference.prototype.replace = function replace$1(node) {
				this.parent[this.key] = node;
			};
			Reference.prototype.remove = function remove$1() {
				if (Array.isArray(this.parent)) {
					this.parent.splice(this.key, 1);
					return true;
				} else {
					this.replace(null);
					return false;
				}
			};
			function Element$1(node, path$1, wrap, ref$1) {
				this.node = node;
				this.path = path$1;
				this.wrap = wrap;
				this.ref = ref$1;
			}
			function Controller() {}
			Controller.prototype.path = function path$1() {
				var i$1, iz, j, jz, result, element$1;
				function addToPath(result$1, path$2) {
					if (Array.isArray(path$2)) for (j = 0, jz = path$2.length; j < jz; ++j) result$1.push(path$2[j]);
					else result$1.push(path$2);
				}
				if (!this.__current.path) return null;
				result = [];
				for (i$1 = 2, iz = this.__leavelist.length; i$1 < iz; ++i$1) {
					element$1 = this.__leavelist[i$1];
					addToPath(result, element$1.path);
				}
				addToPath(result, this.__current.path);
				return result;
			};
			Controller.prototype.type = function() {
				return this.current().type || this.__current.wrap;
			};
			Controller.prototype.parents = function parents() {
				var i$1, iz, result = [];
				for (i$1 = 1, iz = this.__leavelist.length; i$1 < iz; ++i$1) result.push(this.__leavelist[i$1].node);
				return result;
			};
			Controller.prototype.current = function current() {
				return this.__current.node;
			};
			Controller.prototype.__execute = function __execute(callback, element$1) {
				var previous, result = void 0;
				previous = this.__current;
				this.__current = element$1;
				this.__state = null;
				if (callback) result = callback.call(this, element$1.node, this.__leavelist[this.__leavelist.length - 1].node);
				this.__current = previous;
				return result;
			};
			Controller.prototype.notify = function notify(flag) {
				this.__state = flag;
			};
			Controller.prototype.skip = function() {
				this.notify(SKIP);
			};
			Controller.prototype["break"] = function() {
				this.notify(BREAK);
			};
			Controller.prototype.remove = function() {
				this.notify(REMOVE$1);
			};
			Controller.prototype.__initialize = function(root, visitor) {
				this.visitor = visitor;
				this.root = root;
				this.__worklist = [];
				this.__leavelist = [];
				this.__current = null;
				this.__state = null;
				this.__fallback = null;
				if (visitor.fallback === "iteration") this.__fallback = Object.keys;
				else if (typeof visitor.fallback === "function") this.__fallback = visitor.fallback;
				this.__keys = VisitorKeys;
				if (visitor.keys) this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
			};
			function isNode(node) {
				if (node == null) return false;
				return typeof node === "object" && typeof node.type === "string";
			}
			function isProperty(nodeType, key) {
				return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && "properties" === key;
			}
			function candidateExistsInLeaveList(leavelist, candidate) {
				for (var i$1 = leavelist.length - 1; i$1 >= 0; --i$1) if (leavelist[i$1].node === candidate) return true;
				return false;
			}
			Controller.prototype.traverse = function traverse$1(root, visitor) {
				var worklist, leavelist, element$1, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
				this.__initialize(root, visitor);
				sentinel = {};
				worklist = this.__worklist;
				leavelist = this.__leavelist;
				worklist.push(new Element$1(root, null, null, null));
				leavelist.push(new Element$1(null, null, null, null));
				while (worklist.length) {
					element$1 = worklist.pop();
					if (element$1 === sentinel) {
						element$1 = leavelist.pop();
						ret = this.__execute(visitor.leave, element$1);
						if (this.__state === BREAK || ret === BREAK) return;
						continue;
					}
					if (element$1.node) {
						ret = this.__execute(visitor.enter, element$1);
						if (this.__state === BREAK || ret === BREAK) return;
						worklist.push(sentinel);
						leavelist.push(element$1);
						if (this.__state === SKIP || ret === SKIP) continue;
						node = element$1.node;
						nodeType = node.type || element$1.wrap;
						candidates = this.__keys[nodeType];
						if (!candidates) if (this.__fallback) candidates = this.__fallback(node);
						else throw new Error("Unknown node type " + nodeType + ".");
						current = candidates.length;
						while ((current -= 1) >= 0) {
							key = candidates[current];
							candidate = node[key];
							if (!candidate) continue;
							if (Array.isArray(candidate)) {
								current2 = candidate.length;
								while ((current2 -= 1) >= 0) {
									if (!candidate[current2]) continue;
									if (candidateExistsInLeaveList(leavelist, candidate[current2])) continue;
									if (isProperty(nodeType, candidates[current])) element$1 = new Element$1(candidate[current2], [key, current2], "Property", null);
									else if (isNode(candidate[current2])) element$1 = new Element$1(candidate[current2], [key, current2], null, null);
									else continue;
									worklist.push(element$1);
								}
							} else if (isNode(candidate)) {
								if (candidateExistsInLeaveList(leavelist, candidate)) continue;
								worklist.push(new Element$1(candidate, key, null, null));
							}
						}
					}
				}
			};
			Controller.prototype.replace = function replace$1(root, visitor) {
				var worklist, leavelist, node, nodeType, target, element$1, current, current2, candidates, candidate, sentinel, outer, key;
				function removeElem(element$2) {
					var i$1, key$1, nextElem, parent;
					if (element$2.ref.remove()) {
						key$1 = element$2.ref.key;
						parent = element$2.ref.parent;
						i$1 = worklist.length;
						while (i$1--) {
							nextElem = worklist[i$1];
							if (nextElem.ref && nextElem.ref.parent === parent) {
								if (nextElem.ref.key < key$1) break;
								--nextElem.ref.key;
							}
						}
					}
				}
				this.__initialize(root, visitor);
				sentinel = {};
				worklist = this.__worklist;
				leavelist = this.__leavelist;
				outer = { root };
				element$1 = new Element$1(root, null, null, new Reference(outer, "root"));
				worklist.push(element$1);
				leavelist.push(element$1);
				while (worklist.length) {
					element$1 = worklist.pop();
					if (element$1 === sentinel) {
						element$1 = leavelist.pop();
						target = this.__execute(visitor.leave, element$1);
						if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE$1) element$1.ref.replace(target);
						if (this.__state === REMOVE$1 || target === REMOVE$1) removeElem(element$1);
						if (this.__state === BREAK || target === BREAK) return outer.root;
						continue;
					}
					target = this.__execute(visitor.enter, element$1);
					if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE$1) {
						element$1.ref.replace(target);
						element$1.node = target;
					}
					if (this.__state === REMOVE$1 || target === REMOVE$1) {
						removeElem(element$1);
						element$1.node = null;
					}
					if (this.__state === BREAK || target === BREAK) return outer.root;
					node = element$1.node;
					if (!node) continue;
					worklist.push(sentinel);
					leavelist.push(element$1);
					if (this.__state === SKIP || target === SKIP) continue;
					nodeType = node.type || element$1.wrap;
					candidates = this.__keys[nodeType];
					if (!candidates) if (this.__fallback) candidates = this.__fallback(node);
					else throw new Error("Unknown node type " + nodeType + ".");
					current = candidates.length;
					while ((current -= 1) >= 0) {
						key = candidates[current];
						candidate = node[key];
						if (!candidate) continue;
						if (Array.isArray(candidate)) {
							current2 = candidate.length;
							while ((current2 -= 1) >= 0) {
								if (!candidate[current2]) continue;
								if (isProperty(nodeType, candidates[current])) element$1 = new Element$1(candidate[current2], [key, current2], "Property", new Reference(candidate, current2));
								else if (isNode(candidate[current2])) element$1 = new Element$1(candidate[current2], [key, current2], null, new Reference(candidate, current2));
								else continue;
								worklist.push(element$1);
							}
						} else if (isNode(candidate)) worklist.push(new Element$1(candidate, key, null, new Reference(node, key)));
					}
				}
				return outer.root;
			};
			function traverse(root, visitor) {
				return new Controller().traverse(root, visitor);
			}
			function replace(root, visitor) {
				return new Controller().replace(root, visitor);
			}
			function extendCommentRange(comment, tokens) {
				var target = upperBound(tokens, function search(token) {
					return token.range[0] > comment.range[0];
				});
				comment.extendedRange = [comment.range[0], comment.range[1]];
				if (target !== tokens.length) comment.extendedRange[1] = tokens[target].range[0];
				target -= 1;
				if (target >= 0) comment.extendedRange[0] = tokens[target].range[1];
				return comment;
			}
			function attachComments(tree, providedComments, tokens) {
				var comments = [], comment, len, i$1, cursor;
				if (!tree.range) throw new Error("attachComments needs range information");
				if (!tokens.length) {
					if (providedComments.length) {
						for (i$1 = 0, len = providedComments.length; i$1 < len; i$1 += 1) {
							comment = deepCopy(providedComments[i$1]);
							comment.extendedRange = [0, tree.range[0]];
							comments.push(comment);
						}
						tree.leadingComments = comments;
					}
					return tree;
				}
				for (i$1 = 0, len = providedComments.length; i$1 < len; i$1 += 1) comments.push(extendCommentRange(deepCopy(providedComments[i$1]), tokens));
				cursor = 0;
				traverse(tree, { enter: function(node) {
					var comment$1;
					while (cursor < comments.length) {
						comment$1 = comments[cursor];
						if (comment$1.extendedRange[1] > node.range[0]) break;
						if (comment$1.extendedRange[1] === node.range[0]) {
							if (!node.leadingComments) node.leadingComments = [];
							node.leadingComments.push(comment$1);
							comments.splice(cursor, 1);
						} else cursor += 1;
					}
					if (cursor === comments.length) return VisitorOption.Break;
					if (comments[cursor].extendedRange[0] > node.range[1]) return VisitorOption.Skip;
				} });
				cursor = 0;
				traverse(tree, { leave: function(node) {
					var comment$1;
					while (cursor < comments.length) {
						comment$1 = comments[cursor];
						if (node.range[1] < comment$1.extendedRange[0]) break;
						if (node.range[1] === comment$1.extendedRange[0]) {
							if (!node.trailingComments) node.trailingComments = [];
							node.trailingComments.push(comment$1);
							comments.splice(cursor, 1);
						} else cursor += 1;
					}
					if (cursor === comments.length) return VisitorOption.Break;
					if (comments[cursor].extendedRange[0] > node.range[1]) return VisitorOption.Skip;
				} });
				return tree;
			}
			exports$1.Syntax = Syntax;
			exports$1.traverse = traverse;
			exports$1.replace = replace;
			exports$1.attachComments = attachComments;
			exports$1.VisitorKeys = VisitorKeys;
			exports$1.VisitorOption = VisitorOption;
			exports$1.Controller = Controller;
			exports$1.cloneEnvironment = function() {
				return clone$2({});
			};
			return exports$1;
		})(exports);
	}));
	var require_ast = /* @__PURE__ */ __commonJSMin(((exports, module) => {
		(function() {
			function isExpression(node) {
				if (node == null) return false;
				switch (node.type) {
					case "ArrayExpression":
					case "AssignmentExpression":
					case "BinaryExpression":
					case "CallExpression":
					case "ConditionalExpression":
					case "FunctionExpression":
					case "Identifier":
					case "Literal":
					case "LogicalExpression":
					case "MemberExpression":
					case "NewExpression":
					case "ObjectExpression":
					case "SequenceExpression":
					case "ThisExpression":
					case "UnaryExpression":
					case "UpdateExpression": return true;
				}
				return false;
			}
			function isIterationStatement(node) {
				if (node == null) return false;
				switch (node.type) {
					case "DoWhileStatement":
					case "ForInStatement":
					case "ForStatement":
					case "WhileStatement": return true;
				}
				return false;
			}
			function isStatement(node) {
				if (node == null) return false;
				switch (node.type) {
					case "BlockStatement":
					case "BreakStatement":
					case "ContinueStatement":
					case "DebuggerStatement":
					case "DoWhileStatement":
					case "EmptyStatement":
					case "ExpressionStatement":
					case "ForInStatement":
					case "ForStatement":
					case "IfStatement":
					case "LabeledStatement":
					case "ReturnStatement":
					case "SwitchStatement":
					case "ThrowStatement":
					case "TryStatement":
					case "VariableDeclaration":
					case "WhileStatement":
					case "WithStatement": return true;
				}
				return false;
			}
			function isSourceElement(node) {
				return isStatement(node) || node != null && node.type === "FunctionDeclaration";
			}
			function trailingStatement(node) {
				switch (node.type) {
					case "IfStatement":
						if (node.alternate != null) return node.alternate;
						return node.consequent;
					case "LabeledStatement":
					case "ForStatement":
					case "ForInStatement":
					case "WhileStatement":
					case "WithStatement": return node.body;
				}
				return null;
			}
			function isProblematicIfStatement(node) {
				var current;
				if (node.type !== "IfStatement") return false;
				if (node.alternate == null) return false;
				current = node.consequent;
				do {
					if (current.type === "IfStatement") {
						if (current.alternate == null) return true;
					}
					current = trailingStatement(current);
				} while (current);
				return false;
			}
			module.exports = {
				isExpression,
				isStatement,
				isIterationStatement,
				isSourceElement,
				isProblematicIfStatement,
				trailingStatement
			};
		})();
	}));
	var require_code = /* @__PURE__ */ __commonJSMin(((exports, module) => {
		(function() {
			var ES6Regex, ES5Regex = {
				NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
				NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
			}, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
			ES6Regex = {
				NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
				NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
			};
			function isDecimalDigit$1(ch$1) {
				return 48 <= ch$1 && ch$1 <= 57;
			}
			function isHexDigit$1(ch$1) {
				return 48 <= ch$1 && ch$1 <= 57 || 97 <= ch$1 && ch$1 <= 102 || 65 <= ch$1 && ch$1 <= 70;
			}
			function isOctalDigit$1(ch$1) {
				return ch$1 >= 48 && ch$1 <= 55;
			}
			NON_ASCII_WHITESPACES = [
				5760,
				8192,
				8193,
				8194,
				8195,
				8196,
				8197,
				8198,
				8199,
				8200,
				8201,
				8202,
				8239,
				8287,
				12288,
				65279
			];
			function isWhiteSpace(ch$1) {
				return ch$1 === 32 || ch$1 === 9 || ch$1 === 11 || ch$1 === 12 || ch$1 === 160 || ch$1 >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch$1) >= 0;
			}
			function isLineTerminator(ch$1) {
				return ch$1 === 10 || ch$1 === 13 || ch$1 === 8232 || ch$1 === 8233;
			}
			function fromCodePoint(cp) {
				if (cp <= 65535) return String.fromCharCode(cp);
				return String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296) + String.fromCharCode((cp - 65536) % 1024 + 56320);
			}
			IDENTIFIER_START = new Array(128);
			for (ch = 0; ch < 128; ++ch) IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch === 36 || ch === 95;
			IDENTIFIER_PART = new Array(128);
			for (ch = 0; ch < 128; ++ch) IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch >= 48 && ch <= 57 || ch === 36 || ch === 95;
			function isIdentifierStartES5(ch$1) {
				return ch$1 < 128 ? IDENTIFIER_START[ch$1] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch$1));
			}
			function isIdentifierPartES5(ch$1) {
				return ch$1 < 128 ? IDENTIFIER_PART[ch$1] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch$1));
			}
			function isIdentifierStartES6(ch$1) {
				return ch$1 < 128 ? IDENTIFIER_START[ch$1] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch$1));
			}
			function isIdentifierPartES6(ch$1) {
				return ch$1 < 128 ? IDENTIFIER_PART[ch$1] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch$1));
			}
			module.exports = {
				isDecimalDigit: isDecimalDigit$1,
				isHexDigit: isHexDigit$1,
				isOctalDigit: isOctalDigit$1,
				isWhiteSpace,
				isLineTerminator,
				isIdentifierStartES5,
				isIdentifierPartES5,
				isIdentifierStartES6,
				isIdentifierPartES6
			};
		})();
	}));
	var require_keyword = /* @__PURE__ */ __commonJSMin(((exports, module) => {
		(function() {
			var code = require_code();
			function isStrictModeReservedWordES6(id) {
				switch (id) {
					case "implements":
					case "interface":
					case "package":
					case "private":
					case "protected":
					case "public":
					case "static":
					case "let": return true;
					default: return false;
				}
			}
			function isKeywordES5(id, strict) {
				if (!strict && id === "yield") return false;
				return isKeywordES6(id, strict);
			}
			function isKeywordES6(id, strict) {
				if (strict && isStrictModeReservedWordES6(id)) return true;
				switch (id.length) {
					case 2: return id === "if" || id === "in" || id === "do";
					case 3: return id === "var" || id === "for" || id === "new" || id === "try";
					case 4: return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
					case 5: return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
					case 6: return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
					case 7: return id === "default" || id === "finally" || id === "extends";
					case 8: return id === "function" || id === "continue" || id === "debugger";
					case 10: return id === "instanceof";
					default: return false;
				}
			}
			function isReservedWordES5(id, strict) {
				return id === "null" || id === "true" || id === "false" || isKeywordES5(id, strict);
			}
			function isReservedWordES6(id, strict) {
				return id === "null" || id === "true" || id === "false" || isKeywordES6(id, strict);
			}
			function isRestrictedWord(id) {
				return id === "eval" || id === "arguments";
			}
			function isIdentifierNameES5(id) {
				var i$1, iz, ch;
				if (id.length === 0) return false;
				ch = id.charCodeAt(0);
				if (!code.isIdentifierStartES5(ch)) return false;
				for (i$1 = 1, iz = id.length; i$1 < iz; ++i$1) {
					ch = id.charCodeAt(i$1);
					if (!code.isIdentifierPartES5(ch)) return false;
				}
				return true;
			}
			function decodeUtf16(lead, trail) {
				return (lead - 55296) * 1024 + (trail - 56320) + 65536;
			}
			function isIdentifierNameES6(id) {
				var i$1, iz, ch, lowCh, check$1;
				if (id.length === 0) return false;
				check$1 = code.isIdentifierStartES6;
				for (i$1 = 0, iz = id.length; i$1 < iz; ++i$1) {
					ch = id.charCodeAt(i$1);
					if (55296 <= ch && ch <= 56319) {
						++i$1;
						if (i$1 >= iz) return false;
						lowCh = id.charCodeAt(i$1);
						if (!(56320 <= lowCh && lowCh <= 57343)) return false;
						ch = decodeUtf16(ch, lowCh);
					}
					if (!check$1(ch)) return false;
					check$1 = code.isIdentifierPartES6;
				}
				return true;
			}
			function isIdentifierES5(id, strict) {
				return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
			}
			function isIdentifierES6(id, strict) {
				return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
			}
			module.exports = {
				isKeywordES5,
				isKeywordES6,
				isReservedWordES5,
				isReservedWordES6,
				isRestrictedWord,
				isIdentifierNameES5,
				isIdentifierNameES6,
				isIdentifierES5,
				isIdentifierES6
			};
		})();
	}));
	var require_utils = /* @__PURE__ */ __commonJSMin(((exports) => {
		(function() {
			exports.ast = require_ast();
			exports.code = require_code();
			exports.keyword = require_keyword();
		})();
	}));
	var require_base64 = /* @__PURE__ */ __commonJSMin(((exports) => {
		var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
		exports.encode = function(number$2) {
			if (0 <= number$2 && number$2 < intToCharMap.length) return intToCharMap[number$2];
			throw new TypeError("Must be between 0 and 63: " + number$2);
		};
		exports.decode = function(charCode) {
			var bigA = 65;
			var bigZ = 90;
			var littleA = 97;
			var littleZ = 122;
			var zero$2 = 48;
			var nine = 57;
			var plus = 43;
			var slash = 47;
			var littleOffset = 26;
			var numberOffset = 52;
			if (bigA <= charCode && charCode <= bigZ) return charCode - bigA;
			if (littleA <= charCode && charCode <= littleZ) return charCode - littleA + littleOffset;
			if (zero$2 <= charCode && charCode <= nine) return charCode - zero$2 + numberOffset;
			if (charCode == plus) return 62;
			if (charCode == slash) return 63;
			return -1;
		};
	}));
	var require_base64_vlq = /* @__PURE__ */ __commonJSMin(((exports) => {
		var base64 = require_base64();
		var VLQ_BASE_SHIFT = 5;
		var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
		var VLQ_BASE_MASK = VLQ_BASE - 1;
		var VLQ_CONTINUATION_BIT = VLQ_BASE;
		function toVLQSigned(aValue) {
			return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
		}
		function fromVLQSigned(aValue) {
			var isNegative = (aValue & 1) === 1;
			var shifted = aValue >> 1;
			return isNegative ? -shifted : shifted;
		}
		exports.encode = function base64VLQ_encode(aValue) {
			var encoded = "";
			var digit;
			var vlq = toVLQSigned(aValue);
			do {
				digit = vlq & VLQ_BASE_MASK;
				vlq >>>= VLQ_BASE_SHIFT;
				if (vlq > 0) digit |= VLQ_CONTINUATION_BIT;
				encoded += base64.encode(digit);
			} while (vlq > 0);
			return encoded;
		};
		exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
			var strLen = aStr.length;
			var result = 0;
			var shift = 0;
			var continuation, digit;
			do {
				if (aIndex >= strLen) throw new Error("Expected more digits in base 64 VLQ value.");
				digit = base64.decode(aStr.charCodeAt(aIndex++));
				if (digit === -1) throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
				continuation = !!(digit & VLQ_CONTINUATION_BIT);
				digit &= VLQ_BASE_MASK;
				result = result + (digit << shift);
				shift += VLQ_BASE_SHIFT;
			} while (continuation);
			aOutParam.value = fromVLQSigned(result);
			aOutParam.rest = aIndex;
		};
	}));
	var require_util = /* @__PURE__ */ __commonJSMin(((exports) => {
		function getArg(aArgs, aName, aDefaultValue) {
			if (aName in aArgs) return aArgs[aName];
			else if (arguments.length === 3) return aDefaultValue;
			else throw new Error("\"" + aName + "\" is a required argument.");
		}
		exports.getArg = getArg;
		var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
		var dataUrlRegexp = /^data:.+\,.+$/;
		function urlParse(aUrl) {
			var match = aUrl.match(urlRegexp);
			if (!match) return null;
			return {
				scheme: match[1],
				auth: match[2],
				host: match[3],
				port: match[4],
				path: match[5]
			};
		}
		exports.urlParse = urlParse;
		function urlGenerate(aParsedUrl) {
			var url = "";
			if (aParsedUrl.scheme) url += aParsedUrl.scheme + ":";
			url += "//";
			if (aParsedUrl.auth) url += aParsedUrl.auth + "@";
			if (aParsedUrl.host) url += aParsedUrl.host;
			if (aParsedUrl.port) url += ":" + aParsedUrl.port;
			if (aParsedUrl.path) url += aParsedUrl.path;
			return url;
		}
		exports.urlGenerate = urlGenerate;
		function normalize(aPath) {
			var path$1 = aPath;
			var url = urlParse(aPath);
			if (url) {
				if (!url.path) return aPath;
				path$1 = url.path;
			}
			var isAbsolute = exports.isAbsolute(path$1);
			var parts = path$1.split(/\/+/);
			for (var part, up = 0, i$1 = parts.length - 1; i$1 >= 0; i$1--) {
				part = parts[i$1];
				if (part === ".") parts.splice(i$1, 1);
				else if (part === "..") up++;
				else if (up > 0) if (part === "") {
					parts.splice(i$1 + 1, up);
					up = 0;
				} else {
					parts.splice(i$1, 2);
					up--;
				}
			}
			path$1 = parts.join("/");
			if (path$1 === "") path$1 = isAbsolute ? "/" : ".";
			if (url) {
				url.path = path$1;
				return urlGenerate(url);
			}
			return path$1;
		}
		exports.normalize = normalize;
		function join(aRoot, aPath) {
			if (aRoot === "") aRoot = ".";
			if (aPath === "") aPath = ".";
			var aPathUrl = urlParse(aPath);
			var aRootUrl = urlParse(aRoot);
			if (aRootUrl) aRoot = aRootUrl.path || "/";
			if (aPathUrl && !aPathUrl.scheme) {
				if (aRootUrl) aPathUrl.scheme = aRootUrl.scheme;
				return urlGenerate(aPathUrl);
			}
			if (aPathUrl || aPath.match(dataUrlRegexp)) return aPath;
			if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
				aRootUrl.host = aPath;
				return urlGenerate(aRootUrl);
			}
			var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
			if (aRootUrl) {
				aRootUrl.path = joined;
				return urlGenerate(aRootUrl);
			}
			return joined;
		}
		exports.join = join;
		exports.isAbsolute = function(aPath) {
			return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
		};
		function relative(aRoot, aPath) {
			if (aRoot === "") aRoot = ".";
			aRoot = aRoot.replace(/\/$/, "");
			var level = 0;
			while (aPath.indexOf(aRoot + "/") !== 0) {
				var index = aRoot.lastIndexOf("/");
				if (index < 0) return aPath;
				aRoot = aRoot.slice(0, index);
				if (aRoot.match(/^([^\/]+:\/)?\/*$/)) return aPath;
				++level;
			}
			return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
		}
		exports.relative = relative;
		var supportsNullProto = function() {
			return !("__proto__" in Object.create(null));
		}();
		function identity(s) {
			return s;
		}
		function toSetString(aStr) {
			if (isProtoString(aStr)) return "$" + aStr;
			return aStr;
		}
		exports.toSetString = supportsNullProto ? identity : toSetString;
		function fromSetString(aStr) {
			if (isProtoString(aStr)) return aStr.slice(1);
			return aStr;
		}
		exports.fromSetString = supportsNullProto ? identity : fromSetString;
		function isProtoString(s) {
			if (!s) return false;
			var length = s.length;
			if (length < 9) return false;
			if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) return false;
			for (var i$1 = length - 10; i$1 >= 0; i$1--) if (s.charCodeAt(i$1) !== 36) return false;
			return true;
		}
		function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
			var cmp = strcmp(mappingA.source, mappingB.source);
			if (cmp !== 0) return cmp;
			cmp = mappingA.originalLine - mappingB.originalLine;
			if (cmp !== 0) return cmp;
			cmp = mappingA.originalColumn - mappingB.originalColumn;
			if (cmp !== 0 || onlyCompareOriginal) return cmp;
			cmp = mappingA.generatedColumn - mappingB.generatedColumn;
			if (cmp !== 0) return cmp;
			cmp = mappingA.generatedLine - mappingB.generatedLine;
			if (cmp !== 0) return cmp;
			return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByOriginalPositions = compareByOriginalPositions;
		function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
			var cmp = mappingA.generatedLine - mappingB.generatedLine;
			if (cmp !== 0) return cmp;
			cmp = mappingA.generatedColumn - mappingB.generatedColumn;
			if (cmp !== 0 || onlyCompareGenerated) return cmp;
			cmp = strcmp(mappingA.source, mappingB.source);
			if (cmp !== 0) return cmp;
			cmp = mappingA.originalLine - mappingB.originalLine;
			if (cmp !== 0) return cmp;
			cmp = mappingA.originalColumn - mappingB.originalColumn;
			if (cmp !== 0) return cmp;
			return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
		function strcmp(aStr1, aStr2) {
			if (aStr1 === aStr2) return 0;
			if (aStr1 === null) return 1;
			if (aStr2 === null) return -1;
			if (aStr1 > aStr2) return 1;
			return -1;
		}
		function compareByGeneratedPositionsInflated(mappingA, mappingB) {
			var cmp = mappingA.generatedLine - mappingB.generatedLine;
			if (cmp !== 0) return cmp;
			cmp = mappingA.generatedColumn - mappingB.generatedColumn;
			if (cmp !== 0) return cmp;
			cmp = strcmp(mappingA.source, mappingB.source);
			if (cmp !== 0) return cmp;
			cmp = mappingA.originalLine - mappingB.originalLine;
			if (cmp !== 0) return cmp;
			cmp = mappingA.originalColumn - mappingB.originalColumn;
			if (cmp !== 0) return cmp;
			return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
		function parseSourceMapInput(str) {
			return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
		}
		exports.parseSourceMapInput = parseSourceMapInput;
		function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
			sourceURL = sourceURL || "";
			if (sourceRoot) {
				if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") sourceRoot += "/";
				sourceURL = sourceRoot + sourceURL;
			}
			if (sourceMapURL) {
				var parsed = urlParse(sourceMapURL);
				if (!parsed) throw new Error("sourceMapURL could not be parsed");
				if (parsed.path) {
					var index = parsed.path.lastIndexOf("/");
					if (index >= 0) parsed.path = parsed.path.substring(0, index + 1);
				}
				sourceURL = join(urlGenerate(parsed), sourceURL);
			}
			return normalize(sourceURL);
		}
		exports.computeSourceURL = computeSourceURL;
	}));
	var require_array_set = /* @__PURE__ */ __commonJSMin(((exports) => {
		var util$4 = require_util();
		var has = Object.prototype.hasOwnProperty;
		var hasNativeMap = typeof Map !== "undefined";
		function ArraySet$2() {
			this._array = [];
			this._set = hasNativeMap ? /* @__PURE__ */ new Map() : Object.create(null);
		}
		ArraySet$2.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
			var set$1 = new ArraySet$2();
			for (var i$1 = 0, len = aArray.length; i$1 < len; i$1++) set$1.add(aArray[i$1], aAllowDuplicates);
			return set$1;
		};
		ArraySet$2.prototype.size = function ArraySet_size() {
			return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
		};
		ArraySet$2.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
			var sStr = hasNativeMap ? aStr : util$4.toSetString(aStr);
			var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
			var idx = this._array.length;
			if (!isDuplicate || aAllowDuplicates) this._array.push(aStr);
			if (!isDuplicate) if (hasNativeMap) this._set.set(aStr, idx);
			else this._set[sStr] = idx;
		};
		ArraySet$2.prototype.has = function ArraySet_has(aStr) {
			if (hasNativeMap) return this._set.has(aStr);
			else {
				var sStr = util$4.toSetString(aStr);
				return has.call(this._set, sStr);
			}
		};
		ArraySet$2.prototype.indexOf = function ArraySet_indexOf(aStr) {
			if (hasNativeMap) {
				var idx = this._set.get(aStr);
				if (idx >= 0) return idx;
			} else {
				var sStr = util$4.toSetString(aStr);
				if (has.call(this._set, sStr)) return this._set[sStr];
			}
			throw new Error("\"" + aStr + "\" is not in the set.");
		};
		ArraySet$2.prototype.at = function ArraySet_at(aIdx) {
			if (aIdx >= 0 && aIdx < this._array.length) return this._array[aIdx];
			throw new Error("No element indexed by " + aIdx);
		};
		ArraySet$2.prototype.toArray = function ArraySet_toArray() {
			return this._array.slice();
		};
		exports.ArraySet = ArraySet$2;
	}));
	var require_mapping_list = /* @__PURE__ */ __commonJSMin(((exports) => {
		var util$3 = require_util();
		function generatedPositionAfter(mappingA, mappingB) {
			var lineA = mappingA.generatedLine;
			var lineB = mappingB.generatedLine;
			var columnA = mappingA.generatedColumn;
			var columnB = mappingB.generatedColumn;
			return lineB > lineA || lineB == lineA && columnB >= columnA || util$3.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
		}
		function MappingList$1() {
			this._array = [];
			this._sorted = true;
			this._last = {
				generatedLine: -1,
				generatedColumn: 0
			};
		}
		MappingList$1.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
			this._array.forEach(aCallback, aThisArg);
		};
		MappingList$1.prototype.add = function MappingList_add(aMapping) {
			if (generatedPositionAfter(this._last, aMapping)) {
				this._last = aMapping;
				this._array.push(aMapping);
			} else {
				this._sorted = false;
				this._array.push(aMapping);
			}
		};
		MappingList$1.prototype.toArray = function MappingList_toArray() {
			if (!this._sorted) {
				this._array.sort(util$3.compareByGeneratedPositionsInflated);
				this._sorted = true;
			}
			return this._array;
		};
		exports.MappingList = MappingList$1;
	}));
	var require_source_map_generator = /* @__PURE__ */ __commonJSMin(((exports) => {
		var base64VLQ$1 = require_base64_vlq();
		var util$2 = require_util();
		var ArraySet$1 = require_array_set().ArraySet;
		var MappingList = require_mapping_list().MappingList;
		function SourceMapGenerator$1(aArgs) {
			if (!aArgs) aArgs = {};
			this._file = util$2.getArg(aArgs, "file", null);
			this._sourceRoot = util$2.getArg(aArgs, "sourceRoot", null);
			this._skipValidation = util$2.getArg(aArgs, "skipValidation", false);
			this._sources = new ArraySet$1();
			this._names = new ArraySet$1();
			this._mappings = new MappingList();
			this._sourcesContents = null;
		}
		SourceMapGenerator$1.prototype._version = 3;
		SourceMapGenerator$1.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
			var sourceRoot = aSourceMapConsumer.sourceRoot;
			var generator = new SourceMapGenerator$1({
				file: aSourceMapConsumer.file,
				sourceRoot
			});
			aSourceMapConsumer.eachMapping(function(mapping) {
				var newMapping = { generated: {
					line: mapping.generatedLine,
					column: mapping.generatedColumn
				} };
				if (mapping.source != null) {
					newMapping.source = mapping.source;
					if (sourceRoot != null) newMapping.source = util$2.relative(sourceRoot, newMapping.source);
					newMapping.original = {
						line: mapping.originalLine,
						column: mapping.originalColumn
					};
					if (mapping.name != null) newMapping.name = mapping.name;
				}
				generator.addMapping(newMapping);
			});
			aSourceMapConsumer.sources.forEach(function(sourceFile) {
				var sourceRelative = sourceFile;
				if (sourceRoot !== null) sourceRelative = util$2.relative(sourceRoot, sourceFile);
				if (!generator._sources.has(sourceRelative)) generator._sources.add(sourceRelative);
				var content = aSourceMapConsumer.sourceContentFor(sourceFile);
				if (content != null) generator.setSourceContent(sourceFile, content);
			});
			return generator;
		};
		SourceMapGenerator$1.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
			var generated = util$2.getArg(aArgs, "generated");
			var original = util$2.getArg(aArgs, "original", null);
			var source = util$2.getArg(aArgs, "source", null);
			var name = util$2.getArg(aArgs, "name", null);
			if (!this._skipValidation) this._validateMapping(generated, original, source, name);
			if (source != null) {
				source = String(source);
				if (!this._sources.has(source)) this._sources.add(source);
			}
			if (name != null) {
				name = String(name);
				if (!this._names.has(name)) this._names.add(name);
			}
			this._mappings.add({
				generatedLine: generated.line,
				generatedColumn: generated.column,
				originalLine: original != null && original.line,
				originalColumn: original != null && original.column,
				source,
				name
			});
		};
		SourceMapGenerator$1.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
			var source = aSourceFile;
			if (this._sourceRoot != null) source = util$2.relative(this._sourceRoot, source);
			if (aSourceContent != null) {
				if (!this._sourcesContents) this._sourcesContents = Object.create(null);
				this._sourcesContents[util$2.toSetString(source)] = aSourceContent;
			} else if (this._sourcesContents) {
				delete this._sourcesContents[util$2.toSetString(source)];
				if (Object.keys(this._sourcesContents).length === 0) this._sourcesContents = null;
			}
		};
		SourceMapGenerator$1.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
			var sourceFile = aSourceFile;
			if (aSourceFile == null) {
				if (aSourceMapConsumer.file == null) throw new Error("SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's \"file\" property. Both were omitted.");
				sourceFile = aSourceMapConsumer.file;
			}
			var sourceRoot = this._sourceRoot;
			if (sourceRoot != null) sourceFile = util$2.relative(sourceRoot, sourceFile);
			var newSources = new ArraySet$1();
			var newNames = new ArraySet$1();
			this._mappings.unsortedForEach(function(mapping) {
				if (mapping.source === sourceFile && mapping.originalLine != null) {
					var original = aSourceMapConsumer.originalPositionFor({
						line: mapping.originalLine,
						column: mapping.originalColumn
					});
					if (original.source != null) {
						mapping.source = original.source;
						if (aSourceMapPath != null) mapping.source = util$2.join(aSourceMapPath, mapping.source);
						if (sourceRoot != null) mapping.source = util$2.relative(sourceRoot, mapping.source);
						mapping.originalLine = original.line;
						mapping.originalColumn = original.column;
						if (original.name != null) mapping.name = original.name;
					}
				}
				var source = mapping.source;
				if (source != null && !newSources.has(source)) newSources.add(source);
				var name = mapping.name;
				if (name != null && !newNames.has(name)) newNames.add(name);
			}, this);
			this._sources = newSources;
			this._names = newNames;
			aSourceMapConsumer.sources.forEach(function(sourceFile$1) {
				var content = aSourceMapConsumer.sourceContentFor(sourceFile$1);
				if (content != null) {
					if (aSourceMapPath != null) sourceFile$1 = util$2.join(aSourceMapPath, sourceFile$1);
					if (sourceRoot != null) sourceFile$1 = util$2.relative(sourceRoot, sourceFile$1);
					this.setSourceContent(sourceFile$1, content);
				}
			}, this);
		};
		SourceMapGenerator$1.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
			if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
			if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) return;
			else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) return;
			else throw new Error("Invalid mapping: " + JSON.stringify({
				generated: aGenerated,
				source: aSource,
				original: aOriginal,
				name: aName
			}));
		};
		SourceMapGenerator$1.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
			var previousGeneratedColumn = 0;
			var previousGeneratedLine = 1;
			var previousOriginalColumn = 0;
			var previousOriginalLine = 0;
			var previousName = 0;
			var previousSource = 0;
			var result = "";
			var next;
			var mapping;
			var nameIdx;
			var sourceIdx;
			var mappings = this._mappings.toArray();
			for (var i$1 = 0, len = mappings.length; i$1 < len; i$1++) {
				mapping = mappings[i$1];
				next = "";
				if (mapping.generatedLine !== previousGeneratedLine) {
					previousGeneratedColumn = 0;
					while (mapping.generatedLine !== previousGeneratedLine) {
						next += ";";
						previousGeneratedLine++;
					}
				} else if (i$1 > 0) {
					if (!util$2.compareByGeneratedPositionsInflated(mapping, mappings[i$1 - 1])) continue;
					next += ",";
				}
				next += base64VLQ$1.encode(mapping.generatedColumn - previousGeneratedColumn);
				previousGeneratedColumn = mapping.generatedColumn;
				if (mapping.source != null) {
					sourceIdx = this._sources.indexOf(mapping.source);
					next += base64VLQ$1.encode(sourceIdx - previousSource);
					previousSource = sourceIdx;
					next += base64VLQ$1.encode(mapping.originalLine - 1 - previousOriginalLine);
					previousOriginalLine = mapping.originalLine - 1;
					next += base64VLQ$1.encode(mapping.originalColumn - previousOriginalColumn);
					previousOriginalColumn = mapping.originalColumn;
					if (mapping.name != null) {
						nameIdx = this._names.indexOf(mapping.name);
						next += base64VLQ$1.encode(nameIdx - previousName);
						previousName = nameIdx;
					}
				}
				result += next;
			}
			return result;
		};
		SourceMapGenerator$1.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
			return aSources.map(function(source) {
				if (!this._sourcesContents) return null;
				if (aSourceRoot != null) source = util$2.relative(aSourceRoot, source);
				var key = util$2.toSetString(source);
				return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
			}, this);
		};
		SourceMapGenerator$1.prototype.toJSON = function SourceMapGenerator_toJSON() {
			var map$1 = {
				version: this._version,
				sources: this._sources.toArray(),
				names: this._names.toArray(),
				mappings: this._serializeMappings()
			};
			if (this._file != null) map$1.file = this._file;
			if (this._sourceRoot != null) map$1.sourceRoot = this._sourceRoot;
			if (this._sourcesContents) map$1.sourcesContent = this._generateSourcesContent(map$1.sources, map$1.sourceRoot);
			return map$1;
		};
		SourceMapGenerator$1.prototype.toString = function SourceMapGenerator_toString() {
			return JSON.stringify(this.toJSON());
		};
		exports.SourceMapGenerator = SourceMapGenerator$1;
	}));
	var require_binary_search = /* @__PURE__ */ __commonJSMin(((exports) => {
		exports.GREATEST_LOWER_BOUND = 1;
		exports.LEAST_UPPER_BOUND = 2;
		function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
			var mid = Math.floor((aHigh - aLow) / 2) + aLow;
			var cmp = aCompare(aNeedle, aHaystack[mid], true);
			if (cmp === 0) return mid;
			else if (cmp > 0) {
				if (aHigh - mid > 1) return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
				if (aBias == exports.LEAST_UPPER_BOUND) return aHigh < aHaystack.length ? aHigh : -1;
				else return mid;
			} else {
				if (mid - aLow > 1) return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
				if (aBias == exports.LEAST_UPPER_BOUND) return mid;
				else return aLow < 0 ? -1 : aLow;
			}
		}
		exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
			if (aHaystack.length === 0) return -1;
			var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
			if (index < 0) return -1;
			while (index - 1 >= 0) {
				if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) break;
				--index;
			}
			return index;
		};
	}));
	var require_quick_sort = /* @__PURE__ */ __commonJSMin(((exports) => {
		function swap(ary, x$1, y) {
			var temp = ary[x$1];
			ary[x$1] = ary[y];
			ary[y] = temp;
		}
		function randomIntInRange(low, high) {
			return Math.round(low + Math.random() * (high - low));
		}
		function doQuickSort(ary, comparator, p$1, r) {
			if (p$1 < r) {
				var pivotIndex = randomIntInRange(p$1, r);
				var i$1 = p$1 - 1;
				swap(ary, pivotIndex, r);
				var pivot = ary[r];
				for (var j = p$1; j < r; j++) if (comparator(ary[j], pivot) <= 0) {
					i$1 += 1;
					swap(ary, i$1, j);
				}
				swap(ary, i$1 + 1, j);
				var q = i$1 + 1;
				doQuickSort(ary, comparator, p$1, q - 1);
				doQuickSort(ary, comparator, q + 1, r);
			}
		}
		exports.quickSort = function(ary, comparator) {
			doQuickSort(ary, comparator, 0, ary.length - 1);
		};
	}));
	var require_source_map_consumer = /* @__PURE__ */ __commonJSMin(((exports) => {
		var util$1 = require_util();
		var binarySearch = require_binary_search();
		var ArraySet = require_array_set().ArraySet;
		var base64VLQ = require_base64_vlq();
		var quickSort = require_quick_sort().quickSort;
		function SourceMapConsumer(aSourceMap, aSourceMapURL) {
			var sourceMap = aSourceMap;
			if (typeof aSourceMap === "string") sourceMap = util$1.parseSourceMapInput(aSourceMap);
			return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
		}
		SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
			return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
		};
		SourceMapConsumer.prototype._version = 3;
		SourceMapConsumer.prototype.__generatedMappings = null;
		Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
			configurable: true,
			enumerable: true,
			get: function() {
				if (!this.__generatedMappings) this._parseMappings(this._mappings, this.sourceRoot);
				return this.__generatedMappings;
			}
		});
		SourceMapConsumer.prototype.__originalMappings = null;
		Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
			configurable: true,
			enumerable: true,
			get: function() {
				if (!this.__originalMappings) this._parseMappings(this._mappings, this.sourceRoot);
				return this.__originalMappings;
			}
		});
		SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
			var c = aStr.charAt(index);
			return c === ";" || c === ",";
		};
		SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
			throw new Error("Subclasses must implement _parseMappings");
		};
		SourceMapConsumer.GENERATED_ORDER = 1;
		SourceMapConsumer.ORIGINAL_ORDER = 2;
		SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
		SourceMapConsumer.LEAST_UPPER_BOUND = 2;
		SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
			var context = aContext || null;
			var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
			var mappings;
			switch (order) {
				case SourceMapConsumer.GENERATED_ORDER:
					mappings = this._generatedMappings;
					break;
				case SourceMapConsumer.ORIGINAL_ORDER:
					mappings = this._originalMappings;
					break;
				default: throw new Error("Unknown order of iteration.");
			}
			var sourceRoot = this.sourceRoot;
			mappings.map(function(mapping) {
				var source = mapping.source === null ? null : this._sources.at(mapping.source);
				source = util$1.computeSourceURL(sourceRoot, source, this._sourceMapURL);
				return {
					source,
					generatedLine: mapping.generatedLine,
					generatedColumn: mapping.generatedColumn,
					originalLine: mapping.originalLine,
					originalColumn: mapping.originalColumn,
					name: mapping.name === null ? null : this._names.at(mapping.name)
				};
			}, this).forEach(aCallback, context);
		};
		SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
			var line = util$1.getArg(aArgs, "line");
			var needle = {
				source: util$1.getArg(aArgs, "source"),
				originalLine: line,
				originalColumn: util$1.getArg(aArgs, "column", 0)
			};
			needle.source = this._findSourceIndex(needle.source);
			if (needle.source < 0) return [];
			var mappings = [];
			var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$1.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
			if (index >= 0) {
				var mapping = this._originalMappings[index];
				if (aArgs.column === void 0) {
					var originalLine = mapping.originalLine;
					while (mapping && mapping.originalLine === originalLine) {
						mappings.push({
							line: util$1.getArg(mapping, "generatedLine", null),
							column: util$1.getArg(mapping, "generatedColumn", null),
							lastColumn: util$1.getArg(mapping, "lastGeneratedColumn", null)
						});
						mapping = this._originalMappings[++index];
					}
				} else {
					var originalColumn = mapping.originalColumn;
					while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
						mappings.push({
							line: util$1.getArg(mapping, "generatedLine", null),
							column: util$1.getArg(mapping, "generatedColumn", null),
							lastColumn: util$1.getArg(mapping, "lastGeneratedColumn", null)
						});
						mapping = this._originalMappings[++index];
					}
				}
			}
			return mappings;
		};
		exports.SourceMapConsumer = SourceMapConsumer;
		function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
			var sourceMap = aSourceMap;
			if (typeof aSourceMap === "string") sourceMap = util$1.parseSourceMapInput(aSourceMap);
			var version$2 = util$1.getArg(sourceMap, "version");
			var sources = util$1.getArg(sourceMap, "sources");
			var names = util$1.getArg(sourceMap, "names", []);
			var sourceRoot = util$1.getArg(sourceMap, "sourceRoot", null);
			var sourcesContent = util$1.getArg(sourceMap, "sourcesContent", null);
			var mappings = util$1.getArg(sourceMap, "mappings");
			var file$1 = util$1.getArg(sourceMap, "file", null);
			if (version$2 != this._version) throw new Error("Unsupported version: " + version$2);
			if (sourceRoot) sourceRoot = util$1.normalize(sourceRoot);
			sources = sources.map(String).map(util$1.normalize).map(function(source) {
				return sourceRoot && util$1.isAbsolute(sourceRoot) && util$1.isAbsolute(source) ? util$1.relative(sourceRoot, source) : source;
			});
			this._names = ArraySet.fromArray(names.map(String), true);
			this._sources = ArraySet.fromArray(sources, true);
			this._absoluteSources = this._sources.toArray().map(function(s) {
				return util$1.computeSourceURL(sourceRoot, s, aSourceMapURL);
			});
			this.sourceRoot = sourceRoot;
			this.sourcesContent = sourcesContent;
			this._mappings = mappings;
			this._sourceMapURL = aSourceMapURL;
			this.file = file$1;
		}
		BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
		BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
		BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
			var relativeSource = aSource;
			if (this.sourceRoot != null) relativeSource = util$1.relative(this.sourceRoot, relativeSource);
			if (this._sources.has(relativeSource)) return this._sources.indexOf(relativeSource);
			var i$1;
			for (i$1 = 0; i$1 < this._absoluteSources.length; ++i$1) if (this._absoluteSources[i$1] == aSource) return i$1;
			return -1;
		};
		BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
			var smc = Object.create(BasicSourceMapConsumer.prototype);
			var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
			var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
			smc.sourceRoot = aSourceMap._sourceRoot;
			smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
			smc.file = aSourceMap._file;
			smc._sourceMapURL = aSourceMapURL;
			smc._absoluteSources = smc._sources.toArray().map(function(s) {
				return util$1.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
			});
			var generatedMappings = aSourceMap._mappings.toArray().slice();
			var destGeneratedMappings = smc.__generatedMappings = [];
			var destOriginalMappings = smc.__originalMappings = [];
			for (var i$1 = 0, length = generatedMappings.length; i$1 < length; i$1++) {
				var srcMapping = generatedMappings[i$1];
				var destMapping = new Mapping();
				destMapping.generatedLine = srcMapping.generatedLine;
				destMapping.generatedColumn = srcMapping.generatedColumn;
				if (srcMapping.source) {
					destMapping.source = sources.indexOf(srcMapping.source);
					destMapping.originalLine = srcMapping.originalLine;
					destMapping.originalColumn = srcMapping.originalColumn;
					if (srcMapping.name) destMapping.name = names.indexOf(srcMapping.name);
					destOriginalMappings.push(destMapping);
				}
				destGeneratedMappings.push(destMapping);
			}
			quickSort(smc.__originalMappings, util$1.compareByOriginalPositions);
			return smc;
		};
		BasicSourceMapConsumer.prototype._version = 3;
		Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", { get: function() {
			return this._absoluteSources.slice();
		} });
		function Mapping() {
			this.generatedLine = 0;
			this.generatedColumn = 0;
			this.source = null;
			this.originalLine = null;
			this.originalColumn = null;
			this.name = null;
		}
		BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
			var generatedLine = 1;
			var previousGeneratedColumn = 0;
			var previousOriginalLine = 0;
			var previousOriginalColumn = 0;
			var previousSource = 0;
			var previousName = 0;
			var length = aStr.length;
			var index = 0;
			var cachedSegments = {};
			var temp = {};
			var originalMappings = [];
			var generatedMappings = [];
			var mapping, str, segment, end, value;
			while (index < length) if (aStr.charAt(index) === ";") {
				generatedLine++;
				index++;
				previousGeneratedColumn = 0;
			} else if (aStr.charAt(index) === ",") index++;
			else {
				mapping = new Mapping();
				mapping.generatedLine = generatedLine;
				for (end = index; end < length; end++) if (this._charIsMappingSeparator(aStr, end)) break;
				str = aStr.slice(index, end);
				segment = cachedSegments[str];
				if (segment) index += str.length;
				else {
					segment = [];
					while (index < end) {
						base64VLQ.decode(aStr, index, temp);
						value = temp.value;
						index = temp.rest;
						segment.push(value);
					}
					if (segment.length === 2) throw new Error("Found a source, but no line and column");
					if (segment.length === 3) throw new Error("Found a source and line, but no column");
					cachedSegments[str] = segment;
				}
				mapping.generatedColumn = previousGeneratedColumn + segment[0];
				previousGeneratedColumn = mapping.generatedColumn;
				if (segment.length > 1) {
					mapping.source = previousSource + segment[1];
					previousSource += segment[1];
					mapping.originalLine = previousOriginalLine + segment[2];
					previousOriginalLine = mapping.originalLine;
					mapping.originalLine += 1;
					mapping.originalColumn = previousOriginalColumn + segment[3];
					previousOriginalColumn = mapping.originalColumn;
					if (segment.length > 4) {
						mapping.name = previousName + segment[4];
						previousName += segment[4];
					}
				}
				generatedMappings.push(mapping);
				if (typeof mapping.originalLine === "number") originalMappings.push(mapping);
			}
			quickSort(generatedMappings, util$1.compareByGeneratedPositionsDeflated);
			this.__generatedMappings = generatedMappings;
			quickSort(originalMappings, util$1.compareByOriginalPositions);
			this.__originalMappings = originalMappings;
		};
		BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
			if (aNeedle[aLineName] <= 0) throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
			if (aNeedle[aColumnName] < 0) throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
			return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
		};
		BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
			for (var index = 0; index < this._generatedMappings.length; ++index) {
				var mapping = this._generatedMappings[index];
				if (index + 1 < this._generatedMappings.length) {
					var nextMapping = this._generatedMappings[index + 1];
					if (mapping.generatedLine === nextMapping.generatedLine) {
						mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
						continue;
					}
				}
				mapping.lastGeneratedColumn = Infinity;
			}
		};
		BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
			var needle = {
				generatedLine: util$1.getArg(aArgs, "line"),
				generatedColumn: util$1.getArg(aArgs, "column")
			};
			var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util$1.compareByGeneratedPositionsDeflated, util$1.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
			if (index >= 0) {
				var mapping = this._generatedMappings[index];
				if (mapping.generatedLine === needle.generatedLine) {
					var source = util$1.getArg(mapping, "source", null);
					if (source !== null) {
						source = this._sources.at(source);
						source = util$1.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
					}
					var name = util$1.getArg(mapping, "name", null);
					if (name !== null) name = this._names.at(name);
					return {
						source,
						line: util$1.getArg(mapping, "originalLine", null),
						column: util$1.getArg(mapping, "originalColumn", null),
						name
					};
				}
			}
			return {
				source: null,
				line: null,
				column: null,
				name: null
			};
		};
		BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
			if (!this.sourcesContent) return false;
			return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
				return sc == null;
			});
		};
		BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
			if (!this.sourcesContent) return null;
			var index = this._findSourceIndex(aSource);
			if (index >= 0) return this.sourcesContent[index];
			var relativeSource = aSource;
			if (this.sourceRoot != null) relativeSource = util$1.relative(this.sourceRoot, relativeSource);
			var url;
			if (this.sourceRoot != null && (url = util$1.urlParse(this.sourceRoot))) {
				var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
				if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
				if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
			}
			if (nullOnMissing) return null;
			else throw new Error("\"" + relativeSource + "\" is not in the SourceMap.");
		};
		BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
			var source = util$1.getArg(aArgs, "source");
			source = this._findSourceIndex(source);
			if (source < 0) return {
				line: null,
				column: null,
				lastColumn: null
			};
			var needle = {
				source,
				originalLine: util$1.getArg(aArgs, "line"),
				originalColumn: util$1.getArg(aArgs, "column")
			};
			var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$1.compareByOriginalPositions, util$1.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
			if (index >= 0) {
				var mapping = this._originalMappings[index];
				if (mapping.source === needle.source) return {
					line: util$1.getArg(mapping, "generatedLine", null),
					column: util$1.getArg(mapping, "generatedColumn", null),
					lastColumn: util$1.getArg(mapping, "lastGeneratedColumn", null)
				};
			}
			return {
				line: null,
				column: null,
				lastColumn: null
			};
		};
		exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
		function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
			var sourceMap = aSourceMap;
			if (typeof aSourceMap === "string") sourceMap = util$1.parseSourceMapInput(aSourceMap);
			var version$2 = util$1.getArg(sourceMap, "version");
			var sections = util$1.getArg(sourceMap, "sections");
			if (version$2 != this._version) throw new Error("Unsupported version: " + version$2);
			this._sources = new ArraySet();
			this._names = new ArraySet();
			var lastOffset = {
				line: -1,
				column: 0
			};
			this._sections = sections.map(function(s) {
				if (s.url) throw new Error("Support for url field in sections not implemented.");
				var offset = util$1.getArg(s, "offset");
				var offsetLine = util$1.getArg(offset, "line");
				var offsetColumn = util$1.getArg(offset, "column");
				if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) throw new Error("Section offsets must be ordered and non-overlapping.");
				lastOffset = offset;
				return {
					generatedOffset: {
						generatedLine: offsetLine + 1,
						generatedColumn: offsetColumn + 1
					},
					consumer: new SourceMapConsumer(util$1.getArg(s, "map"), aSourceMapURL)
				};
			});
		}
		IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
		IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
		IndexedSourceMapConsumer.prototype._version = 3;
		Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", { get: function() {
			var sources = [];
			for (var i$1 = 0; i$1 < this._sections.length; i$1++) for (var j = 0; j < this._sections[i$1].consumer.sources.length; j++) sources.push(this._sections[i$1].consumer.sources[j]);
			return sources;
		} });
		IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
			var needle = {
				generatedLine: util$1.getArg(aArgs, "line"),
				generatedColumn: util$1.getArg(aArgs, "column")
			};
			var sectionIndex = binarySearch.search(needle, this._sections, function(needle$1, section$1) {
				var cmp = needle$1.generatedLine - section$1.generatedOffset.generatedLine;
				if (cmp) return cmp;
				return needle$1.generatedColumn - section$1.generatedOffset.generatedColumn;
			});
			var section = this._sections[sectionIndex];
			if (!section) return {
				source: null,
				line: null,
				column: null,
				name: null
			};
			return section.consumer.originalPositionFor({
				line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
				column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
				bias: aArgs.bias
			});
		};
		IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
			return this._sections.every(function(s) {
				return s.consumer.hasContentsOfAllSources();
			});
		};
		IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
			for (var i$1 = 0; i$1 < this._sections.length; i$1++) {
				var content = this._sections[i$1].consumer.sourceContentFor(aSource, true);
				if (content) return content;
			}
			if (nullOnMissing) return null;
			else throw new Error("\"" + aSource + "\" is not in the SourceMap.");
		};
		IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
			for (var i$1 = 0; i$1 < this._sections.length; i$1++) {
				var section = this._sections[i$1];
				if (section.consumer._findSourceIndex(util$1.getArg(aArgs, "source")) === -1) continue;
				var generatedPosition = section.consumer.generatedPositionFor(aArgs);
				if (generatedPosition) return {
					line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
					column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
				};
			}
			return {
				line: null,
				column: null
			};
		};
		IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
			this.__generatedMappings = [];
			this.__originalMappings = [];
			for (var i$1 = 0; i$1 < this._sections.length; i$1++) {
				var section = this._sections[i$1];
				var sectionMappings = section.consumer._generatedMappings;
				for (var j = 0; j < sectionMappings.length; j++) {
					var mapping = sectionMappings[j];
					var source = section.consumer._sources.at(mapping.source);
					source = util$1.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
					this._sources.add(source);
					source = this._sources.indexOf(source);
					var name = null;
					if (mapping.name) {
						name = section.consumer._names.at(mapping.name);
						this._names.add(name);
						name = this._names.indexOf(name);
					}
					var adjustedMapping = {
						source,
						generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
						generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
						originalLine: mapping.originalLine,
						originalColumn: mapping.originalColumn,
						name
					};
					this.__generatedMappings.push(adjustedMapping);
					if (typeof adjustedMapping.originalLine === "number") this.__originalMappings.push(adjustedMapping);
				}
			}
			quickSort(this.__generatedMappings, util$1.compareByGeneratedPositionsDeflated);
			quickSort(this.__originalMappings, util$1.compareByOriginalPositions);
		};
		exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
	}));
	var require_source_node = /* @__PURE__ */ __commonJSMin(((exports) => {
		var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
		var util = require_util();
		var REGEX_NEWLINE = /(\r?\n)/;
		var NEWLINE_CODE = 10;
		var isSourceNode = "$$$isSourceNode$$$";
		function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
			this.children = [];
			this.sourceContents = {};
			this.line = aLine == null ? null : aLine;
			this.column = aColumn == null ? null : aColumn;
			this.source = aSource == null ? null : aSource;
			this.name = aName == null ? null : aName;
			this[isSourceNode] = true;
			if (aChunks != null) this.add(aChunks);
		}
		SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
			var node = new SourceNode();
			var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
			var remainingLinesIndex = 0;
			var shiftNextLine = function() {
				return getNextLine() + (getNextLine() || "");
				function getNextLine() {
					return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
				}
			};
			var lastGeneratedLine = 1, lastGeneratedColumn = 0;
			var lastMapping = null;
			aSourceMapConsumer.eachMapping(function(mapping) {
				if (lastMapping !== null) if (lastGeneratedLine < mapping.generatedLine) {
					addMappingWithCode(lastMapping, shiftNextLine());
					lastGeneratedLine++;
					lastGeneratedColumn = 0;
				} else {
					var nextLine = remainingLines[remainingLinesIndex] || "";
					var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
					remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
					lastGeneratedColumn = mapping.generatedColumn;
					addMappingWithCode(lastMapping, code);
					lastMapping = mapping;
					return;
				}
				while (lastGeneratedLine < mapping.generatedLine) {
					node.add(shiftNextLine());
					lastGeneratedLine++;
				}
				if (lastGeneratedColumn < mapping.generatedColumn) {
					var nextLine = remainingLines[remainingLinesIndex] || "";
					node.add(nextLine.substr(0, mapping.generatedColumn));
					remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
					lastGeneratedColumn = mapping.generatedColumn;
				}
				lastMapping = mapping;
			}, this);
			if (remainingLinesIndex < remainingLines.length) {
				if (lastMapping) addMappingWithCode(lastMapping, shiftNextLine());
				node.add(remainingLines.splice(remainingLinesIndex).join(""));
			}
			aSourceMapConsumer.sources.forEach(function(sourceFile) {
				var content = aSourceMapConsumer.sourceContentFor(sourceFile);
				if (content != null) {
					if (aRelativePath != null) sourceFile = util.join(aRelativePath, sourceFile);
					node.setSourceContent(sourceFile, content);
				}
			});
			return node;
			function addMappingWithCode(mapping, code) {
				if (mapping === null || mapping.source === void 0) node.add(code);
				else {
					var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
					node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
				}
			}
		};
		SourceNode.prototype.add = function SourceNode_add(aChunk) {
			if (Array.isArray(aChunk)) aChunk.forEach(function(chunk) {
				this.add(chunk);
			}, this);
			else if (aChunk[isSourceNode] || typeof aChunk === "string") {
				if (aChunk) this.children.push(aChunk);
			} else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
			return this;
		};
		SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
			if (Array.isArray(aChunk)) for (var i$1 = aChunk.length - 1; i$1 >= 0; i$1--) this.prepend(aChunk[i$1]);
			else if (aChunk[isSourceNode] || typeof aChunk === "string") this.children.unshift(aChunk);
			else throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
			return this;
		};
		SourceNode.prototype.walk = function SourceNode_walk(aFn) {
			var chunk;
			for (var i$1 = 0, len = this.children.length; i$1 < len; i$1++) {
				chunk = this.children[i$1];
				if (chunk[isSourceNode]) chunk.walk(aFn);
				else if (chunk !== "") aFn(chunk, {
					source: this.source,
					line: this.line,
					column: this.column,
					name: this.name
				});
			}
		};
		SourceNode.prototype.join = function SourceNode_join(aSep) {
			var newChildren;
			var i$1;
			var len = this.children.length;
			if (len > 0) {
				newChildren = [];
				for (i$1 = 0; i$1 < len - 1; i$1++) {
					newChildren.push(this.children[i$1]);
					newChildren.push(aSep);
				}
				newChildren.push(this.children[i$1]);
				this.children = newChildren;
			}
			return this;
		};
		SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
			var lastChild = this.children[this.children.length - 1];
			if (lastChild[isSourceNode]) lastChild.replaceRight(aPattern, aReplacement);
			else if (typeof lastChild === "string") this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
			else this.children.push("".replace(aPattern, aReplacement));
			return this;
		};
		SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
			this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
		};
		SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
			for (var i$1 = 0, len = this.children.length; i$1 < len; i$1++) if (this.children[i$1][isSourceNode]) this.children[i$1].walkSourceContents(aFn);
			var sources = Object.keys(this.sourceContents);
			for (var i$1 = 0, len = sources.length; i$1 < len; i$1++) aFn(util.fromSetString(sources[i$1]), this.sourceContents[sources[i$1]]);
		};
		SourceNode.prototype.toString = function SourceNode_toString() {
			var str = "";
			this.walk(function(chunk) {
				str += chunk;
			});
			return str;
		};
		SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
			var generated = {
				code: "",
				line: 1,
				column: 0
			};
			var map$1 = new SourceMapGenerator(aArgs);
			var sourceMappingActive = false;
			var lastOriginalSource = null;
			var lastOriginalLine = null;
			var lastOriginalColumn = null;
			var lastOriginalName = null;
			this.walk(function(chunk, original) {
				generated.code += chunk;
				if (original.source !== null && original.line !== null && original.column !== null) {
					if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) map$1.addMapping({
						source: original.source,
						original: {
							line: original.line,
							column: original.column
						},
						generated: {
							line: generated.line,
							column: generated.column
						},
						name: original.name
					});
					lastOriginalSource = original.source;
					lastOriginalLine = original.line;
					lastOriginalColumn = original.column;
					lastOriginalName = original.name;
					sourceMappingActive = true;
				} else if (sourceMappingActive) {
					map$1.addMapping({ generated: {
						line: generated.line,
						column: generated.column
					} });
					lastOriginalSource = null;
					sourceMappingActive = false;
				}
				for (var idx = 0, length = chunk.length; idx < length; idx++) if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
					generated.line++;
					generated.column = 0;
					if (idx + 1 === length) {
						lastOriginalSource = null;
						sourceMappingActive = false;
					} else if (sourceMappingActive) map$1.addMapping({
						source: original.source,
						original: {
							line: original.line,
							column: original.column
						},
						generated: {
							line: generated.line,
							column: generated.column
						},
						name: original.name
					});
				} else generated.column++;
			});
			this.walkSourceContents(function(sourceFile, sourceContent) {
				map$1.setSourceContent(sourceFile, sourceContent);
			});
			return {
				code: generated.code,
				map: map$1
			};
		};
		exports.SourceNode = SourceNode;
	}));
	var require_source_map = /* @__PURE__ */ __commonJSMin(((exports) => {
		exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
		exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
		exports.SourceNode = require_source_node().SourceNode;
	}));
	var require_package = /* @__PURE__ */ __commonJSMin(((exports, module) => {
		module.exports = {
			"name": "escodegen",
			"description": "ECMAScript code generator",
			"homepage": "http://github.com/estools/escodegen",
			"main": "escodegen.js",
			"bin": {
				"esgenerate": "./bin/esgenerate.js",
				"escodegen": "./bin/escodegen.js"
			},
			"files": [
				"LICENSE.BSD",
				"README.md",
				"bin",
				"escodegen.js",
				"package.json"
			],
			"version": "2.1.0",
			"engines": { "node": ">=6.0" },
			"maintainers": [{
				"name": "Yusuke Suzuki",
				"email": "utatane.tea@gmail.com",
				"web": "http://github.com/Constellation"
			}],
			"repository": {
				"type": "git",
				"url": "http://github.com/estools/escodegen.git"
			},
			"dependencies": {
				"estraverse": "^5.2.0",
				"esutils": "^2.0.2",
				"esprima": "^4.0.1"
			},
			"optionalDependencies": { "source-map": "~0.6.1" },
			"devDependencies": {
				"acorn": "^8.0.4",
				"bluebird": "^3.4.7",
				"bower-registry-client": "^1.0.0",
				"chai": "^4.2.0",
				"chai-exclude": "^2.0.2",
				"commonjs-everywhere": "^0.9.7",
				"gulp": "^4.0.2",
				"gulp-eslint": "^6.0.0",
				"gulp-mocha": "^7.0.2",
				"minimist": "^1.2.5",
				"optionator": "^0.9.1",
				"semver": "^7.3.4"
			},
			"license": "BSD-2-Clause",
			"scripts": {
				"test": "gulp travis",
				"unit-test": "gulp test",
				"lint": "gulp lint",
				"release": "node tools/release.js",
				"build-min": "./node_modules/.bin/cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
				"build": "./node_modules/.bin/cjsify -a path: tools/entry-point.js > escodegen.browser.js"
			}
		};
	}));
	var import_escodegen = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((exports) => {
		(function() {
			var Syntax, Precedence, BinaryPrecedence, SourceNode$1, estraverse = require_estraverse(), esutils = require_utils(), base$1, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse$5, sourceMap, sourceCode, preserveBlankLines, FORMAT_MINIFY, FORMAT_DEFAULTS;
			Syntax = estraverse.Syntax;
			function isExpression(node) {
				return CodeGenerator.Expression.hasOwnProperty(node.type);
			}
			function isStatement(node) {
				return CodeGenerator.Statement.hasOwnProperty(node.type);
			}
			Precedence = {
				Sequence: 0,
				Yield: 1,
				Assignment: 1,
				Conditional: 2,
				ArrowFunction: 2,
				Coalesce: 3,
				LogicalOR: 4,
				LogicalAND: 5,
				BitwiseOR: 6,
				BitwiseXOR: 7,
				BitwiseAND: 8,
				Equality: 9,
				Relational: 10,
				BitwiseSHIFT: 11,
				Additive: 12,
				Multiplicative: 13,
				Exponentiation: 14,
				Await: 15,
				Unary: 15,
				Postfix: 16,
				OptionalChaining: 17,
				Call: 18,
				New: 19,
				TaggedTemplate: 20,
				Member: 21,
				Primary: 22
			};
			BinaryPrecedence = {
				"??": Precedence.Coalesce,
				"||": Precedence.LogicalOR,
				"&&": Precedence.LogicalAND,
				"|": Precedence.BitwiseOR,
				"^": Precedence.BitwiseXOR,
				"&": Precedence.BitwiseAND,
				"==": Precedence.Equality,
				"!=": Precedence.Equality,
				"===": Precedence.Equality,
				"!==": Precedence.Equality,
				"is": Precedence.Equality,
				"isnt": Precedence.Equality,
				"<": Precedence.Relational,
				">": Precedence.Relational,
				"<=": Precedence.Relational,
				">=": Precedence.Relational,
				"in": Precedence.Relational,
				"instanceof": Precedence.Relational,
				"<<": Precedence.BitwiseSHIFT,
				">>": Precedence.BitwiseSHIFT,
				">>>": Precedence.BitwiseSHIFT,
				"+": Precedence.Additive,
				"-": Precedence.Additive,
				"*": Precedence.Multiplicative,
				"%": Precedence.Multiplicative,
				"/": Precedence.Multiplicative,
				"**": Precedence.Exponentiation
			};
			var F_ALLOW_IN = 1, F_ALLOW_CALL = 2, F_ALLOW_UNPARATH_NEW = 4, F_FUNC_BODY = 8, F_DIRECTIVE_CTX = 16, F_SEMICOLON_OPT = 32, F_FOUND_COALESCE = 64;
			var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TTF = F_ALLOW_IN | F_ALLOW_CALL, E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TFF = F_ALLOW_IN, E_FFT = F_ALLOW_UNPARATH_NEW, E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;
			var S_TFFF = F_ALLOW_IN, S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT, S_FFFF = 0, S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX, S_TTFF = F_ALLOW_IN | F_FUNC_BODY;
			function getDefaultOptions() {
				return {
					indent: null,
					base: null,
					parse: null,
					comment: false,
					format: {
						indent: {
							style: "    ",
							base: 0,
							adjustMultilineComment: false
						},
						newline: "\n",
						space: " ",
						json: false,
						renumber: false,
						hexadecimal: false,
						quotes: "single",
						escapeless: false,
						compact: false,
						parentheses: true,
						semicolons: true,
						safeConcatenation: false,
						preserveBlankLines: false
					},
					moz: {
						comprehensionExpressionStartsWithAssignment: false,
						starlessGenerator: false
					},
					sourceMap: null,
					sourceMapRoot: null,
					sourceMapWithCode: false,
					directive: false,
					raw: true,
					verbatim: null,
					sourceCode: null
				};
			}
			function stringRepeat(str, num) {
				var result = "";
				for (num |= 0; num > 0; num >>>= 1, str += str) if (num & 1) result += str;
				return result;
			}
			function hasLineTerminator(str) {
				return /[\r\n]/g.test(str);
			}
			function endsWithLineTerminator(str) {
				var len = str.length;
				return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
			}
			function merge$1(target, override) {
				var key;
				for (key in override) if (override.hasOwnProperty(key)) target[key] = override[key];
				return target;
			}
			function updateDeeply(target, override) {
				var key, val$1;
				function isHashObject(target$1) {
					return typeof target$1 === "object" && target$1 instanceof Object && !(target$1 instanceof RegExp);
				}
				for (key in override) if (override.hasOwnProperty(key)) {
					val$1 = override[key];
					if (isHashObject(val$1)) if (isHashObject(target[key])) updateDeeply(target[key], val$1);
					else target[key] = updateDeeply({}, val$1);
					else target[key] = val$1;
				}
				return target;
			}
			function generateNumber(value) {
				var result, point, temp, exponent, pos;
				if (value !== value) throw new Error("Numeric literal whose value is NaN");
				if (value < 0 || value === 0 && 1 / value < 0) throw new Error("Numeric literal whose value is negative");
				if (value === Infinity) return json ? "null" : renumber ? "1e400" : "1e+400";
				result = "" + value;
				if (!renumber || result.length < 3) return result;
				point = result.indexOf(".");
				if (!json && result.charCodeAt(0) === 48 && point === 1) {
					point = 0;
					result = result.slice(1);
				}
				temp = result;
				result = result.replace("e+", "e");
				exponent = 0;
				if ((pos = temp.indexOf("e")) > 0) {
					exponent = +temp.slice(pos + 1);
					temp = temp.slice(0, pos);
				}
				if (point >= 0) {
					exponent -= temp.length - point - 1;
					temp = +(temp.slice(0, point) + temp.slice(point + 1)) + "";
				}
				pos = 0;
				while (temp.charCodeAt(temp.length + pos - 1) === 48) --pos;
				if (pos !== 0) {
					exponent -= pos;
					temp = temp.slice(0, pos);
				}
				if (exponent !== 0) temp += "e" + exponent;
				if ((temp.length < result.length || hexadecimal && value > 0xe8d4a51000 && Math.floor(value) === value && (temp = "0x" + value.toString(16)).length < result.length) && +temp === value) result = temp;
				return result;
			}
			function escapeRegExpCharacter(ch, previousIsBackslash) {
				if ((ch & -2) === 8232) return (previousIsBackslash ? "u" : "\\u") + (ch === 8232 ? "2028" : "2029");
				else if (ch === 10 || ch === 13) return (previousIsBackslash ? "" : "\\") + (ch === 10 ? "n" : "r");
				return String.fromCharCode(ch);
			}
			function generateRegExp(reg) {
				var match, result = reg.toString(), flags, i$1, iz, ch, characterInBrack, previousIsBackslash;
				if (reg.source) {
					match = result.match(/\/([^/]*)$/);
					if (!match) return result;
					flags = match[1];
					result = "";
					characterInBrack = false;
					previousIsBackslash = false;
					for (i$1 = 0, iz = reg.source.length; i$1 < iz; ++i$1) {
						ch = reg.source.charCodeAt(i$1);
						if (!previousIsBackslash) {
							if (characterInBrack) {
								if (ch === 93) characterInBrack = false;
							} else if (ch === 47) result += "\\";
							else if (ch === 91) characterInBrack = true;
							result += escapeRegExpCharacter(ch, previousIsBackslash);
							previousIsBackslash = ch === 92;
						} else {
							result += escapeRegExpCharacter(ch, previousIsBackslash);
							previousIsBackslash = false;
						}
					}
					return "/" + result + "/" + flags;
				}
				return result;
			}
			function escapeAllowedCharacter(code, next) {
				var hex;
				if (code === 8) return "\\b";
				if (code === 12) return "\\f";
				if (code === 9) return "\\t";
				hex = code.toString(16).toUpperCase();
				if (json || code > 255) return "\\u" + "0000".slice(hex.length) + hex;
				else if (code === 0 && !esutils.code.isDecimalDigit(next)) return "\\0";
				else if (code === 11) return "\\x0B";
				else return "\\x" + "00".slice(hex.length) + hex;
			}
			function escapeDisallowedCharacter(code) {
				if (code === 92) return "\\\\";
				if (code === 10) return "\\n";
				if (code === 13) return "\\r";
				if (code === 8232) return "\\u2028";
				if (code === 8233) return "\\u2029";
				throw new Error("Incorrectly classified character");
			}
			function escapeDirective(str) {
				var i$1, iz, code, quote = quotes === "double" ? "\"" : "'";
				for (i$1 = 0, iz = str.length; i$1 < iz; ++i$1) {
					code = str.charCodeAt(i$1);
					if (code === 39) {
						quote = "\"";
						break;
					} else if (code === 34) {
						quote = "'";
						break;
					} else if (code === 92) ++i$1;
				}
				return quote + str + quote;
			}
			function escapeString(str) {
				var result = "", i$1, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;
				for (i$1 = 0, len = str.length; i$1 < len; ++i$1) {
					code = str.charCodeAt(i$1);
					if (code === 39) ++singleQuotes;
					else if (code === 34) ++doubleQuotes;
					else if (code === 47 && json) result += "\\";
					else if (esutils.code.isLineTerminator(code) || code === 92) {
						result += escapeDisallowedCharacter(code);
						continue;
					} else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 32 || !json && !escapeless && (code < 32 || code > 126))) {
						result += escapeAllowedCharacter(code, str.charCodeAt(i$1 + 1));
						continue;
					}
					result += String.fromCharCode(code);
				}
				single = !(quotes === "double" || quotes === "auto" && doubleQuotes < singleQuotes);
				quote = single ? "'" : "\"";
				if (!(single ? singleQuotes : doubleQuotes)) return quote + result + quote;
				str = result;
				result = quote;
				for (i$1 = 0, len = str.length; i$1 < len; ++i$1) {
					code = str.charCodeAt(i$1);
					if (code === 39 && single || code === 34 && !single) result += "\\";
					result += String.fromCharCode(code);
				}
				return result + quote;
			}
			function flattenToString(arr$1) {
				var i$1, iz, elem, result = "";
				for (i$1 = 0, iz = arr$1.length; i$1 < iz; ++i$1) {
					elem = arr$1[i$1];
					result += Array.isArray(elem) ? flattenToString(elem) : elem;
				}
				return result;
			}
			function toSourceNodeWhenNeeded(generated, node) {
				if (!sourceMap) if (Array.isArray(generated)) return flattenToString(generated);
				else return generated;
				if (node == null) if (generated instanceof SourceNode$1) return generated;
				else node = {};
				if (node.loc == null) return new SourceNode$1(null, null, sourceMap, generated, node.name || null);
				return new SourceNode$1(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated, node.name || null);
			}
			function noEmptySpace() {
				return space ? space : " ";
			}
			function join$1(left, right) {
				var leftSource = toSourceNodeWhenNeeded(left).toString(), rightSource, leftCharCode, rightCharCode;
				if (leftSource.length === 0) return [right];
				rightSource = toSourceNodeWhenNeeded(right).toString();
				if (rightSource.length === 0) return [left];
				leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
				rightCharCode = rightSource.charCodeAt(0);
				if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) || leftCharCode === 47 && rightCharCode === 105) return [
					left,
					noEmptySpace(),
					right
				];
				else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) return [left, right];
				return [
					left,
					space,
					right
				];
			}
			function addIndent(stmt) {
				return [base$1, stmt];
			}
			function withIndent(fn$1) {
				var previousBase = base$1;
				base$1 += indent;
				fn$1(base$1);
				base$1 = previousBase;
			}
			function calculateSpaces(str) {
				var i$1;
				for (i$1 = str.length - 1; i$1 >= 0; --i$1) if (esutils.code.isLineTerminator(str.charCodeAt(i$1))) break;
				return str.length - 1 - i$1;
			}
			function adjustMultilineComment(value, specialBase) {
				var array$1 = value.split(/\r\n|[\r\n]/), i$1, len, line, j, spaces = Number.MAX_VALUE, previousBase, sn;
				for (i$1 = 1, len = array$1.length; i$1 < len; ++i$1) {
					line = array$1[i$1];
					j = 0;
					while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) ++j;
					if (spaces > j) spaces = j;
				}
				if (typeof specialBase !== "undefined") {
					previousBase = base$1;
					if (array$1[1][spaces] === "*") specialBase += " ";
					base$1 = specialBase;
				} else {
					if (spaces & 1) --spaces;
					previousBase = base$1;
				}
				for (i$1 = 1, len = array$1.length; i$1 < len; ++i$1) {
					sn = toSourceNodeWhenNeeded(addIndent(array$1[i$1].slice(spaces)));
					array$1[i$1] = sourceMap ? sn.join("") : sn;
				}
				base$1 = previousBase;
				return array$1.join("\n");
			}
			function generateComment(comment, specialBase) {
				if (comment.type === "Line") if (endsWithLineTerminator(comment.value)) return "//" + comment.value;
				else {
					var result = "//" + comment.value;
					if (!preserveBlankLines) result += "\n";
					return result;
				}
				if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) return adjustMultilineComment("/*" + comment.value + "*/", specialBase);
				return "/*" + comment.value + "*/";
			}
			function addComments(stmt, result) {
				var i$1, len, comment, save, tailingToStatement, specialBase, fragment, extRange, range$1, prevRange, prefix, infix, suffix, count;
				if (stmt.leadingComments && stmt.leadingComments.length > 0) {
					save = result;
					if (preserveBlankLines) {
						comment = stmt.leadingComments[0];
						result = [];
						extRange = comment.extendedRange;
						range$1 = comment.range;
						prefix = sourceCode.substring(extRange[0], range$1[0]);
						count = (prefix.match(/\n/g) || []).length;
						if (count > 0) {
							result.push(stringRepeat("\n", count));
							result.push(addIndent(generateComment(comment)));
						} else {
							result.push(prefix);
							result.push(generateComment(comment));
						}
						prevRange = range$1;
						for (i$1 = 1, len = stmt.leadingComments.length; i$1 < len; i$1++) {
							comment = stmt.leadingComments[i$1];
							range$1 = comment.range;
							infix = sourceCode.substring(prevRange[1], range$1[0]);
							count = (infix.match(/\n/g) || []).length;
							result.push(stringRepeat("\n", count));
							result.push(addIndent(generateComment(comment)));
							prevRange = range$1;
						}
						suffix = sourceCode.substring(range$1[1], extRange[1]);
						count = (suffix.match(/\n/g) || []).length;
						result.push(stringRepeat("\n", count));
					} else {
						comment = stmt.leadingComments[0];
						result = [];
						if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) result.push("\n");
						result.push(generateComment(comment));
						if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) result.push("\n");
						for (i$1 = 1, len = stmt.leadingComments.length; i$1 < len; ++i$1) {
							comment = stmt.leadingComments[i$1];
							fragment = [generateComment(comment)];
							if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) fragment.push("\n");
							result.push(addIndent(fragment));
						}
					}
					result.push(addIndent(save));
				}
				if (stmt.trailingComments) if (preserveBlankLines) {
					comment = stmt.trailingComments[0];
					extRange = comment.extendedRange;
					range$1 = comment.range;
					prefix = sourceCode.substring(extRange[0], range$1[0]);
					count = (prefix.match(/\n/g) || []).length;
					if (count > 0) {
						result.push(stringRepeat("\n", count));
						result.push(addIndent(generateComment(comment)));
					} else {
						result.push(prefix);
						result.push(generateComment(comment));
					}
				} else {
					tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
					specialBase = stringRepeat(" ", calculateSpaces(toSourceNodeWhenNeeded([
						base$1,
						result,
						indent
					]).toString()));
					for (i$1 = 0, len = stmt.trailingComments.length; i$1 < len; ++i$1) {
						comment = stmt.trailingComments[i$1];
						if (tailingToStatement) {
							if (i$1 === 0) result = [result, indent];
							else result = [result, specialBase];
							result.push(generateComment(comment, specialBase));
						} else result = [result, addIndent(generateComment(comment))];
						if (i$1 !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) result = [result, "\n"];
					}
				}
				return result;
			}
			function generateBlankLines(start, end, result) {
				var j, newlineCount = 0;
				for (j = start; j < end; j++) if (sourceCode[j] === "\n") newlineCount++;
				for (j = 1; j < newlineCount; j++) result.push(newline);
			}
			function parenthesize(text$1, current, should) {
				if (current < should) return [
					"(",
					text$1,
					")"
				];
				return text$1;
			}
			function generateVerbatimString(string$2) {
				var i$1, iz, result = string$2.split(/\r\n|\n/);
				for (i$1 = 1, iz = result.length; i$1 < iz; i$1++) result[i$1] = newline + base$1 + result[i$1];
				return result;
			}
			function generateVerbatim(expr, precedence) {
				var verbatim = expr[extra.verbatim], result, prec;
				if (typeof verbatim === "string") result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
				else {
					result = generateVerbatimString(verbatim.content);
					prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;
					result = parenthesize(result, prec, precedence);
				}
				return toSourceNodeWhenNeeded(result, expr);
			}
			function CodeGenerator() {}
			CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
				var result, noLeadingComment, that = this;
				noLeadingComment = !extra.comment || !stmt.leadingComments;
				if (stmt.type === Syntax.BlockStatement && noLeadingComment) return [space, this.generateStatement(stmt, flags)];
				if (stmt.type === Syntax.EmptyStatement && noLeadingComment) return ";";
				withIndent(function() {
					result = [newline, addIndent(that.generateStatement(stmt, flags))];
				});
				return result;
			};
			CodeGenerator.prototype.maybeBlockSuffix = function(stmt, result) {
				var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
				if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) return [result, space];
				if (ends) return [result, base$1];
				return [
					result,
					newline,
					base$1
				];
			};
			function generateIdentifier(node) {
				return toSourceNodeWhenNeeded(node.name, node);
			}
			function generateAsyncPrefix(node, spaceRequired) {
				return node.async ? "async" + (spaceRequired ? noEmptySpace() : space) : "";
			}
			function generateStarSuffix(node) {
				return node.generator && !extra.moz.starlessGenerator ? "*" + space : "";
			}
			function generateMethodPrefix(prop) {
				var func = prop.value, prefix = "";
				if (func.async) prefix += generateAsyncPrefix(func, !prop.computed);
				if (func.generator) prefix += generateStarSuffix(func) ? "*" : "";
				return prefix;
			}
			CodeGenerator.prototype.generatePattern = function(node, precedence, flags) {
				if (node.type === Syntax.Identifier) return generateIdentifier(node);
				return this.generateExpression(node, precedence, flags);
			};
			CodeGenerator.prototype.generateFunctionParams = function(node) {
				var i$1, iz, result, hasDefault = false;
				if (node.type === Syntax.ArrowFunctionExpression && !node.rest && (!node.defaults || node.defaults.length === 0) && node.params.length === 1 && node.params[0].type === Syntax.Identifier) result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
				else {
					result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
					result.push("(");
					if (node.defaults) hasDefault = true;
					for (i$1 = 0, iz = node.params.length; i$1 < iz; ++i$1) {
						if (hasDefault && node.defaults[i$1]) result.push(this.generateAssignment(node.params[i$1], node.defaults[i$1], "=", Precedence.Assignment, E_TTT));
						else result.push(this.generatePattern(node.params[i$1], Precedence.Assignment, E_TTT));
						if (i$1 + 1 < iz) result.push("," + space);
					}
					if (node.rest) {
						if (node.params.length) result.push("," + space);
						result.push("...");
						result.push(generateIdentifier(node.rest));
					}
					result.push(")");
				}
				return result;
			};
			CodeGenerator.prototype.generateFunctionBody = function(node) {
				var result = this.generateFunctionParams(node), expr;
				if (node.type === Syntax.ArrowFunctionExpression) {
					result.push(space);
					result.push("=>");
				}
				if (node.expression) {
					result.push(space);
					expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);
					if (expr.toString().charAt(0) === "{") expr = [
						"(",
						expr,
						")"
					];
					result.push(expr);
				} else result.push(this.maybeBlock(node.body, S_TTFF));
				return result;
			};
			CodeGenerator.prototype.generateIterationForStatement = function(operator, stmt, flags) {
				var result = ["for" + (stmt.await ? noEmptySpace() + "await" : "") + space + "("], that = this;
				withIndent(function() {
					if (stmt.left.type === Syntax.VariableDeclaration) withIndent(function() {
						result.push(stmt.left.kind + noEmptySpace());
						result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
					});
					else result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
					result = join$1(result, operator);
					result = [join$1(result, that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)), ")"];
				});
				result.push(this.maybeBlock(stmt.body, flags));
				return result;
			};
			CodeGenerator.prototype.generatePropertyKey = function(expr, computed) {
				var result = [];
				if (computed) result.push("[");
				result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));
				if (computed) result.push("]");
				return result;
			};
			CodeGenerator.prototype.generateAssignment = function(left, right, operator, precedence, flags) {
				if (Precedence.Assignment < precedence) flags |= F_ALLOW_IN;
				return parenthesize([
					this.generateExpression(left, Precedence.Call, flags),
					space + operator + space,
					this.generateExpression(right, Precedence.Assignment, flags)
				], Precedence.Assignment, precedence);
			};
			CodeGenerator.prototype.semicolon = function(flags) {
				if (!semicolons && flags & F_SEMICOLON_OPT) return "";
				return ";";
			};
			CodeGenerator.Statement = {
				BlockStatement: function(stmt, flags) {
					var range$1, content, result = ["{", newline], that = this;
					withIndent(function() {
						if (stmt.body.length === 0 && preserveBlankLines) {
							range$1 = stmt.range;
							if (range$1[1] - range$1[0] > 2) {
								content = sourceCode.substring(range$1[0] + 1, range$1[1] - 1);
								if (content[0] === "\n") result = ["{"];
								result.push(content);
							}
						}
						var i$1, iz, fragment, bodyFlags = S_TFFF;
						if (flags & F_FUNC_BODY) bodyFlags |= F_DIRECTIVE_CTX;
						for (i$1 = 0, iz = stmt.body.length; i$1 < iz; ++i$1) {
							if (preserveBlankLines) {
								if (i$1 === 0) {
									if (stmt.body[0].leadingComments) {
										range$1 = stmt.body[0].leadingComments[0].extendedRange;
										content = sourceCode.substring(range$1[0], range$1[1]);
										if (content[0] === "\n") result = ["{"];
									}
									if (!stmt.body[0].leadingComments) generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
								}
								if (i$1 > 0) {
									if (!stmt.body[i$1 - 1].trailingComments && !stmt.body[i$1].leadingComments) generateBlankLines(stmt.body[i$1 - 1].range[1], stmt.body[i$1].range[0], result);
								}
							}
							if (i$1 === iz - 1) bodyFlags |= F_SEMICOLON_OPT;
							if (stmt.body[i$1].leadingComments && preserveBlankLines) fragment = that.generateStatement(stmt.body[i$1], bodyFlags);
							else fragment = addIndent(that.generateStatement(stmt.body[i$1], bodyFlags));
							result.push(fragment);
							if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) if (preserveBlankLines && i$1 < iz - 1) {
								if (!stmt.body[i$1 + 1].leadingComments) result.push(newline);
							} else result.push(newline);
							if (preserveBlankLines) {
								if (i$1 === iz - 1) {
									if (!stmt.body[i$1].trailingComments) generateBlankLines(stmt.body[i$1].range[1], stmt.range[1], result);
								}
							}
						}
					});
					result.push(addIndent("}"));
					return result;
				},
				BreakStatement: function(stmt, flags) {
					if (stmt.label) return "break " + stmt.label.name + this.semicolon(flags);
					return "break" + this.semicolon(flags);
				},
				ContinueStatement: function(stmt, flags) {
					if (stmt.label) return "continue " + stmt.label.name + this.semicolon(flags);
					return "continue" + this.semicolon(flags);
				},
				ClassBody: function(stmt, flags) {
					var result = ["{", newline], that = this;
					withIndent(function(indent$1) {
						var i$1, iz;
						for (i$1 = 0, iz = stmt.body.length; i$1 < iz; ++i$1) {
							result.push(indent$1);
							result.push(that.generateExpression(stmt.body[i$1], Precedence.Sequence, E_TTT));
							if (i$1 + 1 < iz) result.push(newline);
						}
					});
					if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) result.push(newline);
					result.push(base$1);
					result.push("}");
					return result;
				},
				ClassDeclaration: function(stmt, flags) {
					var result = ["class"], fragment;
					if (stmt.id) result = join$1(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));
					if (stmt.superClass) {
						fragment = join$1("extends", this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));
						result = join$1(result, fragment);
					}
					result.push(space);
					result.push(this.generateStatement(stmt.body, S_TFFT));
					return result;
				},
				DirectiveStatement: function(stmt, flags) {
					if (extra.raw && stmt.raw) return stmt.raw + this.semicolon(flags);
					return escapeDirective(stmt.directive) + this.semicolon(flags);
				},
				DoWhileStatement: function(stmt, flags) {
					var result = join$1("do", this.maybeBlock(stmt.body, S_TFFF));
					result = this.maybeBlockSuffix(stmt.body, result);
					return join$1(result, [
						"while" + space + "(",
						this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
						")" + this.semicolon(flags)
					]);
				},
				CatchClause: function(stmt, flags) {
					var result, that = this;
					withIndent(function() {
						var guard;
						if (stmt.param) {
							result = [
								"catch" + space + "(",
								that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
								")"
							];
							if (stmt.guard) {
								guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
								result.splice(2, 0, " if ", guard);
							}
						} else result = ["catch"];
					});
					result.push(this.maybeBlock(stmt.body, S_TFFF));
					return result;
				},
				DebuggerStatement: function(stmt, flags) {
					return "debugger" + this.semicolon(flags);
				},
				EmptyStatement: function(stmt, flags) {
					return ";";
				},
				ExportDefaultDeclaration: function(stmt, flags) {
					var result = ["export"], bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;
					result = join$1(result, "default");
					if (isStatement(stmt.declaration)) result = join$1(result, this.generateStatement(stmt.declaration, bodyFlags));
					else result = join$1(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
					return result;
				},
				ExportNamedDeclaration: function(stmt, flags) {
					var result = ["export"], bodyFlags, that = this;
					bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;
					if (stmt.declaration) return join$1(result, this.generateStatement(stmt.declaration, bodyFlags));
					if (stmt.specifiers) {
						if (stmt.specifiers.length === 0) result = join$1(result, "{" + space + "}");
						else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) result = join$1(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
						else {
							result = join$1(result, "{");
							withIndent(function(indent$1) {
								var i$1, iz;
								result.push(newline);
								for (i$1 = 0, iz = stmt.specifiers.length; i$1 < iz; ++i$1) {
									result.push(indent$1);
									result.push(that.generateExpression(stmt.specifiers[i$1], Precedence.Sequence, E_TTT));
									if (i$1 + 1 < iz) result.push("," + newline);
								}
							});
							if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) result.push(newline);
							result.push(base$1 + "}");
						}
						if (stmt.source) result = join$1(result, [
							"from" + space,
							this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
							this.semicolon(flags)
						]);
						else result.push(this.semicolon(flags));
					}
					return result;
				},
				ExportAllDeclaration: function(stmt, flags) {
					return [
						"export" + space,
						"*" + space,
						"from" + space,
						this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
						this.semicolon(flags)
					];
				},
				ExpressionStatement: function(stmt, flags) {
					var result, fragment;
					function isClassPrefixed(fragment$1) {
						var code;
						if (fragment$1.slice(0, 5) !== "class") return false;
						code = fragment$1.charCodeAt(5);
						return code === 123 || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);
					}
					function isFunctionPrefixed(fragment$1) {
						var code;
						if (fragment$1.slice(0, 8) !== "function") return false;
						code = fragment$1.charCodeAt(8);
						return code === 40 || esutils.code.isWhiteSpace(code) || code === 42 || esutils.code.isLineTerminator(code);
					}
					function isAsyncPrefixed(fragment$1) {
						var code, i$1, iz;
						if (fragment$1.slice(0, 5) !== "async") return false;
						if (!esutils.code.isWhiteSpace(fragment$1.charCodeAt(5))) return false;
						for (i$1 = 6, iz = fragment$1.length; i$1 < iz; ++i$1) if (!esutils.code.isWhiteSpace(fragment$1.charCodeAt(i$1))) break;
						if (i$1 === iz) return false;
						if (fragment$1.slice(i$1, i$1 + 8) !== "function") return false;
						code = fragment$1.charCodeAt(i$1 + 8);
						return code === 40 || esutils.code.isWhiteSpace(code) || code === 42 || esutils.code.isLineTerminator(code);
					}
					result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
					fragment = toSourceNodeWhenNeeded(result).toString();
					if (fragment.charCodeAt(0) === 123 || isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || directive && flags & F_DIRECTIVE_CTX && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === "string") result = [
						"(",
						result,
						")" + this.semicolon(flags)
					];
					else result.push(this.semicolon(flags));
					return result;
				},
				ImportDeclaration: function(stmt, flags) {
					var result, cursor, that = this;
					if (stmt.specifiers.length === 0) return [
						"import",
						space,
						this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
						this.semicolon(flags)
					];
					result = ["import"];
					cursor = 0;
					if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
						result = join$1(result, [this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)]);
						++cursor;
					}
					if (stmt.specifiers[cursor]) {
						if (cursor !== 0) result.push(",");
						if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) result = join$1(result, [space, this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)]);
						else {
							result.push(space + "{");
							if (stmt.specifiers.length - cursor === 1) {
								result.push(space);
								result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
								result.push(space + "}" + space);
							} else {
								withIndent(function(indent$1) {
									var i$1, iz;
									result.push(newline);
									for (i$1 = cursor, iz = stmt.specifiers.length; i$1 < iz; ++i$1) {
										result.push(indent$1);
										result.push(that.generateExpression(stmt.specifiers[i$1], Precedence.Sequence, E_TTT));
										if (i$1 + 1 < iz) result.push("," + newline);
									}
								});
								if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) result.push(newline);
								result.push(base$1 + "}" + space);
							}
						}
					}
					result = join$1(result, [
						"from" + space,
						this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
						this.semicolon(flags)
					]);
					return result;
				},
				VariableDeclarator: function(stmt, flags) {
					var itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;
					if (stmt.init) return [
						this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
						space,
						"=",
						space,
						this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
					];
					return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
				},
				VariableDeclaration: function(stmt, flags) {
					var result, i$1, iz, node, bodyFlags, that = this;
					result = [stmt.kind];
					bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;
					function block() {
						node = stmt.declarations[0];
						if (extra.comment && node.leadingComments) {
							result.push("\n");
							result.push(addIndent(that.generateStatement(node, bodyFlags)));
						} else {
							result.push(noEmptySpace());
							result.push(that.generateStatement(node, bodyFlags));
						}
						for (i$1 = 1, iz = stmt.declarations.length; i$1 < iz; ++i$1) {
							node = stmt.declarations[i$1];
							if (extra.comment && node.leadingComments) {
								result.push("," + newline);
								result.push(addIndent(that.generateStatement(node, bodyFlags)));
							} else {
								result.push("," + space);
								result.push(that.generateStatement(node, bodyFlags));
							}
						}
					}
					if (stmt.declarations.length > 1) withIndent(block);
					else block();
					result.push(this.semicolon(flags));
					return result;
				},
				ThrowStatement: function(stmt, flags) {
					return [join$1("throw", this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];
				},
				TryStatement: function(stmt, flags) {
					var result = ["try", this.maybeBlock(stmt.block, S_TFFF)], i$1, iz, guardedHandlers;
					result = this.maybeBlockSuffix(stmt.block, result);
					if (stmt.handlers) for (i$1 = 0, iz = stmt.handlers.length; i$1 < iz; ++i$1) {
						result = join$1(result, this.generateStatement(stmt.handlers[i$1], S_TFFF));
						if (stmt.finalizer || i$1 + 1 !== iz) result = this.maybeBlockSuffix(stmt.handlers[i$1].body, result);
					}
					else {
						guardedHandlers = stmt.guardedHandlers || [];
						for (i$1 = 0, iz = guardedHandlers.length; i$1 < iz; ++i$1) {
							result = join$1(result, this.generateStatement(guardedHandlers[i$1], S_TFFF));
							if (stmt.finalizer || i$1 + 1 !== iz) result = this.maybeBlockSuffix(guardedHandlers[i$1].body, result);
						}
						if (stmt.handler) if (Array.isArray(stmt.handler)) for (i$1 = 0, iz = stmt.handler.length; i$1 < iz; ++i$1) {
							result = join$1(result, this.generateStatement(stmt.handler[i$1], S_TFFF));
							if (stmt.finalizer || i$1 + 1 !== iz) result = this.maybeBlockSuffix(stmt.handler[i$1].body, result);
						}
						else {
							result = join$1(result, this.generateStatement(stmt.handler, S_TFFF));
							if (stmt.finalizer) result = this.maybeBlockSuffix(stmt.handler.body, result);
						}
					}
					if (stmt.finalizer) result = join$1(result, ["finally", this.maybeBlock(stmt.finalizer, S_TFFF)]);
					return result;
				},
				SwitchStatement: function(stmt, flags) {
					var result, fragment, i$1, iz, bodyFlags, that = this;
					withIndent(function() {
						result = [
							"switch" + space + "(",
							that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
							")" + space + "{" + newline
						];
					});
					if (stmt.cases) {
						bodyFlags = S_TFFF;
						for (i$1 = 0, iz = stmt.cases.length; i$1 < iz; ++i$1) {
							if (i$1 === iz - 1) bodyFlags |= F_SEMICOLON_OPT;
							fragment = addIndent(this.generateStatement(stmt.cases[i$1], bodyFlags));
							result.push(fragment);
							if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) result.push(newline);
						}
					}
					result.push(addIndent("}"));
					return result;
				},
				SwitchCase: function(stmt, flags) {
					var result, fragment, i$1, iz, bodyFlags, that = this;
					withIndent(function() {
						if (stmt.test) result = [join$1("case", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)), ":"];
						else result = ["default:"];
						i$1 = 0;
						iz = stmt.consequent.length;
						if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
							fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
							result.push(fragment);
							i$1 = 1;
						}
						if (i$1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) result.push(newline);
						bodyFlags = S_TFFF;
						for (; i$1 < iz; ++i$1) {
							if (i$1 === iz - 1 && flags & F_SEMICOLON_OPT) bodyFlags |= F_SEMICOLON_OPT;
							fragment = addIndent(that.generateStatement(stmt.consequent[i$1], bodyFlags));
							result.push(fragment);
							if (i$1 + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) result.push(newline);
						}
					});
					return result;
				},
				IfStatement: function(stmt, flags) {
					var result, bodyFlags, semicolonOptional, that = this;
					withIndent(function() {
						result = [
							"if" + space + "(",
							that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
							")"
						];
					});
					semicolonOptional = flags & F_SEMICOLON_OPT;
					bodyFlags = S_TFFF;
					if (semicolonOptional) bodyFlags |= F_SEMICOLON_OPT;
					if (stmt.alternate) {
						result.push(this.maybeBlock(stmt.consequent, S_TFFF));
						result = this.maybeBlockSuffix(stmt.consequent, result);
						if (stmt.alternate.type === Syntax.IfStatement) result = join$1(result, ["else ", this.generateStatement(stmt.alternate, bodyFlags)]);
						else result = join$1(result, join$1("else", this.maybeBlock(stmt.alternate, bodyFlags)));
					} else result.push(this.maybeBlock(stmt.consequent, bodyFlags));
					return result;
				},
				ForStatement: function(stmt, flags) {
					var result, that = this;
					withIndent(function() {
						result = ["for" + space + "("];
						if (stmt.init) if (stmt.init.type === Syntax.VariableDeclaration) result.push(that.generateStatement(stmt.init, S_FFFF));
						else {
							result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
							result.push(";");
						}
						else result.push(";");
						if (stmt.test) {
							result.push(space);
							result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
							result.push(";");
						} else result.push(";");
						if (stmt.update) {
							result.push(space);
							result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
							result.push(")");
						} else result.push(")");
					});
					result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
					return result;
				},
				ForInStatement: function(stmt, flags) {
					return this.generateIterationForStatement("in", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
				},
				ForOfStatement: function(stmt, flags) {
					return this.generateIterationForStatement("of", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
				},
				LabeledStatement: function(stmt, flags) {
					return [stmt.label.name + ":", this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
				},
				Program: function(stmt, flags) {
					var result, fragment, i$1, iz = stmt.body.length, bodyFlags;
					result = [safeConcatenation && iz > 0 ? "\n" : ""];
					bodyFlags = S_TFTF;
					for (i$1 = 0; i$1 < iz; ++i$1) {
						if (!safeConcatenation && i$1 === iz - 1) bodyFlags |= F_SEMICOLON_OPT;
						if (preserveBlankLines) {
							if (i$1 === 0) {
								if (!stmt.body[0].leadingComments) generateBlankLines(stmt.range[0], stmt.body[i$1].range[0], result);
							}
							if (i$1 > 0) {
								if (!stmt.body[i$1 - 1].trailingComments && !stmt.body[i$1].leadingComments) generateBlankLines(stmt.body[i$1 - 1].range[1], stmt.body[i$1].range[0], result);
							}
						}
						fragment = addIndent(this.generateStatement(stmt.body[i$1], bodyFlags));
						result.push(fragment);
						if (i$1 + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) if (preserveBlankLines) {
							if (!stmt.body[i$1 + 1].leadingComments) result.push(newline);
						} else result.push(newline);
						if (preserveBlankLines) {
							if (i$1 === iz - 1) {
								if (!stmt.body[i$1].trailingComments) generateBlankLines(stmt.body[i$1].range[1], stmt.range[1], result);
							}
						}
					}
					return result;
				},
				FunctionDeclaration: function(stmt, flags) {
					return [
						generateAsyncPrefix(stmt, true),
						"function",
						generateStarSuffix(stmt) || noEmptySpace(),
						stmt.id ? generateIdentifier(stmt.id) : "",
						this.generateFunctionBody(stmt)
					];
				},
				ReturnStatement: function(stmt, flags) {
					if (stmt.argument) return [join$1("return", this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];
					return ["return" + this.semicolon(flags)];
				},
				WhileStatement: function(stmt, flags) {
					var result, that = this;
					withIndent(function() {
						result = [
							"while" + space + "(",
							that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
							")"
						];
					});
					result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
					return result;
				},
				WithStatement: function(stmt, flags) {
					var result, that = this;
					withIndent(function() {
						result = [
							"with" + space + "(",
							that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
							")"
						];
					});
					result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
					return result;
				}
			};
			merge$1(CodeGenerator.prototype, CodeGenerator.Statement);
			CodeGenerator.Expression = {
				SequenceExpression: function(expr, precedence, flags) {
					var result, i$1, iz;
					if (Precedence.Sequence < precedence) flags |= F_ALLOW_IN;
					result = [];
					for (i$1 = 0, iz = expr.expressions.length; i$1 < iz; ++i$1) {
						result.push(this.generateExpression(expr.expressions[i$1], Precedence.Assignment, flags));
						if (i$1 + 1 < iz) result.push("," + space);
					}
					return parenthesize(result, Precedence.Sequence, precedence);
				},
				AssignmentExpression: function(expr, precedence, flags) {
					return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
				},
				ArrowFunctionExpression: function(expr, precedence, flags) {
					return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
				},
				ConditionalExpression: function(expr, precedence, flags) {
					if (Precedence.Conditional < precedence) flags |= F_ALLOW_IN;
					return parenthesize([
						this.generateExpression(expr.test, Precedence.Coalesce, flags),
						space + "?" + space,
						this.generateExpression(expr.consequent, Precedence.Assignment, flags),
						space + ":" + space,
						this.generateExpression(expr.alternate, Precedence.Assignment, flags)
					], Precedence.Conditional, precedence);
				},
				LogicalExpression: function(expr, precedence, flags) {
					if (expr.operator === "??") flags |= F_FOUND_COALESCE;
					return this.BinaryExpression(expr, precedence, flags);
				},
				BinaryExpression: function(expr, precedence, flags) {
					var result, leftPrecedence, rightPrecedence, currentPrecedence = BinaryPrecedence[expr.operator], fragment, leftSource;
					leftPrecedence = expr.operator === "**" ? Precedence.Postfix : currentPrecedence;
					rightPrecedence = expr.operator === "**" ? currentPrecedence : currentPrecedence + 1;
					if (currentPrecedence < precedence) flags |= F_ALLOW_IN;
					fragment = this.generateExpression(expr.left, leftPrecedence, flags);
					leftSource = fragment.toString();
					if (leftSource.charCodeAt(leftSource.length - 1) === 47 && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) result = [
						fragment,
						noEmptySpace(),
						expr.operator
					];
					else result = join$1(fragment, expr.operator);
					fragment = this.generateExpression(expr.right, rightPrecedence, flags);
					if (expr.operator === "/" && fragment.toString().charAt(0) === "/" || expr.operator.slice(-1) === "<" && fragment.toString().slice(0, 3) === "!--") {
						result.push(noEmptySpace());
						result.push(fragment);
					} else result = join$1(result, fragment);
					if (expr.operator === "in" && !(flags & F_ALLOW_IN)) return [
						"(",
						result,
						")"
					];
					if ((expr.operator === "||" || expr.operator === "&&") && flags & F_FOUND_COALESCE) return [
						"(",
						result,
						")"
					];
					return parenthesize(result, currentPrecedence, precedence);
				},
				CallExpression: function(expr, precedence, flags) {
					var result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)], i$1, iz;
					if (expr.optional) result.push("?.");
					result.push("(");
					for (i$1 = 0, iz = expr["arguments"].length; i$1 < iz; ++i$1) {
						result.push(this.generateExpression(expr["arguments"][i$1], Precedence.Assignment, E_TTT));
						if (i$1 + 1 < iz) result.push("," + space);
					}
					result.push(")");
					if (!(flags & F_ALLOW_CALL)) return [
						"(",
						result,
						")"
					];
					return parenthesize(result, Precedence.Call, precedence);
				},
				ChainExpression: function(expr, precedence, flags) {
					if (Precedence.OptionalChaining < precedence) flags |= F_ALLOW_CALL;
					return parenthesize(this.generateExpression(expr.expression, Precedence.OptionalChaining, flags), Precedence.OptionalChaining, precedence);
				},
				NewExpression: function(expr, precedence, flags) {
					var result, length = expr["arguments"].length, i$1, iz, itemFlags = flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0 ? E_TFT : E_TFF;
					result = join$1("new", this.generateExpression(expr.callee, Precedence.New, itemFlags));
					if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
						result.push("(");
						for (i$1 = 0, iz = length; i$1 < iz; ++i$1) {
							result.push(this.generateExpression(expr["arguments"][i$1], Precedence.Assignment, E_TTT));
							if (i$1 + 1 < iz) result.push("," + space);
						}
						result.push(")");
					}
					return parenthesize(result, Precedence.New, precedence);
				},
				MemberExpression: function(expr, precedence, flags) {
					var result = [this.generateExpression(expr.object, Precedence.Call, flags & F_ALLOW_CALL ? E_TTF : E_TFF)], fragment;
					if (expr.computed) {
						if (expr.optional) result.push("?.");
						result.push("[");
						result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
						result.push("]");
					} else {
						if (!expr.optional && expr.object.type === Syntax.Literal && typeof expr.object.value === "number") {
							fragment = toSourceNodeWhenNeeded(result).toString();
							if (fragment.indexOf(".") < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)) result.push(" ");
						}
						result.push(expr.optional ? "?." : ".");
						result.push(generateIdentifier(expr.property));
					}
					return parenthesize(result, Precedence.Member, precedence);
				},
				MetaProperty: function(expr, precedence, flags) {
					var result = [];
					result.push(typeof expr.meta === "string" ? expr.meta : generateIdentifier(expr.meta));
					result.push(".");
					result.push(typeof expr.property === "string" ? expr.property : generateIdentifier(expr.property));
					return parenthesize(result, Precedence.Member, precedence);
				},
				UnaryExpression: function(expr, precedence, flags) {
					var result, fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT), rightCharCode, leftSource, leftCharCode;
					if (space === "") result = join$1(expr.operator, fragment);
					else {
						result = [expr.operator];
						if (expr.operator.length > 2) result = join$1(result, fragment);
						else {
							leftSource = toSourceNodeWhenNeeded(result).toString();
							leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
							rightCharCode = fragment.toString().charCodeAt(0);
							if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode)) {
								result.push(noEmptySpace());
								result.push(fragment);
							} else result.push(fragment);
						}
					}
					return parenthesize(result, Precedence.Unary, precedence);
				},
				YieldExpression: function(expr, precedence, flags) {
					var result;
					if (expr.delegate) result = "yield*";
					else result = "yield";
					if (expr.argument) result = join$1(result, this.generateExpression(expr.argument, Precedence.Yield, E_TTT));
					return parenthesize(result, Precedence.Yield, precedence);
				},
				AwaitExpression: function(expr, precedence, flags) {
					return parenthesize(join$1(expr.all ? "await*" : "await", this.generateExpression(expr.argument, Precedence.Await, E_TTT)), Precedence.Await, precedence);
				},
				UpdateExpression: function(expr, precedence, flags) {
					if (expr.prefix) return parenthesize([expr.operator, this.generateExpression(expr.argument, Precedence.Unary, E_TTT)], Precedence.Unary, precedence);
					return parenthesize([this.generateExpression(expr.argument, Precedence.Postfix, E_TTT), expr.operator], Precedence.Postfix, precedence);
				},
				FunctionExpression: function(expr, precedence, flags) {
					var result = [generateAsyncPrefix(expr, true), "function"];
					if (expr.id) {
						result.push(generateStarSuffix(expr) || noEmptySpace());
						result.push(generateIdentifier(expr.id));
					} else result.push(generateStarSuffix(expr) || space);
					result.push(this.generateFunctionBody(expr));
					return result;
				},
				ArrayPattern: function(expr, precedence, flags) {
					return this.ArrayExpression(expr, precedence, flags, true);
				},
				ArrayExpression: function(expr, precedence, flags, isPattern) {
					var result, multiline, that = this;
					if (!expr.elements.length) return "[]";
					multiline = isPattern ? false : expr.elements.length > 1;
					result = ["[", multiline ? newline : ""];
					withIndent(function(indent$1) {
						var i$1, iz;
						for (i$1 = 0, iz = expr.elements.length; i$1 < iz; ++i$1) {
							if (!expr.elements[i$1]) {
								if (multiline) result.push(indent$1);
								if (i$1 + 1 === iz) result.push(",");
							} else {
								result.push(multiline ? indent$1 : "");
								result.push(that.generateExpression(expr.elements[i$1], Precedence.Assignment, E_TTT));
							}
							if (i$1 + 1 < iz) result.push("," + (multiline ? newline : space));
						}
					});
					if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) result.push(newline);
					result.push(multiline ? base$1 : "");
					result.push("]");
					return result;
				},
				RestElement: function(expr, precedence, flags) {
					return "..." + this.generatePattern(expr.argument);
				},
				ClassExpression: function(expr, precedence, flags) {
					var result = ["class"], fragment;
					if (expr.id) result = join$1(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
					if (expr.superClass) {
						fragment = join$1("extends", this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));
						result = join$1(result, fragment);
					}
					result.push(space);
					result.push(this.generateStatement(expr.body, S_TFFT));
					return result;
				},
				MethodDefinition: function(expr, precedence, flags) {
					var result, fragment;
					if (expr["static"]) result = ["static" + space];
					else result = [];
					if (expr.kind === "get" || expr.kind === "set") fragment = [join$1(expr.kind, this.generatePropertyKey(expr.key, expr.computed)), this.generateFunctionBody(expr.value)];
					else fragment = [
						generateMethodPrefix(expr),
						this.generatePropertyKey(expr.key, expr.computed),
						this.generateFunctionBody(expr.value)
					];
					return join$1(result, fragment);
				},
				Property: function(expr, precedence, flags) {
					if (expr.kind === "get" || expr.kind === "set") return [
						expr.kind,
						noEmptySpace(),
						this.generatePropertyKey(expr.key, expr.computed),
						this.generateFunctionBody(expr.value)
					];
					if (expr.shorthand) {
						if (expr.value.type === "AssignmentPattern") return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);
						return this.generatePropertyKey(expr.key, expr.computed);
					}
					if (expr.method) return [
						generateMethodPrefix(expr),
						this.generatePropertyKey(expr.key, expr.computed),
						this.generateFunctionBody(expr.value)
					];
					return [
						this.generatePropertyKey(expr.key, expr.computed),
						":" + space,
						this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
					];
				},
				ObjectExpression: function(expr, precedence, flags) {
					var multiline, result, fragment, that = this;
					if (!expr.properties.length) return "{}";
					multiline = expr.properties.length > 1;
					withIndent(function() {
						fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
					});
					if (!multiline) {
						if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) return [
							"{",
							space,
							fragment,
							space,
							"}"
						];
					}
					withIndent(function(indent$1) {
						var i$1, iz;
						result = [
							"{",
							newline,
							indent$1,
							fragment
						];
						if (multiline) {
							result.push("," + newline);
							for (i$1 = 1, iz = expr.properties.length; i$1 < iz; ++i$1) {
								result.push(indent$1);
								result.push(that.generateExpression(expr.properties[i$1], Precedence.Sequence, E_TTT));
								if (i$1 + 1 < iz) result.push("," + newline);
							}
						}
					});
					if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) result.push(newline);
					result.push(base$1);
					result.push("}");
					return result;
				},
				AssignmentPattern: function(expr, precedence, flags) {
					return this.generateAssignment(expr.left, expr.right, "=", precedence, flags);
				},
				ObjectPattern: function(expr, precedence, flags) {
					var result, i$1, iz, multiline, property, that = this;
					if (!expr.properties.length) return "{}";
					multiline = false;
					if (expr.properties.length === 1) {
						property = expr.properties[0];
						if (property.type === Syntax.Property && property.value.type !== Syntax.Identifier) multiline = true;
					} else for (i$1 = 0, iz = expr.properties.length; i$1 < iz; ++i$1) {
						property = expr.properties[i$1];
						if (property.type === Syntax.Property && !property.shorthand) {
							multiline = true;
							break;
						}
					}
					result = ["{", multiline ? newline : ""];
					withIndent(function(indent$1) {
						var i$2, iz$1;
						for (i$2 = 0, iz$1 = expr.properties.length; i$2 < iz$1; ++i$2) {
							result.push(multiline ? indent$1 : "");
							result.push(that.generateExpression(expr.properties[i$2], Precedence.Sequence, E_TTT));
							if (i$2 + 1 < iz$1) result.push("," + (multiline ? newline : space));
						}
					});
					if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) result.push(newline);
					result.push(multiline ? base$1 : "");
					result.push("}");
					return result;
				},
				ThisExpression: function(expr, precedence, flags) {
					return "this";
				},
				Super: function(expr, precedence, flags) {
					return "super";
				},
				Identifier: function(expr, precedence, flags) {
					return generateIdentifier(expr);
				},
				ImportDefaultSpecifier: function(expr, precedence, flags) {
					return generateIdentifier(expr.id || expr.local);
				},
				ImportNamespaceSpecifier: function(expr, precedence, flags) {
					var result = ["*"];
					var id = expr.id || expr.local;
					if (id) result.push(space + "as" + noEmptySpace() + generateIdentifier(id));
					return result;
				},
				ImportSpecifier: function(expr, precedence, flags) {
					var imported = expr.imported;
					var result = [imported.name];
					var local = expr.local;
					if (local && local.name !== imported.name) result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(local));
					return result;
				},
				ExportSpecifier: function(expr, precedence, flags) {
					var local = expr.local;
					var result = [local.name];
					var exported = expr.exported;
					if (exported && exported.name !== local.name) result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(exported));
					return result;
				},
				Literal: function(expr, precedence, flags) {
					var raw;
					if (expr.hasOwnProperty("raw") && parse$5 && extra.raw) try {
						raw = parse$5(expr.raw).body[0].expression;
						if (raw.type === Syntax.Literal) {
							if (raw.value === expr.value) return expr.raw;
						}
					} catch (e$1) {}
					if (expr.regex) return "/" + expr.regex.pattern + "/" + expr.regex.flags;
					if (typeof expr.value === "bigint") return expr.value.toString() + "n";
					if (expr.bigint) return expr.bigint + "n";
					if (expr.value === null) return "null";
					if (typeof expr.value === "string") return escapeString(expr.value);
					if (typeof expr.value === "number") return generateNumber(expr.value);
					if (typeof expr.value === "boolean") return expr.value ? "true" : "false";
					return generateRegExp(expr.value);
				},
				GeneratorExpression: function(expr, precedence, flags) {
					return this.ComprehensionExpression(expr, precedence, flags);
				},
				ComprehensionExpression: function(expr, precedence, flags) {
					var result, i$1, iz, fragment, that = this;
					result = expr.type === Syntax.GeneratorExpression ? ["("] : ["["];
					if (extra.moz.comprehensionExpressionStartsWithAssignment) {
						fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
						result.push(fragment);
					}
					if (expr.blocks) withIndent(function() {
						for (i$1 = 0, iz = expr.blocks.length; i$1 < iz; ++i$1) {
							fragment = that.generateExpression(expr.blocks[i$1], Precedence.Sequence, E_TTT);
							if (i$1 > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) result = join$1(result, fragment);
							else result.push(fragment);
						}
					});
					if (expr.filter) {
						result = join$1(result, "if" + space);
						fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
						result = join$1(result, [
							"(",
							fragment,
							")"
						]);
					}
					if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
						fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
						result = join$1(result, fragment);
					}
					result.push(expr.type === Syntax.GeneratorExpression ? ")" : "]");
					return result;
				},
				ComprehensionBlock: function(expr, precedence, flags) {
					var fragment;
					if (expr.left.type === Syntax.VariableDeclaration) fragment = [
						expr.left.kind,
						noEmptySpace(),
						this.generateStatement(expr.left.declarations[0], S_FFFF)
					];
					else fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
					fragment = join$1(fragment, expr.of ? "of" : "in");
					fragment = join$1(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));
					return [
						"for" + space + "(",
						fragment,
						")"
					];
				},
				SpreadElement: function(expr, precedence, flags) {
					return ["...", this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)];
				},
				TaggedTemplateExpression: function(expr, precedence, flags) {
					var itemFlags = E_TTF;
					if (!(flags & F_ALLOW_CALL)) itemFlags = E_TFF;
					return parenthesize([this.generateExpression(expr.tag, Precedence.Call, itemFlags), this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)], Precedence.TaggedTemplate, precedence);
				},
				TemplateElement: function(expr, precedence, flags) {
					return expr.value.raw;
				},
				TemplateLiteral: function(expr, precedence, flags) {
					var result = ["`"], i$1, iz;
					for (i$1 = 0, iz = expr.quasis.length; i$1 < iz; ++i$1) {
						result.push(this.generateExpression(expr.quasis[i$1], Precedence.Primary, E_TTT));
						if (i$1 + 1 < iz) {
							result.push("${" + space);
							result.push(this.generateExpression(expr.expressions[i$1], Precedence.Sequence, E_TTT));
							result.push(space + "}");
						}
					}
					result.push("`");
					return result;
				},
				ModuleSpecifier: function(expr, precedence, flags) {
					return this.Literal(expr, precedence, flags);
				},
				ImportExpression: function(expr, precedence, flag) {
					return parenthesize([
						"import(",
						this.generateExpression(expr.source, Precedence.Assignment, E_TTT),
						")"
					], Precedence.Call, precedence);
				}
			};
			merge$1(CodeGenerator.prototype, CodeGenerator.Expression);
			CodeGenerator.prototype.generateExpression = function(expr, precedence, flags) {
				var result, type$2 = expr.type || Syntax.Property;
				if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) return generateVerbatim(expr, precedence);
				result = this[type$2](expr, precedence, flags);
				if (extra.comment) result = addComments(expr, result);
				return toSourceNodeWhenNeeded(result, expr);
			};
			CodeGenerator.prototype.generateStatement = function(stmt, flags) {
				var result = this[stmt.type](stmt, flags), fragment;
				if (extra.comment) result = addComments(stmt, result);
				fragment = toSourceNodeWhenNeeded(result).toString();
				if (stmt.type === Syntax.Program && !safeConcatenation && newline === "" && fragment.charAt(fragment.length - 1) === "\n") result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, "") : fragment.replace(/\s+$/, "");
				return toSourceNodeWhenNeeded(result, stmt);
			};
			function generateInternal(node) {
				var codegen = new CodeGenerator();
				if (isStatement(node)) return codegen.generateStatement(node, S_TFFF);
				if (isExpression(node)) return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
				throw new Error("Unknown node type: " + node.type);
			}
			function generate(node, options$1) {
				var defaultOptions$1 = getDefaultOptions(), result, pair;
				if (options$1 != null) {
					if (typeof options$1.indent === "string") defaultOptions$1.format.indent.style = options$1.indent;
					if (typeof options$1.base === "number") defaultOptions$1.format.indent.base = options$1.base;
					options$1 = updateDeeply(defaultOptions$1, options$1);
					indent = options$1.format.indent.style;
					if (typeof options$1.base === "string") base$1 = options$1.base;
					else base$1 = stringRepeat(indent, options$1.format.indent.base);
				} else {
					options$1 = defaultOptions$1;
					indent = options$1.format.indent.style;
					base$1 = stringRepeat(indent, options$1.format.indent.base);
				}
				json = options$1.format.json;
				renumber = options$1.format.renumber;
				hexadecimal = json ? false : options$1.format.hexadecimal;
				quotes = json ? "double" : options$1.format.quotes;
				escapeless = options$1.format.escapeless;
				newline = options$1.format.newline;
				space = options$1.format.space;
				if (options$1.format.compact) newline = space = indent = base$1 = "";
				parentheses = options$1.format.parentheses;
				semicolons = options$1.format.semicolons;
				safeConcatenation = options$1.format.safeConcatenation;
				directive = options$1.directive;
				parse$5 = json ? null : options$1.parse;
				sourceMap = options$1.sourceMap;
				sourceCode = options$1.sourceCode;
				preserveBlankLines = options$1.format.preserveBlankLines && sourceCode !== null;
				extra = options$1;
				if (sourceMap) if (!exports.browser) SourceNode$1 = require_source_map().SourceNode;
				else SourceNode$1 = global.sourceMap.SourceNode;
				result = generateInternal(node);
				if (!sourceMap) {
					pair = {
						code: result.toString(),
						map: null
					};
					return options$1.sourceMapWithCode ? pair : pair.code;
				}
				pair = result.toStringWithSourceMap({
					file: options$1.file,
					sourceRoot: options$1.sourceMapRoot
				});
				if (options$1.sourceContent) pair.map.setSourceContent(options$1.sourceMap, options$1.sourceContent);
				if (options$1.sourceMapWithCode) return pair;
				return pair.map.toString();
			}
			FORMAT_MINIFY = {
				indent: {
					style: "",
					base: 0
				},
				renumber: true,
				hexadecimal: true,
				quotes: "auto",
				escapeless: true,
				compact: true,
				parentheses: false,
				semicolons: false
			};
			FORMAT_DEFAULTS = getDefaultOptions().format;
			exports.version = require_package().version;
			exports.generate = generate;
			exports.attachComments = estraverse.attachComments;
			exports.Precedence = updateDeeply({}, Precedence);
			exports.browser = false;
			exports.FORMAT_MINIFY = FORMAT_MINIFY;
			exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
		})();
	})))());
	var noiseGLSL = "// Based on https://github.com/patriciogonzalezvivo/lygia/blob/main/generative/noise.glsl (MIT)\n// Adapted for use in p5.strands\n\nvec2 random2(vec2 st) {\n  st = vec2(dot(st, vec2(127.1, 311.7)),\n            dot(st, vec2(269.5, 183.3)));\n  return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nfloat baseNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  vec2 a = random2(i);\n  vec2 b = random2(i + vec2(1.0, 0.0));\n  vec2 c = random2(i + vec2(0.0, 1.0));\n  vec2 d = random2(i + vec2(1.0, 1.0));\n\n  vec2 u = f * f * (3.0 - 2.0 * f);\n\n  return mix(mix(dot(a, f - vec2(0.0, 0.0)), \n                 dot(b, f - vec2(1.0, 0.0)), u.x),\n             mix(dot(c, f - vec2(0.0, 1.0)), \n                 dot(d, f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// Fractal noise using 4 octaves\nfloat noise(vec2 st) {\n  float result = 0.0;\n  float amplitude = 1.0;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    result += amplitude * baseNoise(st * frequency);\n    frequency *= 2.0;\n    amplitude *= 0.5;\n  }\n\n  return result;\n}\n";
	function shadergenerator(p5$2, fn$1) {
		let GLOBAL_SHADER;
		let BRANCH;
		const oldModify = p5$2.Shader.prototype.modify;
		p5$2.Shader.prototype.modify = function(shaderModifier, scope = {}) {
			if (shaderModifier instanceof Function) {
				const options$1 = { srcLocations: false };
				let generatorFunction;
				{
					const ast = parse(`(${shaderModifier.toString()})`, {
						ecmaVersion: 2021,
						locations: options$1.srcLocations
					});
					ancestor(ast, ASTCallbacks, void 0, { varyings: {} });
					const transpiledSource = import_escodegen.generate(ast);
					const scopeKeys = Object.keys(scope);
					const internalGeneratorFunction = new Function("__p5", ...scopeKeys, transpiledSource.slice(transpiledSource.indexOf("{") + 1, transpiledSource.lastIndexOf("}")).replaceAll(";", ""));
					generatorFunction = () => internalGeneratorFunction(p5$2, ...scopeKeys.map((key) => scope[key]));
				}
				const generatedModifyArgument = new ShaderGenerator(generatorFunction, this, options$1.srcLocations).generate();
				return oldModify.call(this, generatedModifyArgument);
			} else return oldModify.call(this, shaderModifier);
		};
		function replaceBinaryOperator(codeSource) {
			switch (codeSource) {
				case "+": return "add";
				case "-": return "sub";
				case "*": return "mult";
				case "/": return "div";
				case "%": return "mod";
				case "==":
				case "===": return "equalTo";
				case ">": return "greaterThan";
				case ">=": return "greaterThanEqualTo";
				case "<": return "lessThan";
				case "&&": return "and";
				case "||": return "or";
			}
		}
		function nodeIsUniform(ancestor$1) {
			return ancestor$1.type === "CallExpression" && (ancestor$1.callee?.type === "Identifier" && ancestor$1.callee?.name.startsWith("uniform") || ancestor$1.callee?.type === "MemberExpression" && ancestor$1.callee?.property.name.startsWith("uniform"));
		}
		const ASTCallbacks = {
			UnaryExpression(node, _state, ancestors) {
				if (ancestors.some(nodeIsUniform)) return;
				const signNode = {
					type: "Literal",
					value: node.operator
				};
				const standardReplacement = (node$1) => {
					node$1.type = "CallExpression";
					node$1.callee = {
						type: "Identifier",
						name: "__p5.unaryNode"
					};
					node$1.arguments = [node$1.argument, signNode];
				};
				if (node.type === "MemberExpression") {
					const property = node.argument.property.name;
					if ([
						[
							"x",
							"y",
							"z",
							"w"
						],
						[
							"r",
							"g",
							"b",
							"a"
						],
						[
							"s",
							"t",
							"p",
							"q"
						]
					].some((set$1) => [...property].every((char) => set$1.includes(char))) && node.argument.type === "MemberExpression") {
						node.type = "MemberExpression";
						node.object = {
							type: "CallExpression",
							callee: {
								type: "Identifier",
								name: "__p5.unaryNode"
							},
							arguments: [node.argument.object, signNode]
						};
						node.property = {
							type: "Identifier",
							name: property
						};
					} else standardReplacement(node);
				} else standardReplacement(node);
				delete node.argument;
				delete node.operator;
			},
			VariableDeclarator(node, _state, ancestors) {
				if (ancestors.some(nodeIsUniform)) return;
				if (nodeIsUniform(node.init)) {
					const uniformNameLiteral = {
						type: "Literal",
						value: node.id.name
					};
					node.init.arguments.unshift(uniformNameLiteral);
				}
				if (node.init.callee && node.init.callee.name?.startsWith("varying")) {
					const varyingNameLiteral = {
						type: "Literal",
						value: node.id.name
					};
					node.init.arguments.unshift(varyingNameLiteral);
					_state.varyings[node.id.name] = varyingNameLiteral;
				}
			},
			Identifier(node, _state, ancestors) {
				if (ancestors.some(nodeIsUniform)) return;
				if (_state.varyings[node.name] && !_ancestors.some((a) => a.type === "AssignmentExpression" && a.left === node)) {
					node.type = "ExpressionStatement";
					node.expression = {
						type: "CallExpression",
						callee: {
							type: "MemberExpression",
							object: {
								type: "Identifier",
								name: node.name
							},
							property: {
								type: "Identifier",
								name: "getValue"
							}
						},
						arguments: []
					};
				}
			},
			ArrayExpression(node, _state, ancestors) {
				if (ancestors.some(nodeIsUniform)) return;
				const original = JSON.parse(JSON.stringify(node));
				node.type = "CallExpression";
				node.callee = {
					type: "Identifier",
					name: "__p5.dynamicNode"
				};
				node.arguments = [original];
			},
			AssignmentExpression(node, _state, ancestors) {
				if (ancestors.some(nodeIsUniform)) return;
				if (node.operator !== "=") {
					const methodName = replaceBinaryOperator(node.operator.replace("=", ""));
					const rightReplacementNode = {
						type: "CallExpression",
						callee: {
							type: "MemberExpression",
							object: node.left,
							property: {
								type: "Identifier",
								name: methodName
							}
						},
						arguments: [node.right]
					};
					node.operator = "=";
					node.right = rightReplacementNode;
				}
				if (_state.varyings[node.left.name]) {
					node.type = "ExpressionStatement";
					node.expression = {
						type: "CallExpression",
						callee: {
							type: "MemberExpression",
							object: {
								type: "Identifier",
								name: node.left.name
							},
							property: {
								type: "Identifier",
								name: "bridge"
							}
						},
						arguments: [node.right]
					};
				}
			},
			BinaryExpression(node, _state, ancestors) {
				if (ancestors.some(nodeIsUniform)) return;
				if ([
					"Literal",
					"ArrayExpression",
					"Identifier"
				].includes(node.left.type)) node.left = {
					type: "CallExpression",
					callee: {
						type: "Identifier",
						name: "__p5.dynamicNode"
					},
					arguments: [node.left]
				};
				node.type = "CallExpression";
				node.callee = {
					type: "MemberExpression",
					object: node.left,
					property: {
						type: "Identifier",
						name: replaceBinaryOperator(node.operator)
					}
				};
				node.arguments = [node.right];
			}
		};
		class BaseNode {
			constructor(isInternal, type$2) {
				if (new.target === BaseNode) throw new TypeError("Cannot construct BaseNode instances directly. This is an abstract class.");
				this.type = type$2;
				this.componentNames = [];
				this.componentsChanged = false;
				this.isInternal = isInternal;
				this.usedIn = [];
				this.dependsOn = [];
				this.srcLine = null;
				this.usedInConditional = false;
				if (GLOBAL_SHADER.srcLocations === true && isInternal === false) try {
					throw new Error("StackCapture");
				} catch (e$1) {
					const lines = e$1.stack.split("\n");
					let userSketchLineIndex = 5;
					if (isBinaryExpressionNode(this)) userSketchLineIndex--;
					this.srcLine = lines[userSketchLineIndex].trim();
				}
			}
			addVectorComponents() {
				if (this.type.startsWith("vec")) {
					const vectorDimensions = parseInt(this.type.slice(3));
					this.componentNames = [
						"x",
						"y",
						"z",
						"w"
					].slice(0, vectorDimensions);
					const proxy = this;
					for (let componentName of this.componentNames) {
						let value = new ComponentNode(proxy, componentName, "float", true);
						Object.defineProperty(this, componentName, {
							get() {
								return value;
							},
							set(newValue) {
								this.componentsChanged = true;
								if (isUnaryExpressionNode(this)) this.node.value = newValue;
								else value = newValue;
							}
						});
					}
				}
			}
			forceTemporaryVariable() {
				if (!(isFloatNode(this) && isVectorNode(this.parent)) || !isVariableNode(this)) this.useTemp = true;
			}
			assertUsedInConditional(branch$1) {
				this.usedInConditional = true;
				this.usedIn.push(branch$1);
				this.forceTemporaryVariable();
			}
			isUsedInConditional() {
				return this.usedInConditional;
			}
			checkConditionalDependencies(context) {
				context.ifs.forEach((statement) => {
					const isUsedSatisfied = () => statement.usedInSatisfied.length >= 1;
					const isDepsSatisfied = () => statement.dependsOn.length === statement.dependsOnSatisfied.length;
					if (statement.insertionPoint > -1 || !statement.usedIn.length) return;
					if (statement.dependsOn.some((d$1) => d$1.node === this) && !statement.dependsOnSatisfied.includes(this)) statement.dependsOnSatisfied.push(this);
					if (statement.usedIn.includes(this) && !statement.usedInSatisfied.includes(this)) statement.usedInSatisfied.push(this);
					if (isDepsSatisfied() && isUsedSatisfied()) statement.saveState(context, isDepsSatisfied(), isUsedSatisfied());
				});
			}
			toGLSLBase(context) {
				let result;
				if (this.shouldUseTemporaryVariable()) {
					let oldLength = context.declarations.length;
					result = this.getTemporaryVariable(context);
					let diff = context.declarations.length - 1 - oldLength;
					diff = diff > 0 ? diff : void 0;
					this.dependsOn.forEach((dependency) => {
						if (dependency.isVector) {
							const dependencies = dependency.originalComponents.map((component, i$1) => component === dependency.currentComponents[i$1]);
							context.updateComponents(dependency.node, diff, dependencies);
						} else context.updateComponents(dependency.node, diff);
					});
				} else result = this.toGLSL(context);
				this.checkConditionalDependencies(context);
				return result;
			}
			shouldUseTemporaryVariable() {
				if (this.componentsChanged || hasTemporaryVariable(this) || this.useTemp) return true;
				if (this.isInternal || isVariableNode(this) || isConditionalNode(this) || this.type === "sampler2D") return false;
				let score = 0;
				score += isFunctionCallNode(this) * 2;
				score += isBinaryExpressionNode(this) * 2;
				score += isVectorType(this) * 3;
				score += this.usedIn.length;
				return score >= 4;
			}
			getTemporaryVariable(context) {
				if (!this.temporaryVariable) {
					this.temporaryVariable = `temp_${context.getNextID()}`;
					let line = "";
					if (this.srcLine) line += `\n// From ${this.srcLine}\n`;
					line += "  " + this.type + " " + this.temporaryVariable + " = " + this.toGLSL(context) + ";";
					context.declarations.push(line);
				}
				return this.temporaryVariable;
			}
			add(other) {
				return binaryExpressionNodeConstructor(this, this.enforceType(other), "+");
			}
			sub(other) {
				return binaryExpressionNodeConstructor(this, this.enforceType(other), "-");
			}
			mult(other) {
				return binaryExpressionNodeConstructor(this, this.enforceType(other), "*");
			}
			div(other) {
				return binaryExpressionNodeConstructor(this, this.enforceType(other), "/");
			}
			mod(other) {
				return binaryExpressionNodeConstructor(this, this.enforceType(other), "%");
			}
			enforceType(other) {
				if (isShaderNode(other)) {
					if (!isGLSLNativeType(other.type)) throw new TypeError(`You've tried to perform an operation on a struct of type: ${other.type}. Try accessing a member on that struct with '.'`);
					if (!isGLSLNativeType(other.type)) throw new TypeError(`You've tried to perform an operation on a struct of type: ${other.type}. Try accessing a member on that struct with '.'`);
					if ((isFloatType(this) || isVectorType(this)) && isIntType(other)) return new FloatNode(other);
					return other;
				} else if (typeof other === "number") {
					if (isIntType(this)) return new IntNode(other);
					return new FloatNode(other);
				} else if (Array.isArray(other)) return nodeConstructors.dynamicVector(other);
				else return nodeConstructors[this.type](other);
			}
			toFloat() {
				if (isFloatType(this)) return this;
				else if (isIntType(this)) return new FloatNode(this);
			}
			toGLSL(context) {
				throw new TypeError("Not supposed to call this function on BaseNode, which is an abstract class.");
			}
		}
		class IntNode extends BaseNode {
			constructor(x$1 = 0, isInternal = false) {
				super(isInternal, "int");
				this.x = x$1;
			}
			toGLSL(context) {
				if (isShaderNode(this.x)) {
					let code = this.x.toGLSLBase(context);
					return isIntType(this.x.type) ? code : `int(${code})`;
				} else if (typeof this.x === "number") return `${Math.floor(this.x)}`;
				else return `int(${this.x})`;
			}
		}
		class FloatNode extends BaseNode {
			constructor(x$1 = 0, isInternal = false, _parent = false) {
				super(isInternal, "float");
				if (Array.isArray(x$1)) x$1 = x$1[0];
				if (_parent) {
					const { parent, name } = _parent;
					this.name = name;
					this.parent = parent;
				}
				this.x = x$1;
			}
			toGLSL(context) {
				if (isShaderNode(this.x)) {
					let code = this.x.toGLSLBase(context);
					return isFloatType(this.x) ? code : `float(${code})`;
				} else if (typeof this.x === "number") return `${this.x.toFixed(4)}`;
				else return `float(${this.x})`;
			}
		}
		class VectorNode extends BaseNode {
			constructor(values, type$2, isInternal = false) {
				super(isInternal, type$2);
				this.originalValues = conformVectorParameters(values, parseInt(type$2.slice(3)));
				this.componentNames = [
					"x",
					"y",
					"z",
					"w"
				].slice(0, this.originalValues.length);
			}
			addVectorComponents() {
				const values = this.originalValues;
				this.componentsChanged = false;
				this.componentNames.forEach((componentName, i$1) => {
					const info = {
						name: componentName,
						parent: this
					};
					let value = isFloatNode(values[i$1]) ? values[i$1] : new FloatNode(values[i$1], true, info);
					Object.defineProperty(this, componentName, {
						get() {
							return value;
						},
						set(newValue) {
							this.componentsChanged = true;
							if (isUnaryExpressionNode(this)) this.node.value = newValue;
							else value = isFloatNode(newValue) ? newValue : new FloatNode(newValue, true, info);
						}
					});
				});
				this.originalValues = this.componentNames.map((name) => this[name]);
			}
			toGLSL(context) {
				if ((!this.componentsChanged || !this.defined) && !this.oldName) {
					let glslArgs = this.componentNames.map((_name, i$1) => this.originalValues[i$1].toGLSLBase(context)).join(", ");
					this.defined = true;
					return `${this.type}(${glslArgs})`;
				} else return this.temporaryVariable;
			}
		}
		class FunctionCallNode extends BaseNode {
			constructor(name, userArgs, properties, isInternal = false) {
				let functionSignature;
				const determineFunctionSignature = (props) => {
					let genType;
					let similarity = 0;
					const valid = userArgs.every((userArg, i$1) => {
						const userType = getType(userArg);
						let expectedArgType = props.args[i$1];
						if (expectedArgType === "genType") {
							if (genType === void 0 || genType === "float" && userType.startsWith("vec")) genType = userType;
							expectedArgType = genType;
						}
						similarity += userType === expectedArgType;
						return userType === expectedArgType || userType === "float" && expectedArgType.startsWith("vec");
					});
					return {
						...props,
						valid,
						similarity,
						genType
					};
				};
				if (Array.isArray(properties)) {
					let possibleOverloads = properties.filter((o) => o.args.length === userArgs.length);
					if (possibleOverloads.length === 0) {
						const argsLengthSet = /* @__PURE__ */ new Set();
						const argsLengthArr = [];
						properties.forEach((p$1) => argsLengthSet.add(p$1.args.length));
						argsLengthSet.forEach((len) => argsLengthArr.push(`${len}`));
						const argsLengthStr = argsLengthArr.join(" or ");
						throw new Error(`Function '${name}' has ${properties.length} variants which expect ${argsLengthStr} arguments, but ${userArgs.length} arguments were provided.`);
					}
					const findBestOverload = function(best, current) {
						current = determineFunctionSignature(current);
						if (!current.valid) return best;
						if (!best || current.similarity > best.similarity) best = current;
						return best;
					};
					functionSignature = possibleOverloads.reduce(findBestOverload, null);
				} else functionSignature = determineFunctionSignature(properties);
				if (!functionSignature || !functionSignature.valid) {
					const argsStrJoin = (args) => `(${args.map((arg) => arg).join(", ")})`;
					const expectedArgsString = Array.isArray(properties) ? properties.map((prop) => argsStrJoin(prop.args)).join(" or ") : argsStrJoin(properties.args);
					const providedArgsString = argsStrJoin(userArgs.map((a) => getType(a)));
					throw new Error(`Function '${name}' was called with wrong arguments. Most likely, you provided mixed lengths vectors as arguments.\nExpected argument types: ${expectedArgsString}\nProvided argument types: ${providedArgsString}\nAll of the arguments with expected type 'genType' should have a matching type. If one of those is different, try to find where it was created.
        `);
				}
				if (userArgs.length !== functionSignature.args.length) throw new Error(`Function '${name}' expects ${functionSignature.args.length} arguments, but ${userArgs.length} were provided.`);
				userArgs = userArgs.map((arg, i$1) => {
					if (!isShaderNode(arg)) arg = nodeConstructors[functionSignature.args[i$1] === "genType" ? functionSignature.genType : functionSignature.args[i$1]](arg);
					else if (isFloatType(arg) && functionSignature.args[i$1] === "genType" && functionSignature.genType !== "float") arg = nodeConstructors[functionSignature.genType](arg);
					return arg;
				});
				if (functionSignature.returnType === "genType") functionSignature.returnType = functionSignature.genType;
				super(isInternal, functionSignature.returnType);
				this.name = name;
				this.args = userArgs;
				this.argumentTypes = functionSignature.args;
			}
			deconstructArgs(context) {
				return this.args.map((argNode, i$1) => {
					if (isIntType(argNode) && this.argumentTypes[i$1] != "float") argNode = argNode.toFloat();
					argNode.toGLSLBase(context);
					return argNode.toGLSLBase(context);
				}).join(", ");
			}
			toGLSL(context) {
				return `${this.name}(${this.deconstructArgs(context)})`;
			}
		}
		class VariableNode extends BaseNode {
			constructor(name, type$2, isInternal = false) {
				super(isInternal, type$2);
				this.name = name;
			}
			toGLSL(context) {
				return `${this.name}`;
			}
		}
		class ComponentNode extends BaseNode {
			constructor(parent, componentName, type$2, isInternal = false) {
				super(isInternal, type$2);
				this.parent = parent;
				this.componentName = componentName;
				this.type = type$2;
			}
			toGLSL(context) {
				let parentName = this.parent.toGLSLBase(context);
				if (!isVariableNode(this.parent) && !hasTemporaryVariable(this.parent)) parentName = `(${parentName})`;
				return `${parentName}.${this.componentName}`;
			}
		}
		class VaryingNode extends VariableNode {
			constructor(name, type$2, isInternal = false) {
				super(name, type$2, isInternal);
				this.timesChanged = 0;
				this.tempVars = 0;
			}
			getValue() {
				const context = GLOBAL_SHADER.context;
				if (!context.varyings[this.name] || !this.timesChanged) return this;
				let values = context.varyings[this.name].splice(0, this.timesChanged);
				let snapshot;
				values.forEach((val$1, i$1) => {
					let { value } = val$1;
					context.declarations.push(`  ${this.name} = ${value.toGLSLBase(context)};`);
					if (i$1 === values.length - 1) {
						const tempName = `${this.name}_${this.tempVars++}`;
						snapshot = dynamicAddSwizzleTrap(new VariableNode(tempName, this.type, true));
						context.declarations.push(`  ${this.type} ${tempName} = ${this.name};`);
					}
				});
				this.timesChanged = 0;
				return snapshot;
			}
			bridge(value) {
				if (!isShaderNode(value) || this.type.startsWith("vec") && getType(value) === "float") value = nodeConstructors[this.type](value);
				GLOBAL_SHADER.registerVarying(this, value);
				this.timesChanged += 1;
			}
		}
		class BinaryExpressionNode extends BaseNode {
			constructor(left, right, operator, isInternal = false) {
				super(isInternal, null);
				this.operator = operator;
				this.left = left;
				this.right = right;
				for (const operand of [left, right]) operand.usedIn.push(this);
				this.type = this.determineType();
			}
			determineType() {
				if ([
					"==",
					">",
					">=",
					"<",
					"<=",
					"||",
					"!",
					"&&"
				].includes(this.operator)) return "bool";
				else if (this.left.type === this.right.type) return this.left.type;
				else if (isVectorType(this.left) && isFloatType(this.right)) return this.left.type;
				else if (isVectorType(this.right) && isFloatType(this.left)) return this.right.type;
				else if (isFloatType(this.left) && isIntType(this.right) || isIntType(this.left) && isFloatType(this.right)) return "float";
				else throw new Error("Incompatible types for binary operator");
			}
			processOperand(operand, context) {
				if (operand.temporaryVariable) return operand.temporaryVariable;
				let code = operand.toGLSLBase(context);
				if (isBinaryExpressionNode(operand) && !operand.temporaryVariable) code = `(${code})`;
				if (this.type === "float" && isIntType(operand)) code = `float(${code})`;
				return code;
			}
			toGLSL(context) {
				const a = this.processOperand(this.left, context);
				const b$1 = this.processOperand(this.right, context);
				return `${a} ${this.operator} ${b$1}`;
			}
		}
		class ModulusNode extends BinaryExpressionNode {
			constructor(a, b$1, isInternal) {
				super(a, b$1, isInternal);
			}
			toGLSL(context) {
				if (isVectorType(this) || isFloatType(this)) return `mod(${this.left.toGLSLBase(context)}, ${this.right.toGLSLBase(context)})`;
				return `${this.processOperand(context, this.left)} % ${this.processOperand(context, this.right)}`;
			}
		}
		class UnaryExpressionNode extends BaseNode {
			constructor(node, operator, isInternal = false) {
				super(isInternal, node.type);
				this.node = node;
				this.operator = operator;
			}
			toGLSL(context) {
				let mainStr = this.node.toGLSLBase(context);
				if (!isVariableNode(this.node) && !hasTemporaryVariable(this.node) && !isPrimitiveNode(this.node)) mainStr = `(${mainStr})`;
				return `${this.operator}${mainStr}`;
			}
		}
		BaseNode.prototype.equalTo = function(other) {
			return binaryExpressionNodeConstructor(this, this.enforceType(other), "==");
		};
		BaseNode.prototype.greaterThan = function(other) {
			return binaryExpressionNodeConstructor(this, this.enforceType(other), ">");
		};
		BaseNode.prototype.greaterThanEqualTo = function(other) {
			return binaryExpressionNodeConstructor(this, this.enforceType(other), ">=");
		};
		BaseNode.prototype.lessThan = function(other) {
			return binaryExpressionNodeConstructor(this, this.enforceType(other), "<");
		};
		BaseNode.prototype.lessThanEqualTo = function(other) {
			return binaryExpressionNodeConstructor(this, this.enforceType(other), "<=");
		};
		BaseNode.prototype.not = function() {
			return new UnaryExpressionNode(this.condition, "!", true);
		};
		BaseNode.prototype.or = function(other) {
			return new binaryExpressionNodeConstructor(this, this.enforceType(other), "||", true);
		};
		BaseNode.prototype.and = function(other) {
			return new binaryExpressionNodeConstructor(this, this.enforceType(other), "&&", true);
		};
		function branch(callback) {
			const branch$1 = new BranchNode();
			callback();
			BRANCH = null;
			return branch$1;
		}
		class ConditionalNode {
			constructor(condition, branchCallback) {
				this.dependsOn = [];
				this.usedIn = [];
				this.dependsOnSatisfied = [];
				this.usedInSatisfied = [];
				this.states = [];
				this.if(condition, branchCallback);
				this.insertionPoint = -1;
				this.elseIfs = [];
				this.elseBranch = null;
				GLOBAL_SHADER.context.ifs.push(this);
			}
			if(condition, branchCallback) {
				this.condition = condition;
				this.conditionString = condition.toGLSL(GLOBAL_SHADER.context);
				this.ifBranch = branch(branchCallback);
				this.ifBranch.parent = this;
			}
			elseIf(condition, branchCallback) {
				let elseBranch = branch(branchCallback);
				branchCallback.parent = this;
				this.elseIfs.push({
					condition,
					elseBranch
				});
				return this;
			}
			else(branchCallback) {
				this.elseBranch = branch(branchCallback);
				this.elseBranch.parent = this;
				return this;
			}
			thenDiscard() {
				return new ConditionalDiscard(this.condition);
			}
			saveState(context, usedInSatisfied, dependsOnSatisfied) {
				this.states.push({
					line: context.declarations.length,
					usedInSatisfied,
					dependsOnSatisfied
				});
				this.insertionPoint = context.declarations.length - 1;
			}
			toGLSL(context) {
				const oldLength = context.declarations.length;
				this.dependsOn.forEach((dep) => context.updateComponents(dep.node));
				const diff = context.declarations.length - oldLength;
				this.insertionPoint += diff;
				let codelines = [
					`\n  if (${this.conditionString}) {`,
					`\n    ${this.ifBranch.toGLSL(context)}`,
					`\n  }`
				];
				if (this.elseIfs.length) this.elseIfs.forEach((elif) => {
					let { condition, elseBranch } = elif;
					codelines.push(` else if (${condition.toGLSL(context)}) {`);
					codelines.push(`\n    ${elseBranch.toGLSL(context)}`);
					codelines.push(`\n  }`);
				});
				if (this.elseBranch) {
					codelines.push(` else {`);
					codelines.push(`\n    ${this.elseBranch.toGLSL(context)}`);
					codelines.push(`\n  }\n`);
				}
				codelines.push("\n");
				return codelines.flat().join("");
			}
		}
		fn$1.assign = function(node, value) {
			if (!BRANCH) throw new error("assign() is supposed to be used inside of conditional branchs. Use the \"=\" operator as normal otherwise.");
			BRANCH.assign(node, value);
		};
		class BranchNode {
			constructor() {
				BRANCH = this;
				this.statements = [];
				this.assignments = [];
				this.dependsOn = [];
				this.declarations = [];
				let parent = null;
				Object.defineProperty(this, "parent", {
					get() {
						return parent;
					},
					set(newParent) {
						newParent.dependsOn.push(...this.dependsOn);
						parent = newParent;
					}
				});
			}
			assign(node, value) {
				if (!isShaderNode(value) || value.type !== node.type) {
					value = nodeConstructors[node.type](value);
					this.declarations.push(value);
					this.assignments.push({ node });
				} else this.assignments.push({
					node,
					value
				});
				node = node.parent ? node.parent : node;
				value = value.parent ? value.parent : value;
				if ([node, value].some((n$2) => this.dependsOn.some((d$1) => d$1.node === n$2))) return;
				node.assertUsedInConditional(this);
				this.dependsOn.push(makeDependencyObject(node));
				if (value.shouldUseTemporaryVariable()) {
					value.assertUsedInConditional(this);
					this.dependsOn.push(makeDependencyObject(value));
				}
			}
			toGLSL(context) {
				let declarationsIndex = 0;
				this.assignments.forEach(({ node, value }) => {
					let statement;
					let result;
					if (!value) {
						let decl = this.declarations[declarationsIndex];
						declarationsIndex++;
						decl.temporaryVariable = `temp_${context.getNextID()}`;
						this.statements.push(`${decl.type} ${decl.temporaryVariable} = ${decl.toGLSL(context)};`);
						result = decl.toGLSLBase(context);
					} else result = value.toGLSLBase(context);
					if (isVariableNode(node) || hasTemporaryVariable(node)) statement = `${node.toGLSLBase(context)} = ${result};`;
					else if (isFloatNode(node) && node.name) statement = `${node.parent.toGLSLBase(context)}.${node.name} = ${result};`;
					else {
						node.temporaryVariable = `temp_${context.getNextID()}`;
						statement = `${node.type} ${node.toGLSLBase(context)} = ${result};`;
					}
					this.statements.push(statement);
				});
				return this.statements.join(`\n    `);
			}
		}
		class ConditionalDiscard {
			constructor(condition) {
				this.condition = condition;
			}
			toGLSL(context) {
				context.discardConditions.push(`if (${this.condition}{discard;})`);
			}
		}
		function getType(node) {
			if (isShaderNode(node)) return node.type;
			else if (Array.isArray(node) && node.length > 1) return `vec${node.length}`;
			else if (typeof node === "number" || Array.isArray(node) && node.length === 1) return "float";
		}
		function computeVectorLength(values) {
			let length = 0;
			if (Array.isArray(values)) for (let val$1 of values) if (isVectorType(val$1)) length += parseInt(val$1.type.slice(3));
			else length += 1;
			else if (isVectorType(values)) length += parseInt(val.type.slice(3));
			if (![
				2,
				3,
				4
			].includes(length)) throw new Error(`You have attempted to construct a vector with ${length} values. Only vec2, vec3, and vec4 types are supported.`);
			return length;
		}
		p5$2.dynamicNode = function(input) {
			if (isShaderNode(input)) return input;
			else if (typeof input === "number") return new FloatNode(input);
			else if (Array.isArray(input)) return nodeConstructors.dynamicVector(input);
		};
		p5$2.unaryNode = function(input, sign) {
			input = p5$2.dynamicNode(input);
			return dynamicAddSwizzleTrap(new UnaryExpressionNode(input, sign));
		};
		function isShaderNode(node) {
			return node instanceof BaseNode;
		}
		function isIntType(node) {
			return isShaderNode(node) && node.type === "int";
		}
		function isFloatType(node) {
			return isShaderNode(node) && node.type === "float";
		}
		function isFloatNode(node) {
			return node instanceof FloatNode;
		}
		function isVectorType(node) {
			return isShaderNode(node) && (node.type === "vec2" || node.type === "vec3" || node.type === "vec4");
		}
		function isBinaryExpressionNode(node) {
			return node instanceof BinaryExpressionNode;
		}
		function isVariableNode(node) {
			return node instanceof VariableNode || node instanceof ComponentNode;
		}
		function isConditionalNode(node) {
			return node instanceof ConditionalNode || node instanceof BranchNode;
		}
		function hasTemporaryVariable(node) {
			return node.temporaryVariable;
		}
		function isPrimitiveNode(node) {
			return node instanceof FloatNode || node instanceof IntNode || node instanceof VectorNode;
		}
		function isFunctionCallNode(node) {
			return node instanceof FunctionCallNode;
		}
		function isVectorNode(node) {
			return node instanceof VectorNode;
		}
		function isUnaryExpressionNode(node) {
			return node instanceof UnaryExpressionNode;
		}
		function isGLSLNativeType(typeName) {
			return [
				"int",
				"float",
				"vec2",
				"vec3",
				"vec4",
				"sampler2D"
			].includes(typeName);
		}
		class ShaderGenerator {
			constructor(userCallback, originalShader, srcLocations) {
				GLOBAL_SHADER = this;
				this.userCallback = userCallback;
				this.srcLocations = srcLocations;
				this.cleanup = () => {};
				this.generateHookOverrides(originalShader);
				this.output = {
					vertexDeclarations: /* @__PURE__ */ new Set(),
					fragmentDeclarations: /* @__PURE__ */ new Set(),
					uniforms: {}
				};
				this.uniformNodes = [];
				this.resetGLSLContext();
				this.isGenerating = false;
			}
			generate() {
				const prevFESDisabled = p5$2.disableFriendlyErrors;
				p5$2.disableFriendlyErrors = true;
				this.isGenerating = true;
				this.userCallback();
				this.output.vertexDeclarations = [...this.output.vertexDeclarations].join("\n");
				this.output.fragmentDeclarations = [...this.output.fragmentDeclarations].join("\n");
				this.isGenerating = false;
				this.cleanup();
				p5$2.disableFriendlyErrors = prevFESDisabled;
				return this.output;
			}
			generateHookOverrides(originalShader) {
				const availableHooks = {
					...originalShader.hooks.vertex,
					...originalShader.hooks.fragment
				};
				const windowOverrides = {};
				const fnOverrides = {};
				Object.keys(availableHooks).forEach((hookName) => {
					const hookTypes = originalShader.hookTypes(hookName);
					this[hookTypes.name] = function(userCallback) {
						const argNodes = [];
						const argsArray = [];
						hookTypes.parameters.forEach((parameter) => {
							if (!isGLSLNativeType(parameter.type.typeName)) {
								const structArg = {};
								parameter.type.properties.forEach((property) => {
									structArg[property.name] = variableConstructor(`${parameter.name}.${property.name}`, property.type.typeName, true);
								});
								argNodes.push(structArg);
							} else argNodes.push(variableConstructor(parameter.name, parameter.type.typeName, true));
							const qualifiers = parameter.type.qualifiers.length > 0 ? parameter.type.qualifiers.join(" ") : "";
							argsArray.push(`${qualifiers} ${parameter.type.typeName} ${parameter.name}`.trim());
						});
						let returnedValue = userCallback(...argNodes);
						const expectedReturnType = hookTypes.returnType;
						const toGLSLResults = {};
						if (!isGLSLNativeType(expectedReturnType.typeName)) Object.entries(returnedValue).forEach(([propertyName, propertyNode]) => {
							propertyNode = p5$2.dynamicNode(propertyNode);
							toGLSLResults[propertyName] = propertyNode.toGLSLBase(this.context);
							this.context.updateComponents(propertyNode);
						});
						else {
							if (!isShaderNode(returnedValue)) returnedValue = nodeConstructors[expectedReturnType.typeName](returnedValue);
							else if (isFloatType(returnedValue) && expectedReturnType.typeName.startsWith("vec")) returnedValue = nodeConstructors[expectedReturnType.typeName](returnedValue);
							toGLSLResults["notAProperty"] = returnedValue.toGLSLBase(this.context);
							this.context.updateComponents(returnedValue);
						}
						this.context.ifs.forEach((statement) => {
							if (statement.usedIn.length === 0) return;
							const lines = statement.toGLSL(this.context);
							this.context.declarations.splice(statement.insertionPoint, 0, lines);
						});
						let codeLines = [
							`(${argsArray.join(", ")}) {`,
							...this.context.declarations,
							`\n  ${hookTypes.returnType.typeName} finalReturnValue;`
						];
						Object.entries(toGLSLResults).forEach(([propertyName, result]) => {
							const propString = expectedReturnType.properties ? `.${propertyName}` : "";
							codeLines.push(`  finalReturnValue${propString} = ${result};`);
						});
						this.context.declarations = [];
						for (let key in this.context.varyings) {
							const declArray = this.context.varyings[key];
							const finalVaryingAssignments = [];
							declArray.forEach((obj) => {
								const { node, value } = obj;
								finalVaryingAssignments.push(`  ${node.name} = ${value.toGLSLBase(this.context)};`);
								finalVaryingAssignments.unshift(...this.context.declarations);
								node.timesChanged = 0;
							});
							codeLines.push(...finalVaryingAssignments);
						}
						codeLines.push("  return finalReturnValue;", "}");
						this.output[hookName] = codeLines.join("\n");
						this.resetGLSLContext();
					};
					windowOverrides[hookTypes.name] = window[hookTypes.name];
					fnOverrides[hookTypes.name] = fn$1[hookTypes.name];
					window[hookTypes.name] = function(userOverride) {
						GLOBAL_SHADER[hookTypes.name](userOverride);
					};
					fn$1[hookTypes.name] = function(userOverride) {
						GLOBAL_SHADER[hookTypes.name](userOverride);
					};
				});
				this.cleanup = () => {
					for (const key in windowOverrides) window[key] = windowOverrides[key];
					for (const key in fnOverrides) fn$1[key] = fnOverrides[key];
				};
			}
			registerVarying(node, value) {
				if (!Array.isArray(this.context.varyings[node.name])) this.context.varyings[node.name] = [];
				this.context.varyings[node.name].push({
					node,
					value
				});
				this.output.vertexDeclarations.add(`OUT ${node.type} ${node.name};`);
				this.output.fragmentDeclarations.add(`IN ${node.type} ${node.name};`);
			}
			resetGLSLContext() {
				this.uniformNodes.forEach((node) => {
					node.usedIn = [];
					node.temporaryVariable = void 0;
				});
				this.context = {
					id: 0,
					getNextID() {
						return this.id++;
					},
					declarations: [],
					varyings: [],
					ifs: [],
					updateComponents: function(node, _emplaceAt, _changedComponents) {
						if (node.componentsChanged) {
							if (!_changedComponents) _changedComponents = node.componentNames.map(() => true);
							const lines = [];
							if (isVectorNode(node)) node.componentNames.forEach((name, i$1) => {
								if (!_changedComponents[i$1]) return;
								if (node[name] !== node.originalValues[i$1]) {
									const replacement = nodeConstructors["float"](node[name]);
									const line = `  ${node.temporaryVariable}.${name} = ${replacement.toGLSLBase(this)};`;
									lines.push(line);
								}
							});
							else {
								const components = node.componentNames.map((name) => {
									return node[name];
								});
								const replacement = nodeConstructors[node.type](components);
								const line = `  ${node.temporaryVariable} = ${replacement.toGLSLBase(this)};`;
								lines.push(line);
							}
							if (_emplaceAt) this.declarations.splice(_emplaceAt, 0, ...lines);
							else this.declarations.push(...lines);
							node.componentsChanged = false;
						}
					}
				};
				this.uniformNodes = [];
			}
		}
		function makeDependencyObject(dep) {
			if (isVectorType(dep)) return {
				node: dep,
				isVector: true,
				originalComponents: [...dep.componentNames.map((name) => dep[name])],
				get currentComponents() {
					return dep.componentNames.map((name) => dep[name]);
				}
			};
			else return {
				node: dep,
				isVector: false
			};
		}
		function makeDependencyArray(dependencies) {
			return dependencies.map((dep) => makeDependencyObject(dep));
		}
		function conformVectorParameters(value, vectorDimensions) {
			if (!Array.isArray(value)) value = [value];
			value = value.flat();
			value = value.map((val$1) => {
				if (isVectorType(val$1)) return val$1.componentNames.map((comp) => val$1[comp]);
				else return val$1;
			}).flat();
			if (value.length === 1 && !isVectorNode(value[0])) value = Array(vectorDimensions).fill(value[0]);
			return value;
		}
		function swizzleTrap(size) {
			const swizzleSets = [
				[
					"x",
					"y",
					"z",
					"w"
				],
				[
					"r",
					"g",
					"b",
					"a"
				],
				[
					"s",
					"t",
					"p",
					"q"
				]
			].map((s) => s.slice(0, size));
			return {
				get(target, property, receiver) {
					if (property in target) return Reflect.get(...arguments);
					else for (const set$1 of swizzleSets) if ([...property].every((char) => set$1.includes(char))) {
						if (property.length === 1) return target[swizzleSets[0][set$1.indexOf(property[0])]];
						const components = [...property].map((char) => {
							const index = set$1.indexOf(char);
							return target[swizzleSets[0][index]];
						});
						return nodeConstructors[`vec${property.length}`](components);
					}
				},
				set(target, property, value, receiver) {
					for (const set$1 of swizzleSets) {
						const propertyCharArray = [...property];
						if (propertyCharArray.every((char) => set$1.includes(char))) {
							const newValues = Array.isArray(value) ? value : Array(property.length).fill(value);
							propertyCharArray.forEach((char, i$1) => {
								const index = set$1.indexOf(char);
								const realProperty = swizzleSets[0][index];
								Reflect.set(target, realProperty, newValues[i$1], receiver);
							});
							return true;
						}
					}
					return Reflect.set(...arguments);
				}
			};
		}
		fn$1.If = function(condition, branch$1) {
			return new ConditionalNode(condition, branch$1);
		};
		fn$1.instanceID = function() {
			return variableConstructor("gl_InstanceID", "int");
		};
		fn$1.getTexture = function(...userArgs) {
			return fnNodeConstructor("getTexture", userArgs, {
				args: ["sampler2D", "vec2"],
				returnType: "vec4",
				isp5Function: true
			});
		};
		const GLSLTypesToIdentifiers = {
			int: "Int",
			float: "Float",
			vec2: "Vector2",
			vec3: "Vector3",
			vec4: "Vector4",
			sampler2D: "Texture"
		};
		function dynamicAddSwizzleTrap(node, _size) {
			if (node.type.startsWith("vec") || _size) {
				const size = parseInt(node.type.slice(3));
				node = new Proxy(node, swizzleTrap(size));
				node.addVectorComponents();
			}
			return node;
		}
		function binaryExpressionNodeConstructor(a, b$1, operator, isInternal) {
			let node;
			if (operator === "%") node = new ModulusNode(a, b$1);
			else node = new BinaryExpressionNode(a, b$1, operator, isInternal);
			return dynamicAddSwizzleTrap(node);
		}
		function variableConstructor(name, type$2, isInternal) {
			return dynamicAddSwizzleTrap(new VariableNode(name, type$2, isInternal));
		}
		function fnNodeConstructor(name, userArgs, properties, isInternal) {
			let node = new FunctionCallNode(name, userArgs, properties, isInternal);
			node = dynamicAddSwizzleTrap(node);
			node.dependsOn = makeDependencyArray(node.args);
			node.args.map((arg) => {
				return arg.usedIn.filter((n$2) => isConditionalNode(n$2)).map((c) => {
					if (c instanceof BranchNode) return c.parent;
					else return c;
				});
			}).flat().forEach((conditional) => conditional.usedIn.push(node));
			return node;
		}
		const nodeConstructors = {
			int: (value) => new IntNode(value),
			float: (value) => new FloatNode(value),
			vec2: (value) => dynamicAddSwizzleTrap(new VectorNode(value, "vec2")),
			vec3: (value) => dynamicAddSwizzleTrap(new VectorNode(value, "vec3")),
			vec4: (value) => dynamicAddSwizzleTrap(new VectorNode(value, "vec4")),
			dynamicVector: function(value) {
				const size = computeVectorLength(value);
				return this[`vec${size}`](value);
			}
		};
		for (const glslType in GLSLTypesToIdentifiers) {
			const typeIdentifier = GLSLTypesToIdentifiers[glslType];
			const uniformMethodName = `uniform${typeIdentifier}`;
			ShaderGenerator.prototype[uniformMethodName] = function(...args) {
				let [name, ...defaultValue] = args;
				if (glslType.startsWith("vec") && !(defaultValue[0] instanceof Function)) {
					defaultValue = conformVectorParameters(defaultValue, parseInt(glslType.slice(3)));
					this.output.uniforms[`${glslType} ${name}`] = defaultValue;
				} else this.output.uniforms[`${glslType} ${name}`] = defaultValue[0];
				const uniform = variableConstructor(name, glslType, false);
				this.uniformNodes.push(uniform);
				return uniform;
			};
			fn$1[uniformMethodName] = function(...args) {
				return GLOBAL_SHADER[uniformMethodName](...args);
			};
			if (glslType === "sampler2D") continue;
			const varyingMethodName = `varying${typeIdentifier}`;
			ShaderGenerator.prototype[varyingMethodName] = function(name) {
				return dynamicAddSwizzleTrap(new VaryingNode(name, glslType, false));
			};
			fn$1[varyingMethodName] = function(name) {
				return GLOBAL_SHADER[varyingMethodName](name);
			};
			const originalFn = fn$1[glslType];
			fn$1[glslType] = function(...value) {
				if (GLOBAL_SHADER?.isGenerating) {
					if (glslType.startsWith("vec")) value = conformVectorParameters(value, parseInt(glslType.slice(3)));
					else value = value[0];
					return nodeConstructors[glslType](value);
				} else if (originalFn) return originalFn.apply(this, value);
				else p5$2._friendlyError(`It looks like you've called ${glslType} outside of a shader's modify() function.`);
			};
		}
		Object.entries({
			"acos": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: true
			},
			"acosh": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: false
			},
			"asin": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: true
			},
			"asinh": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: false
			},
			"atan": [{
				args: ["genType"],
				returnType: "genType",
				isp5Function: false
			}, {
				args: ["genType", "genType"],
				returnType: "genType",
				isp5Function: false
			}],
			"atanh": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: false
			},
			"cos": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: true
			},
			"cosh": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: false
			},
			"degrees": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: true
			},
			"radians": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: true
			},
			"sin": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: true
			},
			"sinh": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: false
			},
			"tan": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: true
			},
			"tanh": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: false
			},
			"abs": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: true
			},
			"ceil": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: true
			},
			"clamp": {
				args: [
					"genType",
					"genType",
					"genType"
				],
				returnType: "genType",
				isp5Function: false
			},
			"dFdx": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: false
			},
			"dFdy": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: false
			},
			"exp": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: true
			},
			"exp2": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: false
			},
			"floor": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: true
			},
			"fma": {
				args: [
					"genType",
					"genType",
					"genType"
				],
				returnType: "genType",
				isp5Function: false
			},
			"fract": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: true
			},
			"fwidth": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: false
			},
			"inversesqrt": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: true
			},
			"log": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: true
			},
			"log2": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: false
			},
			"max": [{
				args: ["genType", "genType"],
				returnType: "genType",
				isp5Function: true
			}, {
				args: ["genType", "float"],
				returnType: "genType",
				isp5Function: true
			}],
			"min": [{
				args: ["genType", "genType"],
				returnType: "genType",
				isp5Function: true
			}, {
				args: ["genType", "float"],
				returnType: "genType",
				isp5Function: true
			}],
			"mix": [{
				args: [
					"genType",
					"genType",
					"genType"
				],
				returnType: "genType",
				isp5Function: false
			}, {
				args: [
					"genType",
					"genType",
					"float"
				],
				returnType: "genType",
				isp5Function: false
			}],
			"pow": {
				args: ["genType", "genType"],
				returnType: "genType",
				isp5Function: true
			},
			"round": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: true
			},
			"roundEven": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: false
			},
			"smoothstep": [{
				args: [
					"genType",
					"genType",
					"genType"
				],
				returnType: "genType",
				isp5Function: false
			}, {
				args: [
					"float",
					"float",
					"genType"
				],
				returnType: "genType",
				isp5Function: false
			}],
			"sqrt": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: true
			},
			"step": {
				args: ["genType", "genType"],
				returnType: "genType",
				isp5Function: false
			},
			"trunc": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: false
			},
			"cross": {
				args: ["vec3", "vec3"],
				returnType: "vec3",
				isp5Function: true
			},
			"distance": {
				args: ["genType", "genType"],
				returnType: "float",
				isp5Function: true
			},
			"dot": {
				args: ["genType", "genType"],
				returnType: "float",
				isp5Function: true
			},
			"faceforward": {
				args: [
					"genType",
					"genType",
					"genType"
				],
				returnType: "genType",
				isp5Function: false
			},
			"length": {
				args: ["genType"],
				returnType: "float",
				isp5Function: false
			},
			"normalize": {
				args: ["genType"],
				returnType: "genType",
				isp5Function: true
			},
			"reflect": {
				args: ["genType", "genType"],
				returnType: "genType",
				isp5Function: false
			},
			"refract": {
				args: [
					"genType",
					"genType",
					"float"
				],
				returnType: "genType",
				isp5Function: false
			},
			"texture": {
				args: ["sampler2D", "vec2"],
				returnType: "vec4",
				isp5Function: true
			}
		}).forEach(([functionName, properties]) => {
			if (Array.isArray(properties) ? properties[0].isp5Function : properties.isp5Function) {
				const originalFn = fn$1[functionName];
				fn$1[functionName] = function(...args) {
					if (GLOBAL_SHADER?.isGenerating) return fnNodeConstructor(functionName, args, properties);
					else return originalFn.apply(this, args);
				};
			} else fn$1[functionName] = function(...args) {
				if (GLOBAL_SHADER?.isGenerating) return new fnNodeConstructor(functionName, args, properties);
				else p5$2._friendlyError(`It looks like you've called ${functionName} outside of a shader's modify() function.`);
			};
		});
		const originalLerp = fn$1.lerp;
		fn$1.lerp = function(...args) {
			if (GLOBAL_SHADER?.isGenerating) return this.mix(...args);
			else return originalLerp.apply(this, args);
		};
		const originalNoise = fn$1.noise;
		fn$1.noise = function(...args) {
			if (!GLOBAL_SHADER?.isGenerating) return originalNoise.apply(this, args);
			GLOBAL_SHADER.output.vertexDeclarations.add(noiseGLSL);
			GLOBAL_SHADER.output.fragmentDeclarations.add(noiseGLSL);
			let nodeArgs;
			if (args.length === 2) nodeArgs = [fn$1.vec2(args[0], args[1])];
			else nodeArgs = args;
			return fnNodeConstructor("noise", nodeArgs, {
				args: ["vec2"],
				returnType: "float"
			});
		};
	}
	if (typeof p5 !== "undefined") p5.registerAddon(shadergenerator);
	function webgl(p5$2) {
		rendererGL(p5$2, p5$2.prototype);
		primitives3D(p5$2, p5$2.prototype);
		interaction(p5$2, p5$2.prototype);
		light(p5$2, p5$2.prototype);
		loading$1(p5$2, p5$2.prototype);
		material(p5$2, p5$2.prototype);
		text(p5$2, p5$2.prototype);
		renderBuffer(p5$2, p5$2.prototype);
		quat(p5$2, p5$2.prototype);
		matrix(p5$2, p5$2.prototype);
		geometry(p5$2, p5$2.prototype);
		camera(p5$2, p5$2.prototype);
		framebuffer(p5$2, p5$2.prototype);
		dataArray(p5$2, p5$2.prototype);
		shader(p5$2, p5$2.prototype);
		texture(p5$2, p5$2.prototype);
		shadergenerator(p5$2, p5$2.prototype);
	}
	function type(p5$2) {
		p5$2.registerAddon(textCore);
		p5$2.registerAddon(font);
	}
	const _globalInit = () => {
		if (typeof window._setupDone !== "undefined") {
			console.warn("p5.js seems to have been imported multiple times. Please remove the duplicate import");
			return;
		}
		if (!window.mocha) {
			const p5ReadyEvent = new Event("p5Ready");
			window.dispatchEvent(p5ReadyEvent);
			if ((window.setup && typeof window.setup === "function" || window.draw && typeof window.draw === "function") && !p5$1.instance) new p5$1();
		}
	};
	const waitForDocumentReady = () => new Promise((resolve, reject) => {
		if (document.readyState === "complete") resolve();
		else window.addEventListener("load", resolve, false);
	});
	const waitingForTranslator = typeof IS_MINIFIED === "undefined" ? initialize() : Promise.resolve();
	shape(p5$1);
	accessibility(p5$1);
	color(p5$1);
	friendlyErrors(p5$1);
	data(p5$1);
	dom(p5$1);
	events(p5$1);
	image(p5$1);
	io(p5$1);
	math(p5$1);
	utilities(p5$1);
	webgl(p5$1);
	type(p5$1);
	Promise.all([waitForDocumentReady(), waitingForTranslator]).then(_globalInit);
	return p5$1;
})();
